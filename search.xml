<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Androidchrome远程调试</title>
    <url>/2020/09/04/Androidchrome%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><strong>一：背景</strong><br>通常情况我们调试移动端页面最常用的方法就是：切换pc端浏览器的userAgent来模拟手机或其他移动设备调试页面 然后用手机打开要调试的页面 刷新页面查看调试结果</p>
<p>但是这就存在两个问题 在pc浏览器模拟手机可能造成调试不准 用手机直接调试 又多一步刷新 那怎么能达到在pc端修改代码 在手机上直接看到修改结果这样的所见即所得的效果呢 chrome做到了</p>
<a id="more"></a>

<p><strong>二.功能</strong></p>
<p>我们先看下最终想要达到的效果</p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130923544443367.jpg" alt="img"></p>
<p>上图的左边是pc端的chrome浏览器，右边是手机上的chrome 然后可以看到当鼠标移动到某个div上时 手机上的这个区域高亮显示 跟pc上调试某段代码效果一样 你可以修改代码 并直接在手机上反馈修改结果</p>
<p><strong>三，准备</strong></p>
<p>为了完成这一亮骚的移动调试功能我们需要以下准备工作</p>
<p>1.pc端安装最新的chrome<br>2.手机端安装最新的chrome (Android机)<br>3.USB连接线</p>
<p>（感觉是不是too simple）</p>
<p>Tip:之前的的chrome如果要实现这种调试需要安装一个<a href="https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage/related" target="_blank" rel="noopener">ADB插件</a>（需要FQ） 但是最新的chrome已经直接支持对Android的识别 所以也不用再在chrome上安装ADB插件了 但需要下载最新的chrome</p>
<p><strong>四：步骤</strong><br>下来我们逐步完成<br>1.假设你已经在电脑上下载了最新的chrome 也在手机上下载了最新的chrome</p>
<p>2.USB设置 在你的手机里打开”设置”-&gt;”开发人员工具”-&gt;”USB调试” 打开USB调试。 因为Android手机型号众多 很多人找不到”USB调试这个选项在哪” 而且大多数手机”开发者选项”默认是影藏的，你需要看下自己的手机说明然后将手机调到”开发者模式” 就可以找到 “USB调试了” </p>
<p><img src="https://img-blog.csdnimg.cn/2019052811513234.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppb2hvX2NoZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>3.假设你已经将手机设置为”USB调试”打开的状态 将手机连接到电脑 手机会弹出是否链接 点击确定</p>
<p>4.打开电脑的chrome 在地址栏输入 chrome://inspect 选中 Discover USB devices 可以检测到你的设备 可以看到监测到我的设备是M351 魅族X3 </p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130927258353280.png" alt="img"></p>
<p>5.打开手机上的chrome</p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130927507564327.png" alt="img"></p>
<p>上图可以看到手机上chrome打开的页面 此时我手机上的chrome没打开任何网页 历史记录也么有 如果我们在手机 chrome浏览器输入<a href="http://www.cnblogs.com" target="_blank" rel="noopener">www.cnblogs.com</a> 可以看到下图 ，也可以通过 inspect里chrome后面那个输入框直接打开某个链接</p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130928474446813.jpg" alt="img"></p>
<p>6.点击inspect 如下图 就看到了文章开始一样的效果 此时就是可以审查手机页面上的元素了</p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130929083038684.jpg" alt="img"></p>
<p>7.可以点击弹出的审查元素框右上角的方形小图标切换到视图模式 这时会把你手机打开的页面拉到pc上显示<br><img src="https://images0.cnblogs.com/blog/494920/201411/130929414447110.png" alt="img"></p>
<p><strong>五：总结</strong></p>
<p>基本上已经愉快的完成了 总结下整个流程 ：pc端和Android手机端都下载最新的chrome ，在手机设置里将”USB调试”打开 链接到电脑 打开电脑chrome 输入chrome://inspect 打开手机chrome输入你想调试的页面 点击inspect 开始调试 ,整个调试的过程都是要FQ的哦 。</p>
<p>PS:如果inspect出空白窗口，有可能是长城防火城的原因，试下用VPN</p>
<p><img src="https://images0.cnblogs.com/blog/692371/201411/131813137254471.jpg" alt="img"></p>
<p>转载于：<a href="https://www.cnblogs.com/alantao/p/5220392.html" target="_blank" rel="noopener">https://www.cnblogs.com/alantao/p/5220392.html</a></p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5</title>
    <url>/2020/07/22/HTML5/</url>
    <content><![CDATA[<h3 id="h5知识点整理"><a href="#h5知识点整理" class="headerlink" title="h5知识点整理"></a>h5知识点整理</h3><blockquote>
<ol>
<li>任何class和id里都不能包含”ad” 这个关键字,否则会被一些广告屏蔽软件给过滤了</li>
</ol>
</blockquote>
<a id="more"></a>

<blockquote>
<ol start="2">
<li><input type="tel" placeholder="输入手机号" pattern="1[3-8][0-9]{9}" title="输入正确的手机号">
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><meter min="0" low="40" high="90" max="100" value="95"></meter></li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><p contenteditable="true">这里的内容可以编辑</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li><p>使用input数字number类型的时候maxlength无效，假设需要控制输入数量为5，可以用以下方式：</p>
<p>无效： <input type="number" maxlength="5"></p>
<p>有效：<input type="number" oninput="if(value.length>5)value=value.slice(0,5)"> </p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li><p>tel、email</p>
<p>例如说当type=tel的时候,在手机上打开页面会出现电话键盘(不是数字键盘,两者并不一样,电话键盘还包括*和#)</p>
<p>当type=email的时候,会出现带@和.com符号的全键盘(各设配各系统实现貌似有差异)</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="7">
<li><a href="http://www.baidu.com/link?url=gFF8MX53uYP6kl_JnWUbWmEEIn6gA5irf5C_fBWwLtTEccOmxfwGpe899O79mYaM" target="_blank" rel="noopener">HTML页面顶部出现空白部分(&amp;#65279)字符的完美解决办法</a></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;	</span><br><span class="line">   <span class="keyword">var</span> a=<span class="built_in">document</span>.body.innerHTML;   </span><br><span class="line">   <span class="built_in">document</span>.body.innerHTML=a.replace(<span class="regexp">/\ufeff/g</span>,<span class="string">''</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="8">
<li><p>ios的readonly不兼容</p>
<p>unselectable=”on” onfocus=”this.blur()”</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="9">
<li><p>form表单获取input</p>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/2bb1822c99ae4a2c8ea984da3389235a/clipboard.png" alt="img"></p>
<p>document.tmform.tmtext.value</p>
<p>document.tmform.halou.value</p>
</li>
</ol>
</blockquote>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/379f847913f84ae7b460e3cbbad01e88/clipboard.png" alt="img"></p>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/9899b3677e414966a858ad82672e734f/clipboard.png" alt="img"></p>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/822799eecfd840f984dceb5711939da9/clipboard.png" alt="img"></p>
<p>select</p>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/df2aea69272c4df2bf5e36c37900c36f/clipboard.png" alt="img"></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint简介</title>
    <url>/2020/07/30/ESLint%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h4 id="ESLint简介"><a href="#ESLint简介" class="headerlink" title="ESLint简介"></a>ESLint简介</h4><p>ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。如果每次在代码提交之前都进行一次eslint代码检查，就不会因为某个字段未定义为undefined或null这样的错误而导致服务崩溃，可以有效的控制项目代码的质量。</p>
<p>在许多方面，它和 JSLint、JSHint 相似，除了少数的例外：</p>
<ul>
<li>ESLint 使用 Espree 解析 JavaScript。</li>
<li>ESLint 使用 AST 去分析代码中的模式。</li>
<li>ESLint 是完全插件化的。每一个规则都是一个插件并且你可以在运行时添加更多的规则。</li>
</ul>
<a id="more"></a>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ESLint 支持多种安装方式，可以通过 npm 来安装，也可以在 webpack(eslint-loader) 和 Gulp.js(gulp-eslint) 中使用。</p>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g eslint</span><br></pre></td></tr></table></figure>

<h3 id="局部安装（推荐）"><a href="#局部安装（推荐）" class="headerlink" title="局部安装（推荐）"></a>局部安装（推荐）</h3><p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D eslint</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>安装完毕后，接下来新建一个配置文件.eslintrc.js，或者使用如下的命令行来自动生成，命令如下：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>注意：如果你之前使用的版本低于 1.0.0，请查看 <a href="https://cn.eslint.org/docs/user-guide/migrating-to-1.0.0" target="_blank" rel="noopener">迁移指南</a>。<br>运行 eslint –init 之后，.eslintrc 文件会在你的文件夹中自动创建。文件的内容大体如下：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;es6&quot;: true,</span><br><span class="line">        &quot;node&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;no-console&quot;: 0,</span><br><span class="line">        &quot;no-unused-vars&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-use-before-define&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;linebreak-style&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;unix&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;quotes&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;single&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;semi&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;curly&quot;: [&quot;error&quot;, &quot;all&quot;],</span><br><span class="line">        &quot;default-case&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-else-return&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-empty-function&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-implicit-coercion&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-invalid-this&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-loop-func&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-multi-spaces&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-new-func&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-useless-return&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;global-require&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-path-concat&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-sync&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;array-bracket-spacing&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;never&quot; </span><br><span class="line">        ],</span><br><span class="line">        &quot;block-spacing&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;brace-style&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;1tbs&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;camelcase&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;comma-dangle&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always-multiline&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;comma-spacing&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;comma-style&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;last&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;key-spacing&quot;: [</span><br><span class="line">            &quot;error&quot;, </span><br><span class="line">            &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;lines-around-comment&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &#123; &quot;beforeBlockComment&quot;: true &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;newline-after-var&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;newline-before-return&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-multi-assign&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;max-params&quot;: [1, 3],</span><br><span class="line">        &quot;new-cap&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;newIsCap&quot;: true,</span><br><span class="line">                &quot;capIsNew&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;no-multiple-empty-lines&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;max&quot;: 2</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;no-shadow-restricted-names&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-undef-init&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;keyword-spacing&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;space-before-blocks&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ESlint支持的可配置信息主要分为3类：</p>
<ul>
<li>Environments：Javascript 脚步将要运行在什么环境中（如：nodejs，browser，commonjs等）,ESlint支持的所有环境都可以在<a href="https://eslint.org/docs/user-guide/configuring#specifying-environments" target="_blank" rel="noopener">官网</a>查到。</li>
<li>Globals：执行代码时脚步需要访问的额外全局变量。</li>
<li>Rules：开启某些规则，也可以设置规则的等级。</li>
</ul>
<h3 id="检测规则"><a href="#检测规则" class="headerlink" title="检测规则"></a>检测规则</h3><p>接下来，可以在配置文件中设置一些规则。ESLint规则的三种级别：</p>
<ul>
<li>“off” 或者 0：关闭规则。</li>
<li>“warn” 或者 1：打开规则，并且作为一个警告（不影响exit code）。</li>
<li>“error” 或者 2：打开规则，并且作为一个错误（exit code将会是1）。</li>
</ul>
<p>例如，下面的一些配置规则：</p>
<ul>
<li><code>&quot;no-console&quot;:&quot;off&quot;</code>           禁用 console。</li>
<li><code>&quot;no-unused-vars&quot;:2</code>    禁止出现未使用过的变量。</li>
<li><code>&quot;no-use-before-define&quot;:2</code>  不允许在变量定义之前使用它们。</li>
<li><code>&quot;linebreak-style&quot;:[2, &quot;unix&quot;]</code>   强制使用一致的换行风格。</li>
<li><code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code>   强制使用一致的单引号。</li>
<li><code>&quot;semi&quot;:[&quot;error&quot;, &quot;always&quot;]</code>   控制行尾部分号。</li>
<li><code>&quot;curly&quot;:[&quot;error&quot;, &quot;all&quot;]</code>    强制所有控制语句使用一致的括号风格。</li>
</ul>
<ul>
<li><code>&quot;default-case&quot;: &quot;error&quot;</code>    switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告。</li>
<li><code>&quot;no-else-return&quot;:&quot;error&quot;</code>  禁止 if 语句中有 return 之后有 else。</li>
<li><code>&quot;no-implicit-coercion&quot;: &quot;error&quot;</code> 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。</li>
<li><code>&quot;no-invalid-this&quot;: &quot;error&quot;</code> 禁止 this 关键字出现在类和类对象之外。</li>
<li><code>&quot;no-loop-func&quot;:&quot;error&quot;</code> 禁止在循环中出现 function 声明和表达式。</li>
<li><code>&quot;no-multi-spaces&quot;:&quot;error&quot;</code> 禁止使用多个空格。</li>
<li><code>&quot;no-new-func&quot;:&quot;error&quot;</code> 禁止对 空Function 对象使用 new 操作符。</li>
<li><code>&quot;no-useless-return&quot;:&quot;error&quot;</code> 禁止没有任何内容的return;</li>
<li><code>&quot;global-require&quot;: &quot;error&quot;</code> 要求 require() 出现在顶层模块作用域中。</li>
<li><code>&quot;no-path-concat&quot;: &quot;error&quot;</code> 禁止对 dirname 和 filename进行字符串连接</li>
<li><code>&quot;no-sync&quot;: &quot;error&quot;</code> 禁用同步方法。</li>
<li><code>&quot;array-bracket-spacing&quot;: [&quot;error&quot;, &quot;never&quot;]</code> 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格。</li>
<li><code>&quot;block-spacing&quot;: [&quot;error&quot;, &quot;always&quot;]</code> 禁止或强制在单行代码块中使用空格(禁用)。</li>
<li><code>&quot;brace-style&quot;: [&quot;error&quot;, &quot;1tbs&quot;]</code></li>
<li><code>&quot;camelcase&quot;: &quot;error&quot;</code> 强制驼峰法命名。</li>
<li><code>&quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always-multiline&quot;]</code> 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗,always-multiline：多行模式必须带逗号，单行模式不能带逗号号。</li>
<li><code>&quot;comma-spacing&quot;: [&quot;error&quot;, { &quot;before&quot;: false, &quot;after&quot;: true }]</code> 控制逗号前后的空格。</li>
<li><code>&quot;comma-style&quot;: [&quot;error&quot;, &quot;last&quot;]</code> 控制逗号在行尾出现还是在行首出现 (默认行尾)。</li>
<li><code>&quot;key-spacing&quot;: [&quot;error&quot;, { &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true }]</code> 该规则规定了在对象字面量语法中，key和value之间的空白，冒号前不要空格，冒号后面需要一个空格。</li>
<li><code>&quot;lines-around-comment&quot;: [&quot;error&quot;, { &quot;beforeBlockComment&quot;: true }]</code> 要求在注释周围有空行 ( 要求在块级注释之前有一空行)。</li>
<li><code>&quot;newline-after-var&quot;: [&quot;error&quot;, &quot;always&quot;]</code> 要求或禁止 var 声明语句后有一行空行。</li>
<li><code>&quot;newline-before-return&quot;: &quot;error&quot;</code> 要求 return 语句之前有一空行。</li>
<li><code>&quot;no-multi-assign&quot;: &quot;error&quot;</code> 链接变量的赋值可能会导致意外的结果并难以阅读，不允许在单个语句中使用多个分配。</li>
<li><code>&quot;max-params&quot;: [1, 3] function</code> 定义中最多允许的参数数量。</li>
<li><code>&quot;new-cap&quot;: [&quot;error&quot;, { &quot;newIsCap&quot;: true, &quot;capIsNew&quot;: false}]</code> 构造函数首字母大写。</li>
<li><code>&quot;no-multiple-empty-lines&quot;: [&quot;error&quot;, {&quot;max&quot;: 2}]</code> 空行不能够超过2行。</li>
<li><code>&quot;no-shadow-restricted-names&quot;: &quot;error&quot;</code> 禁止对一些关键字或者保留字进行赋值操作，比如NaN、Infinity、undefined、eval、arguments等。</li>
<li><code>&quot;no-undef-init&quot;: &quot;error&quot;</code> 禁止把undefined赋值给一个变量。</li>
<li><code>&quot;keyword-spacing&quot;: &quot;error&quot;</code> keyword 前后需要空格。</li>
<li><code>&quot;space-before-blocks&quot;: [&quot;error&quot;,&quot;always&quot;]</code> 强制在块之前使用一致的空格。</li>
</ul>
<h3 id="忽略检测"><a href="#忽略检测" class="headerlink" title="忽略检测"></a>忽略检测</h3><p>既然有检测的规则，那么必然有忽略检测的配置。要新增忽略检测的规则，首先要在项目根目录创建一个 .eslintignore 文件告诉 ESLint 去忽略掉不需要检测的文件或者目录。</p>
<p>或者通过package.json文件设置需要忽略检测的对象，例如：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my_project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintConfig&quot;: &#123; &#x2F;&#x2F; 也可配置eslint</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;es6&quot;: true,</span><br><span class="line">      &quot;node&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintIgnore&quot;: [&quot;test.js&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gulp中使用ESLint"><a href="#Gulp中使用ESLint" class="headerlink" title="Gulp中使用ESLint"></a>Gulp中使用ESLint</h2><p>除了npm方式之外，ESLint还支持Gulp插件方式使用，使用之前需要先安装插件。</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-eslint</span><br></pre></td></tr></table></figure>

<p>如果要使用gulp-eslint进行eslint规则的校验，可以使用下面的方式：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gulp &#x3D; require(&#39;gulp&#39;);</span><br><span class="line">var eslint &#x3D; require(&#39;gulp-eslint&#39;);</span><br><span class="line">gulp.task(&#39;lint&#39;,function()&#123;</span><br><span class="line">    return gulp.src([&#39;app&#x2F;**&#x2F;*.js&#39;]) &#x2F;&#x2F;指定的校验路径</span><br><span class="line">        .pipe(eslint(&#123;configFle:&quot;.&#x2F;.eslintrc&quot;&#125;)) &#x2F;&#x2F;使用你的eslint校验文件</span><br><span class="line">        .pipe(eslint.format())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="ESLint技巧"><a href="#ESLint技巧" class="headerlink" title="ESLint技巧"></a>ESLint技巧</h1><h2 id="eslint-config-standard"><a href="#eslint-config-standard" class="headerlink" title="eslint-config-standard"></a>eslint-config-standard</h2><p>eslint-config-standard是一个标准的ESLint规则检测库，因此只需要安装这个库就可以省去配置ESLint规则。<br><img src alt="在这里插入图片描述"><br>然后，在项目的根目录里面手动创建一个.eslintrc文件，然后在里面添加如下代码：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完以上步骤，就可以使用ESLint这个工具来校验项目里的代码。</p>
<p>在Vue项目里，.vue文件写的是类似于html的格式，不是标准的JavaScript文件，ESLint无法直接识别.vue文件里的JavaScript代码，那么这个时候我们需要去安装一个工具，安装命令如下：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i eslint-plugin-html -D</span><br></pre></td></tr></table></figure>

<p>因为在vue文件里面写JavaScript代码也是写在script标签里面的，这个插件的作用就是识别一个文件里面script标签里面的JS代码，官方也是这么推荐的。所以我们要在.eslintrc文件里面新增一段脚本：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;html&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完以上步骤后，我们跳转到package.json文件里面的scripts里面新增一条命令：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;lint&quot;: &quot;eslint --ext .js --ext .jsx --ext .vue src&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的脚本命令中，ext后面需要写上指定检测文件的后缀，如.js、.jsx、 .vue等，紧接着后面要写上一个参数，这个参数就是我们要检测哪个目录下面的文件，一般项目文件都在src下面，所以在后面写上src/就好。</p>
<p>现在我们就可以到terminal里面输入$ npm run lint，来检验项目里的代码是否符合ESLint的规则。</p>
<h2 id="ESLint自动修复报错"><a href="#ESLint自动修复报错" class="headerlink" title="ESLint自动修复报错"></a>ESLint自动修复报错</h2><p>一般来说，当我们使用命令“npm run lint”检测JavaScript的时候，基本上都会出现非常的多报错，基本上就是满屏的error和warning。<br><img src alt="在这里插入图片描述"><br>在报这么多的错误之后，如果我们一条一条地去修复，就会变的非常的麻烦，相信刚接触ESLint的童鞋都深有体会。其实这些错误都可以让ESLint帮助我们自动地修复。具体来说，只需要在package.json文件里面的scripts里面新增一条命令即可：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;lint-fix&quot;: &quot;eslint --fix --ext .js --ext .jsx --ext .vue src&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>当我们再去terminal中执行命令：$ npm run lint-fix，你会发现没有那么多飘红的报错，也没有满屏的error和warning了。</p>
<p>当然，还有一种万能方法，就是在报错的JS文件中第一行写上/* eslint-disable */，具体可以参考<a href="https://cn.eslint.org/docs/1.10.3/user-guide/command-line-interface" target="_blank" rel="noopener">Command line Interface</a></p>
<h2 id="eslint-loader"><a href="#eslint-loader" class="headerlink" title="eslint-loader"></a>eslint-loader</h2><p>有时候，我们希望在项目开发的过程当中，每次修改代码都能够自动进行ESLint的检查。因为在我们改代码的过程中去做一次检查，如果有错误，我们就能够很快地去定位到问题并解决问题。这时候我们可以借助eslint-loader插件。</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i eslint-loader babel-eslint -D</span><br></pre></td></tr></table></figure>

<p>执行完安装操作后，我们还需要在.eslintrc文件里面配置如下脚本：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;html&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;parser&quot;: &quot;babel-eslint&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么我们要配置parser呢？因为我们的项目是基于webpack的，项目里的代码都是需要经过babel去处理的。babel处理的这种语法可能对ESLint不是特别的支持，然后我们使用loader处理ESLint的时候就会出现一些问题。所以一般来说，我们用webpack和babel来进行开发的项目，都会指定它的parser使用babel-eslint。</p>
<p>同时，使用webpack方式构建的项目，还需要在webpack.config.base.js的module下面的rules里面添加一个如下脚本：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: &#x2F;\.(vue|js|jsx)$&#x2F;,</span><br><span class="line">    loader: &#39;eslint-loader&#39;,</span><br><span class="line">    exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">    enforce: &#39;pre&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  ......</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后我们就可以使用命令 <code>$ npm run dev</code>就可以在开发环境进行ESLint错误检测。</p>
<p>附：<a href="https://cn.eslint.org/" target="_blank" rel="noopener">https://cn.eslint.org/</a></p>
<p>​    <a href="https://www.imooc.com/article" target="_blank" rel="noopener">https://www.imooc.com/article</a>…</p>
<p>​        <a href="https://segmentfault.com/a/1190000018328740" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018328740</a></p>
]]></content>
      <categories>
        <category>ESLint</category>
      </categories>
      <tags>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>H5移动端调试全攻略</title>
    <url>/2020/09/21/H5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E5%85%A8%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h2 id="H5-移动端调试全攻略"><a href="#H5-移动端调试全攻略" class="headerlink" title="H5 移动端调试全攻略"></a>H5 移动端调试全攻略</h2><h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><p>因为移动端操作系统分为 <code>iOS</code> 和 <code>Android</code> 两派，所以本文的调试技巧也会按照不同的系统来区分。寻找最合适高效的方式，才能让你事半功倍。</p>
<blockquote>
<p>文章会列举目前适合移动端调试的多种方案，快来选择你的最佳实践吧！</p>
</blockquote>
<a id="more"></a>

<h3 id="二、iOS-设备"><a href="#二、iOS-设备" class="headerlink" title="二、iOS 设备"></a>二、iOS 设备</h3><blockquote>
<p>Safari：iphone 调试利器，查错改样式首选，需要我们做如下设置：</p>
</blockquote>
<ul>
<li>浏览器设置：Safari - 偏好设置 - 高级 - 勾选「在菜单栏中显示开发」菜单</li>
<li>iphone 设置：设置 - Safari - 高级 - 打开 Web 检查器</li>
</ul>
<p>大功告成，这时候通过手机的 <code>Safari</code> 来打开 <code>H5</code> 页面，我们通过浏览器开发选项可以看到：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGn5BX8wYAAkWwC94klY7dgu8VHmbnTYC6q0n72vwzjsNgy0XFjhxeHg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p>iOS 模拟器：不需要真机，适合调试 <code>Webview</code> 和 <code>H5</code> 有频繁交互的功能页面。</p>
</blockquote>
<p>首先下载 <code>Xcode</code> ，运行项目，选择模拟器 <code>iphonex</code>，编译后就会打开模拟器，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPG2YGhibTb0YhQ8Z9T3XcbRliaREicZyAkhkD1Y9jp9VY0oN6ubAmd0TJTw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>可以看到 H5 已经在「壳子」中运行起来了，下来就可以尝试调用 <code>Webview</code> 的方法，和「壳子」交互了。更多的调试技巧可以参考文章：iOS 模拟器调试。</p>
<blockquote>
<p>具体的调试功能还是依赖浏览器的开发选项，与上无异，就不赘述了。</p>
</blockquote>
<h3 id="三、抓包"><a href="#三、抓包" class="headerlink" title="三、抓包"></a>三、抓包</h3><blockquote>
<p>Charles：Mac OS 系统首选的抓包工具，适合查看、控制网络请求，分析数据情况。</p>
</blockquote>
<p><code>Charles</code> 抓包首先需要配置手机代理，<code>Wifi</code> - 配置代理（IP 地址） - 手动，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGIP6SIiablZyr5dIVUR5cia8o0Q48e6HDWNDg7pGeKqF595UpxGQzdmRA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGicEHia9puWnLMbfFpugT6JyS0kvmfAjPiccKCneicr3a16wibKL3icI9eZEA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>配置好手机代理，这时候打开 <code>Charles</code> ，就会收到确认提醒，选择允许。接下来就可以捕获手机的请求了，但是这些都是常规操作，我们来点高级的。</p>
<blockquote>
<p>有意思的是：我们可以用本地文件来替换线上文件，方便调试，远程定位线上问题。</p>
</blockquote>
<p>选择 <code>Structure</code>，找到需要替换的文件，右键菜单 - <code>Map Local</code>，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPG74USxfw2vn2icibocyibnKstkO9ux4e63ck3Nun2gKEicCrIL9Hs7U6JpA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>这时候就会打开一个弹窗，填写具体的配置：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGReaE3gLGUgBaTj42WpmGvia2uibqJ7LL2ict6BmMbq9r5BwzJKfDOZ3qQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>OK，大功告成，快去改动本地文件吧，从此再也不怕线上调试了。需要注意的是如果抓取 <code>HTTPS</code> 请求，要安装信任证书，下文会详细说明。</p>
<blockquote>
<p>与之相应的是 Windows 平台的 Fiddler，功能大致相似，这里就不细说了。</p>
</blockquote>
<h3 id="四、Spy-Debugger"><a href="#四、Spy-Debugger" class="headerlink" title="四、Spy-Debugger"></a>四、Spy-Debugger</h3><blockquote>
<p>spy-debugger：移动端调试的利器，便捷的远程调试手机页面、抓包工具。</p>
</blockquote>
<p>我们先来安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sudo npm install spy-debugger -g</span><br></pre></td></tr></table></figure>

<p>启动命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; spy-debugger</span><br></pre></td></tr></table></figure>

<p>这时候，控制台会打印出如下信息，说明服务已经启动了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正在启动代理</span><br><span class="line">本机在当前网络下的IP地址为：10.200.24.46</span><br><span class="line">node-mitmproxy启动端口: 9888</span><br><span class="line">浏览器打开 ---&gt; http:&#x2F;&#x2F;127.0.0.1:50389</span><br></pre></td></tr></table></figure>

<p>最后一步，设置手机代理：<code>10.200.24.46</code>，端口号：<code>9888</code>。补充说明一下：</p>
<ul>
<li><code>Android</code> 设置代理步骤：设置 - <code>WLAN</code> - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动</li>
<li><code>iOS</code> 设置代理步骤：设置 - 无线局域网 - 选中网络 - <code>HTTP</code> 代理手动</li>
</ul>
<p>接下来，尝试一下抓包：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGfV4YjUQtJvCcz3YCmZlY3X2Uias1BVcD8dVfIxmAQEsuXu3hTRkgUQg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>再打开调试页面：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGWib9eta6RUGqoIDZ7ezGblAEC5ocWshv0GiavhfJlGsn08pbrYD9MXaw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p><code>HTTPS</code> 抓包，需要安装根证书，下文会详细说明。</p>
</blockquote>
<h3 id="五、Whistle"><a href="#五、Whistle" class="headerlink" title="五、Whistle"></a>五、Whistle</h3><p>上面推荐了一款操作简单的调试利器，升级一下，看看更加强大的调试工具 <code>whistle</code>。</p>
<blockquote>
<p>whistle：基于 <code>Node</code> 实现的跨平台 <code>Web</code> 调试代理工具。</p>
</blockquote>
<p><code>whistle</code>(读音[ˈwɪsəl]，拼音[wēisǒu])是基于 <code>Node</code>实现的跨平台抓包调试代理工具，有以下基本功能：</p>
<ol>
<li>查看 <code>HTTP</code>、<code>HTTPS</code>请求响应内容</li>
<li>查看 <code>WebSocket</code>、<code>Socket</code> 收发的帧数据</li>
<li>设置请求 <code>hosts</code>、上游 <code>http/socks</code> 代理</li>
<li>修改请求 <code>url</code> 、方法、头部、内容</li>
<li>修改响应状态码、头部、内容，并支持本地替换</li>
<li>修改 <code>WebSocket</code> 或 <code>Socket</code> 收发的帧数据</li>
<li>内置调试移动端页面的 <code>weinre</code> 和 <code>log</code></li>
<li>作为 <code>HTTP</code> 代理或反向代理</li>
<li>支持用 <code>Node</code> 编写插件扩展功能</li>
</ol>
<p>大致了解后，我们来尝试安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install -g whistle</span><br></pre></td></tr></table></figure>

<blockquote>
<p>淘宝镜像：npm install whistle -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</blockquote>
<p><code>whistle</code> 安装完成后，执行命令 <code>whistle help</code> 或 <code>w2 help</code>，查看 <code>whistle</code> 的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run       Start a front service</span><br><span class="line">start     Start a background service</span><br><span class="line">stop      Stop current background service</span><br><span class="line">restart   Restart current background service</span><br><span class="line">help      Display help information</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里只列出部分命令，更多请 w2 help 查看。</p>
</blockquote>
<p>看到上面的操作，我们何不试试缩写 <code>w2 start</code> 来启动服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w2 start</span><br></pre></td></tr></table></figure>

<p>看到如下的输出，说明服务已经正常启动了：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGYCUTtVOiakJN9LoAJGSe0Q3aEyiaZEAYibuDmzN9valO3tHbcKkKSicpWw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>这时候在浏览器打开链接，同时手机上配置代理（同 <code>Charles</code>），接下来就可以愉快的调试了。值得注意的是，<code>whistle</code> 的功能远非如此，更多的扩展请移步官网文档，贴张图先预览下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPG43iak9r6lQ2cO908NJdTN6JnOe9zJyzlicYRUMTibTNWaZMyR9zM6FWoA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p>记得开启拦截 <code>HTTPS</code>：勾选 <code>Capture HTTPS CONNECTs</code></p>
</blockquote>
<h3 id="六、安装-HTTPS-证书"><a href="#六、安装-HTTPS-证书" class="headerlink" title="六、安装 HTTPS 证书"></a>六、安装 HTTPS 证书</h3><p>对于 <code>Charles</code>，按照如下操作安装证书：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help-SSL - Proxying - install Charles root</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGTRe4npicqmibG2ZKhicTib5U30I0Ia2lzLZEH5uAbACwuYzbLStxuv3faA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>弹出安装证书的提示框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGMtQl9rGd7vdP2juoK81CS8oreAdqia1zwfAFzEPjwOyLpUNR52AftnQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p>按照提示去手机浏览器打开：<code>chls.pro/ssl</code>，安装信任证书即可。</p>
</blockquote>
<p>对于 <code>spy-debugger</code>，<code>HTTPS</code> 抓包，需要安装根证书，选择 <code>RootCA</code>，扫描二维码按照提示信任证书。安装证书的时候需要注意以下几件事情：</p>
<p>1.手机必须先设置完代理后再通过(非微信)手机浏览器访问 <code>http://s.xxx</code> (地址二维码)安装证书；<br>2.手机首次调试需要安装证书，已安装了证书的手机无需重复安装；<br>3.手机和 <code>PC</code> 保持在同一网络下（比如同时连到一个 <code>WIFI</code> 下）；</p>
<blockquote>
<p>切记：移动设备和 PC 必须在一个 WIFI 下。</p>
</blockquote>
<h3 id="七、真机调试"><a href="#七、真机调试" class="headerlink" title="七、真机调试"></a>七、真机调试</h3><p>上面说了很多，但是实际开发过程中，我们不会等上线了才去验证兼容性，所以你可能需要提前「真机调试」。这里提供两种方式：</p>
<blockquote>
<p><code>Chrome Remote Devices</code>：依赖 Chrome 来进行远程调试，适合安卓手机。</p>
</blockquote>
<p>首先，开启 <code>Android</code> 手机的「开发者选项」，勾选 「USB 调试」。<br>然后，<code>Chrome</code> 中输入：<code>chrome://inspect</code>，进入调试页面。</p>
<p>很全面的一篇文章，可以参考：Chrome 远程调试。</p>
<blockquote>
<p><code>localhost</code> 转 <code>ip</code>，扫描二维码手机显示，这个比较简单。</p>
</blockquote>
<p>可以在浏览器安装一个 <code>Chrome</code> 插件，用于将当前页面链接转换成二维码，这样就能边开发边真机预览，非常方便。</p>
<h3 id="八、调试工具"><a href="#八、调试工具" class="headerlink" title="八、调试工具"></a>八、调试工具</h3><p>这里推荐一款调试工具：vConsole，一个轻量、可拓展、针对手机网页的前端开发者调试面板。安装很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure>

<p>如果未使用 <code>AMD/CMD</code> 规范，可直接在 <code>HTML</code> 中引入 <code>vConsole</code> 模块。为了便于后续扩展，建议在 <code>&lt;head&gt;</code> 中引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;path&#x2F;to&#x2F;vconsole.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"> var vConsole &#x3D; new VConsole();</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>

<p>如果使用了 <code>AMD/CMD</code> 规范，可在 <code>module</code> 内使用 <code>require()</code> 引入模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var VConsole &#x3D; require(&#39;path&#x2F;to&#x2F;vconsole.min.js&#39;);</span><br><span class="line">var vConsole &#x3D; new VConsole();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，<code>VConsole</code> 只是 <code>vConsole</code> 的原型，而非一个已实例化的对象。</p>
</blockquote>
<p>所以在手动 <code>new</code> 实例化之前，<code>vConsole</code> 不会被插入到网页中。大概功能如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGgpGJKoNJU52RPRqRoTQk3icaicDxjQLLXCb3mjcsHxfr2xtOmucVKbLg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGf2t3W9eBQjBN03LB7ebQ5y6FAKypnUiboCic162ELGIUTg6xktpz167w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>看起来很完美，但是有个小缺点：网络请求，需要刷新页面，可是很多内嵌的 <code>H5</code> 页面是没有机会刷新页面的，所以需要客户端童鞋配合增加刷新的功能方便调试。</p>
<h3 id="九、场景分析"><a href="#九、场景分析" class="headerlink" title="九、场景分析"></a>九、场景分析</h3><blockquote>
<p>既然移动端调试有这么多种方案，那在实际操作中，我该如何取舍？</p>
</blockquote>
<p>说了这么多钟方案，这里总结一下各个方案的适用场景，根据不同的场景去选择最佳的调试方案，这样才能更快速的输出，<code>Carry</code> 全场：</p>
<p>1.<code>Safari</code>：<code>iPhone</code> 调试利器，查错改样式首选；<br>2.<code>iOS</code> 模拟器：不需要真机，适合调试 <code>Webview</code> 和 <code>H5</code> 有频繁交互的功能页面；<br>3.<code>Charles</code>：<code>Mac OS</code> 系统首选的抓包工具，适合查看、控制网络请求，分析数据情况；<br>4.<code>Fiddler</code>：适合 <code>Windows</code> 平台，与 <code>Charles</code> 类似，查看、控制网络请求，分析数据情况；<br>5.<code>Spy-Debugger</code>：移动端调试的利器，便捷的远程调试手机页面、抓包工具；<br>6.<code>Whistle</code>：基于 <code>Node</code> 实现的跨平台 <code>Web</code> 调试代理工具；<br>7.<code>Chrome Remote Devices</code>：依赖 <code>Chrome</code> 来进行远程调试，适合安卓手机远程调试静态页；<br>8.<code>localhost</code> 转 <code>ip</code>：真机调试，适合远程调试静态页面；<br>9.<code>vConsole</code>：内置于项目，打印移动端日志，查看网络请求以及查看 <code>Cookie</code> 和 <code>Storage</code>；</p>
<h3 id="十、白屏处理"><a href="#十、白屏处理" class="headerlink" title="十、白屏处理"></a>十、白屏处理</h3><blockquote>
<p>移动端的白屏是最头疼的问题，这里顺带提供几种分析问题的思路，以供参考。</p>
</blockquote>
<p><strong>1.方案分析 ☆</strong></p>
<p>一般上线后出现问题，我们最容易想到的就是：是否是新代码引起的问题。所以有效解决手段就是「控制变量法」。</p>
<p><strong>2.代码注释法 ☆</strong></p>
<p>莫名奇妙的白屏，适合页面无异常日志，同时无请求发送，问题集中在单一页面的情况。这种问题比较直观，肯定是某一页面出现了代码异常或是无效的 <code>return</code>，导致页面渲染终止，但并不属于异常。这时候，「代码注释法」将是你的最佳选择，逐行去注释可以代码，直到定位问题。</p>
<p><strong>3.类库异常，兼容问题 ☆</strong></p>
<p>这种场景也会经常遇到，我们需要用可以调试页面异常的方式，如 <code>Safari</code>，<code>Spy-Debugger</code>，<code>Whistle</code>，<code>vConsole</code> 查看异常日志，从而迅速定位类库位置，从而找寻替换或是兼容方案。</p>
<p><strong>4.try catch ☆☆</strong></p>
<p>如果你的项目没有异常监控，那么在可疑的代码片段中去 <code>Try Catch</code> 吧。</p>
<p><strong>5.Debug 包 ☆☆☆</strong></p>
<p>在你的项目中装上 <code>[vConsole](https://link.zhihu.com/?target=http%3A//jartto.wang/2018/11/01/mobile-debug/)</code>，并配合客户端 <code>debug</code> 插件，<code>360</code> 度无死角监控异常，这才是最有效的方式。</p>
<p><strong>6.ES6 语法兼容 ☆</strong></p>
<p>一般我们都会通过 <code>Babel</code> 来编译 <code>ES6</code> ，但是额外的第三方类库如果有不兼容的语法，低版本的移动设备就会异常。所以，先用上文讲述的调试方法，确定异常，然后去增加 <code>[polyfill](https://link.zhihu.com/?target=https%3A//polyfill.io/v2/docs/examples)</code> 来兼容吧。</p>
<p>参考链接：<a href="https://mp.weixin.qq.com/s/eUDhoFh7GhdY2oGoSnD88Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eUDhoFh7GhdY2oGoSnD88Q</a></p>
]]></content>
      <categories>
        <category>移动端调试</category>
      </categories>
      <tags>
        <tag>移动端调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vs</title>
    <url>/2020/07/15/Vs/</url>
    <content><![CDATA[<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>1.复制/剪切/删除整行代码</p>
<blockquote>
<p>1)如果你想复制一整行代码，只需将光标移至该行，再使用组合键“Ctrl+C”来完成复制操作，而无需选择整行。</p>
<p>2)如果你想剪切一整行代码，只需将光标移至该行，再使用组合键“Ctrl+X”来完成剪切操作，而无需选择整行。</p>
<p>3)如果你想删除一整行代码，只需将光标移至该行，再使用组合键“Ctrl+L”来完成剪切操作，而无需选择整行。</p>
</blockquote>
<p>2.撤销/反撤销</p>
]]></content>
      <categories>
        <category>vs</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>tool</tag>
        <tag>vs</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/08/06/Promise/</url>
    <content><![CDATA[<p>本质上Promise是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</p>
<p>假设现在有一个名为 <code>createAudioFileAsync()</code> 的函数，它接收一些配置和两个回调函数，然后异步地生成音频文件。一个回调函数在文件成功创建时的被调用，另一个则在出现异常时的被调用。</p>
<p>以下为使用 <code>createAudioFileAsync()</code> 的示例：</p>
<a id="more"></a>

<h3 id="promise定义和用法"><a href="#promise定义和用法" class="headerlink" title="promise定义和用法"></a>promise定义和用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 成功的回调函数</span><br><span class="line">function successCallback(result) &#123;</span><br><span class="line">  console.log(&quot;音频文件创建成功: &quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 失败的回调函数</span><br><span class="line">function failureCallback(error) &#123;</span><br><span class="line">  console.log(&quot;音频文件创建失败: &quot; + error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;普通定义和用法</span><br><span class="line">function createAudioFileAsync(params, successCallback, failureCallback) &#123;</span><br><span class="line">  console.log(params);</span><br><span class="line">  successCallback&amp;&amp;successCallback()</span><br><span class="line">  failureCallback&amp;&amp;failureCallback()</span><br><span class="line">&#125;</span><br><span class="line">createAudioFileAsync(&quot;我是传入参数&quot;, successCallback(&#39;result&#39;), failureCallback(&#39;error&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;promise定义和用法</span><br><span class="line">function createAudioFileAsync(params) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(</span><br><span class="line">      console.log(params)</span><br><span class="line">    )</span><br><span class="line">    reject(</span><br><span class="line">      console.log(&#39;reject--我是拒绝回调&#39;)</span><br><span class="line">    )</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">createAudioFileAsync(&quot;我是传入参数&quot;).then(successCallback(&#39;result&#39;), failureCallback(&#39;error&#39;));</span><br></pre></td></tr></table></figure>

<h3 id="promise链式调用"><a href="#promise链式调用" class="headerlink" title="promise链式调用"></a>promise链式调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在过去，要想做多重的异步操作，会导致经典的回调地狱：</span><br><span class="line">function doSomething(ftc,fail) &#123;</span><br><span class="line">  ftc &amp;&amp; ftc(&#39;doSomething&#39;)</span><br><span class="line">  fail &amp;&amp; fail()</span><br><span class="line">&#125;</span><br><span class="line">function doSomethingElse(ftc, callback, fail) &#123;</span><br><span class="line">  callback &amp;&amp; callback(ftc)</span><br><span class="line">  fail &amp;&amp; fail()</span><br><span class="line">&#125;</span><br><span class="line">function doThirdThing(ftc, callback, fail) &#123;</span><br><span class="line">  callback &amp;&amp; callback(ftc)</span><br><span class="line">  fail &amp;&amp; fail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(function (result) &#123;</span><br><span class="line">  doSomethingElse(result, function (newResult) &#123;</span><br><span class="line">    doThirdThing(newResult, function (finalResult) &#123;</span><br><span class="line">      console.log(finalResult);</span><br><span class="line">    &#125;,failureCallback);</span><br><span class="line">  &#125;,failureCallback);</span><br><span class="line">&#125;,failureCallback);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;现在，我们可以把回调绑定到返回的 Promise 上，形成一个 Promise 链：</span><br><span class="line">function doSomething() &#123;</span><br><span class="line">  return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    resolve(&#39;doSomething&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function doSomethingElse(name) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(name + &#39;1&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function doThirdThing(name) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(name + &#39;2&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">doSomething().then(function (result) &#123;</span><br><span class="line">  return doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(function (newResult) &#123;</span><br><span class="line">    return doThirdThing(newResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (finalResult) &#123;</span><br><span class="line">    console.log(&#39;Got the final result: &#39; + finalResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(failureCallback);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">doSomething().then(result&#x3D;&gt; &#123;</span><br><span class="line">  return doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(newResult&#x3D;&gt; &#123;</span><br><span class="line">    return doThirdThing(newResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(finalResult&#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;Got the final result: &#39; + finalResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(failureCallback);</span><br><span class="line"></span><br><span class="line">() &#x3D;&gt; x 是 () &#x3D;&gt; &#123; return x; &#125;的简写</span><br></pre></td></tr></table></figure>



<h3 id="Pomise-all的使用"><a href="#Pomise-all的使用" class="headerlink" title="Pomise.all的使用"></a>Pomise.all的使用</h3><p>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</p>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&#39;成功了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&#39;success&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p3 &#x3D; Promise.reject(&#39;失败&#39;)</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)               &#x2F;&#x2F;[&#39;成功了&#39;, &#39;success&#39;]</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.all([p1,p3,p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)      &#x2F;&#x2F; 失败了，打出 &#39;失败&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>Promse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。</strong></p>
<ul>
<li>代码模拟：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let wake &#x3D; (time) &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(&#96;$&#123;time &#x2F; 1000&#125;秒后醒来&#96;)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 &#x3D; wake(3000)</span><br><span class="line">let p2 &#x3D; wake(2000)</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)       &#x2F;&#x2F; [ &#39;3秒后醒来&#39;, &#39;2秒后醒来&#39; ]</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</strong></p>
<h3 id="Promise-race的使用"><a href="#Promise-race的使用" class="headerlink" title="Promise.race的使用"></a>Promise.race的使用</h3><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;success&#39;)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    reject(&#39;failed&#39;)</span><br><span class="line">  &#125;, 500)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.race([p1, p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)  &#x2F;&#x2F; 打开的是 &#39;failed&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise</tag>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode</title>
    <url>/2020/07/15/VsCode/</url>
    <content><![CDATA[<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><blockquote>
<p>官网下载：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p>
</blockquote>
<a id="more"></a>

<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><blockquote>
<p>Alt+Z   文件自动换行</p>
<p>Ctrl + / （单行注释）</p>
<p>Shift + Alt + A （多行注释） </p>
<p>若要取消单行或多行注释在按一次该快捷键即可</p>
<p>Ctrl + Shift + Enter （上方插入一行，鼠标光标在当前行的任意位置都可以直接换行到上一行）</p>
<p>Ctrl + Enter （下方插入一行，鼠标光标在当前行的任意位置都可以直接换行到下一行）</p>
<p>Alt + Shift + F （格式化代码，不需要全选中代码，直接格式化即可）</p>
<p>Ctrl + Shift + F （查找文件）</p>
<p>点击设置选择 keyboard shortcuts，右边会弹出所有快捷键目录</p>
</blockquote>
<h4 id="code改成中文"><a href="#code改成中文" class="headerlink" title="code改成中文"></a>code改成中文</h4><blockquote>
<p>方法一：点击插件按钮搜索 Chinese</p>
<p>方法二：</p>
<p>1）打开vscode工具；</p>
<p>2）使用快捷键组合【Ctrl+Shift+p】，在搜索框中输入“configure display language”，点击确定后；</p>
<p>3）修改locale.json文件下的属性“locale”为“zh-CN”;</p>
<p>4）重启vscode工具；</p>
<p>或者 汉化中文（插件）</p>
<p>点击插件按钮搜索 Chinese, 在弹出的选项中选择第一个中文简体</p>
<p>然后右边会弹出如下图安装界面，接着点击 Install 安装</p>
</blockquote>
<h4 id="自动保存设置"><a href="#自动保存设置" class="headerlink" title="自动保存设置"></a>自动保存设置</h4><blockquote>
<p>File（文件）- Preferences（首选项）- Setting （设置）然后弹出下面界面，选择User（一般会默认选中该选项）， </p>
<p>接着如下图选择afterdelay选项即可，下面有个数字1000表示1秒，这个可自行设置，表示多少秒以后自动保存</p>
</blockquote>
<h4 id="自动格式化代码"><a href="#自动格式化代码" class="headerlink" title="自动格式化代码"></a>自动格式化代码</h4><blockquote>
<p>File（文件）- Preferences（首选项）- Setting （设置）</p>
<p>User（用户）- Text-Editor（文本编辑）- Formatng（格式化）</p>
<p>然后勾选下图红色框中的选项后重启Vscode即可</p>
</blockquote>
<h4 id="Vscode更换主题"><a href="#Vscode更换主题" class="headerlink" title="Vscode更换主题"></a>Vscode更换主题</h4><blockquote>
<p>File（文件）- Preferences（首选项）- Color-Theme （颜色主题）</p>
<p>然后会出现下图红色框的界面，此时按键盘上的上下键即可实时查看主题颜色，直接回车可选中对应主题</p>
<p>注：可以点击插件直接搜索 theme 下载其它非内置主题</p>
</blockquote>
<h4 id="隐藏文件夹"><a href="#隐藏文件夹" class="headerlink" title="隐藏文件夹"></a>隐藏文件夹</h4><h5 id="1-点击快捷键Ctrl-Command-Shift-P，输入setting，选择User-Settings那一项；"><a href="#1-点击快捷键Ctrl-Command-Shift-P，输入setting，选择User-Settings那一项；" class="headerlink" title="1. 点击快捷键Ctrl/Command+Shift+P，输入setting，选择User Settings那一项；"></a>1. 点击快捷键Ctrl/Command+Shift+P，输入setting，选择User Settings那一项；</h5><p><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531092521602-901731205.png" alt="按快捷键Ctrl/Command+Shift+P"><br><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531092631020-909971842.png" alt="选择User Settings"></p>
<h5 id="2-点击VS-Code右上角的小图标查看脚本："><a href="#2-点击VS-Code右上角的小图标查看脚本：" class="headerlink" title="2. 点击VS Code右上角的小图标查看脚本："></a>2. 点击VS Code右上角的小图标查看脚本：</h5><p><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531092822279-1906753004.png" alt="点击小图标"><br><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531092939851-854795479.png" alt="查看脚本"></p>
<h5 id="3-在该脚本中，添加排除文件或排除文件夹的代码："><a href="#3-在该脚本中，添加排除文件或排除文件夹的代码：" class="headerlink" title="3. 在该脚本中，添加排除文件或排除文件夹的代码："></a>3. 在该脚本中，添加排除文件或排除文件夹的代码：</h5><p><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531093027056-1932271038.png" alt="示例"></p>
<h5 id="4-如果是隐藏指定后缀的文件，使用”-你要隐藏的文件后缀”-；如果是隐藏指定的文件夹，使用”-你要隐藏的文件夹名称”即可实现。详情如下："><a href="#4-如果是隐藏指定后缀的文件，使用”-你要隐藏的文件后缀”-；如果是隐藏指定的文件夹，使用”-你要隐藏的文件夹名称”即可实现。详情如下：" class="headerlink" title="4. 如果是隐藏指定后缀的文件，使用”/*.你要隐藏的文件后缀” ；如果是隐藏指定的文件夹，使用”/你要隐藏的文件夹名称”即可实现。详情如下："></a>4. 如果是隐藏指定后缀的文件，使用”<strong>/*.你要隐藏的文件后缀” ；如果是隐藏指定的文件夹，使用”</strong>/你要隐藏的文件夹名称”即可实现。详情如下：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;files.exclude&quot;: &#123;</span><br><span class="line">    &quot;*.metadata&quot;: true,</span><br><span class="line">    &quot;*.settings&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.pyc&quot;: true, &#x2F;&#x2F;隐藏所有pyc文件</span><br><span class="line">    &quot;**&#x2F;*.meta&quot;: true, &#x2F;&#x2F;隐藏所有meta文件</span><br><span class="line">    &quot;**&#x2F;*.prefab&quot;: true, &#x2F;&#x2F;隐藏所有prefab文件</span><br><span class="line">    &quot;**&#x2F;*.d.ts&quot;: true, &#x2F;&#x2F;隐藏所有d.ts文件</span><br><span class="line">    &quot;**&#x2F;*.fnt&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.sln&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.csproj&quot;: true,</span><br><span class="line">    &quot;**&#x2F;.vscode&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.anim&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.controller&quot;: true,</span><br><span class="line">    &quot;**&#x2F;Logs&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Pp]lugins&quot;: true, &#x2F;&#x2F;使用中括号时表示不区分大小写</span><br><span class="line">    &quot;**&#x2F;[Mm]aterials&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Aa]nimation&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Pp]ackages&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Tt]extures&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Ss]cenes&quot;: true,</span><br><span class="line">    &quot;**&#x2F;temp&quot;: true, &#x2F;&#x2F;隐藏temp文件夹</span><br><span class="line">    &quot;**&#x2F;library&quot;: true, &#x2F;&#x2F;隐藏library文件夹</span><br><span class="line">    &quot;**&#x2F;audio&quot;: true, &#x2F;&#x2F;隐藏audio文件夹</span><br><span class="line">    &quot;**&#x2F;video&quot;: true, &#x2F;&#x2F;隐藏video文件夹</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vscode-Tab补齐代码设置"><a href="#vscode-Tab补齐代码设置" class="headerlink" title="vscode Tab补齐代码设置"></a>vscode Tab补齐代码设置</h4><p><strong>步骤1：</strong><br>进入vscode里面 =&gt; 文件 =&gt; 首选项 =&gt; 设置=&gt; 工作台=&gt; 外观 =&gt; 在settings.json中编辑 进入编辑状态</p>
<p><strong>步骤2：</strong></p>
<p>添加这个之后保存即可<br>{<br>“emmet.triggerExpansionOnTab”:true<br>}</p>
<h4 id="console-log快捷键"><a href="#console-log快捷键" class="headerlink" title="console.log快捷键"></a>console.log快捷键</h4><ol>
<li>打开vscode,选择文件–首选项–用户代码片段</li>
<li>选择javascript类型，打开javascript.json文件</li>
<li>按照操作，设置快捷输入</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"Print to console"</span>: &#123;</span><br><span class="line">			<span class="string">"prefix"</span>: <span class="string">"lg"</span>,</span><br><span class="line">			<span class="string">"body"</span>: [</span><br><span class="line">				<span class="string">"console.log('$1');"</span>,</span><br><span class="line">			],</span><br><span class="line">			<span class="string">"description"</span>: <span class="string">"Log output to console"</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>tool</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue数据更新但页面没有更新的7种情况</title>
    <url>/2020/09/10/Vue%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BD%86%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%E7%9A%847%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h3 id="Vue-set与-vue-set在使用中的区别-delete和this-delete"><a href="#Vue-set与-vue-set在使用中的区别-delete和this-delete" class="headerlink" title="Vue.set与 vue.$set在使用中的区别(delete和this.$delete)"></a>Vue.set与 vue.$set在使用中的区别(delete和this.$delete)</h3><p>Vue.set 可以设置实例创建之后添加的属性，如sex，而this.$set/vue.$set/vm.$set只能设置实例创建后存在的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    name: <span class="string">"简书"</span>,</span><br><span class="line">    age: <span class="string">'3'</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">        content: <span class="string">'my name is test'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">var</span> key = <span class="string">'content'</span>;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data: data,</span><br><span class="line">    ready: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Vue.set(data,<span class="string">'sex'</span>, <span class="string">'男'</span>)</span><br><span class="line">        <span class="keyword">this</span>.$<span class="keyword">set</span>('sex', '女')</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Vue-无法检测对象-property-的添加或移除"><a href="#Vue-无法检测对象-property-的添加或移除" class="headerlink" title="Vue 无法检测对象 property 的添加或移除"></a>Vue 无法检测对象 property 的添加或移除</h3><p>原因：官方 - 由于 JavaScript（ES5） 的限制，Vue.js <strong>不能检测到对象属性的添加或删除</strong>。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 <code>data</code> 对象上才能让 Vue.js 转换它，才能让它是响应的。</p>
<p>场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      id: 001</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 页面不会变化</span><br><span class="line">  template: &#39;&lt;div&gt;&#123;&#123; obj.message &#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.obj.message &#x3D; &#39;hello&#39; &#x2F;&#x2F; 不是响应式的</span><br><span class="line">delete vm.obj.id       &#x2F;&#x2F; 不是响应式的</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态添加 - Vue.set</span><br><span class="line">Vue.set(vm.obj, propertyName, newValue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态添加 - vm.$set</span><br><span class="line">vm.$set(vm.obj, propertyName, newValue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态添加多个</span><br><span class="line">&#x2F;&#x2F; 代替 Object.assign(this.obj, &#123; a: 1, b: 2 &#125;)</span><br><span class="line">this.obj &#x3D; Object.assign(&#123;&#125;, this.obj, &#123; a: 1, b: 2 &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态移除 - Vue.delete</span><br><span class="line">Vue.delete(vm.obj, propertyName)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态移除 - vm.$delete</span><br><span class="line">vm.$delete(vm.obj, propertyName)</span><br></pre></td></tr></table></figure>


<h3 id="Vue-不能检测通过数组索引直接修改一个数组项"><a href="#Vue-不能检测通过数组索引直接修改一个数组项" class="headerlink" title="Vue 不能检测通过数组索引直接修改一个数组项"></a>Vue 不能检测通过数组索引直接修改一个数组项</h3><p>原因：官方 - 由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化；尤雨溪 - 性能代价和获得用户体验不成正比。</p>
<p>场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[1] &#x3D; &#39;x&#39; &#x2F;&#x2F; 不是响应性的</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue.set</span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; vm.$set</span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>



<h3 id="Vue-不能监测直接修改数组长度的变化"><a href="#Vue-不能监测直接修改数组长度的变化" class="headerlink" title="Vue 不能监测直接修改数组长度的变化"></a>Vue 不能监测直接修改数组长度的变化</h3><p>原因：官方 - 由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化；尤雨溪 - 性能代价和获得用户体验不成正比。</p>
<p>场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items.length &#x3D; 2 &#x2F;&#x2F; 不是响应性的</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>



<h3 id="在异步更新执行之前操作-DOM-数据不会变化-nextTick"><a href="#在异步更新执行之前操作-DOM-数据不会变化-nextTick" class="headerlink" title="在异步更新执行之前操作 DOM 数据不会变化(nextTick)"></a>在异步更新执行之前操作 DOM 数据不会变化(nextTick)</h3><p>原因：Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>
<p>场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;123&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message &#x3D; &#39;new message&#39; &#x2F;&#x2F; 更改数据</span><br><span class="line">vm.$el.textContent &#x3D;&#x3D;&#x3D; &#39;new message&#39; &#x2F;&#x2F; false</span><br><span class="line">vm.$el.style.color &#x3D; &#39;red&#39; &#x2F;&#x2F; 页面没有变化</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;123&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message &#x3D; &#39;new message&#39; &#x2F;&#x2F; 更改数据</span><br><span class="line">&#x2F;&#x2F;使用 Vue.nextTick(callback) callback 将在 DOM 更新完成后被调用</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  vm.$el.textContent &#x3D;&#x3D;&#x3D; &#39;new message&#39; &#x2F;&#x2F; true</span><br><span class="line">  vm.$el.style.color &#x3D; &#39;red&#39; &#x2F;&#x2F; 文字颜色变成红色</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>数据更新</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2020/09/14/WebSocket/</url>
    <content><![CDATA[<h2 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a><strong>什么是WebSocket</strong></h2><p>首先需要明白webSocket的概念，下边是维基百科的解释</p>
<blockquote>
<p>WebSocket是一种通信协议，可在单个TCP连接上进行全双工通信。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以建立持久性的连接，并进行双向数据传输。</p>
</blockquote>
<p>首先，要明白WebSocket是一种通信协议，区别于HTTP协议，HTTP协议只能实现客户端请求，服务端响应的这种单项通信。<br>而WebSocket可以实现客户端与服务端的双向通讯，说白了，最大也是最明显的区别就是可以做到服务端主动将消息推送给客户端。<br>其余的特点有：</p>
<ul>
<li>握手阶段采用 HTTP 协议。</li>
<li>数据格式轻量，性能开销小。客户端与服务端进行数据交换时，服务端到客户端的数据包头只有2到10字节，客户端到服务端需要加上另外4字节的掩码。HTTP每次都需要携带完整头部。</li>
<li>更好的二进制支持，可以发送文本，和二进制数据</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则是wss），请求的地址就是后端支持websocket的API。</li>
</ul>
<a id="more"></a>

<h2 id="几种与服务端实时通信的方法"><a href="#几种与服务端实时通信的方法" class="headerlink" title="几种与服务端实时通信的方法"></a><strong>几种与服务端实时通信的方法</strong></h2><p>我们都知道，不使用WebSocket与服务器实时交互，一般有两种方法。AJAX轮询和Long Polling长轮询。</p>
<h3 id="AJAX轮询"><a href="#AJAX轮询" class="headerlink" title="AJAX轮询"></a><strong>AJAX轮询</strong></h3><p>AJAX轮询也就是定时发送请求，也就是普通的客户端与服务端通信过程，只不过是无限循环发送，这样，可以保证服务端一旦有最新消息，就可以被客户端获取。</p>
<h3 id="Long-Polling长轮询"><a href="#Long-Polling长轮询" class="headerlink" title="Long Polling长轮询"></a><strong>Long Polling长轮询</strong></h3><p>Long Polling长轮询是客户端和浏览器保持一个长连接，等服务端有消息返回，断开。<br>然后再重新连接，也是个循环的过程，无穷尽也。。。</p>
<p>客户端发起一个Long Polling，服务端如果没有数据要返回的话，<br>会hold住请求，等到有数据，就会返回给客户端。客户端又会再次发起一次Long Polling，再重复一次上面的过程。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>上边这两种方式都有个致命的弱点，开销太大，被动性。假设并发很高的话，这对服务端是个考验。<br>而WebSocket一次握手，持久连接，以及主动推送的特点可以解决上边的问题，又不至于损耗性能。</p>
<h2 id="WebSocket连接过程"><a href="#WebSocket连接过程" class="headerlink" title="WebSocket连接过程"></a><strong>WebSocket连接过程</strong></h2><p>客户端发起HTTP握手，告诉服务端进行WebSocket协议通讯，并告知WebSocket协议版本。服务端确认协议版本，升级为WebSocket协议。之后如果有数据需要推送，会主动推送给客户端。</p>
<p>连接开始时，客户端使用HTTP协议和服务端升级协议，升级完成后，后续数据交换遵循WebSocket协议。我们看看Request Headers</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: 127.0.0.1:3000</span><br><span class="line">Origin: http://localhost:3000</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br><span class="line">Sec-WebSocket-Key: bwb9SFiJONXhQ/A4pLaXIg==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>重点字段是这些：</p>
<ul>
<li>Connection: Upgrade 表示要升级协议</li>
<li>Upgrade: websocket 要升级协议到websocket协议</li>
<li>Sec-WebSocket-Version 表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li>
<li>Sec-WebSocket-Key 对应服务端响应头的Sec-WebSocket-Accept，由于没有同源限制，websocket客户端可任意连接支持websocket的服务。这个就相当于一个钥匙一把锁，避免多余的，无意义的连接。</li>
</ul>
<p>再看看看服务端响应的 Response Headers</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: 2jrbCWSCPlzPtxarlGTp4Y8XD20=</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>关键是这个字段</p>
<ul>
<li>Sec-WebSocket-Accept: 用来告知服务器愿意发起一个websocket连接， 值根据客户端请求头的Sec-WebSocket-Key计算出来</li>
</ul>
<h2 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a><strong>WebSocket API</strong></h2><p>客户端若想要与支持webScoket的服务器通信，可以使用WebSocket构造函数返回WebSocket对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:3000&#x2F;websocket&quot;);</span><br></pre></td></tr></table></figure>

<p>这样，客户端就会与服务端开始连接。</p>
<p>返回的实例对象的属性：</p>
<ul>
<li>WebSocket.onopen： 连接成功后的回调</li>
<li>WebSocket.onclose： 连接关闭后的回调</li>
<li>WebSocket.onerror： 连接失败后的回调</li>
<li>WebSocket.onmessage： 客户端接收到服务端数据的回调</li>
<li>webSocket.bufferedAmount： 未发送至服务器的二进制字节数</li>
<li>WebSocket.binaryType： 使用二进制的数据类型连接</li>
<li>WebSocket.protocol ： 服务器选择的下属协议</li>
<li>WebSocket.url ： WebSocket 的绝对路径</li>
<li>WebSocket.readyState： 当前连接状态，对应的四个常量</li>
</ul>
<p>WebSocket.CONNECTING: 0</p>
<p>WebSocket.OPEN: 1</p>
<p>WebSocket.CLOSING: 2</p>
<p>WebSocket.CLOSED: 3</p>
<p>方法：</p>
<ul>
<li>WebSocket.close() 关闭当前连接</li>
<li>WebSocket.send(data) 向服务器发送数据</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>讲了那么多概念以后，终于可以看看怎么用了。实现WebSocket通信，需要客户端和服务端配合。</p>
<p>自己写了一个例子，服务端在开始连接后，利用定时器主动向客户端发送随机数，客户端也可以发给服务器消息，然后服务器返回这条消息给客户端。客户端就是js+html，服务端用了express + express-ws来实现。</p>
<p>示例链接：<a href="https://github.com/neroneroffy/webSocketDemo" target="_blank" rel="noopener">https://github.com/neroneroffy/webSocketDemo</a></p>
<h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;判断当前浏览器是否支持WebSocket</span><br><span class="line">if (&#39;WebSocket&#39; in window) &#123;</span><br><span class="line">    var serviceIp &#x3D;&quot;172.168.0.16:8880&quot;;</span><br><span class="line">    this.websocket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;&quot;+serviceIp+&quot;&#x2F;system&#x2F;websocket&quot;);</span><br><span class="line">&#125;else if (&#39;MozWebSocket&#39; in window) &#123;</span><br><span class="line">    var serviceIp &#x3D;&quot;172.168.0.16:8880&quot;;</span><br><span class="line">    this.websocket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;&quot;+serviceIp+&quot;&#x2F;system&#x2F;websocket&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    console.log(&#39;当前浏览器 Not support websocket&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="vue中使用"><a href="#vue中使用" class="headerlink" title="vue中使用"></a>vue中使用</h2><h3 id="sockjs-client"><a href="#sockjs-client" class="headerlink" title="sockjs-client"></a>sockjs-client</h3><p><a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener">sockjs-client</a>是从SockJS中分离出来的用于客户端使用的通信模块.所以我们就直接来看看SockJS. SockJS是一个浏览器的JavaScript库,它提供了一个类似于网络的对象,SockJS提供了一个连贯的,跨浏览器的JavaScriptAPI,它在浏览器和Web服务器之间创建了一个低延迟,全双工,跨域通信通道. 你可能会问,我为什么不直接用原生的WebSocket而要使用SockJS呢?这得益于SockJS的一大特性,一些浏览器中缺少对WebSocket的支持,因此，回退选项是必要的，而Spring框架提供了基于SockJS协议的透明的回退选项。SockJS提供了浏览器兼容性,优先使用原生的WebSocket,如果某个浏览器不支持WebSocket,SockJS会自动降级为轮询.</p>
<h3 id="stomjs"><a href="#stomjs" class="headerlink" title="stomjs"></a>stomjs</h3><p>STOMP(Simple Text-Orientated Messaging Protocol) 面向消息的简单文本协议; WebSocket是一个消息架构,不强制使用任何特定的消息协议,它依赖于应用层解释消息的含义. 与HTTP不同,WebSocket是处在TCP上非常薄的一层,会将字节流转化为文本/二进制消息,因此,对于实际应用来说,WebSocket的通信形式层级过低,因此，可以在 WebSocket 之上使用STOMP协议，来为浏览器 和 server间的 通信增加适当的消息语义。</p>
<p><strong>STOMP与WebSocket 的关系:</strong></p>
<ol>
<li>HTTP协议解决了web浏览器发起请求以及web服务器响应请求的细节,假设HTTP协议不存在,只能使用TCP套接字来编写web应用,你可能认为这是一件疯狂的事情;</li>
<li>直接使用WebSocket(SockJS)就很类似于使用TCP套接字来编写web应用,因为没有高层协议,就需要我们定义应用间发送消息的语义,还需要确保连接的两端都能遵循这些语义;</li>
<li>同HTTP在TCP套接字上添加请求-响应模型层一样,STOMP在WebSocket之上提供了一个基于帧的线路格式层,用来定义消息语义.</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码中除了最基本的连接,还设置了一个定时器,每隔十秒发送一条数据到服务器端,如果发生错误,catch这个错误,重新建立连接.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装并引入相关模块</span><br><span class="line">import SockJS from  &#39;sockjs-client&#39;;  </span><br><span class="line">import  Stomp from &#39;stompjs&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        dataList: []</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted:function()&#123;</span><br><span class="line">      this.initWebSocket();</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; 页面离开时断开连接,清除定时器</span><br><span class="line">      this.disconnect();</span><br><span class="line">      clearInterval(this.timer);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      initWebSocket() &#123;</span><br><span class="line">        this.connection();</span><br><span class="line">        let self &#x3D; this;</span><br><span class="line">        &#x2F;&#x2F; 断开重连机制,尝试发送消息,捕获异常发生时重连</span><br><span class="line">        this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            self.stompClient.send(&quot;test&quot;);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            console.log(&quot;断线了: &quot; + err);</span><br><span class="line">            self.connection();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">      &#125;,</span><br><span class="line">      removeTab(targetName) &#123;</span><br><span class="line">        console.log(targetName)</span><br><span class="line">      &#125;,</span><br><span class="line">      connection() &#123;</span><br><span class="line">      &#x2F;&#x2F; 建立连接对象</span><br><span class="line">        this.socket &#x3D; new SockJS(&#39;http:&#x2F;&#x2F;xxxxxx:8089&#x2F;ws&#39;);&#x2F;&#x2F;连接服务端提供的通信接口，连接以后才可以订阅广播消息和个人消息</span><br><span class="line">        &#x2F;&#x2F; 获取STOMP子协议的客户端对象</span><br><span class="line">        this.stompClient &#x3D; Stomp.over(this.socket);</span><br><span class="line">        &#x2F;&#x2F; 定义客户端的认证信息,按需求配置</span><br><span class="line">        var headers &#x3D; &#123;</span><br><span class="line">          login: &#39;mylogin&#39;,</span><br><span class="line">          passcode: &#39;mypasscode&#39;,</span><br><span class="line">          &#x2F;&#x2F; additional header</span><br><span class="line">          &#39;client-id&#39;: &#39;my-client-id&#39;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 向服务器发起websocket连接</span><br><span class="line">        this.stompClient.connect(headers,(frame) &#x3D;&gt; &#123;</span><br><span class="line">          this.stompClient.subscribe(&#39;&#x2F;topic&#x2F;chat_msg&#39;, (msg) &#x3D;&gt; &#123; &#x2F;&#x2F; 订阅服务端提供的某个topic</span><br><span class="line">           consolel.log(msg.body);  &#x2F;&#x2F; msg.body存放的是服务端发送给我们的信息</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 连接发生错误时的处理函数</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 断开连接</span><br><span class="line">      disconnect() &#123;</span><br><span class="line">        if (this.stompClient !&#x3D; null) &#123;</span><br><span class="line">          this.stompClient.disconnect();</span><br><span class="line">          console.log(&quot;Disconnected&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>链接：<a href="https://juejin.im/post/6844903664721592327" target="_blank" rel="noopener">https://juejin.im/post/6844903664721592327</a></p>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/2020/07/27/axios/</url>
    <content><![CDATA[<h3 id="vue中使用axios"><a href="#vue中使用axios" class="headerlink" title="vue中使用axios"></a>vue中使用axios</h3><h4 id="安装axios"><a href="#安装axios" class="headerlink" title="安装axios"></a>安装axios</h4><p>npm：</p>
<p>$ npm install axios -S</p>
<p>cdn：</p>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

<a id="more"></a>

<h4 id="配置axios"><a href="#配置axios" class="headerlink" title="配置axios"></a>配置axios</h4><p>在项目中新建api/index.js文件，用以配置axios</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">api/index.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">let</span> http = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'http://localhost:8080/'</span>,</span><br><span class="line">  withCredentials: <span class="literal">true</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded;charset=utf-8'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newData = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(k) === <span class="literal">true</span>) &#123;</span><br><span class="line">        newData += <span class="built_in">encodeURIComponent</span>(k) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[k]) + <span class="string">'&amp;'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newData;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apiAxios</span>(<span class="params">method, url, params, response</span>) </span>&#123;</span><br><span class="line">  http(&#123;</span><br><span class="line">    method: method,</span><br><span class="line">    url: url,</span><br><span class="line">    data: method === <span class="string">'POST'</span> || method === <span class="string">'PUT'</span> ? params : <span class="literal">null</span>,</span><br><span class="line">    params: method === <span class="string">'GET'</span> || method === <span class="string">'DELETE'</span> ? params : <span class="literal">null</span>,</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    response(res);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    response(err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (url, params, response) &#123;</span><br><span class="line">    <span class="keyword">return</span> apiAxios(<span class="string">'GET'</span>, url, params, response)</span><br><span class="line">  &#125;,</span><br><span class="line">  post: <span class="function"><span class="keyword">function</span> (<span class="params">url, params, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apiAxios(<span class="string">'POST'</span>, url, params, response)</span><br><span class="line">  &#125;,</span><br><span class="line">  put: <span class="function"><span class="keyword">function</span> (<span class="params">url, params, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apiAxios(<span class="string">'PUT'</span>, url, params, response)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">delete</span>: <span class="function"><span class="keyword">function</span> (<span class="params">url, params, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apiAxios(<span class="string">'DELETE'</span>, url, params, response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里的配置了POST、GET、PUT、DELETE方法。并且自动将<span class="built_in">JSON</span>格式数据转为URL拼接的方式</span><br><span class="line">同时配置了跨域，不需要的话将withCredentials设置为<span class="literal">false</span>即可</span><br><span class="line">并且设置了默认头部地址为：http:<span class="comment">//localhost:8080/，这样调用的时候只需写访问方法即可</span></span><br></pre></td></tr></table></figure>



<h4 id="请求拦截与响应拦截"><a href="#请求拦截与响应拦截" class="headerlink" title="请求拦截与响应拦截"></a>请求拦截与响应拦截</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">api&#x2F;index.js</span><br><span class="line"></span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">&#x2F;&#x2F; 请求拦截（配置发送请求的信息）</span><br><span class="line">&#x2F;&#x2F; 只要配置了拦截器，那么所有的请求都会走拦截器</span><br><span class="line">&#x2F;&#x2F; 因此，可以在拦截器中统一处理headers（处理：除了登录接口以外的所以接口，都需要将token传递给服务器）</span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理请求之前的配置</span><br><span class="line">  if(!config.url.endsWith(&#39;&#x2F;login&#39;))&#123;</span><br><span class="line">        &#x2F;&#x2F; 判断如果是登录接口，就不需要添加 Authorization 请求头</span><br><span class="line">        config.headers[&#39;Authorization&#39;]&#x3D;localStorage.getItem(&#39;token&#39;) </span><br><span class="line">        &#x2F;&#x2F;将token设置在请求头，传递给服务器接口，这样才能正确的调用这个接口</span><br><span class="line">	&#125;, </span><br><span class="line">	return config;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  &#x2F;&#x2F; 请求失败的处理</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 响应拦截（配置请求回来的信息）</span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理响应数据</span><br><span class="line">  &#x2F;&#x2F;在获取到响应的时候做一些事情， </span><br><span class="line">  if(response.data.meta.status&#x3D;&#x3D;&#x3D;401)&#123;&#x2F;&#x2F;只要token失效，就跳转回登录页面</span><br><span class="line">      &#x2F;&#x2F;因为现在不是在组件中，因此无法通过this.$router来访问到路由实例</span><br><span class="line">      &#x2F;&#x2F; 但是可以直接通过 上面导入的路由模块中的 router来访问到路由</span><br><span class="line">      router.push(&#39;&#x2F;login&#39;) &#x2F;&#x2F;跳转到登录页</span><br><span class="line">      localStorage.removeItem(&#39;token&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  return response</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理响应失败</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="使用axios"><a href="#使用axios" class="headerlink" title="使用axios"></a>使用axios</h4><p>注：PUT请求默认会发送两次请求，第一次预检请求不含参数，所以后端不能对PUT请求地址做参数限制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">首先在main.js中引入方法</span><br><span class="line"><span class="keyword">import</span> Api <span class="keyword">from</span> <span class="string">'./api/index.js'</span>;</span><br><span class="line">Vue.prototype.$api = Api;</span><br><span class="line"></span><br><span class="line">然后在需要的地方调用即可</span><br><span class="line"><span class="keyword">this</span>.$api.post(<span class="string">'user/login.do(地址)'</span>, &#123;</span><br><span class="line">    <span class="string">"参数名"</span>: <span class="string">"参数值"</span></span><br><span class="line">&#125;, response =&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.data);\\请求成功，response为成功信息参数</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.message);\\请求失败，response为失败信息</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">page.js</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getInfo () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$axios.get(<span class="string">'/fcg_myqq_toplist.fcg'</span>, &#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line">          <span class="string">'authorization'</span>: <span class="keyword">this</span>.token</span><br><span class="line">        &#125;,</span><br><span class="line">        params: &#123;</span><br><span class="line">          g_tk: <span class="number">5381</span>,</span><br><span class="line">          uin: <span class="number">0</span>,</span><br><span class="line">          format: <span class="string">'json'</span>,</span><br><span class="line">          inCharset: <span class="string">'utf-8'</span>,</span><br><span class="line">          outCharset: <span class="string">'utf-8'</span>,</span><br><span class="line">          notice: <span class="number">0</span>,</span><br><span class="line">          platform: <span class="string">'h5'</span>,</span><br><span class="line">          needNewCode: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.discList = res.data.data.topList</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.discList)</span><br><span class="line">      &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err.response.status)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    axios.get(<span class="string">'/api/extensys/exten_action.php?act=get_userinfo&amp;unionid=oaNquuJBYcTrl4EJOXYaINXN7xZo'</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.user = response.data.userInfo</span><br><span class="line">            <span class="keyword">this</span>.id = response.data.loginResult.player.userid</span><br><span class="line">            resolve(<span class="keyword">this</span>.id);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">'/api/extensys/action.php?act=get_levelinfo&amp;userid='</span>+id) <span class="comment">// 重要，注意添加了return</span></span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response.data)</span><br><span class="line">            <span class="keyword">return</span> response <span class="comment">// 重要，return了，下一层才可以用</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="keyword">void</span> <span class="built_in">console</span>.log(response))</span><br><span class="line"></span><br><span class="line">简写</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  axios.get(<span class="string">'/api/extensys/exten_action.php?act=get_userinfo&amp;unionid=oaNquuJBYcTrl4EJOXYaINXN7xZo'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.user = response.data.userInfo</span><br><span class="line">      <span class="keyword">this</span>.id = response.data.loginResult.player.userid</span><br><span class="line">      resolve(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> axios.get(<span class="string">'/api/extensys/action.php?act=get_levelinfo&amp;userid='</span>+id) <span class="comment">// 重要，注意添加了return</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="keyword">void</span> <span class="built_in">console</span>.log(response))</span><br><span class="line"></span><br><span class="line">  .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)<span class="comment">//报错信息</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>axios</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>betterScroll</title>
    <url>/2020/07/27/betterScroll/</url>
    <content><![CDATA[<h3 id="better-scroll解释"><a href="#better-scroll解释" class="headerlink" title="better-scroll解释"></a>better-scroll解释</h3><ol>
<li><p>引入</p>
<p><code>npm install better-scroll --save</code></p>
<a id="more"></a>
</li>
<li><p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">"better-scroll"</span>;</span><br><span class="line"><span class="keyword">this</span>.scroll = <span class="keyword">new</span> Bscroll(<span class="keyword">this</span>.$res.wrapper, &#123;</span><br><span class="line">  click: <span class="literal">true</span>,</span><br><span class="line">  probeType: <span class="keyword">this</span>.probeType,</span><br><span class="line">  pullUpLoad: <span class="keyword">this</span>.pullUpLoad</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">startX: <span class="number">0</span> 开始的X轴位置</span><br><span class="line">startY: <span class="number">0</span> 开始的Y轴位置</span><br><span class="line">scrollY: <span class="literal">true</span> 滚动方向为 Y 轴</span><br><span class="line">scrollX: <span class="literal">true</span> 滚动方向为 X 轴</span><br><span class="line">click: <span class="literal">true</span> 是否派发click事件，通常判断浏览器派发的click还是betterscroll派发的click，可以用_constructed，若是bs派发的则为<span class="literal">true</span></span><br><span class="line">directionLockThreshold: <span class="number">5</span></span><br><span class="line">momentum: <span class="literal">true</span> 当快速滑动时是否开启滑动惯性</span><br><span class="line">bounce: <span class="literal">true</span> 是否启用回弹动画效果</span><br><span class="line">selectedIndex: <span class="number">0</span> wheel 为 <span class="literal">true</span> 时有效，表示被选中的 wheel 索引</span><br><span class="line">rotate: <span class="number">25</span> wheel 为 <span class="literal">true</span> 时有效，表示被选中的 wheel 每一层的旋转角度</span><br><span class="line">wheel: <span class="literal">false</span> 该属性是给 picker 组件使用的，普通的列表滚动不需要配置</span><br><span class="line">snap: <span class="literal">false</span> 该属性是给 slider 组件使用的，普通的列表滚动不需要配置</span><br><span class="line">snapLoop: <span class="literal">false</span> 是否可以无缝循环轮播</span><br><span class="line">snapThreshold: <span class="number">0.1</span> 用手指滑动时页面可切换的阈值，大于这个阈值可以滑动的下一页</span><br><span class="line">snapSpeed: <span class="number">400</span>, 轮播图切换的动画时间</span><br><span class="line">swipeTime: <span class="number">2500</span> swipe 持续时间</span><br><span class="line">bounceTime: <span class="number">700</span> 弹力动画持续的毫秒数</span><br><span class="line">adjustTime: <span class="number">400</span> wheel 为 <span class="literal">true</span> 有用，调整停留位置的时间</span><br><span class="line">swipeBounceTime: <span class="number">1200</span> swipe 回弹 时间</span><br><span class="line">deceleration: <span class="number">0.001</span> 滚动动量减速越大越快，建议不大于<span class="number">0.01</span></span><br><span class="line">momentumLimitTime: <span class="number">300</span> 符合惯性拖动的最大时间</span><br><span class="line">momentumLimitDistance: <span class="number">15</span> 符合惯性拖动的最小拖动距离</span><br><span class="line">resizePolling: <span class="number">60</span> 重新调整窗口大小时，重新计算better-scroll的时间间隔</span><br><span class="line">preventDefault: <span class="literal">true</span> 是否阻止默认事件</span><br><span class="line">preventDefaultException: &#123; <span class="attr">tagName</span>: <span class="regexp">/^(INPUT|TEXTAREA|BUTTON|SELECT)$/</span> &#125; 阻止默认事件</span><br><span class="line">HWCompositing: <span class="literal">true</span> 是否启用硬件加速</span><br><span class="line">useTransition: <span class="literal">true</span> 是否使用CSS3的Transition属性</span><br><span class="line">useTransform: <span class="literal">true</span> 是否使用CSS3的Transform属性</span><br><span class="line">probeType: <span class="number">1</span> 滚动的时候会派发scroll事件，会截流。<span class="number">2</span>滚动的时候实时派发scroll事件，不会截流。 <span class="number">3</span>除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件</span><br><span class="line">pullingUp: boolean 启用上拉加载</span><br></pre></td></tr></table></figure>
</li>
<li><p>Events 事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeScrollStart - 滚动开始之前触发</span><br><span class="line">scrollStart - 滚动开始时触发</span><br><span class="line">scroll - 滚动时触发（自带参数，x和y轴移动的距离）</span><br><span class="line">scrollCancel - 取消滚动时触发</span><br><span class="line">scrollEnd - 滚动结束时触发</span><br><span class="line">touchend - 手指移开屏幕时触发</span><br><span class="line">flick - 触发了 fastclick 时的回调函数</span><br><span class="line">refresh - 当 better-scroll 刷新时触发</span><br><span class="line">destroy - 销毁 better-scroll 实例时触发</span><br></pre></td></tr></table></figure>
</li>
<li><p>特别注意</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pullingUp() </span><br><span class="line">监听上拉加载事件</span><br><span class="line"></span><br><span class="line">finishPullUp()</span><br><span class="line">在请求完下一页数据的时候，结束下拉加载，必须加，否则下拉失效</span><br><span class="line"></span><br><span class="line">scrollTo(x, y, time, easing)</span><br><span class="line">滚动到某个位置，x,y 代表坐标，time 表示动画时间，easing 表示缓动函数</span><br><span class="line">scroll.scrollTo(0, 500)</span><br><span class="line"></span><br><span class="line">scrollToElement(el, time, offsetX, offsetY, easing)</span><br><span class="line">滚动到某个元素，el（必填）表示 dom 元素，time 表示动画时间，offsetX 和 offsetY 表示坐标偏移量，easing 表示缓动函数</span><br><span class="line"></span><br><span class="line">refresh()</span><br><span class="line">强制 scroll 重新计算，当 better-scroll 中的元素发生变化的时候调用此方法</span><br><span class="line">DOM树结构改变时</span><br><span class="line">图片列表等展示形式中 图片加载完成时</span><br><span class="line"></span><br><span class="line">getCurrentPage()</span><br><span class="line">snap 为 true 时，获取滚动的当前页，返回的对象结构为 &#123;x, y, pageX, pageY&#125;，其中 x,y 代表滚动横向和纵向的位置；pageX，pageY 表示横向和纵向的页面索引。用法如：getCurrentPage().pageX</span><br><span class="line"></span><br><span class="line">goToPage(x, y, time, easing)</span><br><span class="line">snap 为 true，滚动到对应的页面，x 表示横向页面索引，y 表示纵向页面索引， time 表示动画，easing 表示缓动函数（可省略不写）</span><br><span class="line"></span><br><span class="line">enable()启用 better-scroll，默认开启</span><br><span class="line"></span><br><span class="line">disable()  禁用 better-scroll</span><br><span class="line"></span><br><span class="line">destroy() 销毁 better-scroll，解绑事件</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>对better-scroll的二次封装 举例</p>
<ul>
<li>在better-scroll的封装文件中（vue）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"wrapper"</span> ref=<span class="string">"wrapper"</span>&gt;</span><br><span class="line">    &lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> &lt;script&gt;</span></span><br><span class="line"><span class="regexp">import BScroll from "better-scroll";</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: "alley-BScroll",</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    this.scroll = new BScroll(this.$refs.wrapper, &#123;</span></span><br><span class="line"><span class="regexp">      tap: true,</span></span><br><span class="line"><span class="regexp">      pullDownRefresh: true, /</span><span class="regexp">/这个配置用于做下拉刷新功能，默认为 false。当设置为 true 或者是一个 Object 的时候，可以开启下拉刷新</span></span><br><span class="line"><span class="regexp">      pullUpLoad: true, /</span><span class="regexp">/这个配置用于做上拉加载功能，默认为 false。当设置为 true 或者是一个 Object 的时候，可以开启上拉加载</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/下拉刷新加载数据</span></span><br><span class="line"><span class="regexp">    handlepullingDown(callback) &#123;</span></span><br><span class="line"><span class="regexp">      this.scroll.on("pullingDown", () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        callback();</span></span><br><span class="line"><span class="regexp">      &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/下拉刷新加载数据完毕通知better-scroll</span></span><br><span class="line"><span class="regexp">    handlefinishPullDown() &#123;</span></span><br><span class="line"><span class="regexp">      this.scroll.finishPullDown(); /</span><span class="regexp">/通知bettwer-scroll已经加载完毕</span></span><br><span class="line"><span class="regexp">      this.scroll.refresh(); /</span><span class="regexp">/重新计算 better-scroll，当 DOM 结构发生变化的时候务必要调用确保滚动的效果正常。</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/上拉加载更多</span></span><br><span class="line"><span class="regexp">    handlepullingUp(callback) &#123;</span></span><br><span class="line"><span class="regexp">      this.scroll.on("pullingUp", () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        callback();</span></span><br><span class="line"><span class="regexp">      &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    handlefinishPullUp() &#123;</span></span><br><span class="line"><span class="regexp">      this.scroll.finishPullUp();</span></span><br><span class="line"><span class="regexp">      this.scroll.refresh();</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &lt;style&gt;</span><br><span class="line">.wrapper &#123;</span><br><span class="line">  height: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在要使用该使用该封装的组件，只需要用这个组件将要出现效果的元素包裹起来即可，如下所示，包起来后，内容便可以有弹性的滑动了。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">alley-BScroll</span> <span class="attr">ref</span>=<span class="string">"alleyscroll"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"movie_body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"movie_item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(item,index) in movieList"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">click</span>=<span class="string">"handleclick()"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"movie_item_pic"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"item.img |ToImg('128.180')"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"movie_item_info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;item.nm&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          观众评:</span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"grade"</span>&gt;</span>&#123;&#123;item.sc&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          主演：</span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;item.star&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;item.showInfo&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:class</span>=<span class="string">"item.globalReleased?'movie_item_btn asale':'movie_item_btn ticket'"</span></span></span><br><span class="line"><span class="tag">      &gt;</span>&#123;&#123;item.globalReleased?'购票':'预售'&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alley-BScroll</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接下来便可以调用封装组件里的方法了，因为需要获取DOM元素，便要写在mounted这个生命周期内。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line"><span class="comment">//下拉刷新</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.alleyscroll.handlepullingDown(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">7</span>);</span><br><span class="line">      <span class="keyword">let</span> arr = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">59</span>]</span><br><span class="line">      <span class="keyword">let</span> data = <span class="keyword">await</span> movie_now_api(arr[n]);</span><br><span class="line">      <span class="keyword">this</span>.movieList = data.data.movieList;</span><br><span class="line">      sessionStorage.setItem(<span class="string">"movieList"</span>,<span class="built_in">JSON</span>.stringify(data.data.movieList))</span><br><span class="line">      <span class="keyword">this</span>.$refs.alleyscroll.handlefinishPullDown();<span class="comment">//下拉刷新完成后，通知better-scroll，下拉刷新已经完成。</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>//上拉加载更多
this.$refs.alleyscroll.handlepullingUp(async ()=&gt;{
    let n = parseInt(Math.random()*7);
    let arr = [10,1,20,40,50,55,59]
    let data = await movie_now_api(arr[n]);
    this.movieList = [...this.movieList,...data.data.movieList];
    sessionStorage.setItem(&quot;movieList&quot;,JSON.stringify(data.data.movieList))
    this.$refs.alleyscroll.handlefinishPullUp();
})</code></pre><p>   }<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>better-scroll</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>插件</tag>
        <tag>better-scroll</tag>
      </tags>
  </entry>
  <entry>
    <title>axios之get和post</title>
    <url>/2020/09/27/axios%E4%B9%8Bget%E5%92%8Cpost/</url>
    <content><![CDATA[<p>1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内</p>
<p>2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制</p>
<p>3.get后退不会有影响，post后退会重新进行提交</p>
<p>4.get请求可以被缓存，post不可以被缓存</p>
<p>5.get请求只URL编码，post支持多种编码方式</p>
<p>6.get请求的记录会留在历史记录中，post请求不会留在历史记录</p>
<p>7.get只支持ASCII字符，post没有字符类型限制</p>
<h3 id="什么是GET和POST请求"><a href="#什么是GET和POST请求" class="headerlink" title="什么是GET和POST请求"></a>什么是GET和POST请求</h3><p>GET：向指定路径资源发送请求，通常用于获取数据</p>
<p>POST：向指定路径资源提交数据进行处理请求，通常用于提交表单或者上传文件</p>
<h3 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h3><p>1，GET一般是从服务器上获取数据，POST是向服务器提交数据。</p>
<p>2，GET通过URL提交数据，数据在URL中可以看到，POST则是在HEADER内提交。</p>
<p>3，GET提交的数据不能大于2KB，而POST不受限制。</p>
<p>4，GET数据容易泄露，POST较为安全</p>
<a id="more"></a>

<p><img src="https://exp-picture.cdn.bcebos.com/dd58d02c5b1b1edea3f5908d981fceecd2d90fbd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>Content-Type是指发送信息至服务器时的内容编码类型，常见的表单提交或上传文件的常用的资源类型有application/x-www-form-urlencoded、multipart/form-data、 application/json、 application/xml，默认情况下为application/x-www-form-unlencoded。</p>
<h3 id="axios发送GET请求"><a href="#axios发送GET请求" class="headerlink" title="axios发送GET请求"></a>axios发送GET请求</h3><p>get发送请求时参数附在URL上，已键值对的形式呈现，如<a href="http://localhost:8000/test/?name=kevinfan&amp;&amp;age=18,这里传递的就是name=kevinfan&amp;&amp;age=18两个参数。" target="_blank" rel="noopener">http://localhost:8000/test/?name=kevinfan&amp;&amp;age=18,这里传递的就是name=kevinfan&amp;&amp;age=18两个参数。</a></p>
<p><img src="https://exp-picture.cdn.bcebos.com/125ed0ecd3d96975afeddc2dd243040149fe09bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p> 那么axios发送请求的时候就可以这样写</p>
<p><img src="https://exp-picture.cdn.bcebos.com/49bf00425d6b04d12c00aa3cb213e8e5edee01bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p>get除了可以发送一些简单的参数也可以携带请求头参数，比如说我想把token通过请求头的形式发送至后台，这里我在headers中定义了Authorization=token，通过验证token来获取用户信息。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/edafb3bcbe2f47702b31ef6e6f3b3b86032179bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p>后台接受请求头信息时应该用request.META.get(‘HTTP_AUTHORIZATION’)，而且这里我们需要注意的是，前端发过来的字段是Authorization，而后台接受时确是HTTP_AUTHORIZATION。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/4e168d5653bbf82012d2a6bfba21056105a36ebd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<h3 id="axios发送POST请求"><a href="#axios发送POST请求" class="headerlink" title="axios发送POST请求"></a>axios发送POST请求</h3><p>post发送请求时参数放在HEADER的请求体中，axios默认发送数据时，数据格式是Request Payload（请求头 Content-Type: application/json），而我们常用的是Form Data（请求头 Content-Type: application/x-www-form-urlencoded）格式。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/04201aa355e983ae95fe699e68efe078153169bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p>如果我们直接将如上所示的数据发送给Django后台的话收到的数据会是None，这里我们可以看到发送的数据格式为Request Payload（请求头 Content-Type: application/json）,这时我们就不能以json形式传参，而是通过键值对形式传参。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/586bfdefe07814315d9f02d8dc6699cf035362bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p>解决办法：axios中提供了qs模块，可以对数据格式进行转换，在axios中引入this.$qs.stringify()，这样在传参前将数据自动处理成键值对形式，这里我们可以看到发送的数据格式为Form Data（请求头 Content-Type: application/x-www-form-urlencoded），后台也正常接收到了数据。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/332d496699cf0253a84a13316b36e29146e85fbd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p><img src="https://exp-picture.cdn.bcebos.com/22c4fe36e29147e8bfc909c6b603bbea3f8658bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<h3 id="axios通过POST传文件"><a href="#axios通过POST传文件" class="headerlink" title="axios通过POST传文件"></a>axios通过POST传文件</h3><p>POST除了可以发送数据之后，还可以用于发送文件（如传图片等），那么这时文件就是个对象而并不是参数。这是我们就需要申明一个FormData对象，以formData.append(‘键’,对象)形式将对象添加到formData中然后传递。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/46a92de039723d0334c30e32bb486143d6d457bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
]]></content>
      <categories>
        <category>axios</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
        <tag>get</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title>cd</title>
    <url>/2020/07/29/cd/</url>
    <content><![CDATA[<h3 id="cd就是change-directory的缩写，即改变目录。"><a href="#cd就是change-directory的缩写，即改变目录。" class="headerlink" title="cd就是change directory的缩写，即改变目录。"></a>cd就是change directory的缩写，即改变目录。</h3><p>cd desktop 进入桌面<br>mkdir movietalk 新建movietalk 文件夹<br>.则是表示目前所在的目录，<br>..则表示目前目录位置的上一层目录。<br>cd    进入用户主目录；<br>cd ~  进入用户主目录；<br>cd -  返回进入此目录之前所在的目录；<br>cd ..  返回上级目录（若当前目录为“/“，则执行完后还在“/“；”..”为上级目录的意思）；<br>cd ../..  返回上两级目录；</p>
<a id="more"></a>

<p>讲cd命令之前，先来看看提示符是什么意思。现在的提示符是<a href="https://www.baidu.com/s?wd=c%3A&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">c:</a>&gt;</p>
<p><strong>c:说明现在的工作盘是c盘，\告诉我们当前的工作目录是根目录。</strong></p>
<p>&gt;的作用是把工作目录和我们要输入的命令分隔开来。</p>
<p>好，下面就开始列举cd的各种命令。</p>
<p><strong>1.如果想要进入C盘下的任意文件或文件夹。</strong></p>
<p>直接<strong>cd+空格+文件或文件夹的路径</strong>（这个路径省略最开始的根目录，即C盘）</p>
<p>比如想要进入C盘下的Program Files里的Java文件里，敲cd Program Files\Java就可以。</p>
<p><img src="https://www.pianshen.com/images/684/779bf1f7d5e264a8033ae59aa24b8dbc.png" alt="img"></p>
<p><strong>2.想要返回到上一级目录或者当前工作目录下的根目录</strong></p>
<p>返回到上一句目录：<strong>cd+..</strong></p>
<p><img src="https://www.pianshen.com/images/664/229c207f9464aae73fcc4fa06fa55040.png" alt="img"></p>
<p>返回到根目录：cd + \</p>
<p><img src="https://www.pianshen.com/images/100/c1407b1edb67c5f461b501e16ffb82ec.png" alt="img"></p>
<p><strong>3.提醒一下，如果需要访问非当前根目录下的目录文件，</strong></p>
<p>应该<strong>先输入该盘符，敲回车，然后再用cd命令</strong></p>
<p><img src="https://www.pianshen.com/images/412/3211d3df1f59785fd5aeecaeed8131cc.png" alt="img"></p>
<p>如果要切换到D:\Program Files目录下，大多数人会想当然的在命令行窗口输入 cd D:\Program Files回车。</p>
<p>如下所示：</p>
<p><img src="https://www.pianshen.com/images/6/a8b579fcd4973d87692cb9d8fe23327e.png" alt="img"></p>
<p>发现并没有切换到D:\Program Files。</p>
<p>正确的做法是输入D:  回车。</p>
<p><img src="https://www.pianshen.com/images/92/14aa82211ef63d1c6821eb7a563bce04.png" alt="img"></p>
<p><img src="https://blog.csdn.net/chengdongyuan/article/details/73256862" alt="img"></p>
<p>发现已经切换到D盘下。</p>
<p>输入cd Program Files 回车。</p>
<p><img src="https://www.pianshen.com/images/677/fb9789051e08119e0d15766b11e2d0f5.png" alt="img"></p>
<p><img src="https://blog.csdn.net/chengdongyuan/article/details/73256862" alt="img"></p>
<p>成功切换到D:\Program Files目录下。</p>
]]></content>
      <categories>
        <category>cd</category>
      </categories>
      <tags>
        <tag>cd</tag>
      </tags>
  </entry>
  <entry>
    <title>charles抓包</title>
    <url>/2020/09/07/charles%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>一、</p>
<p>安装前提：配置好了Jdk环境</p>
<p>若不进行破解，则每次只能试用30分钟，30分钟后工具自动关闭</p>
<p>破解方法：将破解补丁charles.jar文件复制到lib文件夹下，替换掉同名jar包</p>
<a id="more"></a>

<p>二、</p>
<p>工具简单介绍：</p>
<p>1：清空列表所有请求</p>
<p>2：开始抓取 / 停止抓取</p>
<p>3：开启节流 / 停止节流</p>
<p>4：开启断点 / 结束断点</p>
<p>5：编辑请求</p>
<p>6：重发请求</p>
<p>7：校验请求的结果</p>
<p>8：快捷工具箱</p>
<p>9：快捷设置</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/082B867F5C764ABAA14C14322D09D3DB/3025" alt="img"></p>
<p>Structure：</p>
<p>以域名划分请求信息，可清晰地看到请求的数据结构</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/C161DEF842DD42AAADBD03B7392FBD7F/3088" alt="img"></p>
<p>Sequence：</p>
<p>可清晰看到全部请求，不用一层一层点开，按数据请求的时间顺序执行</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/E8011D8C641746F5B991A65C49125440/3085" alt="img"></p>
<p>三、</p>
<p>快捷搜索功能：通过ctrl+F进入搜索页面</p>
<p>1、关键词输入框：可输入正则表达式，不必区分大小写</p>
<p>2、搜索路径：</p>
<p>（1）全部会话</p>
<p>（2）当前会话</p>
<p>（3）指定的请求路径，在右侧输入框中输入</p>
<p>3、搜索范围：</p>
<p>（1）请求URL</p>
<p>（2）请求Header</p>
<p>（3）请求Body</p>
<p>（4）返回Header</p>
<p>（5）返回Body</p>
<p>4、搜索结果显示</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/ED862148378A4175B9EABF9BF984E650/3067" alt="img"></p>
<p>四、抓取手机请求</p>
<p>1、使手机与电脑处于同一局域网下（如连同一WiFi），如图，连接网络tczc，连接成功后打开代理设置，设置为【手动】</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/7A10EC84A6E04279ACCDF8BAD8B28DCF/3098" alt="img"></p>
<p>2、windows+R，输入cmd进入命令行，使用ipconfig命令查看电脑的ip地址</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/0E9A457E28C74B9F8285DD4CAE17E1B6/3151" alt="img"></p>
<p>3、在服务器一栏中填入电脑ip地址，端口号填8888。（端口号在Proxy-Proxy Settings下自己设置的）</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/DF82AAABD8794629A6423D47DA9183E4/3102" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/1598911FB55A482799C85BAF44980F5B/3115" alt="img"></p>
<p>4、注意：首次设置代理网络时，如果电脑端的Charles是打开的，则会提示是否允许设备连接Charles，这时必须应许，否则无法抓包，手机也无法连接网络；若这样设置后还是无法上网，则尝试重启电脑+手机。</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/8C44E37C6AE74B5684F13E0E725F6620/3158" alt="img"></p>
<p>如果不小心点了Deny，可以到Proxy - Access Control Settings下去查看，可手动移除或新增允许访问的IP地址。</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/E3CAFDF8DF5C42ECB711881E3258E6C4/3167" alt="img"></p>
<p>至此代理已经设置成功，可以抓取手机端的http请求。</p>
<p>5、若想抓取手机端的https请求，则必须安装手机端证书。</p>
<p>方法：在手机浏览器中输入 <a href="http://charlesproxy.com/getssl" target="_blank" rel="noopener">http://charlesproxy.com/getssl</a> 去安装证书。</p>
<p>ios系统的，在设置 - 通用 - 描述文件与设备管理下可查看安装的证书。</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/E9C3DF391F6C4E92952960FD048E0EA1/3180" alt="img"></p>
<p>另外要注意的是，在通用 - 关于本机 - 证书信任设置中，要开启对此证书的信任，否则同样抓取不到https请求。</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/F802904FA3DE4A63A624650F526B88A4/3183" alt="img"></p>
<p>6、以上设置完毕后，可以试着访问某个APP，如图，虽然能看到发出的请求，但请求和响应中出现了乱码：</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/7756E14FD7AF4D43ABD3A1168C17E64B/3205" alt="img"></p>
<p>解决方案是：</p>
<p>Proxy - SSL Proxying Settings下，将出现乱码的该域名添加进去</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/133548E8DE6940228B09DA265763D7B0/3209" alt="img"></p>
<p>设置完毕后，清除所有会话，重新访问一次，当当当当！！！成功了！！</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/C666882664FF44EDACE773A9E6FBED23/3215" alt="img"></p>
<p>五、抓取电脑请求</p>
<p>1、抓取电脑http请求：勾选这一项即可 Proxy - Windows Proxy</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/2C7CDF862BC147D9B5AF62664A434926/3235" alt="img"></p>
<p>2、抓取电脑端https请求，同样需要安装证书。</p>
<p>电脑端证书安装：Proxy - SSL Proxying - Install Charles Root Certificate</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/AB331E14DD4D40AAA1B3C2B0EB05A225/3222" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/830E7DC1B2054B318078EC01B2777E2C/3229" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/7D30139836A54643BECE96A0EDB08CF3/3231" alt="img"></p>
<p>六、其他功能点（选中会话，点击右键）</p>
<p>1、Repeat：重复执行请求</p>
<p>2、Repeat Advanced：可以指定请求的遍数</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/CCE4DDB106B1408594E49D61541B03F5/3245" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/98F9FE68FD4B4F189ECA0C03CCA94658/3257" alt="img"></p>
<p>3、Focus</p>
<p>右键某会话，点击Focus，可以使该域名置顶，其他域名统一被放到下面的Other Hosts下：</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/307B6C6B1D3A4D53B0B4F3988DB35703/3269" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/6925C705DCC6400F8A96BE193D6E2E59/3271" alt="img"></p>
<p>除了通过这种方法设置，也可在View - Focused Hosts下统一设置</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/603213AF038847838EADD5D81C238329/3277" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/8069161252554DC1BC8C03022028A5B7/3281" alt="img"></p>
<p>4、黑名单 / 白名单</p>
<p>Black List：黑名单中的域名不能联网</p>
<p>White List：白名单开启后，只有在白名单中的域名可以访问网络，不在白名单中的不能联网</p>
<p>（如果一个域名既在黑名单，又在白名单，那么也不能联网）</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/0735CCE2871A426DB534AD44307D8641/3287" alt="img"></p>
<p>5、导出会话功能</p>
<p>Export：可将会话导出到本地，下次可通过File - Open Session打开</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/88D11E6684F44747ADA1BD7AD87A32FF/3301" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/D04C613AFBB64560940B2DC1072D68A9/3307" alt="img"></p>
<p>6、比较功能</p>
<p>Compare：在左侧列表中选中两个请求，右键即可看到此选项，可用于比对两个请求的入参和出参</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/CB4FEC96F91E4F029D5B3A7A7D58D0F3/3311" alt="img"></p>
<p>未完待续….</p>
<p>有道云笔记地址：</p>
]]></content>
      <categories>
        <category>charles</category>
      </categories>
      <tags>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title>easy-mock</title>
    <url>/2020/07/30/easy-mock/</url>
    <content><![CDATA[<h3 id="easy-mock的使用"><a href="#easy-mock的使用" class="headerlink" title="easy-mock的使用"></a>easy-mock的使用</h3><p>Easy Mock 是一个可视化，并且能快速生成模拟数据的持久化服务。简单来说，easy-mock可以提供api接口，让程序员在写好程序以后进行数据模拟。</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>创建一个项目</p>
<a id="more"></a>

<p><img src="/2020/07/30/easy-mock/clipboard.png" alt="clipboard"></p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>填写信息，这里项目名和url都是按照自己的意愿来填写，这会为最后生成的api数据接口提供地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/18143787-9f66b8a931aa6e8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>创建mock</p>
<p>![clipboard (1)](easy-mock.assets/clipboard (1).png)</p>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>最后就可以在这里写下mock的代码啦！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/18143787-26185e5f83289a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>easy-mock 本地部署（坑）</p>
<p><a href="https://blog.csdn.net/qq_40895460/article/details/105029475" target="_blank" rel="noopener">https://blog.csdn.net/qq_40895460/article/details/105029475</a></p>
]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>mock</tag>
        <tag>easy-mock</tag>
      </tags>
  </entry>
  <entry>
    <title>css3</title>
    <url>/2020/07/23/css3/</url>
    <content><![CDATA[<h3 id="日常积累"><a href="#日常积累" class="headerlink" title="日常积累"></a>日常积累</h3><a id="more"></a>

<ol>
<li><p>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</p>
<blockquote>
<ul>
<li>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin </li>
<li>低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin</li>
</ul>
</blockquote>
</li>
<li><p>box-sizing属性</p>
<blockquote>
<p>用来控制元素的盒子模型的解析模式，默认为content-box </p>
<ul>
<li>context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽 </li>
<li>border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽</li>
</ul>
</blockquote>
</li>
<li><p>CSS选择器有哪些？哪些属性可以继承？</p>
<blockquote>
<ul>
<li>CSS选择符：id选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child）</li>
<li>可继承的属性：font-size, font-family, color</li>
<li>不可继承的样式：border, padding, margin, width, height</li>
<li>优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ] </li>
<li>!important 比内联优先级高</li>
</ul>
</blockquote>
</li>
<li><p>CSS优先级算法如何计算？</p>
<blockquote>
<p>元素选择符： 1 </p>
<p>class选择符： 10 </p>
<p>id选择符：100 </p>
<p>元素标签：1000</p>
<p>!important声明的样式优先级最高，如果冲突再进行计算。 </p>
<p>如果优先级相同，则选择最后出现的样式。 </p>
<p>继承得到的样式的优先级最低。</p>
</blockquote>
</li>
<li><p>CSS3伪类有那些?</p>
<blockquote>
<ul>
<li><p>p:first-of-type 选择属于其父元素的首个元素 </p>
</li>
<li><p>p:last-of-type 选择属于其父元素的最后元素 </p>
</li>
<li><p>p:only-of-type 选择属于其父元素唯一的元素 </p>
</li>
<li><p>p:only-child 选择属于其父元素的唯一子元素 </p>
</li>
<li><p>p:nth-child(2) 选择属于其父元素的第二个子元素 </p>
</li>
<li><p>plate:nth-of-type(even) 或 plate:nth-of-type(2n)  选中所有偶数的plate</p>
<p>plate:nth-of-type(odd) 或 plate:nth-of-type(2n+1)  奇数项</p>
<p>plate:nth-of-type(2n+3) 选择偶数项并从第三个开始</p>
<p>plate:nth-of-type(3n) 选择3的倍数</p>
</li>
<li><p>:enabled :disabled 表单控件的禁用状态。 </p>
</li>
<li><p>:checked 单选框或复选框被选中。</p>
</li>
<li><p>bento ~ pickle  bento旁边的pickle元素  </p>
</li>
</ul>
</blockquote>
</li>
<li><p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p>
<blockquote>
<ul>
<li><p>div：</p>
<p>border: 1px solid red; </p>
<p>margin: 0 auto; </p>
<p>height: 50px; </p>
<p>width: 80px; </p>
</li>
<li><p>浮动元素的上下左右居中：</p>
<p>border: 1px solid red; </p>
<p>float: left; </p>
<p>position: absolute; </p>
<p>width: 200px; </p>
<p>height: 100px; </p>
<p>left: 50%; </p>
<p>top: 50%; </p>
<p>margin: -50px 0 0 -100px; </p>
</li>
<li><p>绝对定位的左右居中：</p>
<p>border: 1px solid black; </p>
<p>position: absolute; </p>
<p>width: 200px; </p>
<p>height: 100px; </p>
<p>margin: 0 auto; </p>
<p>left: 0; </p>
<p>right: 0;</p>
</li>
<li><p>flex布局所有元素在范围内水平垂直分布</p>
</li>
</ul>
<p>​      display: flex;</p>
<p>​      flex-wrap: wrap;</p>
<p>​      align-items: center;</p>
<p>​      justify-content: center;</p>
<p>​     所有子级元素</p>
<p>​    &gt; h1, &gt; h2, p {</p>
<p>​           width: 100%;</p>
<p>​           text-align: center;</p>
<p>​     }</p>
</blockquote>
</li>
<li><p>position的值</p>
<blockquote>
<ul>
<li>static（默认）：按照正常文档流进行排列； </li>
<li>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位； </li>
<li>absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位； </li>
<li>fixed(固定定位)：所固定的参照对像是可视窗口。</li>
</ul>
</blockquote>
</li>
<li><p>CSS3有哪些新特性</p>
<blockquote>
<ul>
<li><p>对长的不可分割单词换行 word-wrap：break-word </p>
</li>
<li><p>英文和数字不换行 word-break: break-all;</p>
</li>
<li><p>文字超出行数以省略号显示</p>
<p>display: -webkit-box !important;</p>
<p>-ms-text-overflow: ellipsis;</p>
<p>text-overflow: ellipsis;</p>
<p>overflow: hidden;</p>
<p>word-break: break-all;</p>
<p>-webkit-box-orient: vertical;</p>
<p>-webkit-line-clamp: 3; // 可显示行数</p>
</li>
<li><p>取消a标签在移动端点击时的蓝色</p>
<p>-webkit-tap-highlight-color: rgba(255, 255, 255, 0);</p>
<p>-webkit-user-select: none;</p>
<p>-moz-user-focus: none;</p>
<p>-moz-user-select: none;</p>
</li>
<li><p>指定位置剪切图片</p>
<p>img{</p>
<p>position:absolute; </p>
<p>​    clip:rect(0px 500px 150px 0px); </p>
<p>}</p>
</li>
<li><p>阻止旋转屏幕时自动调整字体大小</p>
<p>移动端开发时，屏幕有竖屏和横屏模式，当屏幕进行旋转时，字体大小则有可能会发生变化，从而影响页面布局的整体样式，为避免此类情况发生，只需设置如下样式即可</p>
<p>{ -webkit-text-size-adjust: none;}</p>
</li>
<li><p>修改移动端难看的点击的高亮效果，iOS和安卓下都有效</p>
<p> -webkit-tap-highlight-color: rgba(0,0,0,0);</p>
</li>
<li><p>禁止在input中输入中文</p>
<p>用文本框的CSS属性ime-mode实现。 </p>
<input onpaste="return false" ondragenter="return false" style="ime-mode:disabled"> 

<p> 提示：设置ime-mode为disabled的意思是禁止在输入时禁止用户激活输入中文，韩文，日文等的输入法（IME）状态，因为这个只能检测到键盘的输入，对通过鼠标操作的粘贴和拖放无效。 </p>
</li>
</ul>
</blockquote>
</li>
<li><p>icon字体</p>
<blockquote>
<p>1.引入css</p>
<link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_918569_2pxb1owlzc1.css">

<p>2.使用</p>
<p><span class="iconfont icon-xiaoxi"></span></p>
</blockquote>
</li>
<li><p>三角</p>
<blockquote>
<p>![01 (1)](css3.assets/01 (1).png)</p>
<p>width: 0;<br>height: 0;<br>border: 50px solid;<br>border-color: red yellow green blue;</p>
<p>![01 (2)](css3.assets/01 (2).png)</p>
<p>width: 0;<br>height: 0;<br>border: 50px solid;<br>border-color: red transparent transparent transparent;</p>
</blockquote>
<p>​</p>
<p>​</p>
</li>
<li><p>对勾</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tesy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.tesy</span> &#123;</span></span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 110px;</span><br><span class="line">    top: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">、  <span class="selector-class">.tesy</span><span class="selector-pseudo">:before</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    content: '';</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 6px;</span><br><span class="line">    height: 15px;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#1137a0</span>;</span></span><br><span class="line">    border-bottom: 1px solid;</span><br><span class="line">    border-right: 1px solid;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    -webkit-transform-origin: center;</span><br><span class="line">            transform-origin: center;</span><br><span class="line">    transform: translate(-50%, -30%) rotate(45deg);</span><br><span class="line">    -webkit-transform: translate(-50%, -30%) rotate(45deg);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>三角突出效果</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rongpi"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wenan"</span>&gt;</span>跟团游<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sanjiao"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">.rongpi&#123;</span><br><span class="line">			height: 15px;</span><br><span class="line">			overflow: hidden;</span><br><span class="line">			position: absolute;</span><br><span class="line">			top:0;</span><br><span class="line">			left: 0;</span><br><span class="line">		&#125;</span><br><span class="line">		.wenan&#123;</span><br><span class="line">			float: left;</span><br><span class="line">			position: relative;</span><br><span class="line">			z-index: 3;</span><br><span class="line">			height: 15px;</span><br><span class="line">			padding-left: 4px;</span><br><span class="line">			line-height: 16px;</span><br><span class="line">			color:white;</span><br><span class="line">			background: red;</span><br><span class="line">			font-size: 10px;</span><br><span class="line">		&#125;</span><br><span class="line">		.sanjiao&#123;</span><br><span class="line">			width:0;</span><br><span class="line">			height: 0;</span><br><span class="line">			border-right: 20px solid transparent;</span><br><span class="line">			border-top: 30px solid red;</span><br><span class="line">			float: right;</span><br><span class="line">			margin-left: -9px;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>渐变</p>
<blockquote>
<ul>
<li><p>背景颜色渐变色</p>
<p>background:linear-gradient(116deg,rgba(247,209,177,1) 0%,rgba(210,162,122,1) 100%);</p>
<p><a href="https://blog.csdn.net/qq_36538012/article/details/79467097" target="_blank" rel="noopener">https://blog.csdn.net/qq_36538012/article/details/79467097</a></p>
<p><a href="https://blog.csdn.net/qq_16390749/article/details/77718834" target="_blank" rel="noopener">https://blog.csdn.net/qq_16390749/article/details/77718834</a></p>
</li>
<li><p>字体颜色渐变色</p>
<p><a href="https://blog.csdn.net/qq_34122603/article/details/78684445" target="_blank" rel="noopener">https://blog.csdn.net/qq_34122603/article/details/78684445</a></p>
</li>
</ul>
</blockquote>
</li>
<li><p>判断机型（页面大小）</p>
<blockquote>
<ul>
<li><p>iphoneX</p>
<p>@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {</p>
<p>​     .BottomProgress {</p>
<p>​        bottom: 34px !important;</p>
<p>​    }</p>
<p>}</p>
</li>
</ul>
</blockquote>
</li>
<li><p>彩色进度条</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">progress: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> filldiv = $(<span class="string">"#filldiv"</span>);</span><br><span class="line">  <span class="keyword">var</span> percent = $(<span class="string">"#percent"</span>);</span><br><span class="line">  <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#filldiv"</span>).css(<span class="string">"width"</span>, i++ + <span class="string">'%'</span>)</span><br><span class="line">    $(<span class="string">"#filldiv"</span>).css(<span class="string">"background"</span>, self.getColor())</span><br><span class="line">    $(<span class="string">"#percent"</span>).innerHTML = <span class="built_in">parseInt</span>(i * <span class="number">100</span> / <span class="number">500</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">100</span>) &#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">////获取十六进制的随机颜色值</span></span><br><span class="line">getColor: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">"0123456789abcdef"</span>;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="string">"#"</span>;</span><br><span class="line">  <span class="keyword">var</span> rand;</span><br><span class="line">  <span class="comment">//str有下标 0-15</span></span><br><span class="line">  <span class="comment">//获取0-15的随机数</span></span><br><span class="line">  <span class="comment">//通过这个随机数作为str的下标，</span></span><br><span class="line">  <span class="comment">//获取随机字符</span></span><br><span class="line">  <span class="comment">//获取六个随机字符拼成一个字符串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    rand = self.getRand(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    color += str.charAt(rand);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> color;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//获取min-max之间的随机整数</span></span><br><span class="line">getRand: <span class="function"><span class="keyword">function</span> (<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>条纹滚动进度条</p>
<p><img src="/2020/07/23/css3/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/a9c3115c2406484ea92d78187053848c/1c0ba1a3675e9eeb2b43efe126b06d4.png" alt="img"></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">progressBar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  self.progressText = <span class="string">''</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"progress-container "</span>).style.width = i++ + <span class="string">'%'</span>;</span><br><span class="line">    self.progressText = $(<span class="string">"progress-container "</span>).style.width</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="string">"progress-container "</span>).style.width &gt;= <span class="string">"98%"</span>) &#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;,</span><br><span class="line">html</span><br><span class="line">  &lt; div <span class="class"><span class="keyword">class</span></span>=<span class="string">"progress-container"</span> id = <span class="string">"progress-container "</span> &gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"progress-cont"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span> &gt;</span><br><span class="line">  样式</span><br><span class="line">    .progress - container &#123;</span><br><span class="line">  height: <span class="number">100</span> %;</span><br><span class="line">  width: <span class="number">100</span> %;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br><span class="line">.progress - cont &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">-1000</span>px;</span><br><span class="line">  height: <span class="number">100</span> %;</span><br><span class="line">  width: <span class="number">2000</span>px;</span><br><span class="line">  background - image: linear - gradient(90deg, transparent 0rem, transparent 2rem, #FFEBEC 2em, #FFEBEC 4rem, transparent 4rem);</span><br><span class="line">  background - color: #FFF2F2;</span><br><span class="line">  background - size: <span class="number">40</span>px <span class="number">100</span> %;</span><br><span class="line">  background - repeat: repeat - x;</span><br><span class="line">  transform: skewX(<span class="number">-30</span>deg)!important;</span><br><span class="line">&#125;</span><br><span class="line">.progress - cont &#123;</span><br><span class="line">  animation: reverse progress - bar - stripes <span class="number">0.40</span>s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes progress - bar - stripes &#123;</span><br><span class="line">  <span class="keyword">from</span> &#123;</span><br><span class="line">    background - position: <span class="number">40</span>px <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  to &#123;</span><br><span class="line">    background - position: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>CSS选择器合集</p>
<blockquote>
<p>\1. div &gt;a</p>
<p>这个选择器将使我们能够选择所有父元素是div标签的元素。</p>
<!-- This one will be selected --> 

<div>   

<p>​     <a></a></p>
</div>

<!-- This one won't be selected -->

<p>   

<pre><code>&lt;a&gt;&lt;/a&gt;</code></pre></p>

<p>\2. div +a</p>
<p>选择紧接在div元素之后的每个标签。如果我们在div和a标签之间有一个元素，则不会选择该元素。</p>
<main>

<!-- This one will be selected --> 

   <div></div>  

<p>   <a></a></p>
<!-- This one won't be selected -->  

  <div></div> 

   <p></p>  

<p>   <a></a></p>
</main>

<p>\3. div ~a</p>
<p>如果a标签具有div标签作为同级元素，则将选择该标签。</p>
<main>

<!-- This one will be selected -->

<p>​    <div></div> </p>
<p>​    <a></a></p>
<!-- This one will be selected -->

<p>​    <div></div></p>
<p>​    </p><p></p> <p></p>
<p>​    <a></a> </p>
<section>

<!-- This one will be selected -->

<p>​    <div></div> </p>
<p>​    </p><p></p>  <p></p>
<p>​    <a></a>  </p>
 </section>

<footer>

<!-- This one won't be selected -->

<p>​    </p><p></p> <p></p>
<p>​    <a></a>   </p>
 </footer>

</main>

<p>\4. [属性^=值]</p>
<p>例如：[class ^ =“ list-”]此选择器将选择每个包含class属性且其值以list-开头的元素。</p>
<main>

<!-- This one will be selected -->

<p>​    <div class="list-element"></div></p>
<!-- This one will be selected -->

<p>​    <div class="list-container"></div></p>
<!-- This one will be selected -->

<p>​    <div class="list-item"></div></p>
<!-- This one won't be selected -->

<p>​    <div class="list__footer"></div></p>
</main>

<p>\5. [属性$=值]</p>
<p>例如：[src $ =“.png”]这将选择每个值以.png结尾的src属性。</p>
<div>

<!-- This one will be selected -->

<p>​    <img src="/2020/07/23/css3/image1.png"></p>
<!-- This one will be not selected -->

<p>​    <img src="/2020/07/23/css3/image2.jpg"></p>
<!-- This one will be selected -->

<p>​    <img src="/2020/07/23/css3/image3.png"></p>
<!-- This one won't be selected -->

<p>​    <img src="/2020/07/23/css3/image4.svg"></p>
</div>

<p>\6. [属性*=值]</p>
<p>例如：[class * =“-list”]此选择器将选择其class属性包含-list的每个元素。 不管-list是在类值的开头，中间还是结尾都没有关系。最重要的是该值必须包含-list。</p>
<main>

<!-- This one will be selected -->

<p>​    <div class="main-list-container"></div></p>
<!-- This one will be selected -->

<p>​    <div class="primary-list"></div></p>
<!-- This one will be selected -->

<p>​    <div class="primary-list-item"></div></p>
<!-- This one won't be selected -->

<p>​    <div class="list-footer"></div></p>
</main>
</blockquote>
</li>
<li><p>使用text-transform转换字母为大写</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;movie-poster&quot;&gt;Star Wars: The Force Awakens&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">.movie-poster &#123;</span><br><span class="line">	text-transform: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="19">
<li>Em, Rem与px</li>
</ol>
<p>设置元素与文本的大小应该用哪种单位，em，rem，还是px？一直以来都有很多的争论。事实是，这三种选择都是可行的，都有其利弊。</p>
<p>在什么时候在什么项目使用哪种单位是没有一个定论的，开发人员的习惯不同，项目的要求不同，都可能会使用不同的单位。然而，虽然没有固定的规则，但是每种单位还是有一些要注意的地方的：</p>
<ul>
<li>em - 设置元素为1em，其大小与父元素的font-size属性有关。这个单位用于媒体查询中，特别适用于响应式开发，但是由于em单位在每一级中都是相对于父元素进行计算的，所以要得出某个子元素em单位对应的px值，有时候是很麻烦的。</li>
<li>rem - 相对于<html>元素的font-size大小计算，rem使得统一改变页面上的所有标题和段落文本大小变得非常容易。</html></li>
<li>px - 像素单位是最精确的，但是不适用于自适应的设计。px单位是可靠的，并且易于理解，我们可以精细的控制元素的大小和移动到1px。</li>
</ul>
<p>最重要的是，不要害怕尝试，尝试所有方法，看看最适合什么。有时候，em和rem可以节省很多工作，尤其是在构建响应式页面时。</p>
<ol start="20">
<li>CSS 利用transform达到居中效果</li>
</ol>
<blockquote>
<body>

<pre><code>&lt;div class=&quot;center&quot;&gt;
    ....
&lt;/div&gt;</code></pre></body>

<p>让left和top都是50%，这在水平方向上让div的最左与屏幕的最左相距50%，垂直方向上一样，所以再用transform向左（上）平移它自己宽度（高度）的50%，也就达到居中效果了</p>
<p>.center{<br>    text-align: center;<br>    background-color: #fff;<br>    border-radius: 20px;<br>    width: 300px;<br>    height: 350px;<br>    position: absolute;<br>    left: 50%;<br>    top: 50%;<br>    transform: translate(-50%,-50%);<br>}</p>
</blockquote>
<ol start="21">
<li>一行 CSS 为网页添加暗黑模式支持</li>
</ol>
<blockquote>
<p>html[theme=’dark-mode’] {<br>  filter: invert(1) hue-rotate(180deg);<br>}</p>
<p>我们还将向HTML元素添加一个 <code>transition</code> ，以确保过渡不会过于花哨!</p>
<p>html {<br>    transition: color 300ms, background-color 300ms;<br>}</p>
<p><code>filter</code> CSS 属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p>
<p>对于暗黑模式，将使用两个 <code>filter</code> ：<code>invert</code> 和 <code>hue-rotate</code></p>
<p><strong>invert</strong>：反转配色。黑色变为白色，白色变为黑色，所有颜色都是如此</p>
<p><strong>hue-rotate</strong>：帮助我们处理所有其他非黑色和白色的颜色。将色相旋转180度，我们确保应用程序的颜色主题不会改变，而只是减弱其颜色。</p>
</blockquote>
<ol start="22">
<li>文字竖向排版</li>
</ol>
<blockquote>
<p>第一种</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/eXCSRjyNYcYU0xWZN4hLpZlic52RVnK5xj4toUBicq3q2hWpX6UGLtxia8cx5mFQ9ndmHCSE6SKCEmiciazONichGfpQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<style>  
.one {  
    width: 20px;  
    margin: 0 auto;  
    line-height: 24px;  
    font-size: 20px;
}
.two {  
    width: 15px;  
    margin: 0 auto;  
    line-height: 24px;  
    font-size: 20px;  
    word-wrap: break-word;/*英文的时候需要加上这句，自动换行*/  
}  
</style>  
<body>  
    <div class="one">我是竖列排版</div>  
    <div class="two">I AM ENGLISH</div>

</body>

<p>第二种</p>
<p><img src="/2020/07/23/css3/image-20200914175703225.png" alt="image-20200914175703225"></p>
<style>  
.one {  
    margin: 0 auto;  
    height: 140px;  
    writing-mode: vertical-lr;/*从左向右 从右向左是 writing-mode: vertical-rl;*/  
    writing-mode: tb-lr;/*IE浏览器的从左向右 从右向左是 writing-mode: tb-rl；*/  
}  
</style>  
<body>  
    <div class="one">欲话毗陵君反袂，欲言夏口我沾衣。谁知临老相逢日，悲叹声多语笑稀。</div>  
    <div class="one">I AM ENGLISH</div>
</body>

<p>第三种</p>
<p><img src="/2020/07/23/css3/image-20200914175815863.png" alt="image-20200914175815863"></p>
<style>
.one {
    margin: 150px auto;
    width: 200px;
    font-size: 20px; 
    line-height: 24px;
    transform:rotate(90deg);
    -ms-transform:rotate(90deg);     /* IE 9 */
    -moz-transform:rotate(90deg);     /* Firefox */
    -webkit-transform:rotate(90deg); /* Safari 和 Chrome */
    -o-transform:rotate(90deg);     /* Opera */
}
</style>
<body>
    <div class="one">欲话毗陵君反袂</div>
    <div class="one">ENGLISH</div>
</body>
</blockquote>
<ol start="23">
<li>单侧投影</li>
</ol>
<blockquote>
<p>果阴影的模糊半径，与负的扩张半径一致，那么我们将看不到任何阴影，因为生成的阴影将被包含在原来的元素之下，除非给它设定一个方向的偏移量。所以这个时候，我们给定一个方向的偏移值，即可实现单侧投影：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eXCSRjyNYcaY1AYPXeaTj5zK4qzBIwWxqaOGCww1luEoUc2ZDpoPtnqXHFWol4pa0dhnfWMCcm5kxMGESvOQKg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
</blockquote>
<ol start="24">
<li>使用负 letter-spacing 倒序排列文字</li>
</ol>
<blockquote>
<p>letter-spacing: -72px;</p>
</blockquote>
<ol start="25">
<li>立即执行延迟动画</li>
</ol>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;g-container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt; </span><br><span class="line">    &lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">    &lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.item &#123;</span><br><span class="line">  transform: rotate(0) translate(-80px, 0) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item:nth-child(1) &#123;</span><br><span class="line">  animation: rotate 3s infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item:nth-child(2) &#123;</span><br><span class="line">  animation: rotate 3s infinite -1s linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item:nth-child(3) &#123;</span><br><span class="line">  animation: rotate 3s infinite -2s linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@keyframes rotate &#123;</span><br><span class="line">  100% &#123;</span><br><span class="line">      transform: rotate(360deg) translate(-80px, 0) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="23">
<li>attr()</li>
</ol>
<blockquote>
<p><code>attr</code> 函数用于获取所选元素的属性值。它接受三个参数，<code>属性名称</code>，<code>类型</code>和<code>默认值</code>。</p>
<blockquote>
<p>语法: attr( attribute-name? [,]? )</p>
</blockquote>
<p>事例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p data-text&#x3D;&quot;the attr function&quot;</span><br><span class="line">  data-tooltip&#x3D;&quot;Hi from attr!&quot; class&#x3D;&quot;attr&quot;&gt;This text is combined with&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p::after &#123;</span><br><span class="line">  content: &#39; &#39; attr(data-text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.attr:hover::after &#123;</span><br><span class="line">  content: &#39; &#39; attr(data-tooltip);</span><br><span class="line">  background-color: orange;</span><br><span class="line">  color: white</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="24">
<li>word-wrap和word-break</li>
</ol>
<p>word-wrap:break-word;（换行后截断）</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/2050/201208/201208101725587335.png" alt="01"></p>
<p>word-break：break-all（直接截断）</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/2050/201208/201208101726046184.png" alt="01"></p>
<ol start="25">
<li>classList对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;myDIV&quot;).classList.add(&quot;mystyle&quot;);</span><br><span class="line"></span><br><span class="line">add(class1, class2, ...)	在元素中添加一个或多个类名。</span><br><span class="line">如果指定的类名已存在，则不会添加</span><br><span class="line"></span><br><span class="line">contains(class)	返回布尔值，判断指定的类名是否存在。</span><br><span class="line">可能值：</span><br><span class="line">true - 元素包已经包含了该类名</span><br><span class="line">false - 元素中不存在该类名</span><br><span class="line">item(index)	返回元素中索引值对应的类名。索引值从 0 开始。</span><br><span class="line">如果索引值在区间范围外则返回 null</span><br><span class="line"></span><br><span class="line">remove(class1, class2, ...)	移除元素中一个或多个类名。</span><br><span class="line">注意： 移除不存在的类名，不会报错。</span><br><span class="line"></span><br><span class="line">toggle(class, true|false)	在元素中切换类名。</span><br><span class="line">第一个参数为要在元素中移除的类名，并返回 false。</span><br><span class="line">如果该类名不存在则会在元素中添加类名，并返回 true。</span><br><span class="line"></span><br><span class="line">第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在。例如：</span><br><span class="line"></span><br><span class="line">移除一个 class: element.classList.toggle(&quot;classToRemove&quot;, false);</span><br><span class="line">添加一个 class: element.classList.toggle(&quot;classToAdd&quot;, true);</span><br><span class="line"></span><br><span class="line">注意： Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。</span><br></pre></td></tr></table></figure>

<ol start="26">
<li>画一条0.5px的直线？</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">height: 1px;</span><br><span class="line">transform: scale(0.5);</span><br></pre></td></tr></table></figure>



<ol start="24">
<li>8种让人眼前一亮的hover效果</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/dNR0ZykPSDEW1z6qH7iCMg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dNR0ZykPSDEW1z6qH7iCMg</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>es6-Class</title>
    <url>/2020/08/07/es6-Class/</url>
    <content><![CDATA[<h1 id="你真的理解ES6的Class吗"><a href="#你真的理解ES6的Class吗" class="headerlink" title="你真的理解ES6的Class吗"></a><a href="https://segmentfault.com/a/1190000019792333" target="_blank" rel="noopener">你真的理解ES6的Class吗</a></h1><blockquote>
<p>在面向对象的编程中,类是一个用于创建对象，为状态（成员变量）和行为实现（成员函数或方法）提供初始值的可扩展程序代码模板。（提供封装在一起的变量和函数）</p>
</blockquote>
<p>在实际开发中，我们往往需要创建很多相同类型的对象，如用户、商品或其他对象。我们知道，通过new一个function可以创建一个对象，但在现代的JavaScript里，有一个更高级的“类”结构，对于面向对象编程提供了一些很不错的特性。</p>
<h2 id="Class语法"><a href="#Class语法" class="headerlink" title="Class语法"></a>Class语法</h2><a id="more"></a>

<p>基本的class语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    constructor()&#123;&#125;</span><br><span class="line">    method1()&#123;&#125;</span><br><span class="line">    method2()&#123;&#125;</span><br><span class="line">    method3()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过<strong>new MyClass()</strong>来创建一个拥有以上方法的对象实例，与此同时，通过<strong>new</strong>操作符,<strong>构造方法(constructor)</strong>是被自动调用,的，这意味着在构造方法中我们可以做一些初始化的工作。</p>
<p>列如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    showUInfo()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Usage:</span><br><span class="line">let user &#x3D; new User(&#39;Darkcode&#39;)</span><br><span class="line">user.showUInfo()</span><br></pre></td></tr></table></figure>

<p>当<strong>new User(‘Darkcode’)</strong>被调用的时候：</p>
<ul>
<li>创建了一个新的对象</li>
<li>构造方法通过给定的参数运行，并为其分配this.name</li>
</ul>
<p>然后我们能够调用方法，如user.showUInfo()</p>
<p><em>注意：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类方法之间是没有逗号的</span><br></pre></td></tr></table></figure>



<h2 id="究竟什么是类？"><a href="#究竟什么是类？" class="headerlink" title="究竟什么是类？"></a>究竟什么是类？</h2><p>其实，在JavaScript中，类是函数的一种。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    showUInfo()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(typeof User)&#x2F;&#x2F;function</span><br></pre></td></tr></table></figure>

<p><strong>class User {…}</strong>做了什么呢：</p>
<ol>
<li>创建一个名为User的函数，该函数将成为类声明的结果</li>
<li>在User.prototype中存储所有方法，例如showUInfo</li>
</ol>
<p>之后，对于新对象，当我们调用一个方法的时候，它就是从原型中获取的，因此新的User对象就可以访问到类方法了。</p>
<p>我们可以将<strong>class User</strong>的声明做如下简述：<br><img src="https://segmentfault.com/img/bVbvcLM?w=780&h=171" alt="class User过程图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">  	this.name &#x3D; name</span><br><span class="line">  &#125;</span><br><span class="line">  showUInfo()&#123;</span><br><span class="line">  	alert(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">alert(typeof User)&#x2F;&#x2F;function</span><br><span class="line"></span><br><span class="line">alert(User &#x3D;&#x3D;&#x3D; User.prototype.constructor)&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">alert(User.prototype.showUInfo)&#x2F;&#x2F; alert(this.name);</span><br><span class="line"></span><br><span class="line">alert(Object.getOwnPropertyNames(User.prototype)); &#x2F;&#x2F; constructor, showUInfo</span><br></pre></td></tr></table></figure>

<h2 id="并不只是语法糖-比较"><a href="#并不只是语法糖-比较" class="headerlink" title="并不只是语法糖(比较)"></a>并不只是语法糖(比较)</h2><p>一些人说在JavaScript中class是一种”语法糖”，因为我们实际上可以在没有class关键字的情况下声明一个类。在Es6之前，es5我们可以通过function去实现一个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. Create constructor function</span><br><span class="line">function User(name) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; any function prototype has constructor property by default,</span><br><span class="line">&#x2F;&#x2F; so we don&#39;t need to create it</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. Add the method to prototype</span><br><span class="line">User.prototype.showUInfo &#x3D; function () &#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Usage:</span><br><span class="line">let user &#x3D; new User(&#39;Darkcode&#39;)</span><br><span class="line">user.showUInfo()</span><br></pre></td></tr></table></figure>

<p>这个定义的结果大致相同。因此，确实可以将类视为一种语法糖来定义构造函数及其原型方法。但与class的方式创建一个类有着重要的差异。</p>
<p>首先，<strong>由class创建的函数由特殊的内部属性标记</strong>[[FunctionKind]]:”classConstructor”<strong>.所以它与手动创建并不完全相同</strong>。与常规函数不同，如果没有new，则无法调用类构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(typeof User); &#x2F;&#x2F; function</span><br><span class="line">User(); &#x2F;&#x2F; Error: Class constructor User cannot be invoked without &#39;new&#39;</span><br></pre></td></tr></table></figure>

<p>此外，大多数JavaScript引擎中的类构造函数的字符串表示形式都以“class …”开头。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(User); &#x2F;&#x2F; class User &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>其次，<strong>类方法是不可枚举的</strong>。对于原型中的所有方法，类定义将enumerable标志设置为false。</p>
<p>最后，<strong>类总是使用严格模式的。这意味着类构造中的所有代码都自动处于严格模式</strong>。</p>
<p>此外，除了基本操作之外，类语法还带来了许多其他功能，稍后我们将对其进行探讨。</p>
<p>来个例子对比一下：<br>ES6之前，生成实例对象的传统方法是通过构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x &#x3D;x;</span><br><span class="line">  this.y&#x3D;y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString &#x3D; function() &#123;</span><br><span class="line">  return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;;</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; new Point(1,2)</span><br></pre></td></tr></table></figure>

<p>上面的代码用ES6改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x,y)&#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString()&#123;</span><br><span class="line">     return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面ES6改写的代码注意看两点：</p>
<blockquote>
<p>1.ES6写法定义了一个类，可以看到Point类里面有个constructor方法（构造方法）—-ES5的构造函数Point，就对应的是ES6的Point类的构造方法<br>2.Point类中我们还看到了toString方法。注意，定义<code>类</code>的方法的时候，在方法前不要加<code>function</code>关键字，直接把函数定义放进去即可。还需要注意一点，方法之间是不能用逗号分隔的，否则会报错。</p>
</blockquote>
<p>ES6的类，完全可看作构造函数的另一种写法（在类的实例上面调用方法，其实就是调用原型上的方法），这两句话用代码说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##demo1</span><br><span class="line">class liumz()&#123;&#125;</span><br><span class="line">typeof liumz &#x2F;&#x2F;&quot;function&quot;</span><br><span class="line">liumz &#x3D;&#x3D;&#x3D; liumz.prototype.constructor &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">##demo2</span><br><span class="line">class B &#123;&#125;</span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype &#x3D; &#123;</span><br><span class="line">  constructor() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于类的方法都定义在prototype对象上，所以类的新方法可以添加在protype对象上面:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">Object.assign(Point.protype,&#123;</span><br><span class="line">  toValue()&#123;&#125;,</span><br><span class="line">  toString()&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看到上面一堆的代码与定义文字说明，不妨小憩一下，回顾上面到底说了个啥：</p>
<blockquote>
<p>ES6新引进了Class这个概念，这个概念的引入只是让对象原型的写法更清晰（Class的绝大部分功能在ES5中都可以实现），ES5中的构造函数相当于Class中的构造方法。类的数据类型就是函数，类本身指向构造函数。<br>构造函数是有prototype属性的，这个属性在ES6的类上是继续存在的，只是换了一种写法.</p>
</blockquote>
<p>在充分理解了上面的内容时，我们继续深入，ES6的类，内部定义的方法，都是不可枚举的，啥意思？看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">  constructor(x,y)&#123;&#125;</span><br><span class="line">  toString()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.keys(Point.prototype) &#x2F;&#x2F;[]</span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)&#x2F;&#x2F;[&quot;constructor&quot;,&quot;toString&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><p>就像函数一样，类可以在另一个表达式中定义，传递，返回，分配等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let User &#x3D; class &#123;</span><br><span class="line">         showUInfo() &#123;</span><br><span class="line">             alert(&quot;Hello&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">new User().showUInfo()</span><br></pre></td></tr></table></figure>

<p>与命名函数表达式类似，类表达式可能有也可能没有名称。</p>
<p>如果<strong>类表达式具有名称，则它仅在类中可见</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let User &#x3D; class MyClass &#123;</span><br><span class="line">    showUInfo() &#123;</span><br><span class="line">      alert(&quot;MyClass&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let test &#x3D; new MyClass()&#x2F;&#x2F; 失效报错</span><br><span class="line">let test &#x3D; new User()&#x2F;&#x2F; 有效</span><br><span class="line">test.showUInfo()</span><br></pre></td></tr></table></figure>

<p>我们甚至可以“按需”动态创建类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function makeClass(phrase) &#123;</span><br><span class="line">    &#x2F;&#x2F; declare a class and return it</span><br><span class="line">    return class &#123;</span><br><span class="line">        showUInfo() &#123;</span><br><span class="line">            alert(phrase);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create a new class</span><br><span class="line">let User &#x3D; makeClass(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">new User().showUInfo(); &#x2F;&#x2F; Hello</span><br></pre></td></tr></table></figure>

<h2 id="Getters-Setters"><a href="#Getters-Setters" class="headerlink" title="Getters/Setters"></a>Getters/Setters</h2><p>类可能包括getter / setter，生成器，计算属性等。这里通过使用get/set来实现user.name</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this._name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get name()&#123;</span><br><span class="line">        return this._name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set name(value)&#123;</span><br><span class="line">        if(value.length&lt;4)&#123;</span><br><span class="line">            alert(&quot;名字长度不够.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this._name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;get</span><br><span class="line">let user &#x3D; new User(&#39;Darkcode&#39;)</span><br><span class="line">console.log(user.name);&#x2F;&#x2F;Darkcode</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;set</span><br><span class="line">let user &#x3D; new User()</span><br><span class="line">user.name &#x3D; &#39;165&#39;</span><br><span class="line">console.log(user.name);&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<p>在User的原型对象中，通过类声明创建get/set：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperties(User.prototype, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return this._name</span><br><span class="line">    &#125;,</span><br><span class="line">    set(name) &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>在上面的列子中，User类中仅仅添加了简单的方法，现在来添加一些属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  name &#x3D; &quot;Anonymous&quot;;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(&#96;Hello, $&#123;this.name&#125;!&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new User().sayHi();</span><br></pre></td></tr></table></figure>

<p>该属性未放入User的原型中。相反，它是由new创建的，分别为每个对象创建。因此，该属性永远不会在同一个类的不同对象之间共享。</p>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h3><hr>
<blockquote>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#39;hello&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() &#x2F;&#x2F; &#39;hello&#39;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">&#x2F;&#x2F; TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure>

<p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static bar() &#123;</span><br><span class="line">    this.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  static baz() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() &#x2F;&#x2F; hello</span><br></pre></td></tr></table></figure>

<p>虽然既然类的静态方法不可被实例所继承，但是却可以被子类继承，不赘述。</p>
<h3 id="3-实例属性的新写法"><a href="#3-实例属性的新写法" class="headerlink" title="3.实例属性的新写法"></a>3.实例属性的新写法</h3><hr>
<p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。写法对比：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实例属性this._count定义在constructor()方法里面</span><br><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._count &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&#39;Getting the current value!&#39;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;属性定义在类的最顶层，其它不变</span><br><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  _count &#x3D; 0;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&#39;Getting the current value!&#39;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>
</blockquote>
<h3 id="4-静态属性"><a href="#4-静态属性" class="headerlink" title="4.静态属性"></a>4.静态属性</h3><hr>
<blockquote>
<p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop &#x3D; 1;</span><br><span class="line">Foo.prop &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-class-fields" target="_blank" rel="noopener">提案</a>提供了类的静态属性，写法是在实例属性法的前面，加上<code>static</code>关键字。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">class Foo &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">Foo.prop &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">class Foo &#123;</span><br><span class="line">  static prop &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>es6之arrayFrom</title>
    <url>/2020/09/28/es6%E4%B9%8BarrayFrom/</url>
    <content><![CDATA[<p>Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。</p>
<p>　　那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象。</p>
<p>　　1、将类数组对象转换为真正数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    0: &#39;tom&#39;, </span><br><span class="line">    1: &#39;65&#39;,</span><br><span class="line">    2: &#39;男&#39;,</span><br><span class="line">    3: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;],</span><br><span class="line">    &#39;length&#39;: 4</span><br><span class="line">&#125;</span><br><span class="line">let arr &#x3D; Array.from(arrayLike)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [&#39;tom&#39;,&#39;65&#39;,&#39;男&#39;,[&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;]]</span><br></pre></td></tr></table></figure>

<p>　　那么，如果将上面代码中length属性去掉呢？实践证明，答案会是一个长度为0的空数组。</p>
<p>　　这里将代码再改一下，就是具有length属性，但是对象的属性名不再是数字类型的，而是其他字符串型的，代码如下：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    &#39;name&#39;: &#39;tom&#39;, </span><br><span class="line">    &#39;age&#39;: &#39;65&#39;,</span><br><span class="line">    &#39;sex&#39;: &#39;男&#39;,</span><br><span class="line">    &#39;friends&#39;: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;],</span><br><span class="line">    length: 4</span><br><span class="line">&#125;</span><br><span class="line">let arr &#x3D; Array.from(arrayLike)</span><br><span class="line">console.log(arr)  &#x2F;&#x2F; [ undefined, undefined, undefined, undefined ]</span><br></pre></td></tr></table></figure>

<p>　　会发现结果是长度为4，元素均为undefined的数组</p>
<p>　　由此可见，要将一个类数组对象转换为一个真正的数组，必须具备以下条件：</p>
<p>　　1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。</p>
<p>　　2、该类数组对象的属性名必须为数值型或字符串型的数字</p>
<p>　　ps: 该类数组对象的属性名可以加引号，也可以不加引号</p>
<p>　　2、将Set结构的数据转换为真正的数组：　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [12,45,97,9797,564,134,45642]</span><br><span class="line">let set &#x3D; new Set(arr)</span><br><span class="line">console.log(Array.from(set))  &#x2F;&#x2F; [ 12, 45, 97, 9797, 564, 134, 45642 ]</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　<code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [12,45,97,9797,564,134,45642]</span><br><span class="line">let set &#x3D; new Set(arr)</span><br><span class="line">console.log(Array.from(set, item &#x3D;&gt; item + 1)) &#x2F;&#x2F; [ 13, 46, 98, 9798, 565, 135, 45643 ]</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　3、将字符串转换为数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let  str &#x3D; &#39;hello world!&#39;;</span><br><span class="line">console.log(Array.from(str)) &#x2F;&#x2F; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot;]</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　4、Array.from参数是一个真正的数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Array.from([12,45,47,56,213,4654,154]))</span><br></pre></td></tr></table></figure>

<p>　　像这种情况，Array.from会返回一个一模一样的新数组</p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>arrayFrom</tag>
      </tags>
  </entry>
  <entry>
    <title>es6之map和set结构</title>
    <url>/2020/09/14/es6%E4%B9%8Bmap%E5%92%8Cset%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="一-Map结构数据"><a href="#一-Map结构数据" class="headerlink" title="一.Map结构数据"></a>一.Map结构数据</h2><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-625e0db86d075be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</blockquote>
<a id="more"></a>

<h4 id="1-传统对象键名必须为字符串"><a href="#1-传统对象键名必须为字符串" class="headerlink" title="1. 传统对象键名必须为字符串"></a>1. 传统对象键名必须为字符串</h4><p>let obj = {a:1, 666:2}; console.log(666);–&gt;报错</p>
<h4 id="2-map结构数据是一种“值-值”对应关系"><a href="#2-map结构数据是一种“值-值”对应关系" class="headerlink" title="2.map结构数据是一种“值-值”对应关系"></a>2.map结构数据是一种“值-值”对应关系</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Map();</span><br><span class="line">m.<span class="keyword">set</span>(<span class="number">123</span>,<span class="string">'abc'</span>);</span><br><span class="line">console.log(m.<span class="keyword">get</span>(<span class="number">123</span>));</span><br><span class="line">--&gt; abc</span><br></pre></td></tr></table></figure>

<h2 id="二-Map结构数据初始化和方法"><a href="#二-Map结构数据初始化和方法" class="headerlink" title="二.Map结构数据初始化和方法"></a>二.Map结构数据初始化和方法</h2><h4 id="1-可直接传入键值对二维数组"><a href="#1-可直接传入键值对二维数组" class="headerlink" title="1. 可直接传入键值对二维数组"></a>1. 可直接传入键值对二维数组</h4><h4 id="2-get-获得数据"><a href="#2-get-获得数据" class="headerlink" title="2. get()-获得数据"></a>2. get()-获得数据</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Map([</span><br><span class="line">    [<span class="meta">123,'abc'</span>],</span><br><span class="line">    [<span class="meta">'a',&#123;x:1,y:2&#125;</span>],</span><br><span class="line">    [<span class="meta">3&gt;1,666</span>]</span><br><span class="line">]);</span><br><span class="line">获得数据</span><br><span class="line">console.log(m.<span class="keyword">get</span>(<span class="literal">true</span>));</span><br><span class="line">--&gt;返回<span class="number">666</span></span><br></pre></td></tr></table></figure>

<h4 id="3-has-查找有没有字符串对应的值"><a href="#3-has-查找有没有字符串对应的值" class="headerlink" title="3. has()-查找有没有字符串对应的值"></a>3. has()-查找有没有字符串对应的值</h4><p>接上面例子</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">m.has(<span class="string">'a'</span>);--&gt;<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="4-delete-删除"><a href="#4-delete-删除" class="headerlink" title="4. delete()-删除"></a>4. delete()-删除</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="keyword">delete</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h2 id="三-map结构对象键名特点"><a href="#三-map结构对象键名特点" class="headerlink" title="三.map结构对象键名特点"></a>三.map结构对象键名特点</h2><h4 id="1-传址特点–对象作为键名，传输的是地址，所以下例中的两个-x-1-虽然长相一样，但实际值不同（存储在堆内存的两个位置）"><a href="#1-传址特点–对象作为键名，传输的是地址，所以下例中的两个-x-1-虽然长相一样，但实际值不同（存储在堆内存的两个位置）" class="headerlink" title="1. 传址特点–对象作为键名，传输的是地址，所以下例中的两个{x:1}虽然长相一样，但实际值不同（存储在堆内存的两个位置）"></a>1. 传址特点–对象作为键名，传输的是地址，所以下例中的两个{x:1}虽然长相一样，但实际值不同（存储在堆内存的两个位置）</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,<span class="string">'cdf'</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;));</span><br><span class="line">--&gt;<span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>可以修改成下面形式</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [obj,<span class="string">'cdf'</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(obj));</span><br><span class="line">--&gt;cdf</span><br></pre></td></tr></table></figure>

<h2 id="四-map结构遍历"><a href="#四-map结构遍历" class="headerlink" title="四.map结构遍历"></a>四.map结构遍历</h2><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-97f1f22420a77e1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/952/format/webp" alt="img"></p>
</blockquote>
<h4 id="1-keys-–-gt-将键名都取出来，组成一个可遍历的数据集合"><a href="#1-keys-–-gt-将键名都取出来，组成一个可遍历的数据集合" class="headerlink" title="1. keys()–&gt;将键名都取出来，组成一个可遍历的数据集合"></a>1. keys()–&gt;将键名都取出来，组成一个可遍历的数据集合</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'a'</span>,<span class="string">'hahaha'</span>],</span><br><span class="line">    [<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> m.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;<span class="number">123</span> a <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="2-values"><a href="#2-values" class="headerlink" title="2. values()"></a>2. values()</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'a'</span>,<span class="string">'hahaha'</span>],</span><br><span class="line">    [<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> m.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;abc hahaha baidu.com</span><br></pre></td></tr></table></figure>

<h4 id="3-entries"><a href="#3-entries" class="headerlink" title="3. entries()"></a>3. entries()</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">let m = <span class="keyword">new</span> Map([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'a'</span>,<span class="string">'hahaha'</span>],</span><br><span class="line">    [<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span>(let x of m.entries())&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br><span class="line"><span class="keyword">Array</span>[<span class="number">123</span>,<span class="string">'abc'</span>]</span><br><span class="line"><span class="keyword">Array</span>[<span class="string">'a'</span>,<span class="string">'hahaha'</span>]</span><br><span class="line"><span class="keyword">Array</span>[<span class="keyword">false</span> ,<span class="string">'baidu.com]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-forEach-–第一个参数代表键值，第二个参数代表键名"><a href="#4-forEach-–第一个参数代表键值，第二个参数代表键名" class="headerlink" title="4. forEach()–第一个参数代表键值，第二个参数代表键名"></a>4. forEach()–第一个参数代表键值，第二个参数代表键名</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'a'</span>,<span class="string">'hahaha'</span>],</span><br><span class="line">    [<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">]);</span><br><span class="line">m.forEach(<span class="function"><span class="params">x</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;)</span><br><span class="line">--&gt;返回abc hahaha baidu.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m.forEach(<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;)</span><br><span class="line">--&gt;返回</span><br><span class="line">abc <span class="number">123</span> </span><br><span class="line">hahaha a</span><br><span class="line">baidu.com <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="五-map结构扩展运算符"><a href="#五-map结构扩展运算符" class="headerlink" title="五.map结构扩展运算符"></a>五.map结构扩展运算符</h2><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-0243bc74a207350d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/734/format/webp" alt="img"></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-29c920ecbfe9d944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/668/format/webp" alt="img"></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-4b3a1d9eed0acb8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/992/format/webp" alt="img"></p>
<p>输出hd</p>
</blockquote>
<blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-fcd1a0816cc30ab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/990/format/webp" alt="img"></p>
</blockquote>
<h2 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————-"></a>——————————————————-</h2><h2 id="一-Set结构数据"><a href="#一-Set结构数据" class="headerlink" title="一.Set结构数据"></a>一.Set结构数据</h2><h4 id="1-set结构的数据类似于数组，但成员值都是没有重复的唯一值。"><a href="#1-set结构的数据类似于数组，但成员值都是没有重复的唯一值。" class="headerlink" title="1. set结构的数据类似于数组，但成员值都是没有重复的唯一值。"></a>1. set结构的数据类似于数组，但成员值都是没有重复的唯一值。</h4><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-95dfcd842c22cbdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1162/format/webp" alt="img"></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-c5a33afd58d42fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/986/format/webp" alt="img"></p>
<p>s-&gt;Set[1,2,3,4]//注意：此时他是set结构数据，不是数组</p>
</blockquote>
<h2 id="二-数组去重"><a href="#二-数组去重" class="headerlink" title="二.数组去重"></a>二.数组去重</h2><h4 id="1-可以用作数组去重的功能"><a href="#1-可以用作数组去重的功能" class="headerlink" title="1. 可以用作数组去重的功能"></a>1. 可以用作数组去重的功能</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'3'</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">s-&gt;<span class="built_in">Set</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'3'</span>];注意此时s为<span class="keyword">set</span>结构数据</span><br></pre></td></tr></table></figure>

<h4 id="2-将set结构数据变成数组–-gt-扩展运算符…"><a href="#2-将set结构数据变成数组–-gt-扩展运算符…" class="headerlink" title="2. 将set结构数据变成数组–&gt;扩展运算符…"></a>2. 将set结构数据变成数组–&gt;扩展运算符…</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'3'</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...s];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr-&gt;<span class="built_in">Array</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'3'</span>];</span><br></pre></td></tr></table></figure>

<h4 id="3-方法二：Array-from-方法可将数据转化成数组"><a href="#3-方法二：Array-from-方法可将数据转化成数组" class="headerlink" title="3. 方法二：Array.from()方法可将数据转化成数组"></a>3. 方法二：Array.from()方法可将数据转化成数组</h4><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-bab71776f3ab4159.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</blockquote>
<h2 id="三-set结构数据方法"><a href="#三-set结构数据方法" class="headerlink" title="三.set结构数据方法"></a>三.set结构数据方法</h2><ul>
<li><h4 id="set实例的属性和方法"><a href="#set实例的属性和方法" class="headerlink" title="set实例的属性和方法"></a>set实例的属性和方法</h4></li>
</ul>
<blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-9e7c4298bbb198d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1172/format/webp" alt="img"></p>
</blockquote>
<h4 id="1-add-value"><a href="#1-add-value" class="headerlink" title="1. add(value);"></a>1. add(value);</h4><ul>
<li><strong>s.size获得set数据的长度</strong></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s.size);</span><br><span class="line">--&gt;<span class="number">4</span></span><br><span class="line">s.add(<span class="number">6</span>);</span><br><span class="line">s.add(<span class="number">6</span>);</span><br><span class="line">s.add(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">s--&gt;<span class="built_in">Set</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2-delete-value"><a href="#2-delete-value" class="headerlink" title="2. delete(value)"></a>2. delete(value)</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">s--&gt;<span class="built_in">Set</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="3-has-value"><a href="#3-has-value" class="headerlink" title="3. has(value)"></a>3. has(value)</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">7</span>));</span><br><span class="line">--&gt;<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="4-clear"><a href="#4-clear" class="headerlink" title="4. clear()"></a>4. clear()</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">s.clear();</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">--&gt;<span class="built_in">Set</span>[];</span><br></pre></td></tr></table></figure>

<h2 id="四-set结构数据遍历"><a href="#四-set结构数据遍历" class="headerlink" title="四.set结构数据遍历"></a>四.set结构数据遍历</h2><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-31d5191deb76df59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp" alt="img"></p>
</blockquote>
<ul>
<li><h4 id="遍历器只能用for…of…来遍历"><a href="#遍历器只能用for…of…来遍历" class="headerlink" title="遍历器只能用for…of…来遍历"></a>遍历器只能用for…of…来遍历</h4></li>
<li><h4 id="补充：对象中的键名和键值-eg-a-1-b-2-–-gt-a-b为键名，1-2为键值"><a href="#补充：对象中的键名和键值-eg-a-1-b-2-–-gt-a-b为键名，1-2为键值" class="headerlink" title="补充：对象中的键名和键值 eg:{a:1,b:2}–&gt;a,b为键名，1,2为键值"></a>补充：对象中的键名和键值 eg:{a:1,b:2}–&gt;a,b为键名，1,2为键值</h4></li>
</ul>
<h4 id="1-for…of…用来遍历遍历器"><a href="#1-for…of…用来遍历遍历器" class="headerlink" title="1. for…of…用来遍历遍历器"></a>1. for…of…用来遍历遍历器</h4><h4 id="2-keys-–-gt-将set数据里的键名全部拢在一起，再利用for-of遍历"><a href="#2-keys-–-gt-将set数据里的键名全部拢在一起，再利用for-of遍历" class="headerlink" title="2. keys()–&gt;将set数据里的键名全部拢在一起，再利用for of遍历"></a>2. keys()–&gt;将set数据里的键名全部拢在一起，再利用for of遍历</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'a'</span>]);</span><br><span class="line"><span class="keyword">for</span> ( x <span class="keyword">of</span> s.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;a b c d</span><br></pre></td></tr></table></figure>

<ul>
<li>set数据不分键名和键值，所以keys和values一样</li>
</ul>
<h4 id="3-values"><a href="#3-values" class="headerlink" title="3. values()"></a>3. values()</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'a'</span>]);</span><br><span class="line"><span class="keyword">for</span> ( x <span class="keyword">of</span> s.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;a b c d</span><br></pre></td></tr></table></figure>

<h4 id="4-entries-键值对指键名与键值的集合"><a href="#4-entries-键值对指键名与键值的集合" class="headerlink" title="4.entries();键值对指键名与键值的集合"></a>4.entries();键值对指键名与键值的集合</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'a'</span>]);</span><br><span class="line"><span class="keyword">for</span> ( x <span class="keyword">of</span> s.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;<span class="built_in">Array</span>[<span class="string">'a'</span>,<span class="string">'a'</span>] </span><br><span class="line"><span class="built_in">Array</span>[<span class="string">'b'</span>,<span class="string">'b'</span>]</span><br><span class="line"><span class="built_in">Array</span>[<span class="string">'c'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="built_in">Array</span>[<span class="string">'d'</span>,<span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="5-forEach-；与数组forEach-循环方法一样"><a href="#5-forEach-；与数组forEach-循环方法一样" class="headerlink" title="5. forEach()；与数组forEach()循环方法一样"></a>5. forEach()；与数组forEach()循环方法一样</h4><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-7845549dc0dfb2f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</blockquote>
<p>链接：<a href="https://www.jianshu.com/p/7f934c99c4dd" target="_blank" rel="noopener">https://www.jianshu.com/p/7f934c99c4dd</a></p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>es6之扩展运算符</title>
    <url>/2020/09/14/es6%E4%B9%8B%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a><strong>含义</strong></h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">&#x2F;&#x2F; 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">&#x2F;&#x2F; 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(&#39;div&#39;)]</span><br><span class="line">&#x2F;&#x2F; [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>该运算符主要用于函数调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [4, 38];</span><br><span class="line">add(...numbers) &#x2F;&#x2F; 42</span><br></pre></td></tr></table></figure>

<p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f(v, w, x, y, z) &#123; &#125;</span><br><span class="line">const args &#x3D; [0, 1];</span><br><span class="line">f(-1, ...args, 2, ...[3]);</span><br></pre></td></tr></table></figure>

<p>扩展运算符后面还可以放置表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [</span><br><span class="line">  ...(x &gt; 0 ? [&#39;a&#39;] : []),</span><br><span class="line">  &#39;b&#39;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...[], 1]</span><br><span class="line">&#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure>

<p>注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(...[1, 2])</span><br><span class="line">&#x2F;&#x2F; Uncaught SyntaxError: Unexpected number</span><br><span class="line"></span><br><span class="line">console.log((...[1, 2]))</span><br><span class="line">&#x2F;&#x2F; Uncaught SyntaxError: Unexpected number</span><br><span class="line"></span><br><span class="line">console.log(...[1, 2])</span><br><span class="line">&#x2F;&#x2F; 1 2</span><br></pre></td></tr></table></figure>

<p>上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。</p>
<h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a><strong>替代函数的 apply 方法</strong></h3><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5 的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">var args &#x3D; [0, 1, 2];</span><br><span class="line">f.apply(null, args);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">let args &#x3D; [0, 1, 2];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure>

<p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5 的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5的 写法</span><br><span class="line">var arr1 &#x3D; [0, 1, 2];</span><br><span class="line">var arr2 &#x3D; [3, 4, 5];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 的写法</span><br><span class="line">let arr1 &#x3D; [0, 1, 2];</span><br><span class="line">let arr2 &#x3D; [3, 4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure>

<p>上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">new (Date.bind.apply(Date, [null, 2015, 1, 1]))</span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">new Date(...[2015, 1, 1]);</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a><strong>扩展运算符的应用</strong></h3><p><strong>（1）复制数组</strong></p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 &#x3D; [1, 2];</span><br><span class="line">const a2 &#x3D; a1;</span><br><span class="line"></span><br><span class="line">a2[0] &#x3D; 2;</span><br><span class="line">a1 &#x2F;&#x2F; [2, 2]</span><br></pre></td></tr></table></figure>

<p>上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。</p>
<p>ES5 只能用变通方法来复制数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 &#x3D; [1, 2];</span><br><span class="line">const a2 &#x3D; a1.concat();</span><br><span class="line"></span><br><span class="line">a2[0] &#x3D; 2;</span><br><span class="line">a1 &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure>

<p>上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 &#x3D; [1, 2];</span><br><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">const a2 &#x3D; [...a1];</span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">const [...a2] &#x3D; a1;</span><br></pre></td></tr></table></figure>

<p>上面的两种写法，a2都是a1的克隆。</p>
<p><strong>（2）合并数组</strong></p>
<p>扩展运算符提供了数组合并的新写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [&#39;a&#39;, &#39;b&#39;];</span><br><span class="line">const arr2 &#x3D; [&#39;c&#39;];</span><br><span class="line">const arr3 &#x3D; [&#39;d&#39;, &#39;e&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES5 的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</span><br></pre></td></tr></table></figure>

<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 &#x3D; [&#123; foo: 1 &#125;];</span><br><span class="line">const a2 &#x3D; [&#123; bar: 2 &#125;];</span><br><span class="line"></span><br><span class="line">const a3 &#x3D; a1.concat(a2);</span><br><span class="line">const a4 &#x3D; [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[0] &#x3D;&#x3D;&#x3D; a1[0] &#x2F;&#x2F; true</span><br><span class="line">a4[0] &#x3D;&#x3D;&#x3D; a1[0] &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。</p>
<p><strong>（3）与解构赋值结合</strong></p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">a &#x3D; list[0], rest &#x3D; list.slice(1)</span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">[a, ...rest] &#x3D; list</span><br></pre></td></tr></table></figure>

<p>下面是另外一些例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [first, ...rest] &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">first &#x2F;&#x2F; 1</span><br><span class="line">rest  &#x2F;&#x2F; [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] &#x3D; [];</span><br><span class="line">first &#x2F;&#x2F; undefined</span><br><span class="line">rest  &#x2F;&#x2F; []</span><br><span class="line"></span><br><span class="line">const [first, ...rest] &#x3D; [&quot;foo&quot;];</span><br><span class="line">first  &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line">rest   &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [...butLast, last] &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">&#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p><strong>（4）字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...&#39;hello&#39;]</span><br><span class="line">&#x2F;&#x2F; [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure>

<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;x\uD83D\uDE80y&#39;.length &#x2F;&#x2F; 4</span><br><span class="line">[...&#39;x\uD83D\uDE80y&#39;].length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function length(str) &#123;</span><br><span class="line">  return [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(&#39;x\uD83D\uDE80y&#39;) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &#39;x\uD83D\uDE80y&#39;;</span><br><span class="line"></span><br><span class="line">str.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">&#x2F;&#x2F; &#39;y\uDE80\uD83Dx&#39;</span><br><span class="line"></span><br><span class="line">[...str].reverse().join(&#39;&#39;)</span><br><span class="line">&#x2F;&#x2F; &#39;y\uD83D\uDE80x&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p>
<p><strong>（5）实现了 Iterator 接口的对象</strong></p>
<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let nodeList &#x3D; document.querySelectorAll(&#39;div&#39;);</span><br><span class="line">let array &#x3D; [...nodeList];</span><br></pre></td></tr></table></figure>

<p>上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number.prototype[Symbol.iterator] &#x3D; function*() &#123;</span><br><span class="line">  let i &#x3D; 0;</span><br><span class="line">  let num &#x3D; this.valueOf();</span><br><span class="line">  while (i &lt; num) &#123;</span><br><span class="line">    yield i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log([...5]) &#x2F;&#x2F; [0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>上面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">  &#39;0&#39;: &#39;a&#39;,</span><br><span class="line">  &#39;1&#39;: &#39;b&#39;,</span><br><span class="line">  &#39;2&#39;: &#39;c&#39;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot spread non-iterable object.</span><br><span class="line">let arr &#x3D; [...arrayLike];</span><br></pre></td></tr></table></figure>

<p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<p><strong>（6）Map 和 Set 结构，Generator 函数</strong></p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map([</span><br><span class="line">  [1, &#39;one&#39;],</span><br><span class="line">  [2, &#39;two&#39;],</span><br><span class="line">  [3, &#39;three&#39;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [...map.keys()]; &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const go &#x3D; function*()&#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;a: 1, b: 2&#125;;</span><br><span class="line">let arr &#x3D; [...obj]; &#x2F;&#x2F; TypeError: Cannot spread non-iterable object</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>扩展运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>es6特性</title>
    <url>/2020/07/30/es6%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符"></a>展开操作符</h3><p>顾名思义，用于对象或数组之前的展开操作符（…），将一个结构展开为列表。</p>
<p>演示一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let firstHalf &#x3D; [ &#39;one&#39;, &#39;two&#39;];</span><br><span class="line"></span><br><span class="line">let secondHalf &#x3D; [&#39;three&#39;, &#39;four&#39;, ...firstHalf];</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这种写法够优雅，够简洁吧？如果不用展开操作符</p>
<p>我们得这么写：</p>
<p>let firstHalf = [ ‘one’, ‘two’];</p>
<p>let secondHalf = [‘three’, ‘four’];</p>
<p>for(var i=0, i &lt;firstHalf.length; i++ ) {</p>
<p>  secondHalf.push(firstHalf[i]);</p>
<p>}</p>
<p>展开操作符也适用于合并对象的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hero &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &#39;Xena - Warrior Princess&#39;,</span><br><span class="line"></span><br><span class="line">  realName: &#39;Lucy Lawless&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const heroWithSword &#x3D; &#123;</span><br><span class="line"></span><br><span class="line"> ...hero,</span><br><span class="line"></span><br><span class="line"> weapon: &#39;sword&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不用展开操作符的话，需要遍历对象的属性：</p>
<p>let keys = Object.keys(hero);</p>
<p>let obj = {};</p>
<p>for(var i=0; i&lt; keys.length; i++) {</p>
<p>   obj[keys[i]] = keys[props[i]];</p>
<p>}</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数将剩余的参数收入数列。JavaScript 的特性是参数数目很灵活。通常会有一个 arguments 变量收集参数。</p>
<p>让我们看一个例子：</p>
<p>function add(first, second, …remaining) {</p>
<p>  return first + second;</p>
<p>}</p>
<p>上面的一段代码仅仅将 first 和 second 加起来，也就是说，调用 add(1, 2) 和 add(1, 2, 3, 4) 会得到相同的结果。</p>
<p>下面我们修正一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(first, second, ...remaining) &#123;</span><br><span class="line"></span><br><span class="line">  return first + second + remaining.reduce((acc, curr) &#x3D;&gt; acc + curr, 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如前所述，…remaining 收集了剩余的参数，为我们提供了这些参数的命名，清楚地表明我们打算处理剩余的参数。我记得至迟 ES5 已经有 arguments 了，不过少有人知。</p>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p>见过这样的语句吗？</p>
<p>class Product {</p>
<p> constructor(name, description, price) {</p>
<p>   this.name = name;</p>
<p>   this.description = description;</p>
<p>   this.price = price;</p>
<p> }</p>
<p>getDescription() {</p>
<p>   return “ Full description \n” +</p>
<p>   “ name: “ + this.name +</p>
<p>   “ description: “ + this.description</p>
<p> }</p>
<p>}</p>
<p>当然，我指的是 getDescription() 方法中那个可读性不佳的多行长语句。大多数编程语言中都存在类似现象。一些语言提供了字符串插值，幸运的是，JavaScript 正是其中之一。</p>
<p>我们改写一下 getDescription() 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getDescription() &#123;</span><br><span class="line"></span><br><span class="line">   return &#96;Full description \n:</span><br><span class="line"></span><br><span class="line">   name: $&#123;this.name&#125;</span><br><span class="line"></span><br><span class="line">   description $&#123;this.description&#125;</span><br><span class="line"></span><br><span class="line">   &#96;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一对 包起来的字符串中可以使用 ${} 插值。现在看起来舒服多了。</p>
<h3 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h3><p>在 ES5 中必须这么写：</p>
<p>function createCoord(x, y) {</p>
<p>  return {</p>
<p>​    x: x,</p>
<p>​    y: y</p>
<p>  }</p>
<p>}</p>
<p>ES6 以后可以使用简写属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createCoord(x, y) &#123;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line"></span><br><span class="line">    x,</span><br><span class="line"></span><br><span class="line">    y</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看起来更清爽了吧？</p>
<h3 id="方法属性"><a href="#方法属性" class="headerlink" title="方法属性"></a>方法属性</h3><p>方法属性是在对象中定义指向方法的属性。</p>
<p>考虑下面一段 ES5 代码作为例子：</p>
<p>const math = {</p>
<p>  add: function(a,b) { return a + b; },</p>
<p>  sub: function(a,b) { return a - b; },</p>
<p>  multiply: function(a,b) { return a * b; }</p>
<p>}</p>
<p>ES6 以后只需这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const math &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  add(a,b) &#123; return a + b; &#125;,</span><br><span class="line"></span><br><span class="line">  sub(a,b) &#123; return a - b; &#125;,</span><br><span class="line"></span><br><span class="line">  multiply(a,b) &#123; return a * b; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值有利于开发者本人的心理健康。</p>
<p>考虑下面的代码：</p>
<p>function handle(req, res) {</p>
<p> const name = req.body.name;</p>
<p> const description = req.body.description;</p>
<p> const url = req.url;</p>
<p> log(‘url endpoint’, url);</p>
<p> // 大量代码逻辑</p>
<p> dbService.createPerson(name, description)</p>
<p>}</p>
<p>不管从什么角度来看，上面的代码都不完美，但它确实体现了一种应用场景，我们想要从对象的不同层次获取数据。你也许会问，这里有什么问题？好吧，我可以不用声明这么多变量，省下一些敲击键盘的次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function handle(req, res) &#123;</span><br><span class="line"></span><br><span class="line"> const &#123; body: &#123; name, description &#125;, url &#125; &#x3D; req;</span><br><span class="line"></span><br><span class="line"> log(&#39;url endpoint&#39;, url);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 大量代码逻辑</span><br><span class="line"></span><br><span class="line"> dbService.createPerson(name, description)</span><br></pre></td></tr></table></figure>



<p>看，我们上面的代码将三行压缩成了一行。</p>
<p>解构赋值并不仅仅局限于对象。它同样适用于数组。</p>
<p>考虑下面的代码：</p>
<p>const array = [1,2,3,4,5,6];</p>
<p>const a = array[0];</p>
<p>const c = array[2];</p>
<p>上面的代码可以用更优雅的方式改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array &#x3D; [1,2,3,4,5,6];</span><br><span class="line"></span><br><span class="line">const [a, ,c, ...remaining] &#x3D; arr;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; remaining &#x3D; [4,5,6]</span><br></pre></td></tr></table></figure>

<p>我们可以使用上面的模式匹配分解数组的值。我们使用 , , 跳过某些值。上面提到过的剩余参数这里也能用，在这里我们通过剩余参数捕获了剩余的数组成员。</p>
<p>解构赋值还可以用于函数和参数。函数有不止 2-3 个参数时，使用一个对象收集所有参数是 JavaScript 的事实标准。</p>
<p>例如，下面一个函数：</p>
<p>function doSomething(config) {</p>
<p>  if(config.a) { … }</p>
<p>  if(config.b) { … }</p>
<p>  if(config.c) { … }</p>
<p>}</p>
<p>有更好的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function doSomething(&#123; a, b, c &#125;) &#123;</span><br><span class="line"></span><br><span class="line">  if(a) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  if(b) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  if(c) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数解构的默认参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 解构 —— 只获得 name 属性</span><br><span class="line">&#x2F;&#x2F; 参数默认分配空对象 &#123;&#125;</span><br><span class="line">function test(&#123;name&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  console.log (name || &#39;unknown&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map 是 ES2015(ES6) 引入的新的对象类型，允许您存储键值对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(color) &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用 switch case 语句，根据颜色找出对应的水果</span><br><span class="line">  switch (color) &#123;</span><br><span class="line">    case &#39;red&#39;:</span><br><span class="line">      return [&#39;apple&#39;, &#39;strawberry&#39;];</span><br><span class="line">    case &#39;yellow&#39;:</span><br><span class="line">      return [&#39;banana&#39;, &#39;pineapple&#39;];</span><br><span class="line">    case &#39;purple&#39;:</span><br><span class="line">      return [&#39;grape&#39;, &#39;plum&#39;];</span><br><span class="line">    default:</span><br><span class="line">      return [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试结果</span><br><span class="line">test(null); &#x2F;&#x2F; []</span><br><span class="line">test(&#39;yellow&#39;); &#x2F;&#x2F; [&#39;banana&#39;, &#39;pineapple&#39;]</span><br></pre></td></tr></table></figure>

<p>优化后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用对象字面量，根据颜色找出对应的水果</span><br><span class="line">  const fruitColor &#x3D; &#123;</span><br><span class="line">    red: [&#39;apple&#39;, &#39;strawberry&#39;],</span><br><span class="line">    yellow: [&#39;banana&#39;, &#39;pineapple&#39;],</span><br><span class="line">    purple: [&#39;grape&#39;, &#39;plum&#39;]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">function test(color) &#123;</span><br><span class="line">  return fruitColor[color] || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 Map ，根据颜色找出对应的水果</span><br><span class="line">  const fruitColor &#x3D; new Map()</span><br><span class="line">    .set(&#39;red&#39;, [&#39;apple&#39;, &#39;strawberry&#39;])</span><br><span class="line">    .set(&#39;yellow&#39;, [&#39;banana&#39;, &#39;pineapple&#39;])</span><br><span class="line">    .set(&#39;purple&#39;, [&#39;grape&#39;, &#39;plum&#39;]);</span><br><span class="line"></span><br><span class="line">function test(color) &#123;</span><br><span class="line">  return fruitColor.get(color) || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>ES6 引入了许多有用的数组方法，例如：</p>
<ul>
<li>find()，查找列表中的成员，返回 null 表示没找到</li>
<li>findIndex()，查找列表成员的索引</li>
<li>some()，检查某个断言是否至少在列表的一个成员上为真</li>
<li>includes，列表是否包含某项</li>
</ul>
<p>下面的代码有助于你理解它们的用法：</p>
<p>const array = [{ id: 1, checked: true }, { id: 2 }];</p>
<p>arr.find(item =&gt; item.id === 2) // { id: 2 }</p>
<p>arr.findIndex(item =&gt; item.id === 2) // 1</p>
<p>arr.some(item =&gt; item.checked) // true</p>
<p>const numberArray = [1,2,3,4];</p>
<p>numberArray.includes(2) // true</p>
<p>Promises + Async/Await</p>
<p>如果你在这个圈子里呆了些年头，也许会记得曾经有一个时期我们只有回调</p>
<p>就像这样：</p>
<p>function doSomething(cb) {</p>
<p>  setTimeout(() =&gt;  {</p>
<p>​    cb(‘done’)</p>
<p>  }, 3000)</p>
<p>}</p>
<p>doSomething((arg) =&gt; {</p>
<p> console.log(‘done here’, arg);</p>
<p>})</p>
<p>我们使用回调是因为有些操作是异步的，需要时间来完成。后来我们有了 promise 库，人们开始使用它。然后 JavaScript 逐渐加入了对 promise 的原生支持。</p>
<p>function doSomething() {</p>
<p>  return new Promise((resolve, reject) =&gt; {</p>
<p>​    setTimeout(() =&gt;  {</p>
<p>​      resolve(‘done’)</p>
<p>​    }, 3000)</p>
<p>  })</p>
<p>}</p>
<p>doSomething().then(arg =&gt; {</p>
<p> console.log(‘done here’, arg);</p>
<p>})</p>
<p>我们甚至可以这样调用，将 promise 串起来：</p>
<p>getUser()</p>
<p>  .then(getOrderByUser)</p>
<p>  .then(getOrderItemsByOrder)</p>
<p>  .then(orderItems =&gt; {</p>
<p>​    // 处理排序后的成员</p>
<p>  })</p>
<p>后来生活更加美好，我们有了 async/await</p>
<p>上面一段代码可以这样写：</p>
<p>async function getItems() {</p>
<p>  try {</p>
<p>​    const user = await getUser();</p>
<p>​    const order = await getOrderByUser(user);</p>
<p>​    const items = await getOrderItemsByOrder(order);</p>
<p>​    return items;</p>
<p>  } catch(err) {</p>
<p>​    // 在这里处理错误，建议返回某个值或者重新抛出错误</p>
<p>  }</p>
<p>}</p>
<p>getItems().then(items =&gt; {</p>
<p>  // 处理排序后的成员</p>
<p>})</p>
<p>###模块</p>
<p>差不多任何编程语言都支持模块这一概念，也就是将代码分为多个文件，每个文件是一个自我包含的单元（模块）。</p>
<p>考虑下面的代码：</p>
<p>// math.js</p>
<p>export function add(a,b) { return a + b; }</p>
<p>export function sub(a,b) { return a - b; }</p>
<p>export default mult(a,b) =&gt; a * b;</p>
<p>// main.js</p>
<p>import mult, { add, sub } from ‘./math’;</p>
<p>mult(2, 4) // 8</p>
<p>add(1,1)   // 2</p>
<p>sub(1,2)   // -1</p>
<p>我们在上面用 export 关键字注明了 add 和 sub 这两个结构对任何引入该模块的模块都公开可见。export default 关键字则注明仅仅 import 模块时得到的结构。在 main.js 中，我们将导入的 default 命名为 mult，同时指明我们引入 add() 和 sub() 这两个方法。箭头函数和字典作用域 this</p>
<p>我在这篇文章中很多地方都用到了箭头函数，它不过是另一种函数表示法。</p>
<p>过去我们只能这么声明函数：</p>
<p>function printArray(arr) {</p>
<p> // 具体操作</p>
<p>}</p>
<p>现在我们也可以这么写：</p>
<p>const printArray = (arr) =&gt; {</p>
<p> // 具体操作</p>
<p>}</p>
<p>我们也可以将函数声明写到一行里：</p>
<p>const add = (a,b) =&gt; a + b</p>
<p>上面的代码表明我们进行操作并返回结果。</p>
<p>我们也可以采用下面的语法返回一个对象：</p>
<p>const create = (a,b) = &gt; ({ x: a, y: b })</p>
<p>过去会碰到搞不清 this 是什么的问题。考虑下面的代码：</p>
<p>let array = [1,2,3];</p>
<p>function sum() {</p>
<p>  this.total = 0;</p>
<p>  arr.forEach(function(item) {</p>
<p>​    this.total+= item;  // 糟糕，<code>this</code> 是内层函数的 <code>this</code></p>
<p>  })</p>
<p>  return total;</p>
<p>}</p>
<p>上面代码中的 this 指向 forEach 内部函数的 this，这可不是我们想要的。</p>
<p>过去我们通过以下方式解决这个问题：</p>
<p>function sum() {</p>
<p>  this.total = 0;</p>
<p>  var self = this;</p>
<p>  arr.forEach(function(item) {</p>
<p>​    self.total+= item;  // 这里我们使用 <code>self</code>，它能解决问题，但是感觉有点别扭</p>
<p>  })</p>
<p>  return total;</p>
<p>}</p>
<p>箭头函数可以解决问题，再也不用 self 了</p>
<p>现在代码看起来是这样的：</p>
<p>function sum() {</p>
<p>  this.total = 0;</p>
<p>  arr.forEach((item) =&gt; {</p>
<p>​    this.total+= item;  // 一切安好，<code>this</code> 指向外层函数</p>
<p>  })</p>
<p>  return total;</p>
<p>}</p>
<h3 id="Object-is-方法，它具有-的一些特点，而且更好、更精确"><a href="#Object-is-方法，它具有-的一些特点，而且更好、更精确" class="headerlink" title="Object.is() 方法，它具有 === 的一些特点，而且更好、更精确"></a>Object.is() 方法，它具有 === 的一些特点，而且更好、更精确</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.is(0 , &#39; &#39;); &#x2F;&#x2F;false</span><br><span class="line">Object.is(null, undefined); &#x2F;&#x2F;false</span><br><span class="line">Object.is([1], true); &#x2F;&#x2F;false</span><br><span class="line">Object.is(NaN, NaN); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="ES2020-中-Javascript-10-个你应该知道的新功能"><a href="#ES2020-中-Javascript-10-个你应该知道的新功能" class="headerlink" title="ES2020 中 Javascript 10 个你应该知道的新功能"></a>ES2020 中 Javascript 10 个你应该知道的新功能</h3><h3 id="1-BigInt"><a href="#1-BigInt" class="headerlink" title="1: BigInt"></a>1: BigInt</h3><p>BigInt，Javascript 中最期待的新功能终于落地。它允许开发者在 JS 中使用更大的整数进行数据处理。</p>
<p>之前，Javascript 中最大的整数是 <code>pow(2, 53) \- 1</code>。但是，BigInt 不受此限制。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGwarDI032t9wha7b0IahtTzo8zIeuwhUs1HJBGYfW7pjwd7ibbB5Mdow/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>然而，就如你在上面看到，你需要在数字后面添加一个 <code>n</code>。这个 <code>n</code> 说明这是一个 BigInt，Javascript 引擎应该特殊处理（不管是 V8，还是其它引擎）。</p>
<p>因为传统的数字系统是 IEEE754（它不支持这种大数字），因此，这个改进并不会向后兼容。</p>
<h3 id="2：动态引入"><a href="#2：动态引入" class="headerlink" title="2：动态引入"></a>2：动态引入</h3><p>Javascript 的动态引入，允许你把 JS 文件作为一个模块动态的引入到你的应用中。这就像你使用 webpack 和 Babel 一样。</p>
<p>这个功能可以帮助你处理按需加载的代码，拆分代码，而且，并不需要 webpack 或者其它模块处理器。如果，你喜欢也可以在 if-else 块中加载代码。</p>
<p>在 if-else 块中引入一个模块，这样的好处是：不会污染全局命名空间。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGLpBPLYgYRwZ5ib0tx951uC6yTocZIZ6OicfltYmhNGa1D7yCE5L4K9TQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="3-空值合并"><a href="#3-空值合并" class="headerlink" title="3: 空值合并"></a>3: 空值合并</h3><p>空值合并可以真正的检查 <code>nullish</code> 值，而不是 <code>falsely</code> 值。你或许会问：<code>nullish</code>和 <code>falsely</code> 之间有什么不同呢？</p>
<p>在 Javascript 中有很多值都是 <code>falsely</code>。比如：空字符串、数字 0、<code>undefined</code>、<code>null</code>、 <code>false</code> 、<code>NaN</code> 等。</p>
<p>然而，很多情况下你只想检测一个变量是否为空值 – <code>undefined</code> 或者 <code>null</code>，就像变量可以是一个空字符串甚至是一个假值。</p>
<p>在这个示例中，你将会看到新的空值合并操作符：<code>??</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGGCVd9L1a8WDLibedRyLc0CeOEOUCZha5JXiacCp2KzXicJDR1mXB96zlQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>你可以清楚的看到 OR 操作符总是返回一个真值，但是，空值操作符返回一个非空值。</p>
<h3 id="4：可选链"><a href="#4：可选链" class="headerlink" title="4：可选链"></a>4：可选链</h3><p>可选链语法允许你访问嵌套更深的对象属性，而不用担心属性是否存在。如果，存在很好。反之，会返回 <code>undefined</code>。</p>
<p>它不仅仅可操作对象属性，也可以操作函数的调用或者数组。这样更加方便！以下是个演示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGdbuZJu6Ms94TdPHNp5iaMwyHico9kpkFh90iboBGbTpCM0zZ2ZX2nTssA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="5-Promise-allSettled"><a href="#5-Promise-allSettled" class="headerlink" title="5: Promise.allSettled"></a>5: Promise.allSettled</h3><p><code>Promise.allSettled</code> 方法接收一组 Promise，并且会返回所有的结果 - 而不管是 resolved 还是 rejected。</p>
<p>在之前，这是不可能的，尽管有些类似的实现比如：<code>race</code> 和 <code>all</code>。它只会“运行所有的 promise - 而不关心它们的结果”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGGLZEQbV3z7SI6bA2v7rjFXkib2tosiaLIsfg0gmlpjDibVxetuBn5fVmQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="6-String-matchAll"><a href="#6-String-matchAll" class="headerlink" title="6: String#matchAll"></a>6: String#matchAll</h3><h3 id="举例解决问题"><a href="#举例解决问题" class="headerlink" title="举例解决问题"></a>举例解决问题</h3><h4 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h4><p>在此示例中，我们使用了散布运算符（…），Array的reverse方法和String的join方法来反转给定的字符串。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWS5QUCFTBa7CHlWarkPicvMmxPX22TIc1rAnKbuDfKyWWichiakwjfx5PhQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="2、计算数字的阶乘"><a href="#2、计算数字的阶乘" class="headerlink" title="2、计算数字的阶乘"></a>2、计算数字的阶乘</h4><p>要计算给定数字的阶乘，我们使用箭头函数和嵌套三元运算符。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSqibNic0gumhUb1xeBcKSFmbiaE2bsOPtByxJDOibhau4T7FM4PQQBQ8vag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="3、将数字转换为数字数组"><a href="#3、将数字转换为数字数组" class="headerlink" title="3、将数字转换为数字数组"></a>3、将数字转换为数字数组</h4><p>在此示例中，我们使用了散布运算符（…），Array的map方法以及将该给定数字转换为一个单数数组的parseInt 函数 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSIcozwmwiavIspqX1uMyaNh4RAZibudxVCX97BW27YbT3b9zLQ7Ou02yQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="4、检查数字是否为2的幂"><a href="#4、检查数字是否为2的幂" class="headerlink" title="4、检查数字是否为2的幂"></a>4、检查数字是否为2的幂</h4><p>这很简单。我们检查这number不是虚假的，并使用按位AND运算符 （&amp;）确定是否number为2的幂。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSFJLTkng2dHxMDYiaXQxVDwQzvIGCElMUmUVYYUsXUiaibRHfMdV6Pbib0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="5、从对象创建键-值对数组"><a href="#5、从对象创建键-值对数组" class="headerlink" title="5、从对象创建键-值对数组"></a><strong>5、从对象创建键-值对数组</strong></h4><p>在此示例中，我们使用Object中的keys方法和 Array中的map方法来映射Object的键，并创建一个键值对数组。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSSnDonmibictDW2MVbXE1DSJKvhefIcAYq3kf61YS9Wstuu55ia7D4LJQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="6、从数组中返回-Number-个最大元素"><a href="#6、从数组中返回-Number-个最大元素" class="headerlink" title="6、从数组中返回[Number]个最大元素"></a><strong>6、从数组中返回[Number]个最大元素</strong></h4><p>为了从数组中返回最大元素，我们使用了一个箭头函数，该函数获取数组和希望函数返回的元素数。我们使用了散布运算符（…）以及Array中的sort和slice方法。请注意，如果不提供第二个参数，则number默认值为1，因此仅返回一个最大元素。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWS7D5ZtxhHKCfEibEWvtxf5VgK6kR3CH3tTiaCEStFLVNglVp9rkqE4jNA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="7、检查数组中的所有元素是否相等"><a href="#7、检查数组中的所有元素是否相等" class="headerlink" title="7、检查数组中的所有元素是否相等"></a><strong>7、检查数组中的所有元素是否相等</strong></h4><p>在这个简短的示例中，我们使用Array中的every方法检查数组中的所有元素是否相等。我们基本上检查每个元素是否等于数组中的第一个元素。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWStVhG8l1dPzWm8IZEH4gQJpxdpUuL0gaFQLGDWAW6L5VflYxNcfTjQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="8、返回两个数的平均值"><a href="#8、返回两个数的平均值" class="headerlink" title="8、返回两个数的平均值"></a><strong>8、返回两个数的平均值</strong></h4><p>在此示例中，我们使用了spread运算符（…）和Array中的reduce方法来返回两个给定数字或一个数组的平均值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSS5Piaz8PhaFjX1Adpo4l0ZJqiatS4icRkJTIHCQrmlDj9icol1V0a0GkVg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="9、返回两个或多个数字的和"><a href="#9、返回两个或多个数字的和" class="headerlink" title="9、返回两个或多个数字的和"></a><strong>9、返回两个或多个数字的和</strong></h4><p>要返回两个或多个给定数字或一个数组的总和，我们再次使用散布运算符（…） 和 Array中的reduce方法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSeMEuicAyVrjHB3SpicVpTEmvUoYuKz6gjA0hescic1zwF6BAWluq7NjHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="10、返回数字数组的幂集"><a href="#10、返回数字数组的幂集" class="headerlink" title="10、返回数字数组的幂集"></a><strong>10、返回数字数组的幂集</strong></h4><p>在最后一个示例中，我们要返回数字数组的幂集。因此，我们使用Array中的reduce，map和concat方法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWS2ibeNSm54ZT0LReAsd2IfbKUtveW6Lnx2afRIxlhB1cxVgfm2QMdIMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>更细解说：<a href="https://mp.weixin.qq.com/s/xyHVGYlcng5kucjayOOdwA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xyHVGYlcng5kucjayOOdwA</a></p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>export与importi详解</title>
    <url>/2020/07/30/export%E4%B8%8Eimporti%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>es6模块规范</p>
<p>1、export default 向外暴露的成员，可以使用任意变量来接收</p>
<p>2、在一个模块中，export default 只允许向外暴露一次</p>
<p>3、在一个模块中，可以同时使用export default 和export 向外暴露成员</p>
<p>4、使用export向外暴露的成员，只能使用{ }的形式来接收，这种形式，叫做【按需导出】</p>
<p>5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义</p>
<p>6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收</p>
<p>7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名</p>
<a id="more"></a>

<p>举例</p>
<p>导出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; profile.js</span><br><span class="line">一：</span><br><span class="line">export var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">export var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">export var year &#x3D; 1958;</span><br><span class="line"></span><br><span class="line">二：</span><br><span class="line">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">var year &#x3D; 1958;</span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br><span class="line"></span><br><span class="line">三：</span><br><span class="line">export function multiply(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">四：</span><br><span class="line">function v1() &#123; ... &#125;</span><br><span class="line">function v2() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">  v1 as streamV1,</span><br><span class="line">  v2 as streamV2,</span><br><span class="line">  v2 as streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引入一个</span><br><span class="line"></span><br><span class="line">import &#123;firstName, lastName, year&#125; from &#39;.&#x2F;profile&#39;</span><br><span class="line"></span><br><span class="line">如果想重新给导入的变量一个名字，可以用as关键字，</span><br><span class="line">import &#123; lastName as surname &#125; from &#39;.&#x2F;profile&#39;;</span><br><span class="line"></span><br><span class="line">引入全部</span><br><span class="line">import * as circle from &#39;.&#x2F;circle&#39;;</span><br></pre></td></tr></table></figure>



<p>export default</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认输出</span><br><span class="line">export default function crc32() &#123; &#x2F;&#x2F; 输出</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import crc32 from &#39;crc32&#39;; &#x2F;&#x2F; 输入</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正常输出</span><br><span class="line">export function crc32() &#123; &#x2F;&#x2F; 输出</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">import &#123;crc32&#125; from &#39;crc32&#39;; &#x2F;&#x2F; 输入</span><br></pre></td></tr></table></figure>



<p>CommonJS模块规范（nodejs使用中）</p>
<p>Node应用由模块组成，采用CommonJS模块规范。</p>
<p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 5;</span><br><span class="line"></span><br><span class="line">var addX &#x3D; function (value) &#123;  return value + x;&#125;;</span><br><span class="line"></span><br><span class="line">module.exports.x &#x3D; x;</span><br><span class="line"></span><br><span class="line">module.exports.addX &#x3D; addX;</span><br><span class="line"></span><br><span class="line">上面代码通过module.exports输出变量x和函数addX。</span><br></pre></td></tr></table></figure>



<p>require方法用于加载模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example &#x3D; require(&#39;.&#x2F;example.js&#39;);</span><br><span class="line"></span><br><span class="line">console.log(example.x);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">console.log(example.addX(1));</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 6</span><br><span class="line"></span><br><span class="line">exports 与 module.exports</span><br></pre></td></tr></table></figure>



<p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>
<p>var exports = module.exports;</p>
<p>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
        <tag>export</tag>
        <tag>import</tag>
        <tag>module</tag>
        <tag>require</tag>
      </tags>
  </entry>
  <entry>
    <title>flex</title>
    <url>/2020/10/28/flex/</url>
    <content><![CDATA[<p>父级属性</p>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>![clipboard (10)](flex.assets/clipboard (10).png)</p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>![clipboard (11)](flex.assets/clipboard (11).png)</p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>![clipboard (12)](flex.assets/clipboard (12).png)</p>
<h3 id="align-items-stretch在子项没有高度才能使用-，在子项为单行的时候有效"><a href="#align-items-stretch在子项没有高度才能使用-，在子项为单行的时候有效" class="headerlink" title="align-items(stretch在子项没有高度才能使用)，在子项为单行的时候有效"></a>align-items(stretch在子项没有高度才能使用)，在子项为单行的时候有效</h3><p>![clipboard (13)](flex.assets/clipboard (13).png)</p>
<h3 id="align-content-适用于多行"><a href="#align-content-适用于多行" class="headerlink" title="align-content(适用于多行)"></a>align-content(适用于多行)</h3><p>![clipboard (14)](flex.assets/clipboard (14).png)</p>
<p>区别</p>
<p>![clipboard (15)](flex.assets/clipboard (15).png)</p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>![clipboard (16)](flex.assets/clipboard (16).png)</p>
<p>子级属性</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>![clipboard (17)](flex.assets/clipboard (17).png)</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>![clipboard (18)](flex.assets/clipboard (18).png)</p>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>![clipboard (19)](flex.assets/clipboard (19).png)</p>
<p><strong>flex布局如何左对齐并且间距相同</strong>(适用于少于一行排满的个数或者多余一行但是少于两行)</p>
<p>给item的父类加一个伪类，如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.top-list</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>height一定要给0；width和item的width一致；conten给空即可</strong></p>
]]></content>
  </entry>
  <entry>
    <title>gitExtensions/git/kdiff3/</title>
    <url>/2020/08/18/gitExtensions-git-kdiff3/</url>
    <content><![CDATA[<h3 id="Git-Extension工具安装及使用"><a href="#Git-Extension工具安装及使用" class="headerlink" title="Git Extension工具安装及使用"></a><a href="https://www.cnblogs.com/sumuncle/p/7675921.html" target="_blank" rel="noopener">Git Extension工具安装及使用</a></h3><p>以下界面所示的三个工具，如果没安装过，则勾上让其安装。MsysGit为Git的Windows版本，必须要安装；Kdiff为对比/合并工具，可选安装，可以换为使用其它的相关工具；最后一个Windows Credential Store for Git用于在Windows Credential Manager中存储仓库的密码，这在老版本中没有，也安上吧</p>
<a id="more"></a>

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016110809365-1747214992.png" alt="img"></p>
<p><strong>比较概述：</strong><br>SSH客户端，OpenSSH是命令行的，PuTTY是图形界面的： </p>
<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016110829146-357896798.png" alt="img"></p>
<p>若选择PuTTY则安装成功后,如果有问题，需要进行以下配置:</p>
<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016111207302-993527291.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016111228881-2045654478.png" alt="img"></p>
<p><strong>以下以OpenSSH为例做以下操作:</strong></p>
<p>第一步：安装</p>
<p>1.双击：GitExtensions24703SetupComplete.msi</p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101101099-1387852818.png" alt="img"></p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101117256-804768133.png" alt="img"></p>
<p>选择安装路径</p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101147552-1825946550.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101203974-535514155.png" alt="img"></p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101229693-2058253143.png" alt="img"></p>
<p>点击Install之后跳出以下窗口，点击我接受</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101522412-1379845039.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101539021-1719148735.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101554959-1954911635.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101609834-1365194592.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101624006-1861780982.png" alt="img"></p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101921490-1403912771.png" alt="img"></p>
<p>点击完成后跳出以下窗口，点击Next</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101936334-848543012.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102131974-817517735.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102210724-1255385702.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102231287-1365215914.png" alt="img"></p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102248131-721962200.png" alt="img"></p>
<p>点击后等待安装完成</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102318115-1652078200.png" alt="img"></p>
<p>安装完成后自动关闭窗口，跳转到领一个窗口！点击Finish</p>
<p>点击Finish后，工具就全部安装完成啦！</p>
<p>温馨提示：安装过程中开启的程序可以直接关闭</p>
<p>第二步：配置！</p>
<p>双击软件图标:软件</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102545084-1071616752.png" alt="img"></p>
<p>打开后如下图：进入设置页面，选择全局设置</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102602006-1411834690.png" alt="img"></p>
<p>全局是设置如下图</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102619881-334267455.png" alt="img"></p>
<p>全局设置要求如下：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102632209-937526562.png" alt="img"></p>
<p>SSH设置如下</p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102821959-978142230.png" alt="img"></p>
<p>设置完成后点击应用、接着点击确定</p>
<p>然后出现如下页面：点击克隆档案库</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102859443-624421601.png" alt="img"></p>
<p>出现如下页面：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102916068-1828212738.png" alt="img"></p>
<p>此页面具体设置方法如下图：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103539490-342843931.png" alt="img"></p>
<p>例如配置下图档案库：</p>
<p>档案库地址在：<a href="http://mc.kuaikuai.cn/" target="_blank" rel="noopener">http://mc.kuaikuai.cn</a></p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103647474-1178722425.png" alt="img"></p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103708521-1159470095.png" alt="img"></p>
<p>则文件最终存储的目录为：D:\KuaiKuai_MC_Server\ lostforest</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103733709-556038027.png" alt="img"></p>
<p>点击克隆：弹出输入账户密码窗口，账户由我们快快官方提供</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103806021-1359103381.png" alt="img"></p>
<p>选择路径之后点击克隆，出现以下窗口，输入用户名、点击回车</p>
<p>输入密码</p>
<p>注意：输入密码时看不见输入的键值，光标也不会移动</p>
<p>如果右上角红色X，表示用户名账户验证失败</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104026287-1169565778.png" alt="img"></p>
<p>出现绿色勾为账户验证正确，点击确定。</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104039756-1950152715.png" alt="img"></p>
<p>这个过程中将会把服务器已经存在的文件下载到本地，然后由服主自行替换文件，再上传！</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104108927-1727956402.png" alt="img"></p>
<p>创建成功后如下：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104129771-693242118.png" alt="img"></p>
<p>第三步：上传</p>
<p>点击下图：提交</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104206506-704711939.png" alt="img"></p>
<p>进入以下页面：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104237177-1050313354.png" alt="img"></p>
<p>1区是对应文件夹下的所有文件，选择你需要上传的文件，双击它进入3区！</p>
<p>（注意：1区只显示最新修改的文件，未修改的文件不会显示出来）</p>
<p>2区是显示文本文件的内容。</p>
<p>3区是选择好后需要上传的文件，双击它取消选择</p>
<p>4区是填写操作原因</p>
<p>文件选择完毕之后，填写原因.例如下图：然后点击提交</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104311224-1833734551.png" alt="img"></p>
<p>出现对话框，点击确定</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104336037-321937142.png" alt="img"></p>
<p>进入以下页面，最上方的表示最新创建的任务。等待上传的文件！</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104358318-1599399045.png" alt="img"></p>
<p>如下图：选择第一项，然后点击蓝色向上箭头</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104427256-1658293722.png" alt="img"></p>
<p>点击箭头后出现下图窗口:无需任何操作，直接点击“推送”按钮</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104446568-1900158592.png" alt="img"></p>
<p>点击“推送”后需要验证账户：操作方法与之前一样</p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104513709-1152268099.png" alt="img"></p>
<p>账户验证成功后文件自动上传，出现绿色勾选项表示正确</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104536412-1454555876.png" alt="img"></p>
<p>安装完成，Git Extensions会弹出配置界面，如果有问题，一般就是选择一下相关组件的路径即可：</p>
<p>注意：3.0版本之后，git和kdiff3都要手动安装，一直next就可以了(下图为手动添加kdiff3为对比工具)</p>
<p><img src="https://i.loli.net/2020/08/18/KQMzZ7O2gdXVyw8.png" alt="kdiff3.png"></p>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><blockquote>
<p>SSH是一种<strong>网络协议</strong>，用于计算机之间的<strong>加密</strong>登录。对于SSH详情了解可以去看看这个：<a href="http://www.findme.wang/blog/detail/id/258.html" target="_blank" rel="noopener">http://www.findme.wang/blog/detail/id/258.html</a></p>
</blockquote>
<p>　　每台电脑上会产生出一个ssh key，然后自己有一个远程账户，但是自己有可能有很多台电脑，包括家里的电脑还有公司的电脑，我们可以在任意一台电脑上工作，但是如果想要每台电脑都和远程版本库时刻保持着通讯， 就需要将每台电脑的ssh key添加到远程账户，添加到远程版本库之后，远程版本库就会和已经添加的电脑进行通讯而不会和其他电脑进行通讯。建议：所有的Git操作都通过ssh key进行，因为简单</p>
<h3 id="ssh-key配置-用git命令生成"><a href="#ssh-key配置-用git命令生成" class="headerlink" title="ssh key配置(用git命令生成)"></a><strong>ssh key配置</strong>(用git命令生成)</h3><h5 id="本地电脑配置"><a href="#本地电脑配置" class="headerlink" title="本地电脑配置"></a>本地电脑配置</h5><p>右键空白处，选择Git Bash Here打开相关命令窗口</p>
<p>　　 配置用户名和邮箱（如果已经配置，就跳过）  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;  --引号中自定义</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure>

<p>  之后就会在C:\Users\Administrator下创建一个.gitconfig文件</p>
<p>　　注意：</p>
<ul>
<li>username和email即github的登陆帐号和注册邮箱</li>
<li>git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置</li>
</ul>
<h5 id="检查下自己之前有没有已经生成ssh"><a href="#检查下自己之前有没有已经生成ssh" class="headerlink" title="检查下自己之前有没有已经生成ssh"></a>检查下自己之前有没有已经生成ssh</h5><blockquote>
<p>　　<strong>cd ~/.ssh</strong></p>
</blockquote>
<p>　　证明有ssh存在</p>
<p><img src="https://img2018.cnblogs.com/blog/1691475/201910/1691475-20191017221620652-8123436.png" alt="img"></p>
<p> 　当cd ~/.ssh命令执行后窗口返回“no such file or directory”的时候，表示我们的电脑并没有ssh key，所以需要我们创建ssh ke</p>
<blockquote>
<p>　<strong>ssh-keygen -t rsa -C “<a href="mailto:xxx@xx.com">xxx@xx.com</a>“</strong>  –创建.ssm文件，如果没有这个文件执行即可，接着按三个回车即可。　</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：如果本地有ssh，执行以上命令会出现正面的提示，这里选择y，表示覆盖本地的ssh key，其实也就是ssh秘钥删除的意思</span><br></pre></td></tr></table></figure>



<p>执行命令完成后,默认会在window的C:\Users\Administrator.ssh下面生成如下两个名称的文件:</p>
<p>   C:\Users\Administrator.ssh</p>
<p>​    id_rsa(私钥，不能泄露出去)</p>
<p>​    id_rsa.pub(公钥)</p>
<p>​    known_hosts(不用管)</p>
<p><img src="https://img2018.cnblogs.com/blog/1691475/201910/1691475-20191017222436228-327194399.png" alt="img"></p>
<h3 id="https-和-SSH-的区别"><a href="#https-和-SSH-的区别" class="headerlink" title="https 和 SSH 的区别"></a>https 和 SSH 的区别</h3><blockquote>
<p>1.前者可以随意克隆github上的项目，而不管是谁的；</p>
<p>　　而后者则是你必须是你要克隆的项目的拥有者或管理员，需要先添加 SSH key ，否则无法克隆。</p>
<p>2.https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的；</p>
<p>　　如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。</p>
</blockquote>
<h3 id="Git-Gui生成SSH-Key"><a href="#Git-Gui生成SSH-Key" class="headerlink" title="Git Gui生成SSH Key"></a>Git Gui生成SSH Key</h3><h4 id="打开Git-Gui-选择【help】，点击【Show-SSH-KEY】"><a href="#打开Git-Gui-选择【help】，点击【Show-SSH-KEY】" class="headerlink" title="打开Git Gui, 选择【help】，点击【Show SSH KEY】"></a>打开Git Gui, 选择【help】，点击【Show SSH KEY】</h4><p><img src="https://img-blog.csdn.net/20171213173841712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="由于之前没有配置过SSH-KEY，此时会显示没有任何SSH-公钥"><a href="#由于之前没有配置过SSH-KEY，此时会显示没有任何SSH-公钥" class="headerlink" title="由于之前没有配置过SSH KEY，此时会显示没有任何SSH 公钥"></a>由于之前没有配置过SSH KEY，此时会显示没有任何SSH 公钥</h4><p><img src="https://img-blog.csdn.net/20171213173922842?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="点击右上角【Generate-key】，此时会弹出一个界面，要求你输入passphrase"><a href="#点击右上角【Generate-key】，此时会弹出一个界面，要求你输入passphrase" class="headerlink" title="点击右上角【Generate key】，此时会弹出一个界面，要求你输入passphrase"></a>点击右上角【Generate key】，此时会弹出一个界面，要求你输入passphrase</h4><p><img src="https://img-blog.csdn.net/20171213174146021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="然后再次确认输入passpahrase"><a href="#然后再次确认输入passpahrase" class="headerlink" title="然后再次确认输入passpahrase ."></a>然后再次确认输入passpahrase .</h4><h4 id="此时就会生成一个SSH-Key"><a href="#此时就会生成一个SSH-Key" class="headerlink" title="此时就会生成一个SSH Key"></a>此时就会生成一个SSH Key</h4><p><img src="https://img-blog.csdn.net/20171213174304458?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="如果以后需要查看SSH-Key。此时可以在Git-Gui界面上点击【help】-》【Show-SSH-KEY】，查看此次生成的SSH-Key。"><a href="#如果以后需要查看SSH-Key。此时可以在Git-Gui界面上点击【help】-》【Show-SSH-KEY】，查看此次生成的SSH-Key。" class="headerlink" title="如果以后需要查看SSH Key。此时可以在Git Gui界面上点击【help】-》【Show SSH KEY】，查看此次生成的SSH Key。"></a>如果以后需要查看SSH Key。此时可以在Git Gui界面上点击【help】-》【Show SSH KEY】，查看此次生成的SSH Key。</h4><p><img src="https://img-blog.csdn.net/20171213174406094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="TortoiseGit生成SSH-Key"><a href="#TortoiseGit生成SSH-Key" class="headerlink" title="TortoiseGit生成SSH Key"></a>TortoiseGit生成SSH Key</h3><p>1）运行PuTTYGen，在Conversions菜单中点击Import key，选择ssh-keygen生成的私钥文件所在位置，比如id_rsa文件。</p>
<p>2）点击Save private key按钮，将其保存为.ppk文件。</p>
<p>3）打开Pageant，点击Add Key，选择前一步所保存的.ppk文件所在的位置即可。</p>
<p><a href="https://www.cnblogs.com/sumuncle/p/7675921.html" target="_blank" rel="noopener">参考文章</a></p>
</ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op>]]></content>
      <categories>
        <category>gitExtensions</category>
      </categories>
      <tags>
        <tag>gitExtensions</tag>
        <tag>git</tag>
        <tag>kdiff3</tag>
      </tags>
  </entry>
  <entry>
    <title>express和koa</title>
    <url>/2020/09/15/express%E5%92%8Ckoa/</url>
    <content><![CDATA[<p>Koa和Express都是NodeJS的主流应用开发框架。</p>
<p>Express是一个完整的nodejs应用框架。Koa是由Express团队开发的，但是它有不同的关注点。Koa致力于核心中间件功能。nodejs中间件是访问请求对象（req）和响应对象（res）的例程。这些例程在路由处理程序之前被调用，因此它们位于客户端与生成响应的路由逻辑的“中间”。nodejs应用程序可以将中间件例程“链接”到自定义请求/响应管道中。管道可以根据请求和响应进行操作，包括头和主体。Express和Koa都包含中间件，但实现方法却截然不同。</p>
 <a id="more"></a>

<p>核心Koa模块只是中间件内核。而Express包含一个完整的应用程序框架，具有路由和模板等功能。Koa确实有这些功能的选项，但它们是单独的模块。因此，Koa的模块化程度更高；您只需包含所需的模块即可。核心KOA模块只有大约2千行代码，因此，如果您只需要核心请求应答上下文对象，则Koa占用空间非常小。相比较而言，Express较为庞大，内置了一整套中间件功能，好处是对于大部分应用场合你可以省掉自己选择和组合模块的时间。</p>
<p>Koa对Express进行了扩展，并充分利用了ES7新的语法。Koa的Context对象是对Express核心请求和应答对象的扩展，另外利用async/await来消除回调（callback）陷阱。</p>
<p>回调的语法类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction(params, callback)&#123; </span><br><span class="line">    &#x2F;&#x2F;make async call here  </span><br><span class="line">    asyncCall(params, function(res) &#123; </span><br><span class="line">        callback(res); </span><br><span class="line">    &#125;) </span><br><span class="line">&#125; </span><br><span class="line">myFunction(myParams, function(data)&#123;   </span><br><span class="line">    &#x2F;&#x2F;do something with &#39;data&#39; here </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>异步语法async/await类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async myFunction()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        let res &#x3D; await asyncCall();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(err)&#123;</span><br><span class="line">        console.log(&quot;Error: &quot; + err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let result &#x3D; await myFunction();</span><br></pre></td></tr></table></figure>

<p>回调陷阱（大量嵌套的回调函数）问题这里略过，写过大型JS应用的，应该都深有体会，下面的async/await语法除了执行顺序更加清楚之外，异常处理也更容易。对异步问题的处理方式是Koa和Express两者一个显著区别。</p>
<p>关于性能，这两个框架相差无几，Koa略好，这里略过具体的测试用例了，基本上都能达到几千req/s。</p>
<p>最后简单总结下，如何选型：</p>
<ol>
<li>如果是新项目，运行环境对ES7语法没有限制，对性能比较看重，团队有较高的定制化需求和技能，那么优先选择Koa；</li>
<li>如果是Express的老项目，那么建议继续使用Express，没必要只是为了用新技术而来迁移，Koa和Express也不那么兼容；</li>
<li>如果你不想自己选择和搭建各种模块组件并有可能需要处理兼容问题，而喜欢一体的、快速集成开发，那么选择Express，Express是一套成熟的应用开发框架，而不仅仅提供核心模块</li>
</ol>
<p>参考链接: <a href="https://www.cnblogs.com/leolovexx/p/12212552.html" target="_blank" rel="noopener">https://www.cnblogs.com/leolovexx/p/12212552.html</a></p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoQuest</title>
    <url>/2020/07/15/hexoQuest/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>hexo开发过程中遇到的小坑大坑各种坑合集</p>
<p>部署失败时（deploy处将https改为SSH）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repository: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repository：git@github.com:username&#x2F;username.github.io.git</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="（1）检查是否有SSH-key"><a href="#（1）检查是否有SSH-key" class="headerlink" title="（1）检查是否有SSH key"></a>（1）检查是否有SSH key</h4><p>登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接跳到第（3）步；如果没有，则继续。</p>
<h4 id="（2）新建-SSH-key，在git-shell-或者git-bash等命令窗口-，注意大小写："><a href="#（2）新建-SSH-key，在git-shell-或者git-bash等命令窗口-，注意大小写：" class="headerlink" title="（2）新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写："></a>（2）新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮箱名&quot;</span><br></pre></td></tr></table></figure>

<p>然后会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;dell&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>

<p>直接回车就可以。<br>然后会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p>要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>
<p>注意：输入密码的时候没有*字样的，直接输入就好。<br>然后会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;dell&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;dell&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">65:69:······02:4b emailname@email.com</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|       .   o .   |</span><br><span class="line">|    . o o &#x3D; o    |</span><br><span class="line">|   . o * &#x3D; o     |</span><br><span class="line">|  E  o + o .     |</span><br><span class="line">| . o.   . .      |</span><br><span class="line">|     ..          |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<p>至此，密钥已经成功生成。</p>
<h4 id="（3）接下来在github上添加SSH-key："><a href="#（3）接下来在github上添加SSH-key：" class="headerlink" title="（3）接下来在github上添加SSH key："></a>（3）接下来在github上添加SSH key：</h4><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/dell/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>
<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>
<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。</p>
<h4 id="（4）测试设置是否成功："><a href="#（4）测试设置是否成功：" class="headerlink" title="（4）测试设置是否成功："></a>（4）测试设置是否成功：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>有可能会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (192.30.252.1)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>

<p>或者是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (192.30.252.1)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>

<p>这种情况下，直接 yes 回车</p>
<p>然后会出现（也可能在 <em>++$ ssh -T <a href="mailto:git@github.com">git@github.com</a>++</em> 之后，直接出现的就是这个，我就是这样~）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi username! You&#39;ve successfully authenticated, but GitHub does not </span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure>

<h4 id="（5）设置用户信息："><a href="#（5）设置用户信息：" class="headerlink" title="（5）设置用户信息："></a>（5）设置用户信息：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;用户名&quot;</span><br><span class="line">$ git config --global user.email  &quot;你希望的邮箱名&quot;</span><br></pre></td></tr></table></figure>

<h4 id="（6）然后就可以部署你的博客到github啦"><a href="#（6）然后就可以部署你的博客到github啦" class="headerlink" title="（6）然后就可以部署你的博客到github啦~"></a>（6）然后就可以部署你的博客到github啦~</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>参考文章 <a href="https://www.cnblogs.com/xsilence/p/6001938.html" target="_blank" rel="noopener">ssh</a></p>
]]></content>
      <categories>
        <category>mysoft</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git之错误分支开发的三种情况</title>
    <url>/2020/09/16/git%E4%B9%8B%E9%94%99%E8%AF%AF%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h3 id="还没有commit"><a href="#还没有commit" class="headerlink" title="还没有commit"></a>还没有commit</h3><p>在这种情况下我们可以在当前分支下使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<p>这个命令表示<strong>把我们当前修改的内容暂存起来，然后我们的工作区就恢复到在没有开发新功能之前的样子。</strong></p>
<p>这个时候我们需要切换到正确的工作分支，然后运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="已经在commit了，但是还没有push到远程仓库"><a href="#已经在commit了，但是还没有push到远程仓库" class="headerlink" title="已经在commit了，但是还没有push到远程仓库"></a>已经在commit了，但是还没有<code>push</code>到远程仓库</h3><h4 id="新的功能需要添加在一个新的分支"><a href="#新的功能需要添加在一个新的分支" class="headerlink" title="新的功能需要添加在一个新的分支"></a>新的功能需要添加在一个新的分支</h4><p>首先我们需要知道在我们添加新功能之前，当前分支处于哪一个提交。可以运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>

<p>查看当前分支的提交，可以看到有以下内容的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">085095f (HEAD -&gt; master) update 5</span><br><span class="line">47e52ae update 3</span><br><span class="line">14fefac update 2</span><br><span class="line">fd01444 add README.md</span><br><span class="line">3c76ad1 init</span><br></pre></td></tr></table></figure>

<p>找到我们添加新功能时，当前分支所处的提交。假如是<code>fd01444</code>，那么我们接下来要做的操作就是将<code>HEAD</code>指针指向<code>fd01444</code>，也就是把我们当前分支已提交的内容重置到我们开发新功能之前的样子。我们需要运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset fd01444 # fd01444是某次提交的hash值</span><br></pre></td></tr></table></figure>

<p>如果没有指明重置的模式的话，默认会使用<code>--mixed</code>模式，这样的话我们在<code>fd01444</code>这次提交之后的所有提交都会被重置为没有提交的状态。接下来我们需要把这些新开发的功能迁移到一个新的分支。这时候我们可以使用下面的命令进行操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;newbranch&gt;</span><br></pre></td></tr></table></figure>

<p>这样我们就创建了一个新的分支，并且把新添加的功能也都迁移了过去，接下来就是常规的添加和提交操作了。</p>
<h4 id="新功能需要添加在另一个分支上"><a href="#新功能需要添加在另一个分支上" class="headerlink" title="新功能需要添加在另一个分支上"></a>新功能需要添加在另一个分支上</h4><p>如果我们需要把当前添加的新功能迁移到另一个已经存在的分支，那么我们需要做的前几个步骤跟上面的操作是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline # 查找新功能开发之前的提交</span><br><span class="line">git reset &lt;commit hash&gt; # 将当前分支重置到新功能开发之前的提交</span><br></pre></td></tr></table></figure>

<p>接下来我们现在的状态就回到了<strong>新功能还没有提交的状态</strong>，那么就可以继续使用<code>git stash</code>相关的命令去操作了。</p>
<p>我们还有另外一个方法也能够将已提交到当前分支的功能添加到另一个分支上，那就是使用<code>git cherry-pick</code>命令。首先我们还是先用<code>git log --oneline</code>查找当前已提交的功能的hash值，然后切换到目标分支，运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commit hash&gt;</span><br></pre></td></tr></table></figure>

<p>这样就把我们在另一个分支开发的功能，添加到我们想要的分支了。如果有冲突的话，需要手动处理一下冲突。然后我们回到最初的分支，再次运行<code>git reset &lt;commit hash&gt;</code>命令，把已提交的内容进行重置，然后运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- .</span><br></pre></td></tr></table></figure>



<h2 id="新功能已经commit了，且push到了远程仓库"><a href="#新功能已经commit了，且push到了远程仓库" class="headerlink" title="新功能已经commit了，且push到了远程仓库"></a>新功能已经commit了，且<code>push</code>到了远程仓库</h2><p>第三种情况就是，我们已经把新开发的功能<code>push</code>到远程的仓库了，但是我们忽然发现新功能不应该在这个分支开发，我们这个时候应该怎么办呢？</p>
<p><strong>首先我们应该保持当前的工作区是没有修改的，是一个干净的状态。不然使用撤销命令的时候会提示你需要把当前的文件内容变更先提交或者生成快照</strong>。当我们的工作区的状态是干净的时候，我们就可以进行撤销操作了。</p>
<p>首先需要知道我们应该撤销那一次提交的状态。使用<code>git log --oneline</code>查看要撤销的提交的索引，然后运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p>这个时候命令运行的终端会进入编辑器模式，让你填写提交的信息。当然你也可以使用参数<code>--no-edit</code>这样就不会在进行撤销操作的时候打开编辑模式了。</p>
<p><strong>如果需要撤销的提交比较多的话，我们可以使用<code>..</code>表示一个提交记录的范围。比如<code>c1..c2</code>就表示<code>c2</code>的可达提交，且排除<code>c1</code>的可达提交</strong>。所谓<strong>可达的提交</strong>指的是：<strong>提交本身及其祖先链中提交的集合</strong>。</p>
<p>我们可以举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... a - b - c - d - HEAD</span><br></pre></td></tr></table></figure>

<p>如果上面表示的是某个分支的提交记录，那么对于<code>b..d</code>表示的就是<code>c d</code>这两个提交，对于<code>a..d</code>表示的就是<code>b c d</code>这三个提交。如果大家想了解更多相关的内容，可以在git-rev-list这里深入的学习一下。</p>
<p>所以我们如果想快速的撤销一段范围的提交的话，可以运行类似下面这样的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert 54dc134..a72d612 --no-edit</span><br></pre></td></tr></table></figure>

<p>上述命令的<code>54dc134</code>就表示<code>c1</code>，<code>a72d612</code>就表示<code>c2</code>，<code>--no-edit</code>表明我们在运行撤销操作的时候不打开编辑模式。</p>
<p><strong>我们如果需要对远程的分支进行撤销的话，首先考虑的就是使用<code>git revert</code>命令，因为<code>git revert</code>命令不会修改历史的提交记录，只是在原来的提交基础上添加新的提交，所以不会造成代码的丢失。在多人合作的情况下使用<code>git revert</code>命令撤销<code>push</code>到远程的操作还是很有必要的。</strong></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>错误分支</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoStart</title>
    <url>/2020/07/15/hexoStart/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fhexo.io%2Fzh-cn%2Fdocs%2Findex.html" target="_blank" rel="noopener">Hexo</a>框架，基于Node.js，搭建博客首先需要有一个GitHub账号并且配置了SSH Keys</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol>
<li><p>github仓库创建</p>
<a id="more"></a>

</li>
</ol>
<p>点击New repository创建，注意：仓库名称一定是<code>username.github.io</code>这种格式，username替换一个你喜欢的名字。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4120931-5b31c3ac628564b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/767/format/webp" alt="img"></p>
<ol start="2">
<li><p>Git安装（此处不多做说明，网上很多教程）</p>
<blockquote>
<p>验证：执行<code>git --version</code>如果输出类似<code>git version 2.15.0</code>说明安装成功了</p>
</blockquote>
</li>
<li><p>nodeJs安装（此处不多做说明，网上很多教程）</p>
<blockquote>
<p>验证：执行<code>npm --version</code>如果输出类似<code>5.5.1</code>说明安装成功了</p>
</blockquote>
</li>
<li><p>hexo安装</p>
</li>
</ol>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><ol>
<li><p>hexo文件夹创建</p>
<p>安装 Hexo 完成后，在你喜欢的目录下新建一个文件夹命名为<code>username</code>（替换成你喜欢的名字），然后cd到username文件夹下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd username</span><br><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>执行完毕后你将看到在你刚创建的文件夹下会有很多资源</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4120931-51990266dab56f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/220/format/webp" alt="img"></p>
<ol start="2">
<li><p>基础配置</p>
<p>接下来打开username下的<code>_config.yml</code>文件（上图中的第一个文件），修改一下里面几个关键的信息，修改完记得保存，注意：冒号后面要有空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: my_杨哥      &#x2F;&#x2F;你博客的名字</span><br><span class="line">author: Li Yang    &#x2F;&#x2F;你的名字</span><br><span class="line">language: zh-Hans  &#x2F;&#x2F;语言-简体中文</span><br></pre></td></tr></table></figure>

<p>上面这3个字段是关键信息，如需修改其他信息请参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fhexo.io%2Fzh-cn%2Fdocs%2Fconfiguration.html" target="_blank" rel="noopener">配置</a></p>
</li>
<li><p>主题安装</p>
<p>username下的<code>themes</code>文件夹中存放的是主题，默认的是landscape主题，如果你不喜欢可以安装其他主题。</p>
<p><strong>NexT</strong>主题是一套简约的主题，是目前使用最火的一个主题，下面我们安装一下该主题，你也可参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ftheme-next.iissnan.com%2Fgetting-started.html" target="_blank" rel="noopener">安装NexT</a>。</p>
<p>Hexo还有<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fhexo.io%2Fthemes%2F" target="_blank" rel="noopener">更多主题</a>供你选择</p>
</li>
</ol>
<ul>
<li><p>安装NexT主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd username        &#x2F;&#x2F;进入到username文件夹下</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用NexT主题：<br>打开username下的<code>_config.yml</code>文件（上图中的第一个文件），找到<code>theme</code>字段将其值更改为<code>next</code></p>
</li>
<li><p>验证主题：</p>
<p><em>注意：每次切换主题之后、验证主题之前都要清除 Hexo 的缓存</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean    &#x2F;&#x2F;清除缓存</span><br></pre></td></tr></table></figure>

<p>开始验证：启动Hexo本地服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>然后你将会看到终端输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000&#x2F;. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>这行的意思是说你用浏览器打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
<p>便可看到你的博客了，这只是本地的测试，如果测试没问题就执行Ctrl+C退出去，此时该地址就不能访问了。</p>
</li>
</ul>
<p>OK，现在，你已经成功安装并启用了 NexT 主题。接下来就是对该主题的一些设置，详细可参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ftheme-next.iissnan.com%2Fgetting-started.html%23theme-settings" target="_blank" rel="noopener">NexT主题设定</a></p>
<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><ol>
<li><p>文章新建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new layout title</span><br></pre></td></tr></table></figure>

<p>layout：模板，如果不写将使用默认模板，一般不写，直接<code>$ hexo new title</code></p>
<p>title：文章标题，如果标题包含空格的话，请使用引号括起来。</p>
<p>新建的文章将会存在<code>username/source/_posts</code>中，<code>_posts</code>就是默认模板，文章文件名称将会是<code>title.md</code>，接下来就可以打开该文件进行编辑写你的文章了。</p>
</li>
<li><p>静态文件生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地服务器启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>本地服务器启动完之后就如同上面验证主题一样，访问 <a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A4000" target="_blank" rel="noopener">http://localhost:4000</a> 来验证一下你写的文章预览效果。</p>
</li>
<li><p>网站部署</p>
<p>安装部署工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>安装完毕后打开username下的<code>_config.yml</code>文件，翻到最底部找到deploy节点编辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;YoungerLi&#x2F;youngerli.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>其中<code>https://github.com/YoungerLi/youngerli.github.io.git</code>就是你GitHub中创建的仓库地址，在这复制即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4120931-8525599433d095b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/442/format/webp" alt="img"></p>
<p>repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d        &#x2F;&#x2F;hexo deploy的缩写</span><br></pre></td></tr></table></figure>

<p>第一次执行这一步的时候会让你输入你的GitHub的用户名及密码，输入正确无误后执行完毕，任何人就可以访问 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fyoungerli.github.io" target="_blank" rel="noopener">https://youngerli.github.io</a> 进入你的博客了。</p>
<p>以后每次写完文章之后依次执行以下命令就可以发布更新了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean      &#x2F;&#x2F; 清除缓存</span><br><span class="line">$ hexo g          &#x2F;&#x2F; 生成静态网页文件</span><br><span class="line">$ hexo d          &#x2F;&#x2F; 将本地博客发布到github</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="hexo文章中插入图片"><a href="#hexo文章中插入图片" class="headerlink" title="hexo文章中插入图片"></a>hexo文章中插入图片</h3><p>安装图片插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190410220529100.png" alt="在这里插入图片描述"></p>
<p>在_config.yml配置文件中，修改为 post_asset_folder: true， 然后新建一篇文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post ceshi</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190410220540714.png" alt="在这里插入图片描述"></p>
<p>这个时候会出现一个ceshi.md 和 ceshi的文件夹</p>
<p>然后就可以在文章中引用了 <img src="https://img-blog.csdnimg.cn/20190410220553413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5OTY1NjU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>重新编译一下 然后启动服务</p>
<h3 id="博客备份和恢复"><a href="#博客备份和恢复" class="headerlink" title="博客备份和恢复"></a>博客备份和恢复</h3><h4 id="1-博客备份"><a href="#1-博客备份" class="headerlink" title="1. 博客备份"></a>1. 博客备份</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init &#x2F;&#x2F;git初始化</span><br><span class="line">$ git add . &#x2F;&#x2F;git 文件添加</span><br><span class="line">$ git commit -m &quot;init&quot; &#x2F;&#x2F;git 提交</span><br><span class="line">$ git pull origin hexo &#x2F;&#x2F;pull到hexo分支</span><br><span class="line">$ git push origin hexo &#x2F;&#x2F;push到hexo分支</span><br></pre></td></tr></table></figure>

<h4 id="2-博客恢复"><a href="#2-博客恢复" class="headerlink" title="2. 博客恢复"></a>2. 博客恢复</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（一）配置 ssh 连接 Github</span><br><span class="line">$ cd ~&#x2F;.ssh 或cd .ssh &#x2F;&#x2F;检查本机是否有ssh key设置</span><br><span class="line">$ cd ~  &#x2F;&#x2F;若没有 ssh ，则切换当前路径在 ”~” 下</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;user@example.com&quot; &#x2F;&#x2F;引号内为自己邮箱，三个回车后生成ssh key;添加id_rsa.pub内容到Github;</span><br><span class="line">$ git config --global user.name “your_username”  &#x2F;&#x2F;设置用户名</span><br><span class="line">$ git config --global user.email “your_registered_github_Email”  &#x2F;&#x2F;设置邮箱地址(建议用注册giuhub的邮箱)</span><br><span class="line">$ ssh -T git@github.com &#x2F;&#x2F;测试ssh key是否设置成功</span><br><span class="line">（二）安装 Node.js；Git；Hexo；</span><br><span class="line">$ git clone -b hexo git@github.com:user&#x2F;user.github.io.git  &#x2F;&#x2F;将Github中hexo分支clone到本地</span><br><span class="line">$ cd user.github.io &#x2F;&#x2F;切换到hexo目录下</span><br><span class="line">$ npm install hexo</span><br><span class="line">$ npm install </span><br><span class="line">$ npm install hexo *** &#x2F;&#x2F;安装需要的插件：feed;deployer;abbrlink;sitemap;pdf;nofollow;baidu-url-submit等</span><br><span class="line">$ hexo g -d &#x2F;&#x2F;测试能否正常编译上传</span><br></pre></td></tr></table></figure>

<h4 id="3-博主安装的插件："><a href="#3-博主安装的插件：" class="headerlink" title="3. 博主安装的插件："></a>3. 博主安装的插件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo-abbrlink &#x2F;&#x2F; Hexo 链接优化</span><br><span class="line">hexo-baidu-url-submit &#x2F;&#x2F; 百度链接主动提交</span><br><span class="line">hexo-blog-encrypt &#x2F;&#x2F; 博客文章加密</span><br><span class="line">hexo-autonofollow &#x2F;&#x2F; 出站链接优化</span><br><span class="line">hexo-deployer-git &#x2F;&#x2F; 上传部署</span><br><span class="line">hexo-generator-baidu-sitemap &#x2F;&#x2F;百度站点地图</span><br><span class="line">hexo-generator-feed &#x2F;&#x2F; RSS 插件</span><br><span class="line">hexo-generator-searchdb &#x2F;&#x2F; 站内搜索</span><br><span class="line">hexo-generator-sitemap &#x2F;&#x2F; 站点地图</span><br><span class="line">hexo-neat &#x2F;&#x2F; 博客压缩</span><br><span class="line">hexo-pdf &#x2F;&#x2F; 博客文章 PDF 显示</span><br><span class="line">hexo-wordcount &#x2F;&#x2F; 计数插件</span><br><span class="line">hexo-lazyload-image &#x2F;&#x2F;图片懒加载</span><br></pre></td></tr></table></figure>

<p>参考文档：<a href="https://www.jianshu.com/p/51617690f8ca" target="_blank" rel="noopener">hexo搭建</a></p>
<p>​           <a href="https://www.jianshu.com/p/74673c8bbc12" target="_blank" rel="noopener">hexo其他</a></p>
]]></content>
      <categories>
        <category>mysoft</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoTheme</title>
    <url>/2020/07/15/hexoTheme/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；</p>
<p>另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为<strong>站点配置文件</strong>， 后者称为<strong>主题配置文件</strong>。</p>
<p>备注: 以下所有终端执行的命令都在你的Hexo根目录下</p>
<h4 id="1、基本信息配置"><a href="#1、基本信息配置" class="headerlink" title="1、基本信息配置"></a>1、基本信息配置</h4><p>打开 <strong>站点配置文件</strong> ，找到Site模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>

<hr>
<a id="more"></a>

<h4 id="2、菜单设置"><a href="#2、菜单设置" class="headerlink" title="2、菜单设置"></a>2、菜单设置</h4><p>我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 <strong>主题配置文件</strong> 找到<code>Menu Settings</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home                          &#x2F;&#x2F;首页</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive          &#x2F;&#x2F;归档</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th           &#x2F;&#x2F;分类</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags                     &#x2F;&#x2F;标签</span><br><span class="line">  about: &#x2F;about&#x2F; || user                   &#x2F;&#x2F;关于</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar        &#x2F;&#x2F;日程表</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap        &#x2F;&#x2F;站点地图</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat          &#x2F;&#x2F;公益404</span><br></pre></td></tr></table></figure>

<p>备注：看看你需要哪个菜单就把哪个取消注释打开就行了；</p>
<p>关于后面的格式，以<code>archives: /archives/ || archive</code>为例：</p>
<p><code>||</code> 之前的<code>/archives/</code>表示标题“归档”，关于标题的格式可以去<code>themes/next/languages/zh-Hans.yml</code>中参考或修改</p>
<p><code>||</code>之后的<code>archive</code>表示图标，可以去<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ffontawesome.io%2Ficons%2F" target="_blank" rel="noopener">Font Awesome</a>中查看或修改，Next主题所有的图标都来自Font Awesome。</p>
<hr>
<h4 id="3、Next主题样式设置"><a href="#3、Next主题样式设置" class="headerlink" title="3、Next主题样式设置"></a>3、Next主题样式设置</h4><p>我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 <strong>主题配置文件</strong> 找到<code>Scheme Settings</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4、侧栏设置"><a href="#4、侧栏设置" class="headerlink" title="4、侧栏设置"></a>4、侧栏设置</h4><p>打开 <strong>主题配置文件</strong> 找到<code>sidebar</code>字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line"># Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  position: left        &#x2F;&#x2F;靠左放置</span><br><span class="line">  #position: right      &#x2F;&#x2F;靠右放置</span><br><span class="line"># Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效）</span><br><span class="line">  #display: post        &#x2F;&#x2F;默认行为，在文章页面（拥有目录列表）时显示</span><br><span class="line">  display: always       &#x2F;&#x2F;在所有页面中都显示</span><br><span class="line">  #display: hide        &#x2F;&#x2F;在所有页面中都隐藏（可以手动展开）</span><br><span class="line">  #display: remove      &#x2F;&#x2F;完全移除</span><br><span class="line">  offset: 12            &#x2F;&#x2F;文章间距（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  b2t: false            &#x2F;&#x2F;返回顶部按钮（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  scrollpercent: true   &#x2F;&#x2F;返回顶部按钮的百分比</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5、头像设置"><a href="#5、头像设置" class="headerlink" title="5、头像设置"></a>5、头像设置</h4><p>打开 <strong>主题配置文件</strong> 找到<code>Sidebar Avatar</code>字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar: &#x2F;images&#x2F;header.jpg</span><br></pre></td></tr></table></figure>

<p>这是头像的路径，只需把你的头像命名为<code>header.jpg</code>（随便命名）放入<code>themes/next/source/images</code>中，将<code>avatar</code>的路径名改成你的头像名就OK啦！</p>
<hr>
<h4 id="6、设置RSS"><a href="#6、设置RSS" class="headerlink" title="6、设置RSS"></a>6、设置RSS</h4><p>1、先安装 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fhexojs%2Fhexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>2、打开 <strong>站点配置文件</strong> 找到<code>Extensions</code>在下面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># RSS订阅</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: &#39; &#39;</span><br></pre></td></tr></table></figure>

<p>3、打开 <strong>主题配置文件</strong> 找到<code>rss</code>，设置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rss: &#x2F;atom.xml</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7、添加分类模块"><a href="#7、添加分类模块" class="headerlink" title="7、添加分类模块"></a>7、添加分类模块</h4><p>1、新建一个分类页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>categorcies/index.md</code>，打开<code>index.md</code>文件将title设置为<code>title: 分类</code><br>3、打开 <strong>主题配置文件</strong> 找到<code>menu</code>，将categorcies取消注释<br>4、把文章归入分类只需在文章的顶部标题下方添加<code>categories</code>字段，即可自动创建分类名并加入对应的分类中<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类测试文章标题</span><br><span class="line">categories: 分类名</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8、添加标签模块"><a href="#8、添加标签模块" class="headerlink" title="8、添加标签模块"></a>8、添加标签模块</h4><p>1、新建一个标签页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>tags/index.md</code>，打开<code>index.md</code>文件将title设置为<code>title: 标签</code><br>3、打开 <strong>主题配置文件</strong> 找到<code>menu</code>，将tags取消注释<br>4、把文章添加标签只需在文章的顶部标题下方添加<code>tags</code>字段，即可自动创建标签名并归入对应的标签中<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签测试文章标题</span><br><span class="line">tags: </span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9、添加关于模块"><a href="#9、添加关于模块" class="headerlink" title="9、添加关于模块"></a>9、添加关于模块</h4><p>1、新建一个关于页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>about/index.md</code>，打开<code>index.md</code>文件即可编辑关于你的信息，可以随便编辑。<br>3、打开 <strong>主题配置文件</strong> 找到<code>menu</code>，将about取消注释</p>
<hr>
<h4 id="10、添加搜索功能"><a href="#10、添加搜索功能" class="headerlink" title="10、添加搜索功能"></a>10、添加搜索功能</h4><p>1、安装 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflashlab%2Fhexo-generator-search" target="_blank" rel="noopener">hexo-generator-searchdb</a> 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>2、打开 <strong>站点配置文件</strong> 找到<code>Extensions</code>在下面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>3、打开 <strong>主题配置文件</strong> 找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code></p>
<hr>
<h4 id="11、添加阅读全文按钮"><a href="#11、添加阅读全文按钮" class="headerlink" title="11、添加阅读全文按钮"></a>11、添加阅读全文按钮</h4><p>因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>其后面的部分就不会显示了，只能点击阅读全文才能看</p>
<hr>
<h4 id="12、修改文章内链接文本样式"><a href="#12、修改文章内链接文本样式" class="headerlink" title="12、修改文章内链接文本样式"></a>12、修改文章内链接文本样式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4120931-9cd87c2cc2d0c78f.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/360/format/webp" alt="img"></p>
<p>效果图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;components&#x2F;post&#x2F;post.styl</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-body p a &#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p>
<hr>
<h4 id="13、设置网站缩略图标"><a href="#13、设置网站缩略图标" class="headerlink" title="13、设置网站缩略图标"></a>13、设置网站缩略图标</h4><blockquote>
<p>从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行。</p>
</blockquote>
<p>我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在<code>themes/next/source/images</code>里，然后打开 <strong>主题配置文件</strong> 找到<code>favicon</code>，将<code>small、medium、apple_touch_icon</code>三个字段的值都设置成<code>/images/图片名.jpg</code>就可以了，其他字段都注释掉。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4120931-61a0cc555a25548e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/344/format/webp" alt="img"></p>
<hr>
<h4 id="14、设置文章字体的颜色、大小"><a href="#14、设置文章字体的颜色、大小" class="headerlink" title="14、设置文章字体的颜色、大小"></a>14、设置文章字体的颜色、大小</h4><p><img src="http://upload-images.jianshu.io/upload_images/4120931-e471abbb2b1f459f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/477/format/webp" alt="img"></p>
<p>效果图</p>
<p>如果想设置某一句的颜色或大小，只需用html语法写出来就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接下来就是见证奇迹的时刻</span><br><span class="line">&lt;font color&#x3D;&quot;#FF0000&quot;&gt; 我可以设置这一句的颜色哈哈 &lt;&#x2F;font&gt; </span><br><span class="line">&lt;font size&#x3D;6&gt; 我还可以设置这一句的大小嘻嘻 &lt;&#x2F;font&gt; </span><br><span class="line">&lt;font size&#x3D;5 color&#x3D;&quot;#FF0000&quot;&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="15、设置文字居中"><a href="#15、设置文字居中" class="headerlink" title="15、设置文字居中"></a>15、设置文字居中</h4><p>设置方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;这一行需要居中&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：简书中此方法无效</p>
</blockquote>
<hr>
<h4 id="16、添加评论系统"><a href="#16、添加评论系统" class="headerlink" title="16、添加评论系统"></a>16、添加评论系统</h4>]]></content>
      <categories>
        <category>mysoft</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>introduction</title>
    <url>/2020/07/09/introduction/</url>
    <content><![CDATA[<h6 id><a href="#" class="headerlink" title></a></h6><h5 id="一个入门两年的小前端，日常总结和感悟，目的就是方便自己，方便他人。"><a href="#一个入门两年的小前端，日常总结和感悟，目的就是方便自己，方便他人。" class="headerlink" title="一个入门两年的小前端，日常总结和感悟，目的就是方便自己，方便他人。"></a>一个入门两年的小前端，日常总结和感悟，目的就是方便自己，方便他人。</h5><h5 id="这个博客将会记录我的前端生涯中，不管是鸡毛蒜皮，还是令人头秃的bug和自己记不住的知识点和方法。"><a href="#这个博客将会记录我的前端生涯中，不管是鸡毛蒜皮，还是令人头秃的bug和自己记不住的知识点和方法。" class="headerlink" title="这个博客将会记录我的前端生涯中，不管是鸡毛蒜皮，还是令人头秃的bug和自己记不住的知识点和方法。"></a>这个博客将会记录我的前端生涯中，不管是鸡毛蒜皮，还是令人头秃的bug和自己记不住的知识点和方法。</h5><h5 id="做一行，爱一行，菜鸟也会有飞起的那天，加油鸭！！！"><a href="#做一行，爱一行，菜鸟也会有飞起的那天，加油鸭！！！" class="headerlink" title="做一行，爱一行，菜鸟也会有飞起的那天，加油鸭！！！"></a>做一行，爱一行，菜鸟也会有飞起的那天，加油鸭！！！</h5>]]></content>
      <categories>
        <category>introduction</category>
      </categories>
      <tags>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令合集</title>
    <url>/2020/07/30/git%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq 保存提交信息</span><br><span class="line">q 退出</span><br><span class="line"></span><br><span class="line">git branch dali 创建分支</span><br><span class="line">git branch 或者git branch --list查看分支</span><br><span class="line">git branch -a 查看当前所在分支 </span><br><span class="line">git branch -r 查看远程分支</span><br><span class="line">git branch -m dali dali01 重命名成dali01</span><br><span class="line">git branch -d dali01 删除分支dali01</span><br><span class="line">git checkout dali 切换分支</span><br><span class="line"></span><br><span class="line">git push -u origin master 将本地推送到远程</span><br><span class="line">git clone https:&#x2F;&#x2F;git 新名字</span><br><span class="line">git fetch 提取远程代码</span><br><span class="line"></span><br><span class="line">git merge dali 将dali分支合到本地分支 </span><br><span class="line">git fast-forward 出现代表快速合并，本地没有任何提交，会直接合并</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;git 添加远程库</span><br><span class="line">git remote 查看远程库</span><br><span class="line">git remote -v更详细的远程库</span><br><span class="line"></span><br><span class="line">git 或者 git help --查看帮助</span><br><span class="line">git help -a --查看所有命令</span><br><span class="line">git help -g --查看所有手册</span><br><span class="line">git help add --加上命令或名称，查看详细内容 （F键向下，B键向上翻页，Q键退出）</span><br><span class="line"></span><br><span class="line">git config --global user.name &#39;dali&#39; 设置用户名</span><br><span class="line">git config --global user.email &#39;dali.com&#39;设置邮箱</span><br><span class="line">git config --List 查看用户信息</span><br><span class="line">git config --unset --global user.name 清空用户名</span><br><span class="line">git config color.ui true 设置颜色</span><br><span class="line">git config --global alias.co checkout 给checkout起一个co的别名</span><br><span class="line">cat &#96;&#x2F;.gitconfig 查看当前用户的配置</span><br><span class="line"></span><br><span class="line">git init 初始化git</span><br><span class="line">git status 查看分支什么的</span><br><span class="line"></span><br><span class="line">git add . 添加所有文件到暂存区</span><br><span class="line">git add &#39;index.html&#39; 添加具体文件到暂存区</span><br><span class="line">git commit -m &#39;新建index.html文件&#39;</span><br><span class="line">git commit -am &#39;省略add，直接commit&#39;</span><br><span class="line"></span><br><span class="line">git diff 查看前后对比</span><br><span class="line">git diff --staged 查看暂存区和git上的区别</span><br><span class="line"></span><br><span class="line">git mv style.css  theme.css   将style重命名成theme</span><br><span class="line">git mv theme.css css&#x2F;    将theme.css移动到css文件夹下</span><br><span class="line">git mv css asset&#x2F;    将css移动到asset文件夹下</span><br><span class="line"></span><br><span class="line">git rm theme.css 删除theme.css文件</span><br><span class="line">git rm theme.css style.css文件（多个文件以空格分离）</span><br><span class="line">git rm -r 我的文件夹&#x2F; （删除目录以及所有内容 加上 -r  和目录的名称 表示递归）</span><br><span class="line"></span><br><span class="line">git checkout HEAD  -- index.html 恢复上一次修改</span><br><span class="line">git checkout HEAD^  -- index.html 恢复上一次提交</span><br><span class="line">git revert (提交id) --撤销某一次提交</span><br><span class="line"></span><br><span class="line">其中HEAD代表版本库，index代表暂存区，另外还有一个我们增删改代码的工作区。</span><br><span class="line">--hard : 回退版本库，暂存区，工作区。（因此我们修改过的代码就没了，需要谨慎使用）</span><br><span class="line">--mixed: 回退版本库，暂存区。(--mixed为git reset的默认参数，即当任何参数都不加的时候的参数)</span><br><span class="line">--soft: 回退版本库。</span><br><span class="line">只commit 没有push</span><br><span class="line">git reset --soft （提交id）--撤销commit，工作区代码本地更改留存</span><br><span class="line">git reset --hard（提交id）--慎用 撤销commit，工作区代码本地更改不留存</span><br><span class="line">git reset --mixed（提交id）--版本库和暂存区都将进行了代码回退，工作区代码没动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git diff master..dali 查看两个分支的不同</span><br><span class="line">git diff master..dali index.html 具体文件的不同</span><br><span class="line"></span><br><span class="line">abort 放弃合并</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt; HEAD和&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;之间是本地的代码</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 和&gt;&gt;&gt;&gt;&gt;之间是远程的代码</span><br><span class="line"></span><br><span class="line">git log --oneline --decorate --all -10 --graph --atuhor&#x3D;&#39;dali&#39;  --grep&#x3D;&#39;index.html&#39; --before&#x3D;’2020-20-02‘ </span><br><span class="line">--before&#x3D;&#39;1 week&#39; --before&#x3D;&#39;3 days&#39; 提交日志</span><br><span class="line"> --oneline一行显示</span><br><span class="line"> decorate 查看具体分支</span><br><span class="line"> --all -10前十条</span><br><span class="line"> --graph 图形化</span><br><span class="line"> --atuhor作者</span><br><span class="line"> --grep包含 </span><br><span class="line">--before某个日期之前的，一周内，三天内的提交 </span><br><span class="line"></span><br><span class="line">stash 保存修改&#x2F;工作进度</span><br><span class="line">git stash save &#39;增加一条工作进度&#39;</span><br><span class="line">git stash list 保存工作进度的列表</span><br><span class="line">git stash apply stash@&#123;0&#125;恢复工作进度</span><br><span class="line">git stash drop stash@&#123;0&#125;删除工作进度</span><br><span class="line">git stash show -p stash@&#123;0&#125;显示区别（-p是指 以patch form的的方式展示diff）</span><br></pre></td></tr></table></figure>

<p>补充链接 <a href="https://mp.weixin.qq.com/s/-DjGBDi7HQfVpGNY8sOCmw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-DjGBDi7HQfVpGNY8sOCmw</a></p>
<p>​                <a href="https://mp.weixin.qq.com/s/4vfifX-UkhrfpZjHycthOA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4vfifX-UkhrfpZjHycthOA</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo图片的那些事</title>
    <url>/2020/09/08/hexo%E5%9B%BE%E7%89%87%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="截图图片保存"><a href="#截图图片保存" class="headerlink" title="截图图片保存"></a>截图图片保存</h3><p>1、图片会莫名的丢失（文件的位置变了或者图片不见了）</p>
<p>2、在使用QQ或者各种截图工具，需要先保存到本地，然后在粘贴过来(截图工具默认图片是保存在缓存里的)</p>
<p>  为了解决这个问题，上网找了很多方法，个人比较喜欢的一种解决方式，现记录下来，一来做个记录；二来希望能够帮助和我一样碰到这个问题的朋友。</p>
<a id="more"></a>

<ul>
<li>第一步：文件—&gt;偏好设置（preference）<br><img src="https://img-blog.csdnimg.cn/20200419191321606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM0Mjg0MQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>第二步：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200419191338972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM0Mjg0MQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p> 经过上面设置以后：</p>
<p>1、文档中图片的地址：使用相对</p>
<p>2、在粘贴图片的时候，会自动在文档的当前目录下生成一个“文件名.assets”文件夹，里面会复制一份要粘贴的图片</p>
<p>assets文件夹，里面会复制一份要粘贴的图片</p>
<p>3、在移动或复制文件的时候，连同assets一起复制，这样就不会出现图片显现不出来的问题。</p>
<h3 id="图片转成https"><a href="#图片转成https" class="headerlink" title="图片转成https"></a>图片转成https</h3><p>在线生成图片路径</p>
<p><a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p>
<h3 id="文章添加视频和-gif"><a href="#文章添加视频和-gif" class="headerlink" title="文章添加视频和 gif"></a>文章添加视频和 gif</h3><p>添加视频代码:(长宽可以自己定义)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">100</span> <span class="attr">width</span>=<span class="string">100</span> <span class="attr">src</span>=<span class="string">"视频地址"</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>添加 gif 代码:(长宽可以自己定义)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">100</span> <span class="attr">width</span>=<span class="string">100</span> <span class="attr">src</span>=<span class="string">"gif 图片地址"</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>mysoft</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ipAndDNS</title>
    <url>/2020/07/22/ipAndDNS/</url>
    <content><![CDATA[<h3 id="怎么查找ip地址"><a href="#怎么查找ip地址" class="headerlink" title="怎么查找ip地址"></a>怎么查找ip地址</h3><p>方式一  电脑输入cmd，再输入ipconfig</p>
<p>方式二  本地连接的网络–属性–IPv4 地址 </p>
<a id="more"></a>

<h3 id="设置自动获取DNS服务器地址"><a href="#设置自动获取DNS服务器地址" class="headerlink" title="设置自动获取DNS服务器地址"></a>设置自动获取DNS服务器地址</h3><p>![clipboard (20)](ipAndDNS.assets/clipboard (20).png)</p>
<p>![clipboard (21)](ipAndDNS.assets/clipboard (21).png)</p>
<p>![clipboard (22)](ipAndDNS.assets/clipboard (22).png)</p>
<p>![clipboard (23)](ipAndDNS.assets/clipboard (23).png)</p>
<p>![clipboard (24)](ipAndDNS.assets/clipboard (24).png)</p>
]]></content>
      <categories>
        <category>ip</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>google</title>
    <url>/2020/07/22/google/</url>
    <content><![CDATA[<h3 id="你不知道的隐藏快捷方式"><a href="#你不知道的隐藏快捷方式" class="headerlink" title="你不知道的隐藏快捷方式"></a>你不知道的隐藏快捷方式</h3><h4 id="曾经，在线调伪类样式困扰过你？"><a href="#曾经，在线调伪类样式困扰过你？" class="headerlink" title="曾经，在线调伪类样式困扰过你？"></a>曾经，在线调伪类样式困扰过你？</h4><p><img src="/2020/07/22/google/640.webp" alt="640"></p>
<a id="more"></a>

<h4 id="2-源代码快速定位到某一行！ctrl-p"><a href="#2-源代码快速定位到某一行！ctrl-p" class="headerlink" title="2.源代码快速定位到某一行！ctrl + p"></a>2.源代码快速定位到某一行！ctrl + p</h4><p><img src="/2020/07/22/google/640-1600053258638.gif" alt="640"></p>
<h4 id="3-联调接口失败时，后台老哥总管你要response？"><a href="#3-联调接口失败时，后台老哥总管你要response？" class="headerlink" title="3.联调接口失败时，后台老哥总管你要response？"></a>3.联调接口失败时，后台老哥总管你要response？</h4><p>![640 (1)](google.assets/640 (1).gif)</p>
<h4 id="4-你还一层层展开dom？Alt-Click"><a href="#4-你还一层层展开dom？Alt-Click" class="headerlink" title="4.你还一层层展开dom？Alt + Click"></a>4.你还一层层展开dom？Alt + Click</h4><p>![640 (2)](google.assets/640 (2).gif)</p>
<h4 id="5-是不是报错了，你才去打断点？"><a href="#5-是不是报错了，你才去打断点？" class="headerlink" title="5.是不是报错了，你才去打断点？"></a>5.是不是报错了，你才去打断点？</h4><p>![640 (3)](google.assets/640 (3).gif)</p>
<h4 id="6-你是不是经常想不起来，在哪绑定事件的？"><a href="#6-你是不是经常想不起来，在哪绑定事件的？" class="headerlink" title="6.你是不是经常想不起来，在哪绑定事件的？"></a>6.你是不是经常想不起来，在哪绑定事件的？</h4><p>![640 (4)](google.assets/640 (4).gif)</p>
<h4 id="7-你是不是打断点时还要去改代码？"><a href="#7-你是不是打断点时还要去改代码？" class="headerlink" title="7.你是不是打断点时还要去改代码？"></a>7.你是不是打断点时还要去改代码？</h4><p>![640 (5)](google.assets/640 (5).gif)</p>
<h4 id="8-看dom层级的最直观的方式？"><a href="#8-看dom层级的最直观的方式？" class="headerlink" title="8.看dom层级的最直观的方式？"></a>8.看dom层级的最直观的方式？</h4><p>![640 (6)](google.assets/640 (6).gif)</p>
<h4 id="9-查一些特定的请求，过滤器Filter用过吗？"><a href="#9-查一些特定的请求，过滤器Filter用过吗？" class="headerlink" title="9.查一些特定的请求，过滤器Filter用过吗？"></a>9.查一些特定的请求，过滤器Filter用过吗？</h4><p>![640 (7)](google.assets/640 (7).gif)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">domain：资源所在的域，即url中的域名部分。如 domain:api.github.com</span><br><span class="line"></span><br><span class="line">has-response-header：资源是否存在响应头，无论其值是什么。如 has-response-header：Access-Control-Allow-Origin</span><br><span class="line"></span><br><span class="line">is：当前时间点在执行的请求。当前可用值：running</span><br><span class="line"></span><br><span class="line">larger-than：显示大于指定值大小规格的资源。单位是字节(B),但是K(kB)和M(MB)也是可以的~ 如larger-than:150K</span><br><span class="line"></span><br><span class="line">method：使用何种HTTP请求方式。如 GET</span><br><span class="line"></span><br><span class="line">mime-type：也写作content-type，是资源类型的标识符。如 text&#x2F;html</span><br><span class="line"></span><br><span class="line">scheme：协议规定。如 HTTPS</span><br><span class="line"></span><br><span class="line">set-cookie-name：服务器设置的cookies名称</span><br><span class="line"></span><br><span class="line">set-cookie-value：服务器设置的cookies的值</span><br><span class="line"></span><br><span class="line">set-cookie-domain：服务器设置的cookies的域</span><br><span class="line"></span><br><span class="line">status-code：HTTP响应头的状态码</span><br></pre></td></tr></table></figure>



<h4 id="10-在Elements面板调整dom结构很不方便？"><a href="#10-在Elements面板调整dom结构很不方便？" class="headerlink" title="10.在Elements面板调整dom结构很不方便？"></a>10.在Elements面板调整dom结构很不方便？</h4><p>![640 (8)](google.assets/640 (8).gif)</p>
<h4 id="11-想知道，某图片加载的代码在哪？Initiator！！"><a href="#11-想知道，某图片加载的代码在哪？Initiator！！" class="headerlink" title="11.想知道，某图片加载的代码在哪？Initiator！！"></a>11.想知道，某图片加载的代码在哪？Initiator！！</h4><p>![640 (1)](google.assets/640 (1).webp)</p>
<p>![640 (2)](google.assets/640 (2).webp)</p>
<p>![640 (3)](google.assets/640 (3)-1600053530223.webp)</p>
<h4 id="12-不想加载某个文件了？"><a href="#12-不想加载某个文件了？" class="headerlink" title="12.不想加载某个文件了？"></a>12.不想加载某个文件了？</h4><p>![640 (4)](google.assets/640 (4).webp)</p>
<p>![640 (5)](google.assets/640 (5).webp)</p>
<h4 id="13-手动改定位信息"><a href="#13-手动改定位信息" class="headerlink" title="13.手动改定位信息"></a>13.手动改定位信息</h4><p>Chrome中模拟定位信息，清除定位信息</p>
<p>chrome  F12进入调试模式后，点击右上角的 三个点的标志，如下图</p>
<p><img src="/2020/07/22/google/image-20200914112312655.png" alt="image-20200914112312655"></p>
<p>将其Geolocation中的下拉更改为Custom Location（或者直接选择other），在下方填入经纬度信息即可模拟当前位置；</p>
<p>如果要清除位置信息，需将Geolocation修改为No override，并且关闭浏览器，重启启动后才会生效，</p>
<p>切记重启浏览器，否则你可以在调试时看到你传入的经纬度信息依旧是你之前设置的数据，</p>
<p>如果再没有生效，可将浏览器数据清除重试</p>
<h4 id="14-浏览器复制console-log打印的对象"><a href="#14-浏览器复制console-log打印的对象" class="headerlink" title="14. 浏览器复制console.log打印的对象"></a>14. 浏览器复制console.log打印的对象</h4><p>找到想要复制的对象右键 <strong>store as global variable</strong><br><img src="https://img-blog.csdnimg.cn/20190516212308883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUxOTEzNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在弹出的console中copy temp1</p>
<p>ctrl+v出来咯~</p>
<p><img src="https://img-blog.csdnimg.cn/20190516212358116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUxOTEzNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="15-插件"><a href="#15-插件" class="headerlink" title="15.插件"></a>15.插件</h4><blockquote>
<p>json-handle</p>
<p>postwoman</p>
</blockquote>
<h4 id="16-清空控制台"><a href="#16-清空控制台" class="headerlink" title="16.清空控制台"></a>16.清空控制台</h4><p> console.clear</p>
<h4 id="17-t参数支持换行"><a href="#17-t参数支持换行" class="headerlink" title="17.\t参数支持换行"></a>17.\t参数支持换行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(JSON.stringify(&#123; alpha: &#39;A&#39;, beta: &#39;B&#39; &#125;, null, &#39;\t&#39;));</span><br><span class="line">&#x2F;&#x2F; Result:</span><br><span class="line">&#x2F;&#x2F; &#39;&#123;&#x2F;&#x2F;     &quot;alpha&quot;: A,</span><br><span class="line">&#x2F;&#x2F;     &quot;beta&quot;: B</span><br><span class="line">&#x2F;&#x2F; &#125;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="18-追加："><a href="#18-追加：" class="headerlink" title="18.追加："></a>18.追加：</h4><p>8个Chrome面板内容</p>
<p><a href="https://mp.weixin.qq.com/s/-1jf4c7bYhbn-zKVr74hrw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-1jf4c7bYhbn-zKVr74hrw</a></p>
<p>最详细的解释</p>
<p><a href="https://blog.csdn.net/weixin_40876986/article/details/89703977" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40876986/article/details/89703977</a></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp及gulpfile.js</title>
    <url>/2020/07/30/gulp%E5%8F%8Agulpfile-js/</url>
    <content><![CDATA[<h3 id="一、什么是gulp"><a href="#一、什么是gulp" class="headerlink" title="一、什么是gulp"></a>一、什么是gulp</h3><p>简单来说：就是压缩前端代码，实现浏览器自动刷新的工具。</p>
<p>完整地说：gulp是一个前端的自动化构建工具，是基于Node.js的自动化任务运行期，能自动化完成javascript/sass/less/html/image/css等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成、并监听文件在改动后重复指定（在gulpfile.js中指定）的这些步骤。</p>
<a id="more"></a>

<h3 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h3><p><strong>1、全局安装</strong></p>
<p><strong>（1）安装NodeJS环境：（这里直接使用淘宝镜像）</strong></p>
<p>在cmd中输入：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<p>然后就开始下载安装，如下图:</p>
<p><img src="https://img-blog.csdn.net/20180820093107903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1hoaXVfaHVhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>（2）全局安装gulp：</strong></p>
<p>上一步安装结束后，再在cmd下接着输入（这里cnpm也可换成npm，cnpm是在淘宝镜像下载，npm是在国外官网下载，实际上两者相同，这里就看心情选择吧^^）：cnpm install gulp -g</p>
<p><img src="https://img-blog.csdn.net/20180820093141838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1hoaXVfaHVhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>2、局部安装：</strong></p>
<p><strong>（1）在项目中生成package.json文件：</strong></p>
<p>全局安装完成后，开始局部安装。首先，选择一个文件夹，这个文件夹就是你项目的最外层文件夹，在这个文件夹下打开cmd（比如我自己来说，有一个项目名为a，那我就在a下的文件夹里边打开cmd）。</p>
<p><img src="https://img-blog.csdn.net/20180820093609888?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1hoaXVfaHVhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p> 在上图所示的cmd中输入：cnpm init -y，等待下载安装</p>
<p><strong>（2）在项目本地安装gulp：</strong></p>
<p>上一步安装完成后，接着输入：cnpm install gulp –sava-dev</p>
<p><strong>（3）安装gulp插件：</strong></p>
<p><strong>插件介绍：</strong>gulp-clean-css（压缩css的插件）、gulp-htmlmin（压缩html的插件）、gulp-uglify（压缩js）、gulp-babel（将es6转换成es5）、gulp-rename（重命名）、gulp-connect（部署静态资源，实现自动刷新）。。。还有很多，可在<a href="https://www.npmjs.com/package中搜索插件" target="_blank" rel="noopener">https://www.npmjs.com/package中搜索插件</a></p>
<p><strong>安装插件：</strong>（2）下载安装完成后，继续输入：cnpm i 插件名 -D）（比如：cnpm i gulp-clean-css -D），等待下载安装</p>
<p><strong>（4）在项目根目录下，创建gulpfile.js，在里面书写代码，用于操控插件：</strong>书写内容详情见 三 。</p>
<p><strong>（5）执行任务：</strong>（3）安装完成并（4）中的gulpfile.js编写完成后，接着在cmd中输入：gulp 任务名称</p>
<h3 id="三、gulpfile-js编写："><a href="#三、gulpfile-js编写：" class="headerlink" title="三、gulpfile.js编写："></a>三、gulpfile.js编写：</h3><blockquote>
<p>//定义变量，引入gulp及各个插件</p>
<p>const gulp = require(“gulp”),<br>​    sass = require(“gulp-sass”),<br>​    connect = require(“gulp-connect”),<br>​    uglify = require(“gulp-uglify”),<br>​    babel = require(“gulp-babel”),<br>​    htmlmin = require(“gulp-htmlmin”);</p>
<p>// 编译SCSS文件<br>gulp.task(“sass”, function() {<br>​    gulp.src(“./src/scss/<em>.scss”)<br>​        .pipe(sass({outputStyle:”compressed”}))<br>​        .pipe(gulp.dest(“./src/css”))<br>​        .pipe(connect.reload());<br>});<br>// html文件修改刷新<br>gulp.task(“html”, function() {<br>​    gulp.src(“./src/**/</em>.html”)<br>​        .pipe(connect.reload());<br>});<br>// js文件修改刷新<br>gulp.task(“js”, function() {<br>​    gulp.src(“./src/js/<em>.js”)<br>​        .pipe(connect.reload());<br>});<br>// 启动服务器<br>gulp.task(“connect”, function() {<br>​    connect.server({<br>​        root : “src”,<br>​        livereload : true<br>​    });<br>});<br>// 监视任务<br>gulp.task(“watch”, function(){<br>​    gulp.watch(“./src/**/</em>.html”, [“html”]);<br>​    gulp.watch(“./src/js/<em>.js”, [“js”]);<br>​    gulp.watch(“./src/scss/</em>.scss”, [“sass”]);<br>});<br>// 开发环境下的gulp任务<br>gulp.task(“dev”, [“sass”, “html”, “js”, “connect”, “watch”]);</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>// 生产环境下的 gulp 任务，将项目生成到 dist 目录下<br>// dist 目录下的资源是直接用于生产环境（发布项目）的资源<br>// 编译SCSS文件：生产环境<br>gulp.task(“prod_sass”, function() {<br>​    gulp.src(“./src/scss/<em>.scss”)<br>​        .pipe(sass({outputStyle:”compressed”}))<br>​        .pipe(gulp.dest(“./dist/css”))<br>​        .pipe(connect.reload());<br>});<br>// html文件压缩<br>gulp.task(“prod_html”, function() {<br>​    gulp.src(“./src/**/</em>.html”)<br>​        .pipe(htmlmin({collapseWhitespace: true}))<br>​        .pipe(gulp.dest(“./dist”))<br>​        .pipe(connect.reload());<br>});<br>// JS转换及压缩<br>gulp.task(“prod_js”, function() {<br>​    gulp.src(“./src/js/<em>.js”)<br>​        .pipe(babel({<br>​            presets: [‘env’]<br>​        }))<br>​        .pipe(uglify())<br>​        .pipe(gulp.dest(“./dist/js”))<br>​        .pipe(connect.reload());<br>});<br>// 复制源文件夹下资源到目标文件夹<br>gulp.task(“copy-images”, function() {<br>​    gulp.src(“./src/images/**/</em>.*”)<br>​        .pipe(gulp.dest(“./dist/images”));<br>});<br>gulp.task(“copy-lib”, function() {<br>​    gulp.src(“./src/lib/<strong>/<em>.</em>“)<br>​        .pipe(gulp.dest(“./dist/lib”));<br>});<br>gulp.task(“prod_copy”, [“copy-images”, “copy-lib”]);<br>// 监视任务<br>gulp.task(“prod_watch”, function(){<br>​    gulp.watch(“./src/</strong>/<em>.html”, [“prod_html”]);<br>​    gulp.watch(“./src/js/</em>.js”, [“prod_js”]);<br>​    gulp.watch(“./src/scss/*.scss”, [“prod_sass”]);<br>});<br>// 启动服务器<br>gulp.task(“prod_connect”, function() {<br>​    connect.server({<br>​        root : “dist”,<br>​        livereload : true<br>​    });<br>});<br>// 生产环境gulp任务<br>gulp.task(“production”, [“prod_sass”, “prod_html”, “prod_js”, “prod_copy”, “prod_connect”, “prod_watch”]);</p>
</blockquote>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>前端自动化压缩</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jsbridge</title>
    <url>/2020/07/22/jsbridge/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>h5 与原生 app 的交互，本质上说，就是两种调用：</p>
<ol>
<li>app 调用 h5 的代码</li>
<li>h5 调用 app 的代码</li>
</ol>
<a id="more"></a>

<p><strong>1. app 调用 h5 的代码</strong></p>
<p>因为 app 是宿主，可以直接访问 h5，所以这种调用比较简单，就是在 h5 中曝露一些全局对象（包括方法），然后在原生 app 中调用这些对</p>
<p><img src="https://img2018.cnblogs.com/blog/1661048/201908/1661048-20190805104711293-168785251.jpg" alt="img"></p>
<p><strong>javascript</strong></p>
<p><code>window.sdk = {</code></p>
<p><code>``double = value =&gt; value * 2,</code></p>
<p><code>``triple = value =&gt; value * 3,</code></p>
<p><code>};</code></p>
<p><strong>android：</strong></p>
<p><code>webview.evaluateJavascript(``&#39;window.sdk.double(10)&#39;``, ``new</code> <code>ValueCallback&lt;String&gt;() {</code></p>
<p><code>``@Override</code></p>
<p><code>``public</code> <code>void onReceiveValue(String s) {</code></p>
<p><code>``// 20</code></p>
<p><code>``}</code></p>
<p><code>});</code></p>
<p><strong>ios：</strong></p>
<p><code>NSString *func = @``&quot;window.sdk.double(10)&quot;``;</code></p>
<p><code>NSString *str = [webview stringByEvaluatingJavaScriptFromString:func]; ``// 20</code></p>
<p><strong>2. h5 调用 app 的代码</strong></p>
<p>因为 h5 不能直接访问宿主 app，所以这种调用就相对复杂一点。</p>
<p>这种调用常用有两种方式：</p>
<ol>
<li>由app向h5注入一个全局js对象，然后在h5直接访问这个对象</li>
<li>由h5发起一个自定义协议请求，app拦截这个请求后，再由app调用 h5 中的回调函数</li>
</ol>
<p><strong>2.1 由 app 向 h5 注入一个全局 js 对象</strong></p>
<p>这种方式沟通机制简单，比较好理解，并且对于 h5 来说，没有新的东西，所以是比较推荐的一种方式。但这种方式可能存在安全隐患，详细查看 你不知道的 Android WebView 使用漏洞。</p>
<p><img src="https://img2018.cnblogs.com/blog/1661048/201908/1661048-20190805105140875-2098346635.jpg" alt="img"></p>
<p><strong>android</strong></p>
<p><code>webview.addJavascriptInterface(``new</code> <code>Object() {</code></p>
<p><code>``@JavascriptInterface</code></p>
<p><code>``public</code> <code>int double(value) {</code></p>
<p><code>``return</code> <code>value * 2;</code></p>
<p><code>``}</code></p>
<p><code></code> </p>
<p><code>``@JavascriptInterface</code></p>
<p><code>``public</code> <code>int triple(value) {</code></p>
<p><code>``return</code> <code>value * 3;</code></p>
<p><code>``}</code></p>
<p><code>}, ``&quot;appSdk&quot;``);</code></p>
<hr>
<p><strong>ios</strong></p>
<p><code>NSString *scripts = @``&quot;window.appSdk = {double: value =&gt; value * 2, triple: value =&gt; value * 3}&quot;``;</code></p>
<p><code>[webview stringByEvaluatingJavaScriptFromString:scripts];</code></p>
<p><strong>javascript</strong></p>
<p><strong>window.appSdk.double(10); // 20</strong></p>
<hr>
<h3 id="JS-Bridge"><a href="#JS-Bridge" class="headerlink" title="JS Bridge"></a>JS Bridge</h3><h4 id="什么是JS-Bridge"><a href="#什么是JS-Bridge" class="headerlink" title="什么是JS Bridge"></a>什么是JS Bridge</h4><p>在移动开发中为了加快开发进度(0.0)很多页面会用H5来开发，这样一来可以快速完成节约，二来APP内嵌WebView可以较少APP更新频率。因此，成本现在大多数公司的首选，但是部分功能JavaScript的权限受到严格限制，比如拍照，读写权限，获取GPS等等，这些native功能，这时候我们需要去委托原生去实现，原生实现后再告知js。这个时候就需要一个中间桥梁，于是就有了<strong>WebViewJavascriptBridge</strong>，简称 <strong>JS bridge</strong>。</p>
<h4 id="重点叙述在vue中如何调用"><a href="#重点叙述在vue中如何调用" class="headerlink" title="重点叙述在vue中如何调用"></a>重点叙述在vue中如何调用</h4><ul>
<li>创建 src/config/bridge.js 文件，用于封装 WebViewJavascriptBridge</li>
<li>将以下代码拷贝到 bridge.js 文件中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line"><span class="built_in">window</span>.isAndroid = u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>; <span class="comment">//android终端 </span></span><br><span class="line"><span class="built_in">window</span>.isIOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(WebViewJavascriptBridge);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">'WebViewJavascriptBridgeReady'</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(WebViewJavascriptBridge)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.isIOS) &#123;</span><br><span class="line">    <span class="comment">// old ios method</span></span><br><span class="line">    <span class="comment">//setTimeout(function () &#123;</span></span><br><span class="line">    <span class="comment">//    if (window.WVJBCallbacks) &#123;</span></span><br><span class="line">    <span class="comment">//        return window.WVJBCallbacks.push(callback);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//&#125;, 500)</span></span><br><span class="line">    <span class="comment">//window.WVJBCallbacks = [callback];</span></span><br><span class="line">    <span class="comment">//var WVJBIframe = document.createElement('iframe');</span></span><br><span class="line">    <span class="comment">//WVJBIframe.style.display = 'none';</span></span><br><span class="line">    <span class="comment">//WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__';</span></span><br><span class="line">    <span class="comment">//document.documentElement.appendChild(WVJBIframe);</span></span><br><span class="line">    <span class="comment">//setTimeout(function () &#123;</span></span><br><span class="line">    <span class="comment">//    document.documentElement.removeChild(WVJBIframe)</span></span><br><span class="line">    <span class="comment">//&#125;, 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// new ios method</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WKWebViewJavascriptBridge) &#123; <span class="keyword">return</span> callback(WKWebViewJavascriptBridge); &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WKWVJBCallbacks) &#123; <span class="keyword">return</span> <span class="built_in">window</span>.WKWVJBCallbacks.push(callback); &#125;</span><br><span class="line">    <span class="built_in">window</span>.WKWVJBCallbacks = [callback];</span><br><span class="line">    <span class="built_in">window</span>.webkit.messageHandlers.iOS_Native_InjectJavascript.postMessage(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.isIOS) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.init(<span class="function"><span class="keyword">function</span> (<span class="params">message, responseCallback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">        responseCallback(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  callhandler(name, data, callback) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.callHandler(name, data, callback)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  registerhandler(name, callback) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.registerHandler(name, <span class="function"><span class="keyword">function</span> (<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">        callback(data, responseCallback)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 main.js 中引入该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Bridge from &#39;.&#x2F;config&#x2F;bridge.js&#39;</span><br><span class="line">Vue.prototype.$bridge &#x3D; Bridge</span><br></pre></td></tr></table></figure>

<p>在需要调用客户端方法的组件中（ObjC Echo是VUE端调用APP端的方法名）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; params是向app端传的参数</span><br><span class="line">&#x2F;&#x2F; iOS端</span><br><span class="line">this.$bridge.callhandler(&#39;ObjC Echo&#39;, params, (data) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理返回数据</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Android端</span><br><span class="line">JSAndroid.requestPaySupportWithPayWay(params);</span><br></pre></td></tr></table></figure>

<p>当app端需要调用 js 函数时,在mounted钩子中事先注册约定好的函数即可（JS Echo是APP端调用VUE端方法名称，博主没用过）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; iOS端</span><br><span class="line">this.$bridge.registerhandler(&#39;JS Echo&#39;, (data, responseCallback) &#x3D;&gt; &#123;</span><br><span class="line">  alert(&#39;JS Echo called with:&#39;, data)</span><br><span class="line">  responseCallback(data)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Android端</span><br><span class="line">window[&#39;JS Echo&#39;] &#x3D; (data, responseCallback) &#x3D;&gt; &#123;</span><br><span class="line">   alert(&#39;JS Echo called with:&#39;, data)</span><br><span class="line">   responseCallback(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="html中如何使用封装"><a href="#html中如何使用封装" class="headerlink" title="html中如何使用封装"></a>html中如何使用封装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var u &#x3D; navigator.userAgent;</span><br><span class="line">window.isAndroid &#x3D; u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Adr&#39;) &gt; -1; &#x2F;&#x2F;android终端 </span><br><span class="line">window.isIOS &#x3D; !!u.match(&#x2F;\(i[^;]+;( U;)? CPU.+Mac OS X&#x2F;); &#x2F;&#x2F;ios终端 </span><br><span class="line">window.jsbridge &#x3D; function (callback) &#123;</span><br><span class="line">    if (window.WebViewJavascriptBridge) &#123;</span><br><span class="line">        return callback(WebViewJavascriptBridge);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        document.addEventListener(</span><br><span class="line">            &#39;WebViewJavascriptBridgeReady&#39;,</span><br><span class="line">            function () &#123;</span><br><span class="line">                callback(WebViewJavascriptBridge)</span><br><span class="line">            &#125;,</span><br><span class="line">            false</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    if (window.isIOS) &#123;</span><br><span class="line">        &#x2F;&#x2F; old ios method</span><br><span class="line">        &#x2F;&#x2F;setTimeout(function () &#123;</span><br><span class="line">        &#x2F;&#x2F;    if (window.WVJBCallbacks) &#123;</span><br><span class="line">        &#x2F;&#x2F;        return window.WVJBCallbacks.push(callback);</span><br><span class="line">        &#x2F;&#x2F;    &#125;</span><br><span class="line">        &#x2F;&#x2F;&#125;, 500)</span><br><span class="line">        &#x2F;&#x2F;window.WVJBCallbacks &#x3D; [callback];</span><br><span class="line">        &#x2F;&#x2F;var WVJBIframe &#x3D; document.createElement(&#39;iframe&#39;);</span><br><span class="line">        &#x2F;&#x2F;WVJBIframe.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">        &#x2F;&#x2F;WVJBIframe.src &#x3D; &#39;wvjbscheme:&#x2F;&#x2F;__BRIDGE_LOADED__&#39;;</span><br><span class="line">        &#x2F;&#x2F;document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">        &#x2F;&#x2F;setTimeout(function () &#123;</span><br><span class="line">        &#x2F;&#x2F;    document.documentElement.removeChild(WVJBIframe)</span><br><span class="line">        &#x2F;&#x2F;&#125;, 0)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; new ios method</span><br><span class="line">        if (window.WKWebViewJavascriptBridge) &#123; return callback(WKWebViewJavascriptBridge); &#125;</span><br><span class="line">        if (window.WKWVJBCallbacks) &#123; return window.WKWVJBCallbacks.push(callback); &#125;</span><br><span class="line">        window.WKWVJBCallbacks &#x3D; [callback];</span><br><span class="line">        window.webkit.messageHandlers.iOS_Native_InjectJavascript.postMessage(null)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!window.isIOS) &#123;</span><br><span class="line">    jsbridge(function (bridge) &#123;</span><br><span class="line">        bridge.init(function (message, responseCallback) &#123;</span><br><span class="line">            var data &#x3D; &#123;&#125;;</span><br><span class="line">            responseCallback(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;option对象&#125;</span><br><span class="line"> * method: 调用的方法</span><br><span class="line"> * data: 传递的参数</span><br><span class="line"> * callback: 回掉方法</span><br><span class="line"> * @return &#123;[type]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">function bridgeCallHandler(option) &#123;</span><br><span class="line">    &#x2F;&#x2F; alert(option.method)</span><br><span class="line">    jsbridge(function (bridge) &#123;</span><br><span class="line">        bridge.callHandler(</span><br><span class="line">            option.method,</span><br><span class="line">            option.data || &#123;&#125;,</span><br><span class="line">            function (responseData) &#123;</span><br><span class="line">                if (option.callback) &#123;</span><br><span class="line">                    option.callback(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">window.callNativePage &#x3D; function (option) &#123;</span><br><span class="line">    bridgeCallHandler(&#123;</span><br><span class="line">        method: &#39;callNativePage&#39;,</span><br><span class="line">        data: option.data,</span><br><span class="line">        callback: function (responseData) &#123;</span><br><span class="line">            if (option.callback) &#123;</span><br><span class="line">                option.callback(responseData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">js调用app</span><br><span class="line">callNativePage(&#123;</span><br><span class="line">    data: &#123; msg : &#39;test send msg&#39; &#125;,</span><br><span class="line">    callback:function(responseData)&#123;</span><br><span class="line">        console.log(&#39;来源于app的反馈信息&#39;,responseData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;app调js</span><br><span class="line">window.bridgeRegisterHandler &#x3D; function (option) &#123;</span><br><span class="line">    &#x2F;&#x2F; alert(option.method);</span><br><span class="line">    jsbridge(function (bridge) &#123;</span><br><span class="line">        bridge.registerHandler(</span><br><span class="line">            option.method,</span><br><span class="line">            function (data, responseCallback) &#123;</span><br><span class="line">                if (option.callback) &#123;</span><br><span class="line">                    option.callback(data);</span><br><span class="line">                &#125;</span><br><span class="line">                responseCallback(option.data || &#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">window.bridgeRegisterHandler(&#123;</span><br><span class="line">    method:&quot;提供给app调用的方法名&quot;,</span><br><span class="line">    callback:function(data)&#123;</span><br><span class="line">        &#x2F;&#x2F; data : app传递给前端的data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参考链接</p>
<p><a href="https://www.cnblogs.com/tu-front-end/p/11301685.html" target="_blank" rel="noopener">jsbridge</a></p>
<p><a href="https://blog.csdn.net/daipianpian/article/details/90714502" target="_blank" rel="noopener">vue项目使用WebViewJavascriptBridge</a></p>
<p><a href="https://www.jianshu.com/p/2fa0b6cdca17" target="_blank" rel="noopener">H5调用封装</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jsbridge</tag>
      </tags>
  </entry>
  <entry>
    <title>js之call和apply</title>
    <url>/2020/09/14/js%E4%B9%8Bcall%E5%92%8Capply/</url>
    <content><![CDATA[<h3 id="是做啥的"><a href="#是做啥的" class="headerlink" title="是做啥的"></a>是做啥的</h3><p>call()、apply()、bind()是用来改变this的指向的。</p>
<h3 id="call和apply的区别和用法"><a href="#call和apply的区别和用法" class="headerlink" title="call和apply的区别和用法"></a>call和apply的区别和用法</h3><h4 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h4><p>obj.call(thisObj, arg1, arg2, …);<br>obj.apply(thisObj, [arg1, arg2, …]);<br>call和apply作用都是把obj绑定到thisObj的作用，即改变this的指向，然而唯一的区别就是apply传递的参数必须得是数组的形式传递，而call则直接连续参数传递</p>
<a id="more"></a>

<h4 id="call和apply在什么地方可以用到呢？"><a href="#call和apply在什么地方可以用到呢？" class="headerlink" title="call和apply在什么地方可以用到呢？"></a>call和apply在什么地方可以用到呢？</h4><p>当一个对象需要调用另外一个对象里面的方法的时候就可以用到call和apply，call和Apply可以理解成是继承另外一个对象的方法，以下代码举例：</p>
<p>首先，我们先建立两个对象，obj1和obj2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var name &#x3D; &quot;全局中的name&quot;;</span><br><span class="line">    var obj1 &#x3D; &#123;</span><br><span class="line">        name:&quot;obj1中的name&quot;,</span><br><span class="line">        func1:function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        func2:function (a,b) &#123;</span><br><span class="line">            console.log(a+b);</span><br><span class="line">            return a+b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">	name:&quot;obj2中的name&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.func1.call(this);&#x2F;&#x2F;输出：全局中的name</span><br><span class="line">obj1.func1.apply(this);&#x2F;&#x2F;输出：全局中的name</span><br><span class="line"></span><br><span class="line">obj1.func1.call(obj2); &#x2F;&#x2F;输出：obj2中的name</span><br><span class="line">obj1.func1.apply(obj2);&#x2F;&#x2F;输出：obj2中的name</span><br><span class="line"></span><br><span class="line">obj1.func2.call(obj2,1,2);&#x2F;&#x2F;输出：3</span><br><span class="line">obj1.func2.apply(obj2,[1,2]);&#x2F;&#x2F;输出：3</span><br></pre></td></tr></table></figure>



<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>一个叫喵喵的猫喜欢吃鱼，一个叫汪汪的小狗喜欢啃骨头，用代码实现如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var cat = &#123;</span><br><span class="line">  name:"喵喵",</span><br><span class="line">  eatFish:function(param1,param2)&#123;</span><br><span class="line">    console.log("吃鱼");</span><br><span class="line">	console.log("this的指向=&gt;");</span><br><span class="line">	console.log(this);</span><br><span class="line">	console.log(param1,param2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog = &#123;</span><br><span class="line">	name:"汪汪",</span><br><span class="line">	eatBone:function(param1,param2)&#123;</span><br><span class="line">		console.log("啃骨头");</span><br><span class="line">		console.log("this的指向=&gt;");</span><br><span class="line">		console.log(this);</span><br><span class="line">		console.log(param1,param2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一天，小狗汪汪和喵喵共进午餐的时候，汪汪说自己想尝尝小鱼干的味道，但是因为有刺，喵喵就想了个办法，说自己先吃，完了喂给汪汪</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//第一种，用call方法</span><br><span class="line">cat.eatFish.call(dog,"旺财-13岁","call");</span><br><span class="line"></span><br><span class="line">//第二种，用apply方法，参数不一样</span><br><span class="line">cat.eatFish.apply(dog,["旺财-13岁","apply"]);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180517112432197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNzYwOTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>这样，汪汪就吃到了美味的鱼干。可是汪汪每吨都想来点小鱼干，喵喵还要工作去捉老鼠，所以它们又想了一个办法，喵喵把吃鱼的方法教给汪汪。这样，每次汪汪就可以自己吃小鱼干了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var eatFishFun = cat.eatFish.bind(dog,"旺财-13岁","bind"); //返回的是方法</span><br><span class="line">eatFishFun();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180517112744838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNzYwOTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>bind()方法在这里再多说一下，bind的时候传的参数会预先传给返回的方法，调用方法时就不用再传参数了。</p>
<p>撇开上面的例子，看看一个特殊情况：</p>
<p>如果call()和apply()的第一个参数是null或者undefined，那么this的指向就是全局变量，在浏览器里就是window对象。</p>
<p><img src="https://img-blog.csdn.net/2018051715053339?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNzYwOTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>apply</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">89</span>,<span class="number">46</span>]</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(arr)<span class="comment">//89</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title>js之loadshJs</title>
    <url>/2020/10/09/js%E4%B9%8BloadshJs/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Lodash是一个著名的javascript原生库，不需要引入其他第三方依赖。是一个意在提高开发者效率,提高JS原生方法性能的JS库。简单的说就是，很多方法lodash已经帮你写好了，直接调用就行，不用自己费尽心思去写了，而且可以统一方法的一致性。Lodash使用了一个简单的 _ 符号，就像Jquery的 $ 一样，十分简洁。<br> 类似的还有Underscore.js和Lazy.js</p>
<h4 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h4><p>chrome 43往上<br> Firefox 38往上<br> IE 6-11<br> MS Edge<br> Safari 5往上<br> （几乎涵盖现在市面上可以见到的大部分浏览器）</p>
<h4 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h4><a id="more"></a>

<h5 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h5><script src="lodash.js"></script> 直接下载下来引入，或者使用cdn

<h6 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i -g npm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm i --save lodash</span></span><br></pre></td></tr></table></figure>

<p>先全局安装，在单独安装到项目中</p>
<h6 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h6><p><code>var _ = require(&#39;lodash&#39;);</code></p>
<h4 id="为什么使用lodash"><a href="#为什么使用lodash" class="headerlink" title="为什么使用lodash"></a>为什么使用lodash</h4><p>通过使用数组，数字，对象，字符串等方法，Lodash使JavaScript变得更简单。</p>
<h4 id="常用lodash函数"><a href="#常用lodash函数" class="headerlink" title="常用lodash函数"></a>常用lodash函数</h4><p>（参考版本lodash v4.16.1）</p>
<h5 id="1、N次循环"><a href="#1、N次循环" class="headerlink" title="1、N次循环"></a>1、N次循环</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- javascript -------'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//js原生的循环方法</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(i);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- lodash -------'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//ladash的times方法</span></span></span><br><span class="line"><span class="actionscript">    _.times(<span class="number">5</span>,<span class="function"><span class="keyword">function</span><span class="params">(a)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(a);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>for</code>语句是执行循环的不二选择，但在上面代码的使用场景下，<code>_.times()</code>的解决方式更加简洁和易于理解。</p>
<h5 id="2、深层查找属性值"><a href="#2、深层查找属性值" class="headerlink" title="2、深层查找属性值"></a>2、深层查找属性值</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ownerArr = [&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"owner"</span>: <span class="string">"Colin"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog1"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog2"</span>&#125;]</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line"><span class="actionscript">        <span class="string">"owner"</span>: <span class="string">"John"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog3"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog4"</span>&#125;]</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> jsMap = ownerArr.map(<span class="function"><span class="keyword">function</span> <span class="params">(owner)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> owner.pets[<span class="number">0</span>].name;</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- jsMap -------'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(jsMap);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> lodashMap = _.map(ownerArr, <span class="string">'pets[0].name'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- lodashMap -------'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(lodashMap);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Lodash中的<code>_.map</code>方法和JavaScript中原生的数组方法非常的像，但它还是有非常有用的升级。 你可以通过一个字符串而不是回调函数来浏览深度嵌套的对象属性。</p>
<h5 id="3、深克隆对象"><a href="#3、深克隆对象" class="headerlink" title="3、深克隆对象"></a>3、深克隆对象</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objA = &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"name"</span>: <span class="string">"戈德斯文"</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objB = _.cloneDeep(objA);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objB);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA === objB);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>深度克隆JavaScript对象是困难的，并且也没有什么简单的解决方案。你可以使用原生的解决方案:<code>JSON.parse(JSON.stringify(objectToClone))</code> 进行深度克隆。但是，这种方案仅在对象内部没有方法的时候才可行。</p>
<h5 id="4、在指定范围内获取一个随机值"><a href="#4、在指定范围内获取一个随机值" class="headerlink" title="4、在指定范围内获取一个随机值"></a>4、在指定范围内获取一个随机值</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getRandomNumber</span><span class="params">(min, max)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(getRandomNumber(<span class="number">15</span>, <span class="number">20</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.random(<span class="number">15</span>, <span class="number">20</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Lodash中的 <code>_.random</code> 方法要比上面的原生方法更强大与灵活。你可以只传入一个参数作为最大值， 你也可以指定返回的结果为浮点数<code>_.random(15,20,true)</code></p>
<h5 id="5、扩展对象"><a href="#5、扩展对象" class="headerlink" title="5、扩展对象"></a>5、扩展对象</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;    <span class="comment">//判断被扩展的对象有没有某个属性，</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>[i] = obj[i];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"戈德斯文"</span>, <span class="string">"car"</span>: <span class="string">"宝马"</span>&#125;;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objB = &#123;<span class="string">"name"</span>: <span class="string">"柴硕"</span>, <span class="string">"loveEat"</span>: <span class="literal">true</span>&#125;;</span></span><br><span class="line"></span><br><span class="line">    objA.extend(objB);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA); </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.assign(objA, objB));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>_.assign</code> 方法也可以接收多个参数对象进行扩展，都是往后面的对象上合并</p>
<h5 id="6、从列表中随机的选择列表项"><a href="#6、从列表中随机的选择列表项" class="headerlink" title="6、从列表中随机的选择列表项"></a>6、从列表中随机的选择列表项</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> smartTeam = [<span class="string">"戈德斯文"</span>, <span class="string">"杨海月"</span>, <span class="string">"柴硕"</span>, <span class="string">"师贝贝"</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">randomSmarter</span><span class="params">(smartTeam)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * smartTeam.length);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> smartTeam[index];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(randomSmarter(smartTeam));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Lodash</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.sample(smartTeam));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.sampleSize(smartTeam,<span class="number">2</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外，你也可以指定随机返回元素的个数<code>_.sampleSize(smartTeam,n)</code>，n为需要返回的元素个数</p>
<h5 id="7、判断对象中是否含有某元素"><a href="#7、判断对象中是否含有某元素" class="headerlink" title="7、判断对象中是否含有某元素"></a>7、判断对象中是否含有某元素</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> smartPerson = &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="string">'name'</span>: <span class="string">'戈德斯文'</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">'gender'</span>: <span class="string">'male'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        smartTeam = [<span class="string">"戈德斯文"</span>, <span class="string">"杨海月"</span>, <span class="string">"柴硕"</span>, <span class="string">"师贝贝"</span>];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartPerson, <span class="string">'戈德斯文'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartTeam, <span class="string">'杨海月'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartTeam, <span class="string">'杨海月'</span>,<span class="number">2</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>_.includes()</code>第一个参数是需要查询的对象，第二个参数是需要查询的元素，第三个参数是开始查询的下标</p>
<h5 id="8、遍历循环"><a href="#8、遍历循环" class="headerlink" title="8、遍历循环"></a>8、遍历循环</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    _([<span class="number">1</span>, <span class="number">2</span>]).forEach(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(value);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    _.forEach([<span class="number">1</span>, <span class="number">3</span>] , <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(key,value);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两种方法都会分别输出‘1’和‘2’，不仅是数组，对象也可以，数组的是后<code>key</code>是元素的下标，当传入的是对象的时候，<code>key</code>是属性，<code>value</code>是值</p>
<h5 id="9、遍历循环执行某个方法"><a href="#9、遍历循环执行某个方法" class="headerlink" title="9、遍历循环执行某个方法"></a>9、遍历循环执行某个方法</h5><p><code>_.map()</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(n)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> n * n;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map([<span class="number">4</span>, <span class="number">8</span>], square));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [16, 64]</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map(&#123; <span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">8</span> &#125;, square));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [16, 64] (iteration order is not guaranteed)</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> users = [</span></span><br><span class="line"><span class="actionscript">        &#123; <span class="string">'user'</span>: <span class="string">'barney'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">        &#123; <span class="string">'user'</span>: <span class="string">'fred'</span> &#125;</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// The `_.property` iteratee shorthand.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map(users, <span class="string">'user'</span>));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; ['barney', 'fred']</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="10、检验值是否为空"><a href="#10、检验值是否为空" class="headerlink" title="10、检验值是否为空"></a>10、检验值是否为空</h5><p><code>_.isEmpty()</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    _.isEmpty(<span class="literal">null</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    _.isEmpty(<span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line">    _.isEmpty(1);</span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line">    _.isEmpty([1, 2, 3]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; false</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    _.isEmpty(&#123; <span class="string">'a'</span>: <span class="number">1</span> &#125;);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; false</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="11、查找属性"><a href="#11、查找属性" class="headerlink" title="11、查找属性"></a>11、查找属性</h5><p><code>_.find()</code>、<code>_.filter()</code>、<code>_.reject()</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> users = [</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'barney'</span>, <span class="string">'age'</span>: <span class="number">36</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'fred'</span>, <span class="string">'age'</span>: <span class="number">40</span>, <span class="string">'active'</span>: <span class="literal">false</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'pebbles'</span>, <span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> o.age &lt; <span class="number">40</span>;</span></span><br><span class="line">    &#125;));</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, &#123;<span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, &#123;<span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, [<span class="string">'active'</span>, <span class="literal">false</span>]));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, [<span class="string">'active'</span>, <span class="literal">false</span>]));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, <span class="string">'active'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, <span class="string">'active'</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>_.find()</code>第一个返回真值的第一个元素。<br> <code>_.filter()</code>返回真值的所有元素的数组。<br> <code>_.reject()</code>是<code>_.filter</code>的反向方法，不返回真值的（集合）元素</p>
<h5 id="12、数组去重"><a href="#12、数组去重" class="headerlink" title="12、数组去重"></a>12、数组去重</h5><p><code>_.uniq(array)</code>创建一个去重后的array数组副本。</p>
<p>参数<br> <code>array (Array)</code>: 要检查的数组。</p>
<p>返回新的去重后的数组</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr1 = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr2 = _.uniq(arr1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">unique</span><span class="params">(arr)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> newArr = [];</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></span><br><span class="line">            if(newArr.indexOf(arr[i]) == -1)&#123;</span><br><span class="line">                newArr.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> newArr;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr1);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr2);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(unique(arr1));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>_.uniqBy(array,[iteratee=_.identity])</code>这个方法类似 <code>_.uniq</code>，除了它接受一个 <code>iteratee</code>（迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 调用时会传入一个参数：(value)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.uniqBy([<span class="number">2.1</span>, <span class="number">1.2</span>, <span class="number">2.3</span>], <span class="built_in">Math</span>.floor));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [2.1, 1.2]</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.uniqBy([&#123; <span class="string">'x'</span>: <span class="number">1</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">2</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">1</span> &#125;], <span class="string">'x'</span>));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [&#123; 'x': 1 &#125;, &#123; 'x': 2 &#125;]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Math.floor</code>只是向下取整，去重，并没有改变原有的数组，所以还是2.1和1.2，不是2和1。</p>
<h5 id="13、模板插入"><a href="#13、模板插入" class="headerlink" title="13、模板插入"></a>13、模板插入</h5><p><code>_.template([string=&#39;&#39;], [options={}])</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> data = [&#123;name: <span class="string">'戈德斯文'</span>&#125;, &#123;name: <span class="string">'柴硕'</span>&#125;, &#123;name: <span class="string">'杨海月'</span>&#125;];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> t = _.template($(<span class="string">"#tpl"</span>).html());</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#container"</span>).html(t(data));</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    &lt;% _.each(obj,<span class="function"><span class="keyword">function</span><span class="params">(e,i)</span></span>&#123; %&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">e.name</span> %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span> %&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，这个<code>&lt;script&gt;</code>标签的<code>type</code>是<code>text/template</code>，类似于react的JSX的写法，就是js和html可以混写，用<code>&lt;% %&gt;</code>括起来的就是js代码，可以执行，直接写的就是html的标签，并且有类似MVC框架的的数据绑定，在<code>&lt;%= %&gt;</code>中可以调用到数据呈现（纯属个人见解，不知道理解的对不对）</p>
]]></content>
  </entry>
  <entry>
    <title>js之BigNumber.js</title>
    <url>/2020/09/15/js%E4%B9%8BBigNumber-js/</url>
    <content><![CDATA[<p>vue使用BigNumber.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save bignumber.js</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var BigNumber &#x3D; require(&#39;bignumber.js&#39;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 转为 bignumber</span><br><span class="line">const x&#x3D; new BigNumber(&#39;123456789.123456789&#39;);</span><br><span class="line">&#x2F;&#x2F; 转为 普通数字</span><br><span class="line">x.toNumber()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 格式化(小数点)</span><br><span class="line">x.toFormat()    &#x2F;&#x2F; &#39;123,456,789.123456789&#39;</span><br><span class="line">x.toFormat(3)   &#x2F;&#x2F; &#39;123,456,789.123&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算</span><br><span class="line">x.plus(0.1)  &#x2F;&#x2F; 加法</span><br><span class="line">x.minus(0.1)  &#x2F;&#x2F; 减法</span><br><span class="line">x.times(0.1)  &#x2F;&#x2F; 乘法</span><br><span class="line">x.div(0.1)  &#x2F;&#x2F; 除法</span><br><span class="line">x.mod(3)  &#x2F;&#x2F; 取模&#x2F;取余</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比较大小</span><br><span class="line">x.eq(y) &#x2F;&#x2F; isEqualTo 的简写，是否相等</span><br><span class="line">x.gt(y) &#x2F;&#x2F; isGreaterThan 的简写，是否大于</span><br><span class="line">x.gte(y) &#x2F;&#x2F; isGreaterThanOrEqualTo 的简写，是否大于等于</span><br><span class="line">x.lt(y) &#x2F;&#x2F; isLessThan 的简写，是否小于</span><br><span class="line">x.lte(y) &#x2F;&#x2F; isLessThanOrEqualTo 的简写，是否小于等于</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取非，改变数字的正负号</span><br><span class="line">x.negated()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>精度计算</tag>
      </tags>
  </entry>
  <entry>
    <title>js之Math</title>
    <url>/2020/09/23/js%E4%B9%8BMath/</url>
    <content><![CDATA[<h2 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h2><a id="more"></a>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_abs.asp" target="_blank" rel="noopener">abs(x)</a></td>
<td align="left">返回数的绝对值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_acos.asp" target="_blank" rel="noopener">acos(x)</a></td>
<td align="left">返回数的反余弦值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_asin.asp" target="_blank" rel="noopener">asin(x)</a></td>
<td align="left">返回数的反正弦值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_atan.asp" target="_blank" rel="noopener">atan(x)</a></td>
<td align="left">以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_atan2.asp" target="_blank" rel="noopener">atan2(y,x)</a></td>
<td align="left">返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_ceil.asp" target="_blank" rel="noopener">ceil(x)</a></td>
<td align="left">对数进行上舍入。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_cos.asp" target="_blank" rel="noopener">cos(x)</a></td>
<td align="left">返回数的余弦。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_exp.asp" target="_blank" rel="noopener">exp(x)</a></td>
<td align="left">返回 e 的指数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_floor.asp" target="_blank" rel="noopener">floor(x)</a></td>
<td align="left">对数进行下舍入。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_log.asp" target="_blank" rel="noopener">log(x)</a></td>
<td align="left">返回数的自然对数（底为e）。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_max.asp" target="_blank" rel="noopener">max(x,y)</a></td>
<td align="left">返回 x 和 y 中的最高值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_min.asp" target="_blank" rel="noopener">min(x,y)</a></td>
<td align="left">返回 x 和 y 中的最低值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_pow.asp" target="_blank" rel="noopener">pow(x,y)</a></td>
<td align="left">返回 x 的 y 次幂。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_random.asp" target="_blank" rel="noopener">random()</a></td>
<td align="left">返回 0 ~ 1 之间的随机数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_round.asp" target="_blank" rel="noopener">round(x)</a></td>
<td align="left">把数四舍五入为最接近的整数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_sin.asp" target="_blank" rel="noopener">sin(x)</a></td>
<td align="left">返回数的正弦。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_sqrt.asp" target="_blank" rel="noopener">sqrt(x)</a></td>
<td align="left">返回数的平方根。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_tan.asp" target="_blank" rel="noopener">tan(x)</a></td>
<td align="left">返回角的正切。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_tosource_math.asp" target="_blank" rel="noopener">toSource()</a></td>
<td align="left">返回该对象的源代码。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_valueof_math.asp" target="_blank" rel="noopener">valueOf()</a></td>
<td align="left">返回 Math 对象的原始值。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>js之对象的方法合集</title>
    <url>/2020/09/25/js%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="Object构造方法"><a href="#Object构造方法" class="headerlink" title="Object构造方法"></a><code>Object</code>构造方法</h2><ul>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener"><code>Object.assign()</code></a></p>
<p>将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener"><code>Object.create()</code></a></p>
<p>用指定的原型对象和属性创建一个新对象。</p>
<a id="more"></a>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty()</code></a></p>
<p>将给定描述符描述的命名属性添加到对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener"><code>Object.defineProperties()</code></a></p>
<p>将给定描述符描述的命名属性添加到对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener"><code>Object.entries()</code></a></p>
<p>返回一个包含<code>[key, value]</code>给定对象<strong>自己的</strong>可枚举字符串属性的所有对的数组。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener"><code>Object.freeze()</code></a></p>
<p>冻结对象。其他代码无法删除或更改其属性。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries" target="_blank" rel="noopener"><code>Object.fromEntries()</code></a></p>
<p>从可迭代的<code>[key, value]</code>对中返回一个新对象。（这是的反向 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener"><code>Object.entries</code></a>）。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptor()</code></a></p>
<p>返回对象的命名属性的属性描述符。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptors()</code></a></p>
<p>返回一个包含对象自身所有属性描述符的对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" target="_blank" rel="noopener"><code>Object.getOwnPropertyNames()</code></a></p>
<p>返回一个数组，其中包含给定对象<strong>自己</strong>的所有可枚举和不可枚举属性的名称。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="noopener"><code>Object.getOwnPropertySymbols()</code></a></p>
<p>返回直接在给定对象上找到的所有符号属性的数组。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener"><code>Object.getPrototypeOf()</code></a></p>
<p>返回<code>prototype</code>指定对象的。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener"><code>Object.is()</code></a></p>
<p>比较两个值是否相同。求所有<code>NaN</code>值（不同于“抽象相等比较”和“严格相等比较”）。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible" target="_blank" rel="noopener"><code>Object.isExtensible()</code></a></p>
<p>确定是否允许扩展对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen" target="_blank" rel="noopener"><code>Object.isFrozen()</code></a></p>
<p>确定对象是否冻结。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed" target="_blank" rel="noopener"><code>Object.isSealed()</code></a></p>
<p>确定对象是否密封。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener"><code>Object.keys()</code></a></p>
<p>返回一个数组，其中包含给定对象<strong>自己</strong>的所有可枚举字符串属性的名称。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="noopener"><code>Object.preventExtensions()</code></a></p>
<p>防止对象的任何扩展。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener"><code>Object.seal()</code></a></p>
<p>防止其他代码删除对象的属性。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf()</code></a></p>
<p>设置对象的原型（其内部<code>[[Prototype]]</code>属性）。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank" rel="noopener"><code>Object.values()</code></a></p>
<p>返回一个数组，该数组包含与给定对象<strong>自己的所有</strong>可枚举字符串属性相对应的值。</p>
</li>
</ul>
<h2 id="Object实例和Object原型对象"><a href="#Object实例和Object原型对象" class="headerlink" title="Object实例和Object原型对象"></a><code>Object</code>实例和<code>Object</code>原型对象</h2><p>JavaScript中的所有对象均来自<code>Object</code>。所有对象都继承自的方法和属性<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="noopener"><code>Object.prototype</code></a>，尽管它们可能会被覆盖。</p>
<p>例如，其他构造函数的原型将覆盖<code>constructor</code>属性并提供自己的<code>toString()</code>方法。对<code>Object</code>原型对象的更改将传播到所有对象，除非经受这些更改的属性和方法在原型链中进一步被覆盖。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener"><code>Object.prototype.constructor</code></a></p>
<p>指定创建对象原型的函数。</p>
</li>
</ul>
<h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><p>typeof只能判断区分基本类型，number、string、boolean、undefined和object,function；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof 0;  &#x2F;&#x2F;number;</span><br><span class="line">typeof true;  &#x2F;&#x2F;boolean;</span><br><span class="line">typeof undefined;  &#x2F;&#x2F;undefined;</span><br><span class="line">typeof &quot;hello world&quot;   &#x2F;&#x2F;string;</span><br><span class="line">typeof function()&#123;&#125;;   &#x2F;&#x2F;function;</span><br><span class="line"></span><br><span class="line">typeof null; &#x2F;&#x2F;object</span><br><span class="line">typeof &#123;&#125;;  &#x2F;&#x2F;object;</span><br><span class="line">typeof []; &#x2F;&#x2F;object</span><br></pre></td></tr></table></figure>

<p>从上例我们可以看出， typeof 判断对象和数组都返回object,因此它无法区分对象和数组。</p>
<h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a&#x3D;&#123;&#125;;</span><br><span class="line">a instanceof Object  &#x2F;&#x2F;true</span><br><span class="line">a intanceof Array     &#x2F;&#x2F;false</span><br><span class="line">var b&#x3D;[];</span><br><span class="line">b instanceof Array  &#x2F;&#x2F;true</span><br><span class="line">b instanceof  Object &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>因为数组属于object中的一种，所以数组instanceof object,也是true.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c&#x3D;&#39;abc&#39;;</span><br><span class="line">c instanceof String; &#x2F;&#x2F;false</span><br><span class="line">var d&#x3D;new String();</span><br><span class="line">d instanceof String  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>instanceof不能区分基本类型string和boolean,除非是字符串对象和布尔对象。如上例所示。</p>
<h4 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o&#x3D;&#123;&#125;;</span><br><span class="line">o.constructor&#x3D;&#x3D;Object  &#x2F;&#x2F;true</span><br><span class="line">var arr&#x3D;[];</span><br><span class="line">arr.constructor&#x3D;&#x3D;Array  &#x2F;&#x2F;true</span><br><span class="line">arr.constructor&#x3D;&#x3D;Object &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>可以看出constructor可以区分Array和Object。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var n&#x3D;true;</span><br><span class="line">n.constructor&#x3D;&#x3D;Boolean  &#x2F;&#x2F;true</span><br><span class="line">var num&#x3D;1;</span><br><span class="line">num.constructor&#x3D;&#x3D;Number  &#x2F;&#x2F;true</span><br><span class="line">var str&#x3D;&#39;hello world&#39;;</span><br><span class="line">str.constructor&#x3D;&#x3D;String     &#x2F;&#x2F;true</span><br><span class="line">var num&#x3D;new Number();</span><br><span class="line">num.constructor&#x3D;&#x3D;Number  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>不过要注意，constructor属性是可以被修改的，会导致检测出的结果不正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">function Student()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">Student.prototype &#x3D; new Person();</span><br><span class="line">var John &#x3D; new Student();</span><br><span class="line">console.log(John.constructor&#x3D;&#x3D;Student); &#x2F;&#x2F; false</span><br><span class="line">console.log(John.constructor&#x3D;&#x3D;Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h5 id="除了undefined和null，其他类型的变量均能使用constructor判断出类型"><a href="#除了undefined和null，其他类型的变量均能使用constructor判断出类型" class="headerlink" title="除了undefined和null，其他类型的变量均能使用constructor判断出类型."></a>除了undefined和null，其他类型的变量均能使用constructor判断出类型.</h5><h4 id="4-Object-prototype-toString-call-———最好用"><a href="#4-Object-prototype-toString-call-———最好用" class="headerlink" title="4.Object.prototype.toString.call()  ———最好用"></a>4.Object.prototype.toString.call()  ———最好用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(123)</span><br><span class="line">&#x2F;&#x2F;&quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#39;str&#39;)</span><br><span class="line">&#x2F;&#x2F;&quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)</span><br><span class="line">&#x2F;&#x2F;&quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)</span><br><span class="line">&#x2F;&#x2F;&quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])</span><br><span class="line">&#x2F;&#x2F;&quot;[object Array]&quot;</span><br></pre></td></tr></table></figure>

<p>封装一个判断数组和对象的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function typeObj(obj)&#123;</span><br><span class="line">      var type&#x3D;Object.prototype.toString.call(obj);</span><br><span class="line">      if(type&#x3D;&#x3D;&#39;[object Array]&#39;)&#123;</span><br><span class="line">        return &#39;Array&#39;;</span><br><span class="line">      &#125;elseif(type&#x3D;&#x3D;&#39;[object  Object]&#39;)&#123;</span><br><span class="line">        return &#39;Object&#39;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        return &quot;obj is not object or array&quot;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>对象的方法</tag>
      </tags>
  </entry>
  <entry>
    <title>js之今天是星期几</title>
    <url>/2020/09/09/js%E4%B9%8B%E4%BB%8A%E5%A4%A9%E6%98%AF%E6%98%9F%E6%9C%9F%E5%87%A0/</url>
    <content><![CDATA[<h4 id="初学"><a href="#初学" class="headerlink" title="初学"></a>初学</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    if (date &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        string +&#x3D; &quot;日&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        string +&#x3D; &quot;一&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">        string +&#x3D; &quot;二&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 3) &#123;</span><br><span class="line">        string +&#x3D; &quot;三&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        string +&#x3D; &quot;四&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 5) &#123;</span><br><span class="line">        string +&#x3D; &quot;五&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 6) &#123;</span><br><span class="line">        string +&#x3D; &quot;六&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    switch (date) &#123;</span><br><span class="line">        case 0 :</span><br><span class="line">            string +&#x3D; &quot;日&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 1 :</span><br><span class="line">            string +&#x3D; &quot;一&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 2 :</span><br><span class="line">            string +&#x3D; &quot;二&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 3 :</span><br><span class="line">            string +&#x3D; &quot;三&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 4 :</span><br><span class="line">            string +&#x3D; &quot;四&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 5 :</span><br><span class="line">            string +&#x3D; &quot;五&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 6 :</span><br><span class="line">            string +&#x3D; &quot;六&quot;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    &#x2F;&#x2F; 使用数组</span><br><span class="line">    let dateArr &#x3D; [ 天 , 一 , 二 , 三 , 四 , 五 , 六 ];</span><br><span class="line">    return string + dateArr[date]</span><br><span class="line">&#125;</span><br><span class="line">console.log(returnWeekday())</span><br><span class="line"></span><br><span class="line">倘若我们的每个 case 是不规律的字符串呢？那我们使用对象，每个 case 为一个 key</span><br><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    &#x2F;&#x2F; 使用对象</span><br><span class="line">    dateObj &#x3D; &#123; </span><br><span class="line">        0:  天 , </span><br><span class="line">        1: &quot;一&quot;, </span><br><span class="line">        2: &quot;二&quot;, </span><br><span class="line">        3: &quot;三&quot;, </span><br><span class="line">        4: &quot;四&quot;, </span><br><span class="line">        5: &quot;五&quot;, </span><br><span class="line">        6: &quot;六&quot;, </span><br><span class="line">    &#125;;</span><br><span class="line">    return string + dateObj[date]</span><br><span class="line">&#125;</span><br><span class="line">console.log(returnWeekday())</span><br><span class="line"></span><br><span class="line">使用 charAt 字符方法</span><br><span class="line">&#x2F;&#x2F; charAt 定位方法</span><br><span class="line">function returnWeekday()&#123;</span><br><span class="line">    return &quot;今天是星期&quot; + &quot;日一二三四五六&quot;.charAt(new Date().getDay());</span><br><span class="line">&#125;</span><br><span class="line">console.log(returnWeekday())</span><br></pre></td></tr></table></figure>



<h3 id="需求变动-区分工作日和休息日"><a href="#需求变动-区分工作日和休息日" class="headerlink" title="需求变动(区分工作日和休息日)"></a>需求变动(区分工作日和休息日)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    &#x2F;&#x2F; 使用对象</span><br><span class="line">    dateObj &#x3D; &#123; </span><br><span class="line">        0: [&#39;天&#39;,&#39;休&#39;], </span><br><span class="line">        1: [&quot;一&quot;,&#39;工&#39;], </span><br><span class="line">        2: [&quot;二&quot;,&#39;工&#39;], </span><br><span class="line">        3: [&quot;三&quot;,&#39;工&#39;], </span><br><span class="line">        4: [&quot;四&quot;,&#39;工&#39;], </span><br><span class="line">        5: [&quot;五&quot;,&#39;工&#39;], </span><br><span class="line">        6: [&quot;六&quot;,&#39;休&#39;], </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 类型，这里也可以对应相关方法</span><br><span class="line">    dayType &#x3D; &#123;</span><br><span class="line">        &#39;休&#39;: function()&#123;</span><br><span class="line">            &#x2F;&#x2F; some code</span><br><span class="line">            console.log(&#39;为休息日&#39;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;工&#39;: function()&#123;</span><br><span class="line">            &#x2F;&#x2F; some code</span><br><span class="line">            console.log(&#39;为工作日&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let returnData &#x3D; &#123;</span><br><span class="line">         string  : string + dateObj[date][0],</span><br><span class="line">         method  : dayType[dateObj[date][1]]</span><br><span class="line">    &#125;</span><br><span class="line">    return returnData</span><br><span class="line">&#125;;</span><br><span class="line">console.log(returnWeekday().method.call(this))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>星期</tag>
      </tags>
  </entry>
  <entry>
    <title>js之快速理解i闭包</title>
    <url>/2020/09/29/js%E4%B9%8B%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3i%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 累加器</span><br><span class="line">function counter() &#123;</span><br><span class="line">  &#x2F;&#x2F; 秒数</span><br><span class="line">  let second &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  function doCounter() &#123;</span><br><span class="line">    &#x2F;&#x2F; 到达10秒后停止</span><br><span class="line">    if (second &#x3D;&#x3D;&#x3D; 10) &#123;</span><br><span class="line">      clearInterval(recordSecond);</span><br><span class="line">      console.log(&#39;计时结束!&#39;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    second +&#x3D; 1;</span><br><span class="line">    console.log(&#96;$&#123;second&#125;秒&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return doCounter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 得到累加器</span><br><span class="line">const doCounterFn &#x3D; counter();</span><br><span class="line"></span><br><span class="line">const recordSecond &#x3D; setInterval(function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 调用累加器</span><br><span class="line">  doCounterFn();</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>大概意思就是嵌套函数的外部函数如果返回的是一个函数（内部函数），变量和作用域会被保存，所以可以实现变量累加</p>
<blockquote>
<p>提一个概念，当我们将函数调用的返回值赋值给一个变量时，如果调用的这个函数返回的是一个函数，那么变量得到的则是对这个<strong>返回函数</strong>的引用（返回函数的内存地址），当一个函数存在被引用的关系，垃圾回收机制则不会回收它所占的内存，也就是保留该函数的整个执行上下文占用的内存（变量对象，作用域链等）。而因为返回的这个函数同时又是某个函数的内部函数，产生了作用域嵌套，形成了闭包，返回函数的作用域链上包括了外部函数的作用域，也就是返回函数中可以访问外部函数中定义的变量。</p>
</blockquote>
<p>参考链接：<a href="https://juejin.im/post/6877512572178808845" target="_blank" rel="noopener">https://juejin.im/post/6877512572178808845</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>js之构造函数原型实例</title>
    <url>/2020/09/25/js%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>首先用构造函数（一会解释什么叫做构造函数）的方法创建一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name=<span class="string">'123'</span>&#125;   <span class="comment">//ƒ ()&#123;this.name='123'&#125;</span></span><br><span class="line"><span class="keyword">var</span> a1=<span class="keyword">new</span> M()  <span class="comment">//M &#123;name: "123"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.name)  <span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数：</strong>现在M就是构造函数，因为他被new过了！–在js中，只要是被new过的函数都被成为构造函数。</p>
<p><strong>实例对象：</strong>现在a1就叫做实例，因为他是被new出来的！–在js中，只要是被new出来的对象都叫做实例对象。也叫实例。</p>
<p><strong>原型对象：</strong>现在M.prototype就是原型对象，构造函数函数被创建出来的时候，天生就带一个prototype属性，而这个属性里面的东西就叫原型对象。</p>
 <a id="more"></a>

<p><strong><em>\</em>他们之间的关系就如同下图：**</strong>我们暂时只看绿色框中的内容</p>
<p><img src="https://img-blog.csdnimg.cn/20190624230114432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDEwNTQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>从图中可得知4种关系：</p>
<p>1、构造函数（例子中的M）new出来的东西就叫实例，或者叫实例对象</p>
<p>2、构造函数（例子中的M）的prototype属性就叫原型对象</p>
<p>3、原型对象（M.prototype）中的constructor其实就等于构造函数，可以打印一下  M.prototype.constructor===M //true</p>
<p>   这样我们就知道构造函数和原型对象的关系了吧，就是一个闭环。</p>
<p>4、实例（例子中的a1）的_  _proto__属性其实就是把他new出来的那个构造函数的prototype</p>
<p>   可以打印 a1._ <em>proto_</em>===M.prototype //true</p>
<p>接下来我们看图的另一半</p>
<p><img src="https://img-blog.csdnimg.cn/20190625102904387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDEwNTQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>一个被new出来的实例，通过本身的<strong>proto</strong>属性找到他的原型对象，然后再通过他的原型对象的<strong>proto</strong>找到他的原型对象，一直找，递归访问<strong>proto</strong>最终到头，并且值是null，这个过程从头到结束就叫<strong>原型链</strong></p>
<p>构造函数的contructor属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分别以字面量和构造函数的方式创建</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;</span><br><span class="line">o.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span></span><br><span class="line">o.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line">a.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span></span><br><span class="line">a.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line">a.constructor === <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>)</span><br><span class="line">n.constructor === <span class="built_in">Number</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>构造函数</tag>
        <tag>原型对象</tag>
        <tag>实例对象</tag>
      </tags>
  </entry>
  <entry>
    <title>js作用域</title>
    <url>/2020/07/30/js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="js作用域"><a href="#js作用域" class="headerlink" title="js作用域"></a>js作用域</h3><p>![clipboard (2)](js作用域.assets/clipboard (2)-1599547611289.png)</p>
<a id="more"></a>

<p>![clipboard (3)](js作用域.assets/clipboard (3).png)</p>
<p>![clipboard (4)](js作用域.assets/clipboard (4).png)</p>
<p>![clipboard (5)](js作用域.assets/clipboard (5).png)</p>
<p>![clipboard (6)](js作用域.assets/clipboard (6).png)</p>
<p>![clipboard (7)](js作用域.assets/clipboard (7).png)</p>
<p>![clipboard (8)](js作用域.assets/clipboard (8)-1599547718223.png)</p>
<p>![clipboard (9)](js作用域.assets/clipboard (9).png)</p>
]]></content>
      <categories>
        <category>js作用域</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>js之防抖和节流</title>
    <url>/2020/09/29/js%E4%B9%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</span><br></pre></td></tr></table></figure>

<p>举个例子：<br> 当鼠标移动到一个div上时，div的内容一直在更新，如果不用防抖处理，效果如下图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">       let count &#x3D; 0;</span><br><span class="line">       function myEvent()&#123;</span><br><span class="line">           mydiv.innerText &#x3D; count++;</span><br><span class="line">       &#125;</span><br><span class="line">       mydiv.addEventListener(&#39;mouseover&#39;, function(event)&#123;</span><br><span class="line">           myEvent();</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><img src="https://user-gold-cdn.xitu.io/2020/3/3/1709ebe109bc00dd?imageslim" alt="img"></p>
<p>使用了防抖后的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(fn,delay) &#123;</span><br><span class="line">           let timeout &#x3D; null;</span><br><span class="line">           return function () &#123;</span><br><span class="line">               if(timeout)&#123;</span><br><span class="line">                   clearTimeout(timeout);</span><br><span class="line">               &#125;</span><br><span class="line">               timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                   fn.apply(this, arguments);</span><br><span class="line">               &#125;,delay);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">       let count &#x3D; 0;</span><br><span class="line">       function myEvent()&#123;</span><br><span class="line">           mydiv.innerText &#x3D; count++;</span><br><span class="line">       &#125;        </span><br><span class="line">       mydiv.addEventListener(&#39;mouseover&#39;, debounce(myEvent,2000));</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2020/3/3/1709ec48bfa90688?imageslim" alt="img"></p>
<p>代码实现原理：<br> 函数防抖的关键在于，在一个动作发生一定时间后，才执行指定事件；如果n秒内高频事件再次被触发，则重新计算时间；</p>
<p>在document中鼠标移动的时候，会在mouseover最后触发的2s后执行回调函数myEvent；如果我们一直在浏览器中移动鼠标（比如10s），会发现会在10 + 2s后才会执行myEvent函数（因为clearTimeout(timeout)），这个就是函数防抖。</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。稀释事件执行频率。</p>
<p><strong>定时器的实现方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function throttle(fn, delay) &#123;</span><br><span class="line">                let hasRun &#x3D; false;</span><br><span class="line">                return function () &#123;</span><br><span class="line">                    if (hasRun) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hasRun &#x3D; true;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        hasRun &#x3D; false;</span><br><span class="line">                        fn.apply(this, arguments);</span><br><span class="line">                    &#125;, delay);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">        let count &#x3D; 0;</span><br><span class="line">        function myEvent()&#123;</span><br><span class="line">            mydiv.innerText &#x3D; count++;</span><br><span class="line">        &#125;        </span><br><span class="line">        mydiv.addEventListener(&#39;mouseover&#39;, throttle(myEvent,2000));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/3/1709fc48220bf21d?imageslim" alt="img"></p>
<p><strong>时间戳的实现方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var count &#x3D; 0;</span><br><span class="line">function myEvent() &#123;</span><br><span class="line">    div.innerText &#x3D; count++;</span><br><span class="line">&#125;</span><br><span class="line">div.onmouseover &#x3D; throttle(myEvent,2000);</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    let pre &#x3D; 0;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        let now &#x3D; new Date().getTime();</span><br><span class="line">        if (now - pre &gt; wait) &#123;</span><br><span class="line">            pre &#x3D; now;</span><br><span class="line">            func.apply(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码实现原理：每隔n秒执行一次回调函数。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>防抖：<br> 1、search搜索联想，用户在不断输入值时，用防抖来节约请求资源；<br> 2、window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次；<br> 3、防止重复提交；<br> 节流：<br> 1、鼠标不断的点击触发，mousedown（单位时间内只触发一次）；<br> 2、监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断；</p>
<p>链接：<a href="https://juejin.im/post/6844904080540729357" target="_blank" rel="noopener">https://juejin.im/post/6844904080540729357</a></p>
]]></content>
  </entry>
  <entry>
    <title>js之深拷贝和浅拷贝方法合集</title>
    <url>/2020/10/20/js%E4%B9%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="js中的堆和栈"><a href="#js中的堆和栈" class="headerlink" title="js中的堆和栈"></a><a href="https://www.cnblogs.com/cherishnow/p/10901586.html" target="_blank" rel="noopener">js中的堆和栈</a></h2><h3 id="一-栈和堆"><a href="#一-栈和堆" class="headerlink" title="一.栈和堆"></a>一.栈和堆</h3><p>栈(stack)：栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。（基本类型：String，Number，Boolean，Null，Undefined）<br>堆(heap)：动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。（引用类型：Function，Array，Object）</p>
<h3 id="二-区别"><a href="#二-区别" class="headerlink" title="二.区别"></a>二.区别</h3><p>栈：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。<br>优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可以共享；<br>缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。<br>堆：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(参数传递)。创建对象是为了反复利用，这个对象将被保存到运行时数据区。</p>
<a id="more"></a>

<h3 id="三-栈和堆的溢出"><a href="#三-栈和堆的溢出" class="headerlink" title="三.栈和堆的溢出"></a>三.栈和堆的溢出</h3><p>栈：可以递归调用方法，这样随着栈深度的增加，JVM维持着一条长长的方法调用轨迹，知道内存不够分配，产生栈溢出。<br>堆：循环创建对象，通俗点就是不断的new 一个对象。</p>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>JS中的数据类型有两种，分别是基本数据类型和引用数据类型，前者存放在栈中，我们可以通过值的形式去访问；后者则是存放在堆和栈中，我们不能直接操作对象的堆内存空间，只能按照引用进行访问，即只能访问栈中的“地址”，这个地址指向存储在堆中的对象。</p>
<h4 id="自定义函数-–浅拷贝"><a href="#自定义函数-–浅拷贝" class="headerlink" title="自定义函数 –浅拷贝"></a>自定义函数 –浅拷贝</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj&#x3D;&#123;</span><br><span class="line">        name:&#39;zs&#39;,</span><br><span class="line">        age:18,</span><br><span class="line">        friends:[&#39;Kate&#39;,&#39;Bob&#39;,&#39;Mike&#39;],</span><br><span class="line">        hobby:&#123;</span><br><span class="line">            hobby1:&#39;codes&#39;,</span><br><span class="line">            hobby2:&#39;piano&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function copy(obj1)&#123;</span><br><span class="line">        var obj2&#x3D;&#123;&#125;;</span><br><span class="line">        for(var key in obj1)&#123;</span><br><span class="line">            obj2[key]&#x3D;obj1[key]</span><br><span class="line">        &#125;</span><br><span class="line">        return obj2;</span><br><span class="line">    &#125;</span><br><span class="line">    var result&#x3D;copy(obj);   </span><br><span class="line">    console.log(result.friends);&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br></pre></td></tr></table></figure>

<p>以上代码可以将obj的值完全拷贝给obj2，看起来确实没有问题，但是一旦修改了原始对象或者拷贝对象的引用类型的属性值，另一个对象的属性值也会发生相应的改变，很明显这并不是我们想要的。那么为什么修改基本类型的属性值并没有产生影响呢？那就要从浅拷贝原理说起了，其实浅拷贝只是拷贝一层，对于基本数据类型来说，拷贝的是值，而深层次对象级别的则是拷贝引用，也就是平常说的地址。既然拷贝的对象与原始对象指向的地址相同，那么二者便会相互影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.friends.push(&#39;Cherry&#39;);</span><br><span class="line"></span><br><span class="line">console.log(result.friends);&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;, &quot;Cherry&quot;]</span><br><span class="line"></span><br><span class="line">obj.name&#x3D;&#39;Rose&#39;;</span><br><span class="line"></span><br><span class="line">console.log(result.name);&#x2F;&#x2F;zs</span><br></pre></td></tr></table></figure>



<h4 id="es6的扩展运算符（…）–浅拷贝"><a href="#es6的扩展运算符（…）–浅拷贝" class="headerlink" title="es6的扩展运算符（…）–浅拷贝"></a>es6的扩展运算符（…）–浅拷贝</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let newObj &#x3D; &#123;...obj&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Object-assign-obj-–浅拷贝"><a href="#Object-assign-obj-–浅拷贝" class="headerlink" title="Object.assign(obj) –浅拷贝"></a>Object.assign(obj) –浅拷贝</h4><p>ES6中对象新增了一个assign方法，可以迅速实现<strong>浅拷贝</strong>，这里演示一下。当然这个方法也存在着引用拷贝互相影响的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj3&#x3D;Object.assign(obj);</span><br><span class="line"></span><br><span class="line">console.log(obj3.friends)&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br></pre></td></tr></table></figure>

<p>在拷贝完成后，我们希望两个对象之间互不影响，也就是说改变任一对象的属性，另一个对象都不会发生改变。那么怎样实现深拷贝呢？这里介绍两种方法，一种是通过JSON来实现，另一种是运用递归来解决。</p>
<h4 id="JSON-stringify-–深拷贝"><a href="#JSON-stringify-–深拷贝" class="headerlink" title="JSON.stringify –深拷贝"></a>JSON.stringify –深拷贝</h4><p>借用JSON的属性可以先用<code>JSON.stringify</code>把对象转成字符串，再用<code>JSON.parse</code>把字符串转成新的对象。当我们改变原始对象的属性值时，拷贝对象的属性并不会发生变化，但是这种方法存在一个弊端，我们无法拷贝原始对象的函数，因为函数是无法转成字符串的。于是，我们就可以考虑用递归的方法来解决问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepCopy(obj1)&#123;</span><br><span class="line">        var copyObj&#x3D;JSON.parse(JSON.stringify(obj1));</span><br><span class="line">        return copyObj;</span><br><span class="line">    &#125;</span><br><span class="line">    var result&#x3D;deepCopy(obj)</span><br><span class="line">    console.log(result.friends);&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br><span class="line">    obj.friends.push(&#39;Cherry&#39;);</span><br><span class="line">    console.log(result.friends);&#x2F;&#x2F; [&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br><span class="line">    console.log(obj.friends);&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;, &quot;Cherry&quot;]</span><br></pre></td></tr></table></figure>



<h4 id="递归-–深拷贝"><a href="#递归-–深拷贝" class="headerlink" title="递归 –深拷贝"></a>递归 –深拷贝</h4><p>终极办法：递归。因为我们无法确定原始对象里面的嵌套层数，因此可以借助递归的方法，再次调用拷贝函数，直到最深层数据为基本类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj&#x3D;&#123;</span><br><span class="line">        name:&#39;zs&#39;,</span><br><span class="line">        age:18,</span><br><span class="line">        friends:[&#39;Kate&#39;,&#39;Bob&#39;,&#39;Mike&#39;],</span><br><span class="line">        hobby:&#123;</span><br><span class="line">            hobby1:&#39;codes&#39;,</span><br><span class="line">            hobby2:&#39;piano&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    function deepCopy(origin,target)&#123;</span><br><span class="line">        &#x2F;&#x2F;目标值先置为空</span><br><span class="line">        var target&#x3D;null;</span><br><span class="line">        &#x2F;&#x2F;判断原始对象的数据类型</span><br><span class="line">        if(typeof origin&#x3D;&#x3D;&#x3D;&#39;object&#39;&amp;&amp;origin!&#x3D;&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;判断拷贝的是数组还是对象</span><br><span class="line">            target&#x3D;origin instanceof Array?[]:&#123;&#125;;</span><br><span class="line">            for(var key in origin)&#123;</span><br><span class="line">                &#x2F;&#x2F;递归拷贝</span><br><span class="line">                target[key]&#x3D;deepCopy(origin[key],target[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;基本类型直接赋值</span><br><span class="line">            target&#x3D;origin;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">    var newObj&#x3D;&#123;&#125;;</span><br><span class="line">    var result&#x3D;deepCopy(obj,newObj);</span><br><span class="line">    console.log(result);</span><br><span class="line">    obj.friends.push(&#39;Cherry&#39;);</span><br><span class="line">    console.log(result.friends);&#x2F;&#x2F; [&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br><span class="line">    console.log(obj.friends)&#x2F;&#x2F; [&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;, &quot;Cherry&quot;]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>深拷贝浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组方法-reduce</title>
    <url>/2020/08/25/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95-reduce/</url>
    <content><![CDATA[<h1 id="JS数组reduce-方法详解及高级技巧"><a href="#JS数组reduce-方法详解及高级技巧" class="headerlink" title="JS数组reduce()方法详解及高级技巧"></a>JS数组reduce()方法详解及高级技巧</h1><h4 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">arr</span><span class="selector-class">.reduce</span>(<span class="selector-tag">callback</span>,<span class="selector-attr">[initialValue]</span>)</span><br></pre></td></tr></table></figure>

<p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>.reduce(function(prev, currentValue, currentIndex, arr), initialValue)</span><br><span class="line"></span><br><span class="line">prev:表示上一次执行方法所返回的值，或者initialValue。（如果initialValue没有设置，则取<span class="built_in">array</span>中的第一个元素）</span><br><span class="line">currentValue:当前循环的<span class="built_in">array</span>的元素值</span><br><span class="line">currentIndex:当前循环的<span class="built_in">array</span>的元素值所对应的下标</span><br><span class="line">arr:表示当前所遍历的函数</span><br><span class="line">    </span><br><span class="line">initialValue:为prev指定一个初始值，可不写，则取<span class="built_in">array</span>的第一个元素</span><br></pre></td></tr></table></figure>



<h4 id="2、实例解析-initialValue-参数"><a href="#2、实例解析-initialValue-参数" class="headerlink" title="2、实例解析 initialValue 参数"></a>2、实例解析 initialValue 参数</h4><p>先看第一个例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果：<br> 1 2 1<br> 3 3 2<br> 6 4 3<br> [1, 2, 3, 4] 10</p>
</blockquote>
<p>这里可以看出，上面的例子index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。</p>
<p>再看第二个例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;，<span class="number">0</span>) <span class="comment">//注意这里设置了初始值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr, sum);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果：<br> 0 1 0<br> 1 2 1<br> 3 3 2<br> 6 4 3<br> [1, 2, 3, 4] 10</p>
</blockquote>
<p>这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。</p>
<p>结论：<code>如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。</code></p>
<p>注意：如果这个数组为空，运用reduce是什么情况？</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//报错，"TypeError: Reduce of empty array with no initial value"</span></span><br></pre></td></tr></table></figure>

<p>但是要是我们设置了初始值就不会报错，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;，<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [] 0</span></span><br></pre></td></tr></table></figure>

<p><strong>所以一般来说我们提供初始值通常更安全</strong></p>
<h4 id="3、initialValue-类型不同的区别"><a href="#3、initialValue-类型不同的区别" class="headerlink" title="3、initialValue 类型不同的区别"></a>3、initialValue 类型不同的区别</h4><p><strong>初始值为数值：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class="line">const sum &#x3D; arr.reduce(function (prev, current) &#123;</span><br><span class="line">	return prev+current</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(sum) &#x2F;&#x2F;55</span><br></pre></td></tr></table></figure>

<p>reduce根据函数传进来的初始值，不断回调叠加最终算出数组的和</p>
<p><strong>初始值为对象：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class="line">const sum &#x3D; arr.reduce(function (prev, current) &#123;</span><br><span class="line">    prev.count &#x3D; prev.count+current</span><br><span class="line">    return prev</span><br><span class="line">&#125;, &#123;count: 0&#125;)</span><br><span class="line">console.log(sum) &#x2F;&#x2F;&#123;count: 55&#125;</span><br></pre></td></tr></table></figure>

<p>如果初始值为对象的话，返回的也是一个对象</p>
<p><strong>初始值为数组：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str &#x3D; &#39;hello&#39;</span><br><span class="line">const newstr &#x3D; str.split(&#39;&#39;).reduce(function (prev, current) &#123;</span><br><span class="line">    const obj &#x3D; &#123;&#125;;</span><br><span class="line">    obj[current] &#x3D; current;</span><br><span class="line">    prev.push(obj)</span><br><span class="line">    return prev;</span><br><span class="line">&#125;, [])</span><br><span class="line">console.log(newstr)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    h: &#39;h&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    e: &#39;e&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    l: &#39;l&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    l: &#39;l&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    o: &#39;o&#39;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>如果初始值为数组，则返回的也是数组</p>
<h4 id="4、reduce的简单用法"><a href="#4、reduce的简单用法" class="headerlink" title="4、reduce的简单用法"></a>4、reduce的简单用法</h4><p>当然最简单的就是我们常用的数组求和，求乘积了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x+y)</span><br><span class="line"><span class="keyword">var</span> mul = arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x*y)</span><br><span class="line"><span class="built_in">console</span>.log( sum ); <span class="comment">//求和，10</span></span><br><span class="line"><span class="built_in">console</span>.log( mul ); <span class="comment">//求乘积，24</span></span><br></pre></td></tr></table></figure>



<p>计算数组最大值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(prev,cur);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="4、reduce的高级用法"><a href="#4、reduce的高级用法" class="headerlink" title="4、reduce的高级用法"></a>4、reduce的高级用法</h4><p>（1）计算数组中每个元素出现的次数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Bruce'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nameNum = names.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cur <span class="keyword">in</span> pre)&#123;</span><br><span class="line">    pre[cur]++</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    pre[cur] = <span class="number">1</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre</span><br><span class="line">&#125;,&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(nameNum); <span class="comment">//&#123;Alice: 2, Bob: 1, Tiff: 1, Bruce: 1&#125;</span></span><br></pre></td></tr></table></figure>



<p>（2）数组去重</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">方法一</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur,index,curarr</span>) </span>&#123;</span><br><span class="line">    prev.indexOf(cur) === <span class="number">-1</span> &amp;&amp; prev.push(cur);</span><br><span class="line">    <span class="comment">//这里表示prev第一次去设置的init值[]，当满足当前的新数组没有cur（当前元素）时才执行push</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;,[]);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pre.includes(cur))&#123;</span><br><span class="line">      <span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>（3）将二维数组转化为一维</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>



<p>（3）将多维数组转化为一维</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]]</span><br><span class="line"><span class="keyword">const</span> newArr = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>pre.concat(<span class="built_in">Array</span>.isArray(cur)?newArr(cur):cur),[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr(arr)); <span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>



<p>（4）对象里的属性求和</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'math'</span>,</span><br><span class="line">        score: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'chinese'</span>,</span><br><span class="line">        score: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'english'</span>,</span><br><span class="line">        score: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cur.score + prev;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">//60</span></span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://www.jianshu.com/p/e375ba1cfc47" target="_blank" rel="noopener">https://www.jianshu.com/p/e375ba1cfc47</a></p>
<p>参考链接：<a href="https://blog.csdn.net/hope93/article/details/86528183" target="_blank" rel="noopener">https://blog.csdn.net/hope93/article/details/86528183</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组方法之sort</title>
    <url>/2020/09/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E4%B9%8Bsort/</url>
    <content><![CDATA[<p><strong>总之：return -1 和return b-a是降序</strong></p>
<p><strong>总之：return 1 和return a-b是升序</strong></p>
<p><strong><code>sort()</code></strong> 方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串<strong><code>Unicode</code></strong>码点。<br>语法：arrayObject.sort(sortby)；参数sortby可选。规定排序顺序。必须是函数。<br>注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<a id="more"></a>

<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：<br>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p>
<p>例1：我们将创建一个数组，并按字母顺序进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; new Array(6)</span><br><span class="line">arr[0] &#x3D; &quot;George&quot;</span><br><span class="line">arr[1] &#x3D; &quot;John&quot;</span><br><span class="line">arr[2] &#x3D; &quot;Thomas&quot;</span><br><span class="line">arr[3] &#x3D; &quot;James&quot;</span><br><span class="line">arr[4] &#x3D; &quot;Adrew&quot;</span><br><span class="line">arr[5] &#x3D; &quot;Martin&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br &#x2F;&gt;&quot;)</span><br><span class="line">document.write(arr.sort())</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">George,John,Thomas,James,Adrew,Martin</span><br><span class="line">Adrew,George,James,John,Martin,Thomas</span><br></pre></td></tr></table></figure>

<p>例2：我们将创建一个数组，并按字母顺序进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; new Array(6)</span><br><span class="line">arr[0] &#x3D; &quot;10&quot;</span><br><span class="line">arr[1] &#x3D; &quot;5&quot;</span><br><span class="line">arr[2] &#x3D; &quot;40&quot;</span><br><span class="line">arr[3] &#x3D; &quot;25&quot;</span><br><span class="line">arr[4] &#x3D; &quot;1000&quot;</span><br><span class="line">arr[5] &#x3D; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br &#x2F;&gt;&quot;)</span><br><span class="line">document.write(arr.sort())</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10,5,40,25,1000,1</span><br><span class="line">1,10,1000,25,40,5</span><br></pre></td></tr></table></figure>

<p>请注意，上面的代码没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">function sortNumber(a,b)</span><br><span class="line">&#123;</span><br><span class="line">return a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; new Array(6)</span><br><span class="line">arr[0] &#x3D; &quot;10&quot;</span><br><span class="line">arr[1] &#x3D; &quot;5&quot;</span><br><span class="line">arr[2] &#x3D; &quot;40&quot;</span><br><span class="line">arr[3] &#x3D; &quot;25&quot;</span><br><span class="line">arr[4] &#x3D; &quot;1000&quot;</span><br><span class="line">arr[5] &#x3D; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br &#x2F;&gt;&quot;)</span><br><span class="line">document.write(arr.sort(sortNumber))</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10,5,40,25,1000,1</span><br><span class="line">1,5,10,25,40,1000</span><br></pre></td></tr></table></figure>

<h3 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h3><p>这里可以看出，如果安装升序排列，那么方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sortNumber(a,b)&#123;</span><br><span class="line">    return a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是按照降序排列则为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sortNumber(a,b)&#123;</span><br><span class="line">    return b - a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组对象中的某个属性值进行排序"><a href="#数组对象中的某个属性值进行排序" class="headerlink" title="数组对象中的某个属性值进行排序"></a>数组对象中的某个属性值进行排序</h3><p><code>sort</code>方法接收一个函数作为参数，这里嵌套一层函数用来接收对象属性名，其他部分代码与正常使用<code>sort</code>方法相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [</span><br><span class="line">    &#123;name:&#39;zopp&#39;,age:0&#125;,</span><br><span class="line">    &#123;name:&#39;gpp&#39;,age:18&#125;,</span><br><span class="line">    &#123;name:&#39;yjj&#39;,age:8&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function compare(property)&#123;</span><br><span class="line">    return function(a,b)&#123;</span><br><span class="line">        var value1 &#x3D; a[property];</span><br><span class="line">        var value2 &#x3D; b[property];</span><br><span class="line">        return value1 - value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var compare &#x3D; function (prop) &#123;</span><br><span class="line">  return function (obj1, obj2) &#123;</span><br><span class="line">      var val1 &#x3D; obj1[prop];</span><br><span class="line">      var val2 &#x3D; obj2[prop];</span><br><span class="line">      if (!isNaN(Number(val1)) &amp;&amp; !isNaN(Number(val2))) &#123;</span><br><span class="line">          val1 &#x3D; Number(val1);</span><br><span class="line">          val2 &#x3D; Number(val2);</span><br><span class="line">      &#125;</span><br><span class="line">      if (val1 &lt; val2) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">      &#125; else if (val1 &gt; val2) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.sort(compare(&#39;age&#39;)))</span><br></pre></td></tr></table></figure>

<p>结果如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/595142/201705/595142-20170515085841119-1950402124.png" alt="img"></p>
<h3 id="根据参数不同，来确定是升序排列，还是降序排序"><a href="#根据参数不同，来确定是升序排列，还是降序排序" class="headerlink" title="根据参数不同，来确定是升序排列，还是降序排序"></a>根据参数不同，来确定是升序排列，还是降序排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sortBy: function(attr,rev)&#123;</span><br><span class="line">    &#x2F;&#x2F;第二个参数没有传递 默认升序排列</span><br><span class="line">    if(rev &#x3D;&#x3D;  undefined)&#123;</span><br><span class="line">        rev &#x3D; 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        rev &#x3D; (rev) ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return function(a,b)&#123;</span><br><span class="line">        a &#x3D; a[attr];</span><br><span class="line">        b &#x3D; b[attr];</span><br><span class="line">        if(a &lt; b)&#123;</span><br><span class="line">            return rev * -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a &gt; b)&#123;</span><br><span class="line">            return rev * 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newArray.sort(sortBy(&#39;number&#39;,false))</span><br></pre></td></tr></table></figure>

<h3 id="某个属性值相同时，根据另一个属性排序"><a href="#某个属性值相同时，根据另一个属性排序" class="headerlink" title="某个属性值相同时，根据另一个属性排序"></a>某个属性值相同时，根据另一个属性排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D; [ </span><br><span class="line">    &#123; &#39;sortNo&#39;: 2, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 1, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 5, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 6, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 7, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 3, &#39;sortNo2&#39;: 4&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 3, &#39;sortNo2&#39;: 2&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 3, &#39;sortNo2&#39;: 1&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 3, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 8, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 4, &#39;sortNo2&#39;: 1&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 4, &#39;sortNo2&#39;: 2&#125;</span><br><span class="line">];</span><br><span class="line">arr.sort(function(a, b)&#123;</span><br><span class="line">    if (a.sortNo &#x3D;&#x3D;&#x3D; b.sortNo) &#123;</span><br><span class="line">            return b.sortNo2 - a.sortNo2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            return a.sortNo - b.sortNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>js方法（一）</title>
    <url>/2020/07/23/js%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="获取服务器时间"><a href="#获取服务器时间" class="headerlink" title="获取服务器时间"></a>获取服务器时间</h3><a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、依赖jQuery</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServerDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>($.ajax(&#123; <span class="attr">async</span>: <span class="literal">false</span> &#125;).getResponseHeader(<span class="string">"Date"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>、原生</span><br><span class="line">（同步）</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServerDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> <span class="built_in">window</span>.XMLHttpRequest();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// ie</span></span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveObject(<span class="string">"Microsoft"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, <span class="string">"/"</span>, <span class="literal">false</span>)<span class="comment">//false不可变</span></span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">var</span> date = xhr.getResponseHeader(<span class="string">"Date"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">&#125;</span><br><span class="line">（异步）</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServerDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> <span class="built_in">window</span>.XMLHttpRequest();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// ie</span></span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveObject(<span class="string">"Microsoft"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, <span class="string">"/"</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> time, date;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">2</span>) &#123;</span><br><span class="line">      time = xhr.getResponseHeader(<span class="string">"Date"</span>);</span><br><span class="line">      date = <span class="keyword">new</span> <span class="built_in">Date</span>(time);</span><br><span class="line">      <span class="built_in">console</span>.log(date);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="userAgent"><a href="#userAgent" class="headerlink" title="userAgent"></a>userAgent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">userAgent属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。</span><br><span class="line"></span><br><span class="line">一般来讲，它是在 navigator.appCodeName 的值之后加上斜线和 navigator.appVersion 的值构成的。</span><br><span class="line"></span><br><span class="line">例如：Mozilla / <span class="number">4.0</span>(compatible; MSIE <span class="number">6.0</span>; Windows NT <span class="number">5.2</span>; SV1; .NET CLR <span class="number">1.1</span><span class="number">.4322</span>) 。</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;浏览器："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.appName + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">浏览器：Netscape</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;浏览器版本："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.appVersion + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">浏览器版本：<span class="number">5.0</span>(Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit / <span class="number">537.36</span>(KHTML, like Gecko) Chrome / <span class="number">77.0</span><span class="number">.3865</span><span class="number">.120</span> Safari / <span class="number">537.36</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;代码："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.appCodeName + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">代码：Mozilla</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;平台："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.platform + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">平台：Win32</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;Cookies 启用："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.cookieEnabled + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">Cookies 启用：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;浏览器的用户代理报头："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.userAgent + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">浏览器的用户代理报头：Mozilla / <span class="number">5.0</span>(Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit / <span class="number">537.36</span>(KHTML, like Gecko) Chrome / <span class="number">77.0</span><span class="number">.3865</span><span class="number">.120</span> Safari / <span class="number">537.36</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b_version = navigator.appVersion</span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">parseFloat</span>(b_version)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器版本："</span> + version)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、通过判断浏览器的userAgent，用正则来判断是否是ios和Android客户端。代码如下：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、检查是否是移动端（Mobile）、ipad、iphone、微信、QQ等：</span><br><span class="line"></span><br><span class="line">使用方法：</span><br><span class="line"></span><br><span class="line">检测浏览器语言：</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、判断iPhone | iPad | iPod | iOS | Android客户端：</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、判断pc还是移动端：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line"><span class="keyword">var</span> isAndroid = u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>; <span class="comment">//android终端</span></span><br><span class="line"><span class="keyword">var</span> isiOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端</span></span><br></pre></td></tr></table></figure>

<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deepClone: function (obj) &#123;</span><br><span class="line">    var _obj &#x3D; JSON.stringify(obj),</span><br><span class="line">    objClone &#x3D; JSON.parse(_obj);</span><br><span class="line">    return objClone</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="获取url参数"><a href="#获取url参数" class="headerlink" title="获取url参数"></a>获取url参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getUrlParam = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = location.search;</span><br><span class="line">    <span class="keyword">var</span> theRequest = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">"?"</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = url.substr(<span class="number">1</span>);</span><br><span class="line">        strs = str.split(<span class="string">"&amp;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            theRequest[strs[i].split(<span class="string">"="</span>)[<span class="number">0</span>]] = strs[i].split(<span class="string">"="</span>)[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> theRequest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="encodeURI-和encodeURIComponent-decodeURI-和decodeURIComponent"><a href="#encodeURI-和encodeURIComponent-decodeURI-和decodeURIComponent" class="headerlink" title="encodeURI()和encodeURIComponent()  decodeURI()和decodeURIComponent()"></a>encodeURI()和encodeURIComponent()  decodeURI()和decodeURIComponent()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其中encodeURI()主要用于整个URI(例如，http:&#x2F;&#x2F;www.jxbh.cn&#x2F;illegal value.htm)，而encode-URIComponent()主要用于对URI中的某一段(例如前面URI中的illegal value．htm)进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。来看下面的例子：</span><br><span class="line">var uri&#x3D;&quot;http:&#x2F;&#x2F;www.jxbh.cn&#x2F;illegal value.htm#start&quot;;</span><br><span class="line">&#x2F;&#x2F;”http: &#x2F;&#x2F;www.jxbh.cn&#x2F;illegal%20value .htm#s tart”</span><br><span class="line">alert(encodeURI (uri)):</span><br><span class="line">&#x2F;&#x2F;”http% 3A%2F%2Fwww.jxbh.cn%2 Fillegal%2 0value. htm%23 start”</span><br><span class="line">alert( encodaURIComponent (uri));</span><br><span class="line">使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()的原因所在。一般来说,我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多,因为在实践中更常见的是对查询字符串参数而不是对基础URL进行编码.</span><br><span class="line">经我的观测，很多网站的cookie在进行编码的时候，是encodeURIComponent格式的，所以应该使用decodeURIComponent()进行解码</span><br></pre></td></tr></table></figure>





<h3 id="True与False"><a href="#True与False" class="headerlink" title="True与False"></a>True与False</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">以下是Truthy (真值)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> ([])</span><br><span class="line"><span class="keyword">if</span> (<span class="number">42</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"foo"</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-42</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-3.14</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">Infinity</span>)</span><br><span class="line"><span class="keyword">if</span> (-<span class="literal">Infinity</span>)</span><br><span class="line">  </span><br><span class="line">以下是falsy  值</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NaN</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">""</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">``</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all)</span><br></pre></td></tr></table></figure>

<h3 id="ios下时间格式问题"><a href="#ios下时间格式问题" class="headerlink" title="ios下时间格式问题"></a>ios下时间格式问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2016-08-09 00:00:00'</span>).getTime（） <span class="comment">//拿到的值是NaN</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2016-08-09'</span>).getTime（） <span class="comment">//正常</span></span><br><span class="line">原因：ios下不支持<span class="string">'-'</span>格式的时间可以支持<span class="string">'/'</span></span><br><span class="line">解决方案：改成<span class="string">'yy/mm/dd'</span></span><br></pre></td></tr></table></figure>



<h3 id="打印周几"><a href="#打印周几" class="headerlink" title="打印周几"></a>打印周几</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> week=[<span class="string">'星期日'</span>,<span class="string">'星期一'</span>,<span class="string">'星期二'</span>,<span class="string">'星期三'</span>,<span class="string">'星期四'</span>,<span class="string">'星期五'</span>,<span class="string">'星期六'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">document</span>.write(week[date.getDay()])</span><br></pre></td></tr></table></figure>



<h3 id="js-判断当前时间是否处于某个时间段内"><a href="#js-判断当前时间是否处于某个时间段内" class="headerlink" title="js 判断当前时间是否处于某个时间段内"></a>js 判断当前时间是否处于某个时间段内</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isDuringDate: function (beginDateStr, endDateStr) &#123;</span><br><span class="line">    var curDate &#x3D; new Date(),</span><br><span class="line">    beginDate &#x3D; new Date(beginDateStr),</span><br><span class="line">    endDate &#x3D; new Date(endDateStr);</span><br><span class="line">    if (curDate &gt;&#x3D; beginDate &amp;&amp; curDate &lt;&#x3D; endDate) &#123;</span><br><span class="line">    	return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">isDuringDate(&#39;2018&#x2F;09&#x2F;17&#39;, &#39;2030&#x2F;09&#x2F;17&#39;)</span><br></pre></td></tr></table></figure>





<h3 id="当前时间加半个小时"><a href="#当前时间加半个小时" class="headerlink" title="当前时间加半个小时"></a>当前时间加半个小时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">当前时间加上半个小时一个小时等</span><br><span class="line">getHourDate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    date.setTime(date.getTime() + <span class="number">0.5</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">var</span> FullYear = date.getFullYear();</span><br><span class="line">    <span class="keyword">var</span> month = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> dd = date.getDate();</span><br><span class="line">    <span class="keyword">var</span> hh = date.getHours();</span><br><span class="line">    <span class="keyword">var</span> mm = date.getMinutes();</span><br><span class="line">    <span class="keyword">return</span> FullYear + <span class="string">"-"</span> + month + <span class="string">"-"</span> + dd + <span class="string">" "</span> + hh + <span class="string">":"</span> + mm + <span class="string">":00"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="当前时间与目标时间倒计时到达"><a href="#当前时间与目标时间倒计时到达" class="headerlink" title="当前时间与目标时间倒计时到达"></a>当前时间与目标时间倒计时到达</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">countTime: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前时间  </span></span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> now = date.getTime();</span><br><span class="line">    <span class="comment">//设置截止时间  </span></span><br><span class="line">    <span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.endDate.replace(<span class="regexp">/-/g</span>, <span class="string">'/'</span>));</span><br><span class="line">    <span class="keyword">var</span> end = endDate.getTime();</span><br><span class="line">    <span class="comment">//时间差</span></span><br><span class="line">    <span class="keyword">var</span> leftTime = <span class="keyword">this</span>.leftTime = end - now;</span><br><span class="line">    <span class="comment">//定义变量 d,h,m,s保存倒计时的时间  </span></span><br><span class="line">    <span class="keyword">var</span> d, h, m, s;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.leftTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        d = <span class="built_in">Math</span>.floor(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span><br><span class="line">        h = <span class="built_in">Math</span>.floor(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> % <span class="number">24</span>);</span><br><span class="line">        m = <span class="built_in">Math</span>.floor(leftTime / <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">        s = <span class="built_in">Math</span>.floor(leftTime / <span class="number">1000</span> % <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">this</span>.leftStr = d + <span class="string">"天"</span> + h + <span class="string">"时"</span> + m + <span class="string">"分"</span> + s + <span class="string">"秒"</span></span><br><span class="line">        setTimeout(<span class="keyword">this</span>.countTime, <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.isCanPay = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="将当前时间转化为-2018-12-12-12-00-00"><a href="#将当前时间转化为-2018-12-12-12-00-00" class="headerlink" title="将当前时间转化为 2018-12-12 12:00:00"></a>将当前时间转化为 2018-12-12 12:00:00</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> formatDateTime = <span class="function"><span class="keyword">function</span> (<span class="params">date</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = date.getFullYear();</span><br><span class="line">    <span class="keyword">var</span> m = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">    m = m &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + m) : m;</span><br><span class="line">    <span class="keyword">var</span> d = date.getDate();</span><br><span class="line">    d = d &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + d) : d;</span><br><span class="line">    <span class="keyword">var</span> h = date.getHours();</span><br><span class="line">    h = h &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + h) : h;</span><br><span class="line">    <span class="keyword">var</span> minute = date.getMinutes();</span><br><span class="line">    minute = minute &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + minute) : minute;</span><br><span class="line">    <span class="keyword">var</span> second = date.getSeconds();</span><br><span class="line">    second = second &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + second) : second;</span><br><span class="line">    <span class="keyword">return</span> y + <span class="string">'-'</span> + m + <span class="string">'-'</span> + d + <span class="string">' '</span> + h + <span class="string">':'</span> + minute + <span class="string">':'</span> + second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="判断当前日期是否离开"><a href="#判断当前日期是否离开" class="headerlink" title="判断当前日期是否离开"></a>判断当前日期是否<strong>离开</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">departTimeHandle: <span class="function"><span class="keyword">function</span> (<span class="params">departTime</span>) </span>&#123;</span><br><span class="line">    diff = <span class="keyword">new</span> <span class="built_in">Date</span>(departTime.replace(<span class="regexp">/\-/g</span>, <span class="string">"/"</span>)).getTime() - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        alert(<span class="string">'未出发'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'已离开'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="计算两个时间的分钟差"><a href="#计算两个时间的分钟差" class="headerlink" title="计算两个时间的分钟差"></a>计算两个时间的分钟差</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeDifference</span>(<span class="params">time1, time2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//截取字符串，得到日期部分"2009-12-02",用split把字符串分隔成数组</span></span><br><span class="line">    <span class="keyword">var</span> begin1 = time1.substr(<span class="number">0</span>, <span class="number">10</span>).split(<span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">var</span> end1 = time2.substr(<span class="number">0</span>, <span class="number">10</span>).split(<span class="string">"-"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将拆分的数组重新组合，并实例成化新的日期对象</span></span><br><span class="line">    <span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(begin1[<span class="number">1</span>] + - + begin1[<span class="number">2</span>] + - + begin1[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(end1[<span class="number">1</span>] + - + end1[<span class="number">2</span>] + - + end1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到两个日期之间的差值m，以分钟为单位</span></span><br><span class="line">    <span class="comment">//Math.abs(date2-date1)计算出以毫秒为单位的差值</span></span><br><span class="line">    <span class="comment">//Math.abs(date2-date1)/1000得到以秒为单位的差值</span></span><br><span class="line">    <span class="comment">//Math.abs(date2-date1)/1000/60得到以分钟为单位的差值</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.abs(date2 - date1) / <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小时数和分钟数相加得到总的分钟数</span></span><br><span class="line">    <span class="comment">//time1.substr(11,2)截取字符串得到时间的小时数</span></span><br><span class="line">    <span class="comment">//parseInt(time1.substr(11,2))*60把小时数转化成为分钟</span></span><br><span class="line">    <span class="keyword">var</span> min1 = <span class="built_in">parseInt</span>(time1.substr(<span class="number">11</span>, <span class="number">2</span>)) * <span class="number">60</span> + <span class="built_in">parseInt</span>(time1.substr(<span class="number">14</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">var</span> min2 = <span class="built_in">parseInt</span>(time2.substr(<span class="number">11</span>, <span class="number">2</span>)) * <span class="number">60</span> + <span class="built_in">parseInt</span>(time2.substr(<span class="number">14</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个分钟数相减得到时间部分的差值，以分钟为单位</span></span><br><span class="line">    <span class="keyword">var</span> n = min2 - min1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将日期和时间两个部分计算出来的差值相加，即得到两个时间相减后的分钟数</span></span><br><span class="line">    <span class="keyword">var</span> minutes = m + n;</span><br><span class="line">    <span class="built_in">document</span>.writeln(minutes);</span><br><span class="line">&#125;</span><br><span class="line">TimeDifference(<span class="string">"2019-08-12 15:21:00"</span>, <span class="string">"2019-08-21 10:18:34"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="距离当前日期多少天后的日期"><a href="#距离当前日期多少天后的日期" class="headerlink" title="距离当前日期多少天后的日期"></a>距离当前日期多少天后的日期</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetDateStr</span>(<span class="params">AddDayCount</span>) </span>&#123;   </span><br><span class="line">      <span class="keyword">var</span> dd = <span class="keyword">new</span> <span class="built_in">Date</span>();  </span><br><span class="line">      dd.setDate(dd.getDate()+AddDayCount);<span class="comment">//获取AddDayCount天后的日期</span></span><br><span class="line">      <span class="keyword">var</span> y = dd.getFullYear();   </span><br><span class="line">      <span class="keyword">var</span> m = (dd.getMonth()+<span class="number">1</span>)&lt;<span class="number">10</span>?<span class="string">"0"</span>+(dd.getMonth()+<span class="number">1</span>):(dd.getMonth()+<span class="number">1</span>);<span class="comment">//获取当前月份的日期，不足10补0</span></span><br><span class="line">      <span class="keyword">var</span> d = dd.getDate()&lt;<span class="number">10</span>?<span class="string">"0"</span>+dd.getDate():dd.getDate();<span class="comment">//获取当前几号，不足10补0</span></span><br><span class="line">      <span class="keyword">return</span> y+<span class="string">"-"</span>+m+<span class="string">"-"</span>+d;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Date-1556121600000-’和‘-Date-1528953453022-0800-’日期格式处理"><a href="#Date-1556121600000-’和‘-Date-1528953453022-0800-’日期格式处理" class="headerlink" title="/Date(1556121600000)/’和‘/Date(1528953453022+0800)/’日期格式处理"></a>/Date(1556121600000)/’和‘/Date(1528953453022+0800)/’日期格式处理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handelTime</span>(<span class="params">strTime</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">parseInt</span>(strTime.replace(<span class="string">"/Date("</span>, <span class="string">""</span>).replace(<span class="string">")/"</span>, <span class="string">""</span>), <span class="number">10</span>));</span><br><span class="line">       <span class="keyword">return</span> obj.toLocaleDateString();</span><br><span class="line">&#125;</span><br><span class="line">handelTime(<span class="string">'\/Date(1556121600000)\/'</span>)</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">dt</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> year = dt.getFullYear(); </span><br><span class="line">  <span class="keyword">var</span> month = dt.getMonth() + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">var</span> date = dt.getDate(); </span><br><span class="line">  <span class="keyword">var</span> hour = dt.getHours(); </span><br><span class="line">  <span class="keyword">var</span> minute = dt.getMinutes(); </span><br><span class="line">  <span class="keyword">var</span> second = dt.getSeconds(); </span><br><span class="line">  <span class="keyword">return</span> year + <span class="string">"-"</span> + month + <span class="string">"-"</span> + date + <span class="string">" "</span> + hour + <span class="string">":"</span> + minute + <span class="string">":"</span> + second; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">time</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">var</span> t= time.slice(<span class="number">6</span>, <span class="number">19</span>) </span><br><span class="line">	<span class="keyword">var</span> NewDtime = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">parseInt</span>(t)); </span><br><span class="line">	<span class="keyword">return</span> formatDate(NewDtime); </span><br><span class="line">&#125; </span><br><span class="line">Test(<span class="string">"/Date(1528953453022+0800)/"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="验证码60s"><a href="#验证码60s" class="headerlink" title="验证码60s"></a>验证码60s</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getCountDown(time=<span class="number">60</span>) &#123; <span class="comment">//验证码一分钟倒计时</span></span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">parseInt</span>(time);</span><br><span class="line">  <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      sendMg: <span class="string">"获取验证码"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    time: <span class="built_in">parseInt</span>(time) - <span class="number">1</span>,</span><br><span class="line">    sendMg: <span class="string">"剩余"</span> + time + <span class="string">"S"</span></span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(<span class="keyword">this</span>.getCountDown, <span class="number">1000</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="距离当天24点前倒计时"><a href="#距离当天24点前倒计时" class="headerlink" title="距离当天24点前倒计时"></a>距离当天24点前倒计时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCountDown: <span class="function"><span class="keyword">function</span> (<span class="params">endTime=<span class="string">'2020-07-29 00:00:00'</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();<span class="comment">//现在时间（时间戳）</span></span><br><span class="line">    <span class="keyword">var</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>(endTime).getTime();<span class="comment">//结束时间（时间戳）</span></span><br><span class="line">    <span class="keyword">var</span> intDiff = (endTime - nowTime) / <span class="number">1000</span>;<span class="comment">//距离结束的毫秒数</span></span><br><span class="line">    <span class="keyword">var</span> day = <span class="number">0</span>,</span><br><span class="line">      hour = <span class="number">24</span>,</span><br><span class="line">      minute = <span class="number">60</span>,</span><br><span class="line">      second = <span class="number">60</span>;<span class="comment">//时间默认值</span></span><br><span class="line">    <span class="keyword">if</span> (intDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      day = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line">      hour = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span>)) - (day * <span class="number">24</span>);</span><br><span class="line">      minute = <span class="built_in">Math</span>.floor(intDiff / <span class="number">60</span>) - (day * <span class="number">24</span> * <span class="number">60</span>) - (hour * <span class="number">60</span>);</span><br><span class="line">      second = <span class="built_in">Math</span>.floor(intDiff) - (day * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) - (hour * <span class="number">60</span> * <span class="number">60</span>) - (minute * <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hour &lt;= <span class="number">9</span>) hour = <span class="string">'0'</span> + hour;</span><br><span class="line">    <span class="keyword">if</span> (minute &lt;= <span class="number">9</span>) minute = <span class="string">'0'</span> + minute;</span><br><span class="line">    <span class="keyword">if</span> (second &lt;= <span class="number">9</span>) second = <span class="string">'0'</span> + second;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      showTime: day + <span class="string">':'</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second</span><br><span class="line">    &#125;)</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.setCountDown, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h3 id="支付半小时倒计时"><a href="#支付半小时倒计时" class="headerlink" title="支付半小时倒计时"></a>支付半小时倒计时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCountDown: <span class="function"><span class="keyword">function</span> (<span class="params">Time = <span class="string">'2020-07-28 16:25:00'</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> setTime = <span class="number">0.5</span> * <span class="number">3600</span> * <span class="number">1000</span>;<span class="comment">//半个小时的毫秒数</span></span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();<span class="comment">//现在时间（时间戳）</span></span><br><span class="line">    <span class="keyword">var</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>().setTime(<span class="keyword">new</span> <span class="built_in">Date</span>(Time).getTime() + setTime);<span class="comment">//距离参数半个小时后的时间</span></span><br><span class="line">    <span class="keyword">var</span> intDiff = (endTime - nowTime) / <span class="number">1000</span>;<span class="comment">//毫秒数差</span></span><br><span class="line">    <span class="keyword">var</span> day = <span class="number">0</span>,</span><br><span class="line">      hour = <span class="number">24</span>,</span><br><span class="line">      minute = <span class="number">60</span>,</span><br><span class="line">      second = <span class="number">60</span>;<span class="comment">//时间默认值</span></span><br><span class="line">    <span class="keyword">if</span> (intDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      day = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line">      hour = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span>)) - (day * <span class="number">24</span>);</span><br><span class="line">      minute = <span class="built_in">Math</span>.floor(intDiff / <span class="number">60</span>) - (day * <span class="number">24</span> * <span class="number">60</span>) - (hour * <span class="number">60</span>);</span><br><span class="line">      second = <span class="built_in">Math</span>.floor(intDiff) - (day * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) - (hour * <span class="number">60</span> * <span class="number">60</span>) - (minute * <span class="number">60</span>);</span><br><span class="line">      <span class="keyword">if</span> (hour &lt;= <span class="number">9</span>) hour = <span class="string">'0'</span> + hour;</span><br><span class="line">      <span class="keyword">if</span> (minute &lt;= <span class="number">9</span>) minute = <span class="string">'0'</span> + minute;</span><br><span class="line">      <span class="keyword">if</span> (second &lt;= <span class="number">9</span>) second = <span class="string">'0'</span> + second;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        showTime: day + <span class="string">':'</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        showTime: <span class="string">'00:00:00'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.setCountDown, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h3 id="遍历值键对"><a href="#遍历值键对" class="headerlink" title="遍历值键对"></a>遍历值键对</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test: &#123;</span><br><span class="line">                <span class="string">"阿巴嘎旗"</span>: &#123;</span><br><span class="line">                    <span class="string">"hot"</span>: <span class="number">10851</span>,</span><br><span class="line">                    <span class="string">"priority"</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"match"</span>: <span class="string">"abgq|abagaqi"</span>,</span><br><span class="line">                    <span class="string">"stationCode"</span>: <span class="string">"abagaqi"</span>,</span><br><span class="line">                    <span class="string">"cityId"</span>: <span class="number">269</span>,</span><br><span class="line">                    <span class="string">"cityName"</span>: <span class="string">"锡林郭勒盟"</span>,</span><br><span class="line">                    <span class="string">"provinceId"</span>: <span class="number">19</span>,</span><br><span class="line">                    <span class="string">"provinceName"</span>: <span class="string">"内蒙古"</span>,</span><br><span class="line">                    <span class="string">"longitude"</span>: <span class="string">"0.000000"</span>,</span><br><span class="line">                    <span class="string">"latitude"</span>: <span class="string">"0.000000"</span>,</span><br><span class="line">                    <span class="string">"siteCode"</span>: <span class="string">""</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"阿尔山"</span>: &#123;</span><br><span class="line">                    <span class="string">"hot"</span>: <span class="number">311502</span>,</span><br><span class="line">                    <span class="string">"priority"</span>: <span class="number">10</span>,</span><br><span class="line">                    <span class="string">"match"</span>: <span class="string">"aes|aershan"</span>,</span><br><span class="line">                    <span class="string">"stationCode"</span>: <span class="string">"aershan"</span>,</span><br><span class="line">                    <span class="string">"cityId"</span>: <span class="number">270</span>,</span><br><span class="line">                    <span class="string">"cityName"</span>: <span class="string">"兴安盟"</span>,</span><br><span class="line">                    <span class="string">"provinceId"</span>: <span class="number">19</span>,</span><br><span class="line">                    <span class="string">"provinceName"</span>: <span class="string">"内蒙古"</span>,</span><br><span class="line">                    <span class="string">"longitude"</span>: <span class="string">"119.954934"</span>,</span><br><span class="line">                    <span class="string">"latitude"</span>: <span class="string">"47.177865"</span>,</span><br><span class="line">                    <span class="string">"siteCode"</span>: <span class="string">""</span></span><br><span class="line">                &#125;,</span><br><span class="line">&#125;</span><br><span class="line">遍历方法：</span><br><span class="line"><span class="keyword">var</span> allcities = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> test) &#123;</span><br><span class="line">    <span class="keyword">var</span> city = [];</span><br><span class="line">    city.push(test[prop].provinceId, prop, <span class="string">'0'</span>, test[prop].match, test[prop].stationCode);</span><br><span class="line">    allcities.push(city);</span><br><span class="line">    <span class="comment">// console.log(test[prop]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">判断对象是否为空</span><br><span class="line">evtValue = &#123;&#125;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(evtValue) == <span class="string">'&#123;&#125;'</span></span><br><span class="line"><span class="built_in">Object</span>.keys(evtValue).length == <span class="number">0</span></span><br><span class="line">取对象的属性和值</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'叶落森'</span>, <span class="string">'sex'</span>: <span class="string">'女'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">Object</span>.keys(obj); --可以获取key值</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="built_in">Object</span>.values(obj); --可以获取value值</span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// ['id','name','sex']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">//  ['1','叶落森','女']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">1</span>]);  <span class="comment">// 叶落森</span></span><br></pre></td></tr></table></figure>



<h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、window.location具有以下属性：</span><br><span class="line"></span><br><span class="line">1、window.location.href：取得当前地址栏中的完整URL，可以通过赋值改变当前地址栏中的URL；</span><br><span class="line"></span><br><span class="line">2、window.location.search 取得当前URL的参数部分，即“?”后面的部分（包括问号），可以通过赋值改变URL的参数部分；</span><br><span class="line"></span><br><span class="line">3、window.location.host：取得当前URL中的主机信息，包括端口号，可以通过赋值改变主机信息；</span><br><span class="line"></span><br><span class="line">4、window.location.port：取得当前URL中的端口号，可以通过赋值改变端口号；</span><br><span class="line"></span><br><span class="line">5、window.location.pathname：取得当前URL中的路径信息，即域名与参数之间的部分，可以通过赋值改变当前URL的路径；</span><br><span class="line"></span><br><span class="line">6、window.location.protocol：取得当前URL的协议部分，比如http:，https:等，可以通过赋值改变URL的协议部分；</span><br><span class="line"></span><br><span class="line">设置有以下方法：</span><br><span class="line"></span><br><span class="line">1、window.location.replace(url)：用传入的URL字符串替代当前的URL，该方法会将历史记录中的URL一并替换掉，也就是说，这个方法会覆盖之前的历史记录；</span><br><span class="line"></span><br><span class="line">2、window.location.reload()：重新加载当前URL，相当于刷新；</span><br><span class="line"></span><br><span class="line">3、window.location.assign(url)：加载传入的URL，该方法不会覆盖之前的历史记录；</span><br><span class="line"></span><br><span class="line">if(&quot;https:&quot; &#x3D;&#x3D; document.location.protocol </span><br><span class="line">     alert(&quot;HTTPS&quot;)</span><br><span class="line"> );</span><br><span class="line">document.location.protocol</span><br><span class="line">可设置或返回当前 URL 的协议</span><br></pre></td></tr></table></figure>



<h3 id="判断机型–iphoneX"><a href="#判断机型–iphoneX" class="headerlink" title="判断机型–iphoneX"></a>判断机型–iphoneX</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIphoneX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/iphone/gi</span>.test(navigator.userAgent) &amp;&amp; (screen.height == <span class="number">812</span> &amp;&amp; screen.width == <span class="number">375</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="js实现根据身份证号码识别-性别-年龄-生日"><a href="#js实现根据身份证号码识别-性别-年龄-生日" class="headerlink" title="js实现根据身份证号码识别 性别 年龄 生日"></a>js实现根据身份证号码识别 性别 年龄 生日</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discriCard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取输入身份证号码 </span></span><br><span class="line">    <span class="keyword">var</span> UUserCard = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//获取出生日期 </span></span><br><span class="line">    UUserCard.substring(<span class="number">6</span>, <span class="number">10</span>) + <span class="string">"-"</span> + UUserCard.substring(<span class="number">10</span>, <span class="number">12</span>) + <span class="string">"-"</span> + UUserCard.substring(<span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//获取性别 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(UUserCard.substr(<span class="number">16</span>, <span class="number">1</span>)) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        alert(<span class="string">"男"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"女"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取年龄 </span></span><br><span class="line">    <span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> month = myDate.getMonth() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> day = myDate.getDate();</span><br><span class="line">    <span class="keyword">var</span> age = myDate.getFullYear() - UUserCard.substring(<span class="number">6</span>, <span class="number">10</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (UUserCard.substring(<span class="number">10</span>, <span class="number">12</span>) &lt; month || UUserCard.substring(<span class="number">10</span>, <span class="number">12</span>) == month &amp;&amp; UUserCard.substring(<span class="number">12</span>, <span class="number">14</span>) &lt;= day) &#123;</span><br><span class="line">        age++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//年龄 age </span></span><br><span class="line">    alert(age)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="验证身份证有木有18周岁"><a href="#验证身份证有木有18周岁" class="headerlink" title="验证身份证有木有18周岁"></a>验证身份证有木有18周岁</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> strBirthday = num.substr(<span class="number">6</span>, <span class="number">4</span>) + <span class="string">"/"</span> + num.substr(<span class="number">10</span>, <span class="number">2</span>) + <span class="string">"/"</span> + num.substr(<span class="number">12</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> birthDate = <span class="keyword">new</span> <span class="built_in">Date</span>(strBirthday);</span><br><span class="line"><span class="keyword">var</span> nowDateTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> age = nowDateTime.getFullYear() - birthDate.getFullYear();</span><br><span class="line"><span class="keyword">if</span> (nowDateTime.getMonth() &lt; birthDate.getMonth() || (nowDateTime.getMonth() == birthDate.getMonth() &amp;&amp; nowDateTime.getDate() &lt; birthDate.getDate())) &#123;</span><br><span class="line">    age--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="身份证是否合法"><a href="#身份证是否合法" class="headerlink" title="身份证是否合法"></a>身份证是否合法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">验证身份证号方法</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdentityCodeValid = <span class="function">(<span class="params">code</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> city=&#123;<span class="number">11</span>:<span class="string">"北京"</span>,<span class="number">12</span>:<span class="string">"天津"</span>,<span class="number">13</span>:<span class="string">"河北"</span>,<span class="number">14</span>:<span class="string">"山西"</span>,<span class="number">15</span>:<span class="string">"内蒙古"</span>,<span class="number">21</span>:<span class="string">"辽宁"</span>,<span class="number">22</span>:<span class="string">"吉林"</span>,<span class="number">23</span>:<span class="string">"黑龙江 "</span>,<span class="number">31</span>:<span class="string">"上海"</span>,<span class="number">32</span>:<span class="string">"江苏"</span>,<span class="number">33</span>:<span class="string">"浙江"</span>,<span class="number">34</span>:<span class="string">"安徽"</span>,<span class="number">35</span>:<span class="string">"福建"</span>,<span class="number">36</span>:<span class="string">"江西"</span>,<span class="number">37</span>:<span class="string">"山东"</span>,<span class="number">41</span>:<span class="string">"河南"</span>,<span class="number">42</span>:<span class="string">"湖北 "</span>,<span class="number">43</span>:<span class="string">"湖南"</span>,<span class="number">44</span>:<span class="string">"广东"</span>,<span class="number">45</span>:<span class="string">"广西"</span>,<span class="number">46</span>:<span class="string">"海南"</span>,<span class="number">50</span>:<span class="string">"重庆"</span>,<span class="number">51</span>:<span class="string">"四川"</span>,<span class="number">52</span>:<span class="string">"贵州"</span>,<span class="number">53</span>:<span class="string">"云南"</span>,<span class="number">54</span>:<span class="string">"西藏 "</span>,<span class="number">61</span>:<span class="string">"陕西"</span>,<span class="number">62</span>:<span class="string">"甘肃"</span>,<span class="number">63</span>:<span class="string">"青海"</span>,<span class="number">64</span>:<span class="string">"宁夏"</span>,<span class="number">65</span>:<span class="string">"新疆"</span>,<span class="number">71</span>:<span class="string">"台湾"</span>,<span class="number">81</span>:<span class="string">"香港"</span>,<span class="number">82</span>:<span class="string">"澳门"</span>,<span class="number">91</span>:<span class="string">"国外 "</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> tip = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> pass= <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//验证身份证格式（6个地区编码，8位出生日期，3位顺序号，1位校验位）</span></span><br><span class="line">    <span class="keyword">if</span>(!code || !<span class="regexp">/^\d&#123;6&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)$/i</span>.test(code))&#123;</span><br><span class="line">        tip = <span class="string">"身份证号格式错误"</span>;</span><br><span class="line">        pass = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(!city[code.substr(<span class="number">0</span>,<span class="number">2</span>)])&#123;</span><br><span class="line">        tip = <span class="string">"地址编码错误"</span>;</span><br><span class="line">        pass = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//18位身份证需要验证最后一位校验位</span></span><br><span class="line">        <span class="keyword">if</span>(code.length == <span class="number">18</span>)&#123;</span><br><span class="line">            code = code.split(<span class="string">''</span>);</span><br><span class="line">            <span class="comment">//∑(ai×Wi)(mod 11)</span></span><br><span class="line">            <span class="comment">//加权因子</span></span><br><span class="line">            <span class="keyword">var</span> factor = [ <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span> ];</span><br><span class="line">            <span class="comment">//校验位</span></span><br><span class="line">            <span class="keyword">var</span> parity = [ <span class="number">1</span>, <span class="number">0</span>, <span class="string">'X'</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span> ];</span><br><span class="line">            <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> ai = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> wi = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ai = code[i];</span><br><span class="line">                wi = factor[i];</span><br><span class="line">                sum += ai * wi;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> last = parity[sum % <span class="number">11</span>];</span><br><span class="line">            <span class="keyword">if</span>(parity[sum % <span class="number">11</span>] != code[<span class="number">17</span>])&#123;</span><br><span class="line">                tip = <span class="string">"校验位错误"</span>;</span><br><span class="line">                pass =<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(code.length == <span class="number">15</span>)&#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="img标签的onerror事件"><a href="#img标签的onerror事件" class="headerlink" title="img标签的onerror事件"></a>img标签的onerror事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>循环里的图片直接引用原生事件</span><br><span class="line">&lt; div v-<span class="keyword">for</span>= <span class="string">"(item,index) in imgSrcList"</span> &gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; item.test &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img :src="'/i</span>travel/itravel/assets/images/common/<span class="string">'+item.test+'</span>.png<span class="string">'" onerror="javascript:this.src='</span>/itravel/itravel/assets/images/ticket/child-desc.png<span class="string">';" /&gt;</span></span><br><span class="line"><span class="string">&lt;div/ &gt;</span></span><br><span class="line"><span class="string">2.只有一个路径</span></span><br><span class="line"><span class="string">    &lt;div class="pic" &gt;</span></span><br><span class="line"><span class="string">        &lt;img v-bind: src="item.productInfo.images[0].url" v-on: error="imgError(item)" /&gt;</span></span><br><span class="line"><span class="string">    &lt;div/ &gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">imgError: function (item) &#123;</span></span><br><span class="line"><span class="string">    item.productInfo.images[0].url = '</span>http:<span class="comment">//t.cn/RmxJlMa'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递归优化</span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    return n * factorial(n - 1) &#x2F;&#x2F; 重点在尾部调用返回</span><br><span class="line">&#125;</span><br><span class="line">之后</span><br><span class="line">console.log(factorial(5)) &#x2F;&#x2F; 120</span><br><span class="line">function factorial(n, total &#x3D; 1) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">    return factorial(n - 1, total * n); &#x2F;&#x2F; 重点在尾部调用返回</span><br><span class="line">&#125;</span><br><span class="line">console.log(factorial(5)) &#x2F;&#x2F; 120</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务器时间</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组方法</title>
    <url>/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="15种关于JavaScript的数组方法"><a href="#15种关于JavaScript的数组方法" class="headerlink" title="15种关于JavaScript的数组方法"></a>15种关于JavaScript的数组方法</h3><ul>
<li><p>some（）</p>
</li>
<li><p>reduce（）</p>
</li>
<li><p>Every（）</p>
</li>
<li><p>map（）</p>
</li>
<li><p>flat（）</p>
</li>
<li><p>filter（）</p>
<a id="more"></a>
</li>
<li><p>forEach（）</p>
</li>
<li><p>findIndex（）</p>
</li>
<li><p>indexOf（）</p>
</li>
<li><p>find（）</p>
</li>
<li><p>sort（）</p>
</li>
<li><p>concat（）</p>
</li>
<li><p>fill（）</p>
</li>
<li><p>includes（）</p>
</li>
<li><p>reverse（）</p>
</li>
<li><p>flatMap（）</p>
</li>
</ul>
<p>注意，大多数情况下，我们将简化作为参数传递的函数。</p>
<p>// Instead of using this waymyAwesomeArray.some(test =&gt; {  if (test === “d”) {    return test  }})</p>
<p>// We’ll use the shorter onemyAwesomeArray.some(test =&gt; test === “d”)</p>
<p>1、some()</p>
<p>此方法为参数传递的函数测试数组。如果有一个元素与测试元素匹配，则返回true，否则返回false。</p>
<p>译者注： some() 不会对空数组进行检测；some() 不会改变原始数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.some(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;d&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : true</span><br></pre></td></tr></table></figure>



<p>2、reduce（）</p>
<p>此方法接收一个函数作为累加器。它为数组中的每个元素依次执行回调函数，不包括数组中被删除或者从未被赋值的元素。函数应用于累加器，数组中的每个值最后只返回一个值。</p>
<p>译者注：reduce() 方法接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.reduce((total, value) &#x3D;&gt; total * value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 * 2 * 3 * 4 * 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output &#x3D; 120</span><br></pre></td></tr></table></figure>



<p>3、Every（）</p>
<p>此方法是对数组中每项运行给定函数，如果数组的每个元素都与测试匹配，则返回true，反之则返回false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.every(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;d&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : false</span><br><span class="line"></span><br><span class="line">const myAwesomeArray2 &#x3D; [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">myAwesomeArray2.every(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : true</span><br></pre></td></tr></table></figure>



<p>4、map（）</p>
<p>该方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。它按照原始数组元素顺序依次处理元素。</p>
<p>译者注：map() 不会对空数组进行检测；map() 不会改变原始数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [5, 4, 3, 2, 1]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.map(x &#x3D;&gt; x * x)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;--&gt; Output : 25                  </span><br><span class="line"></span><br><span class="line">             16                  </span><br><span class="line"></span><br><span class="line">             9                  </span><br><span class="line"></span><br><span class="line">             4                  </span><br><span class="line"></span><br><span class="line">             1</span><br><span class="line"></span><br><span class="line">let selected_values &#x3D; [ &#39;1&#39;, &#39;5&#39;, &#39;8&#39; ]</span><br><span class="line"></span><br><span class="line">selected_values &#x3D; selected_values.map(Number) &#x2F;&#x2F; [ 1, 5, 8 ]</span><br><span class="line"></span><br><span class="line">selected_values &#x3D; selected_values.map(Boolean) &#x2F;&#x2F;[true, true, true]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在数组中删除某个对象里的某个属性值</span><br><span class="line">如 list &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        China:&#123;name:‘张三’,age:‘10’&#125;,</span><br><span class="line">        English:&#123;name:‘Tony’,age:‘20’&#125;,</span><br><span class="line">        Spanish:&#123;name:‘Someone’,age:‘12’&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">list.map(item&#x3D;&gt;&#123;</span><br><span class="line">	delete item.English</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>(除了将所有值都强制转换为整数，还可以通过简单地更改map函数的参数将数组中的所有值强制转换为布尔值。)</p>
<p>5、flat（）</p>
<p>此方法创建一个新数组，其中包含子数组上的holden元素，并将其平整到新数组中。请注意，此方法只能进行一个级别的深度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [[1, 2], [3, 4], 5]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.flat()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const myAwesomeArray &#x3D; [[1, 2], [3, 4], 5,[7,[9,10]]]</span><br><span class="line">myAwesomeArray.flat(Infinity)</span><br><span class="line">&#x2F;&#x2F;无限内循环</span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>



<p>6、filter（）</p>
<p>该方法接收一个函数作为参数。并返回一个新数组，该数组包含该数组的所有元素，作为参数传递的过滤函数对其返回true。</p>
<p>译者注：filter（）方法是对数据中的元素进行过滤，也就是说是不能修改原数组中的数据，只能读取原数组中的数据，callback需要返回布尔值；为true的时候，对应的元素留下来；为false的时候，对应的元素过滤掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [  &#123; id: 1, name: &quot;john&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,  &#123; id: 4, name: &quot;Mass&quot; &#125;,]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.filter(element &#x3D;&gt; element.name &#x3D;&#x3D;&#x3D; &quot;Mass&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : 0:&#123;id: 3, name: &quot;Mass&quot;&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                   1:&#123;id: 4, name: &quot;Mass&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>7、forEach（）</p>
<p>此方法用于调用数组的每个元素。并将元素传递给回调函数。</p>
<p>译者注: forEach() 对于空数组是不会执行回调函数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [  &#123; id: 1, name: &quot;john&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.forEach(element &#x3D;&gt; console.log(element.name))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : john                  </span><br><span class="line"></span><br><span class="line">                     Ali                  </span><br><span class="line">                     Mass</span><br></pre></td></tr></table></figure>



<p>8、 findIndex（）</p>
<p>此方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。它为数组中的每个元素都调用一次函数执行，当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1</p>
<p>译者注：findIndex() 对于空数组，函数是不会执行的， findIndex() 并没有改变数组的原始值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [  &#123; id: 1, name: &quot;john&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.findIndex(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : 2</span><br><span class="line"></span><br><span class="line">myAwesomeArray.findIndex(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 7)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : -1</span><br></pre></td></tr></table></figure>



<p>9、 find（）</p>
<p>此方法返回通过测试（函数内判断）的数组的第一个元素的值。find() 方法为数组中的每个元素都调用一次函数执行：当数组中的元素在测试条件时回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。</p>
<p>译者注: find() 对于空数组，函数是不会执行的；find() 并没有改变数组的原始值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [  &#123; id: 1, name: &quot;john&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,] </span><br><span class="line"></span><br><span class="line">myAwesomeArray.find(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 3) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : &#123;id: 3, name: &quot;Mass&quot;&#125; </span><br><span class="line"></span><br><span class="line">myAwesomeArray.find(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 7) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : undefined</span><br></pre></td></tr></table></figure>



<p>10、 sort（）</p>
<p>此方法接收一个函数作为参数。它对数组的元素进行排序并返回它。也可以使用含有参数的sort()方法进行排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [5, 4, 3, 2, 1]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sort from smallest to largest</span><br><span class="line"></span><br><span class="line">myAwesomeArray.sort((a, b) &#x3D;&gt; a - b)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  -------&gt; Output : [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Sort from largest to smallest</span><br><span class="line"></span><br><span class="line">myAwesomeArray.sort((a, b) &#x3D;&gt; b - a)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>



<p>11、 concat（）</p>
<p>此方法用于连接两个或多个数组/值，它不会改变现有的数组。而仅仅返回被连接数组的一个新数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const myAwesomeArray2 &#x3D; [10, 20, 30, 40, 50]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.concat(myAwesomeArray2)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]</span><br></pre></td></tr></table></figure>



<p>12、 fill（）</p>
<p>此方法的作用是使用一个固定值来替换数组中的元素。该固定值可以是字母、数字、字符串、数组等等。它还有两个可选参数，表示填充起来的开始位置（默认为0）与结束位置（默认为array.length）。</p>
<p>译者注：fill() 方法用于将一个固定值替换数组的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The first argument (0) is the value</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; he second argument (1) is the starting index</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The third argument (3) is the ending index</span><br><span class="line"></span><br><span class="line">myAwesomeArray.fill(0, 1, 3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [1, 0, 0, 4, 5]</span><br></pre></td></tr></table></figure>



<p>13、 includes（）</p>
<p>此方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。</p>
<p>译者注：includes() 方法区分大小写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.includes(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : true</span><br><span class="line"></span><br><span class="line">myAwesomeArray.includes(8)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(fruit) &#123;</span><br><span class="line">  &#x2F;&#x2F; 条件提取到数组中</span><br><span class="line">  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];</span><br><span class="line"></span><br><span class="line">  if (redFruits.includes(fruit)) &#123;</span><br><span class="line">    console.log(&#39;red&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>14、 reverse（）</p>
<p>此方法用于颠倒数组中元素的顺序。第一个元素成为最后一个，最后一个元素将成为第一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.reverse()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span><br></pre></td></tr></table></figure>



<p>15、 flatMap（）</p>
<p>该方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。它在一个函数中结合了flat（）和map（）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [[1], [2], [3], [4], [5]]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.flatMap(arr &#x3D;&gt; arr * 10)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [10, 20, 30, 40, 50]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;With .flat() and .map()</span><br><span class="line"></span><br><span class="line">myAwesomeArray.flat().map(arr &#x3D;&gt; arr * 10)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [10, 20, 30, 40, 50]</span><br></pre></td></tr></table></figure>



<p>16、 indexOf（）()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">var a &#x3D; fruits.indexOf(&quot;Apple&quot;);</span><br><span class="line">结果输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">indexOf是传入一个值.找到了返回索引,没有找到返回-1</span><br><span class="line">findIndex是传入一个测试条件,也就是函数,找到了返回索引,没有找到返回-1.</span><br></pre></td></tr></table></figure>



<p>实例</p>
<p>迭代一个空数组</p>
<p>JavaScript 中直接创建的数组是松散的，以至于会有很多坑。试着用数组的构造方法创建一个数组，你就会瞬间明白了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; new Array(4);[undefined, undefined, undefined, undefined]&#x2F;&#x2F; 谷歌浏览器中是 [empty x 4]</span><br></pre></td></tr></table></figure>

<p>你会发现，通过一个松散的数组去循环调用一些转换是非常难的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; new Array(4);arr.map((elem, index) &#x3D;&gt; index);[undefined, undefined, undefined, undefined]</span><br></pre></td></tr></table></figure>

<p>想要解决这个问题，你可以使用在创建新数组的时候使用 <em>Array.apply</em>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; Array.apply(null, new Array(4));arr.map((elem, index) &#x3D;&gt; index);[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>



<p>Javascript多维数组扁平化</p>
<p>下面是将多位数组转化为单一数组的三种不同方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</span><br></pre></td></tr></table></figure>

<p>期望结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>解决方案1：使用concat()和apply()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newArr &#x3D; [].concat.apply([], arr);&#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>解决方案2：使用reduce()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newArr &#x3D; arr.reduce(function(prev, curr) &#123;  return prev.concat(curr);&#125;);&#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>解决方案3：使用 ES6 的展开运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newArr &#x3D; [].concat(...arr);console.log(newArr);&#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>解决方案4：使用Array.proptotype.flat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newArr &#x3D; arr.flat()</span><br></pre></td></tr></table></figure>



<h2 id="2-给方法传一个空参数"><a href="#2-给方法传一个空参数" class="headerlink" title="2. 给方法传一个空参数"></a>2. 给方法传一个空参数</h2><p>如果你想调用一个方法，并不填其中的一个参数时，JavaScript 就会报错。</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method(&#39;parameter1&#39;, , &#39;parameter3&#39;); &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token ,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>一个我们常用的解决方法是传递 null 或 undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method(&#39;parameter1&#39;, null, &#39;parameter3&#39;) &#x2F;&#x2F; or</span><br><span class="line">method(&#39;parameter1&#39;, undefined, &#39;parameter3&#39;);</span><br></pre></td></tr></table></figure>

<p>根据 ES6 中对扩展运算符的介绍，有一个更简洁的方法可以将空参数传递给一个方法。正如上面所提到的，数组是松散的，所以给它传空值是可以的，我们正是用到了这个优点。</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method(...[&#39;parameter1&#39;, , &#39;parameter3&#39;]); &#x2F;&#x2F; 代码执行了...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3. 数组去重"></a>3. 数组去重</h2><p>我一直不明白为什么数组不提供一个内置函数可以让我们方便的取到去重以后的值。扩展运算符帮到了我们，使用扩展运算符配合 Set可以生成一个不重复的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [...new Set([1, 2, 3, 3])];&#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>





<p>判断一个数组中是否有相同的</p>
<p>1，普通数组</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/e9dd2688ece34b1ba81d391336c5e0a1/db3151266e069a56a9ba36f665d74f8.png" alt="img"></p>
<p>对象数组</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/136023e12af0401f9b684274c3bbc546/clipboard.png" alt="img"></p>
<p>去重方法</p>
<p>普通数组</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/20373a06171a4ac7bcfe9ea9f0852ba1/clipboard.png" alt="img"></p>
<p>对象数组</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/e50bd5cace6a4f0c9543035efd8a0a1e/clipboard.png" alt="img"></p>
<p>举例</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/c5aa3be1f55f4308a73d94fedf91ec0b/7a5080667b91dd81a3e75ad1c0ff8dc.png" alt="img"></p>
<p>二维数组方法</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/9a4d248972f74ac184f5ee7787a651d7/5e1f34890adcd7abba1b3fc9c0f0503.jpg" alt="img"></p>
<p>var arr=[[1,2,3,4],[5,6,7,8],[‘A’,’B’,’C’,’D’]]</p>
<p>console.log(arr[0].map((n,i)=&gt;arr.reduce((t,c)=&gt;t.concat(c[i]),[])))</p>
<p>二维数组翻转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">翻转二维数组</span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//逆时针旋转 90 度</span></span><br><span class="line">    <span class="comment">//列 = 行</span></span><br><span class="line">    <span class="comment">//行 = n - 1 - 列(j);  n表示总行数</span></span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">var</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> k = len - <span class="number">1</span> -j;</span><br><span class="line">            <span class="keyword">if</span>(!temp[k])&#123;</span><br><span class="line">                temp[k] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            temp[k][i] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> rotate180 = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//逆时针旋转 180 度</span></span><br><span class="line">    <span class="comment">//行 = h - 1 - 行(i);  h表示总行数</span></span><br><span class="line">    <span class="comment">//列 = n - 1 - 列(j);  n表示总列数</span></span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">var</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> k = len - <span class="number">1</span> - i;</span><br><span class="line">            <span class="keyword">if</span>(!temp[k])&#123;</span><br><span class="line">                temp[k] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            temp[k][len<span class="number">-1</span>-j] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> rotate270 = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//逆时针旋转 270 度</span></span><br><span class="line">    <span class="comment">//行 = 列</span></span><br><span class="line">    <span class="comment">//列 = n - 1 - 行(i);  n表示总列数</span></span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">var</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> k = len - <span class="number">1</span> - i;</span><br><span class="line">            <span class="keyword">if</span>(!temp[j])&#123;</span><br><span class="line">                temp[j] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            temp[j][k] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>mdIntro</title>
    <url>/2020/07/15/mdIntro/</url>
    <content><![CDATA[<p><strong>Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。</strong></p>
<h4 id="智能标点"><a href="#智能标点" class="headerlink" title="智能标点"></a>智能标点</h4><p>我认为「智能标点」是比较有趣的一点。它可以自动帮你将不是很美观的直引号 <code>&quot;</code> <code>&#39;</code> 转化为更美观的弯引号 <code>“</code> <code>‘</code> <code>’</code> <code>”</code>。具体内容你可以在官方的 <a href="http://support.typora.io/SmartyPants/" target="_blank" rel="noopener">这篇文档</a> 中查看。关于直弯引号在 macOS 上如何输入你也可以看 <a href="https://sspai.com/post/38342" target="_blank" rel="noopener">这篇文章</a>。</p>
<hr>
<a id="more"></a>

<h4 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h4><p>Typora 支持在拖动或 <code>Ctrl + V</code> 网络图片后自动将其保存到本地。你可以在 <code>文件 - 偏好设置 - 编辑器 - 图片插入</code> 中选择复制到哪个路径，什么情况下需要复制。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/717da653ad91e938c5f1f40555b9c057.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img">图片插入</p>
<p>这一功能保证了即使网络图片源失效了，你还有本地的备份可用。同时也能使你的文档文件夹更合理、完整。</p>
<hr>
<h4 id="打字机模式和专注模式"><a href="#打字机模式和专注模式" class="headerlink" title="打字机模式和专注模式"></a>打字机模式和专注模式</h4><p><strong>「打字机模式」</strong>使得你所编辑的那一行永远处于屏幕正中。</p>
<p><strong>「专注模式」</strong>使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。</p>
<p>你可以在 <code>视图 - 专注模式 / 打字机模式</code> 中勾选使用这两个模式。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/8b4e14ef732a23d4cc2a8fb1f8ec016c.gif" alt="img"></p>
<p>为了防止一些程序 bug 的发生（虽然在我使用下来感到是很少的）导致格式问题无法修改，Typora 保留了一个<strong>「源代码模式」</strong>。你可以通过 <code>视图 - 源代码模式</code> 或左下角的 <code>&lt;/&gt;</code> 按钮进入。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/bcda9c4e35725b7297a6b90d8745564e.gif" alt="img"></p>
<hr>
<h4 id="空格与换行"><a href="#空格与换行" class="headerlink" title="空格与换行"></a>空格与换行</h4><p>Typora 在空格与换行部分主要是使用 <a href="http://www.commonmark.cn/w/" target="_blank" rel="noopener">CommonMark</a> 作为标注规范。与前文提到的 GFM 一样，CommonMark 也是比较流行的 Markdown 语言规范（解析器）之一。</p>
<ul>
<li><strong>空格：</strong>在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。<br>你可以在源代码模式下，为每个空格前加一个 <code>\</code> 转义符，或者直接使用 HTML 风格的 <code>&amp;nbps;</code> 来保持连续的空格。</li>
<li><strong>软换行：</strong>需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 <code>Shift + Enter</code> 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。</li>
<li><strong>硬换行：</strong>你可以通过 <code>空格 + 空格 + Shift + Enter</code> 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。</li>
<li><strong>换段：</strong>你可以通过 <code>Enter</code> 完成一次换段。Typora 会自动帮你完成两次 <code>Shift + Enter</code> 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。</li>
<li><strong>Windows 风格（CR+LF）与 Unix 风格（CR）的换行符：</strong>CR 表示回车 <code>\r</code> ，即回到一行的开头，而 LF 表示换行 <code>\n</code> ，即另起一行。<br>所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 你可以在 <code>文件 - 偏好设置 - 编辑器 - 默认换行符</code> 中对此进行切换。</li>
</ul>
<p>下附以上各空格、换行、换段的测试结果图。具体内容你可以在官网的 <a href="http://support.typora.io/Line-Break/" target="_blank" rel="noopener">这篇文档</a> 中查阅。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/5c2fbaa53b27666a7fd0b07ac3e100bf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<hr>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>除了前文提到的文件侧边栏，Typora 还提供了一些耦合度不高的文件系统。</p>
<ul>
<li><strong>快速打开：</strong>你可以通过 <code>文件 - 快速打开...</code> 或 <code>Ctrl + P</code> 快捷键快速打开最近的文档。</li>
<li><strong>保存：</strong>Typora 支持自动保存，一般很少有写好的文档丢失的情况。同时它也提供了诸如「保存」、「另存为」、「保存全部打开的文件…」之类的功能。</li>
<li><strong>导入：</strong>Typora 支持非常多的文件格式：.docx, .latex, .tex, .ltx, .rst, .rest, .org, .wiki, .dokuwiki, .textile, .opml, .epub。</li>
<li><strong>导出：</strong>Typora 原生支持导出 PDF，HTML等格式。你可以根据软件内提示安装 <strong>Pandoc 插件</strong>来导出更多例如 docx，LaTeX 等格式。 </li>
</ul>
<p><img src="https://cdn.sspai.com/2019/05/24/ba295f21f0b71646bb36a0517e868ced.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img">导出</p>
<hr>
<h2 id="一个伪装成文本编辑器的浏览器"><a href="#一个伪装成文本编辑器的浏览器" class="headerlink" title="一个伪装成文本编辑器的浏览器"></a>一个伪装成文本编辑器的浏览器</h2><p>当我的一个朋友问我「Typora 有什么好写的？」时，我回答「Typora 是一个伪装成文本编辑器的浏览器」。是的，事实上如果你有一定的计算机基础，你可以找到许多有关于「Typora 其实是一个浏览器」的蛛丝马迹。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/13837bcdcded9ae406e8c4aac5f2d752.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img">图片插入</p>
<p>在图片插入的选项中，Typora 用了「复制图片到 ./${filename}.assets 文件夹」的说法，而这其实是网页前端常用的 Javascript 字符串模板语法的风格。</p>
<p>再比如，Typora 将更遵循 GFM 标准的 Markdown 语法模式称为「严格模式 Strict Mode」，这一说法常见于 HTML 和 JavaScript 编程中。类似「源代码模式」的说法也是同理。</p>
<p>当然，最明显的一点是当你按下 <code>Shift + F12</code> 快捷键时，页面会弹出一个基于 Chrome 的开发者工具栏，也就是我们在浏览器中常说的「审查元素」。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/da8c9b305a222cb5fadb41c12da81a12.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<hr>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>为了让文档更美观，我们可以为其加上 CSS style。我认为 Typora 对 CSS 的支持让它成为一众桌面笔记应用中最与众不同的一个。在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。你可以在 <code>文件 - 偏好设置 - 主题 - 打开主题文件夹</code> 看到这些 CSS 文件。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/7d3cfbc92721733e16ed63d72a48a572.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<hr>
<p>除此以外，如果你有一定的 Web 编程基础，你当然也可以自己修改、新建适合你使用需求的 CSS 文件。我自己就写了一份名为 WeChat 的 CSS 文件，来符合我公众号特定的排版需求，例如正文是 15px，页边距是 8，小标题是 18px 等等。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/317ac1df25fcfc817c03f92d6086764e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>使用 Typora 的「主题」功能写公众号的一个好处是，只需要每次都套用同样的主题，我们就可以在保证每次排版规范都相同的同时，节省许多重复的工作。</p>
<hr>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><img src="https://cdn.sspai.com/2019/05/24/98a04c4f9129e0f018d15bc790b376c2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>选择不同的主题可以使文档拥有不同的外观，但不会影响内容。Typora 自带了若干主题，你也可以在 <a href="http://theme.typora.io/" target="_blank" rel="noopener">官网</a> 下载更多的主题。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/efcf65ba993c4bb0b058d6eb8258df6f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<hr>
<h3 id="YAML-front-matter"><a href="#YAML-front-matter" class="headerlink" title="YAML front-matter"></a>YAML front-matter</h3><p>Typora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。</p>
<p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2013&#x2F;7&#x2F;13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure>


<p>参考文档：<a href="https://sspai.com/post/54912" target="_blank" rel="noopener">typora</a></p>
]]></content>
      <categories>
        <category>mysoft</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>js方法（三）</title>
    <url>/2020/07/30/js%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>1.邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isEmail &#x3D; (s) &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$&#x2F;.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.手机号码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isMobile &#x3D; (s) &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;^1[0-9]&#123;10&#125;$&#x2F;.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>3.电话号码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isPhone &#x3D; (s) &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$&#x2F;.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.是否url地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isURL &#x3D; (s) &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;^http[s]?:\&#x2F;\&#x2F;.*&#x2F;.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.是否字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isString &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;String&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.是否数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isNumber &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Number&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.是否boolean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isBoolean &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Boolean&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.是否函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isFunction &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Function&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.是否为null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isNull &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Null&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.是否undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isUndefined &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Undefined&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11.是否对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isObj &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Object&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12.是否数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isArray &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Array&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.是否时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isDate &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Date&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14.是否正则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isRegExp &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;RegExp&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15.是否错误对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isError &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Error&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>16.是否Symbol函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isSymbol &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Symbol&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>17.是否Promise对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isPromise &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Promise&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>18.是否Set对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isSet &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Set&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>19.是否是微信浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const ua &#x3D; navigator.userAgent.toLowerCase();</span><br><span class="line">export const isWeiXin &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return ua.match(&#x2F;microMessenger&#x2F;i) &#x3D;&#x3D; &#39;micromessenger&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>20.是否是移动端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isDeviceMobile &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;android|webos|iphone|ipod|balckberry&#x2F;i.test(ua)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>21.是否是QQ浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isQQBrowser &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return !!ua.match(&#x2F;mqqbrowser|qzone|qqbrowser|qbwebviewtype&#x2F;i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22.是否是爬虫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isSpider &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sogou orion spider&#x2F;.test(ua)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>23.是否ios</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isIos &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    var u &#x3D; navigator.userAgent;</span><br><span class="line">    if (u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1) &#123;  &#x2F;&#x2F;安卓手机</span><br><span class="line">        return false</span><br><span class="line">    &#125; else if (u.indexOf(&#39;iPhone&#39;) &gt; -1) &#123;&#x2F;&#x2F;苹果手机</span><br><span class="line">        return true</span><br><span class="line">    &#125; else if (u.indexOf(&#39;iPad&#39;) &gt; -1) &#123;&#x2F;&#x2F;iPad</span><br><span class="line">        return false</span><br><span class="line">    &#125; else if (u.indexOf(&#39;Windows Phone&#39;) &gt; -1) &#123;&#x2F;&#x2F;winphone手机</span><br><span class="line">        return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>24.是否为PC端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isPC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    var userAgentInfo &#x3D; navigator.userAgent;</span><br><span class="line">    var Agents &#x3D; [&quot;Android&quot;, &quot;iPhone&quot;,</span><br><span class="line">        &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,</span><br><span class="line">        &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class="line">    var flag &#x3D; true;</span><br><span class="line">    for (var v &#x3D; 0; v &lt; Agents.length; v++) &#123;</span><br><span class="line">        if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;</span><br><span class="line">            flag &#x3D; false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>25.去除html标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const removeHtmltag &#x3D; (str) &#x3D;&gt; &#123;</span><br><span class="line">    return str.replace(&#x2F;&lt;[^&gt;]+&gt;&#x2F;g, &#39;&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>26.获取url参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const getQueryString &#x3D; (name) &#x3D;&gt; &#123;</span><br><span class="line">    const reg &#x3D; new RegExp(&#39;(^|&amp;)&#39; + name + &#39;&#x3D;([^&amp;]*)(&amp;|$)&#39;, &#39;i&#39;);</span><br><span class="line">    const search &#x3D; window.location.search.split(&#39;?&#39;)[1] || &#39;&#39;;</span><br><span class="line">    const r &#x3D; search.match(reg) || [];</span><br><span class="line">    return r[2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>27.动态引入js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const injectScript &#x3D; (src) &#x3D;&gt; &#123;</span><br><span class="line">    const s &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    s.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line">    s.async &#x3D; true;</span><br><span class="line">    s.src &#x3D; src;</span><br><span class="line">    const t &#x3D; document.getElementsByTagName(&#39;script&#39;)[0];</span><br><span class="line">    t.parentNode.insertBefore(s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28.根据url地址下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const download &#x3D; (url) &#x3D;&gt; &#123;</span><br><span class="line">    var isChrome &#x3D; navigator.userAgent.toLowerCase().indexOf(&#39;chrome&#39;) &gt; -1;</span><br><span class="line">    var isSafari &#x3D; navigator.userAgent.toLowerCase().indexOf(&#39;safari&#39;) &gt; -1;</span><br><span class="line">    if (isChrome || isSafari) &#123;</span><br><span class="line">        var link &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">        link.href &#x3D; url;</span><br><span class="line">        if (link.download !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">            var fileName &#x3D; url.substring(url.lastIndexOf(&#39;&#x2F;&#39;) + 1, url.length);</span><br><span class="line">            link.download &#x3D; fileName;</span><br><span class="line">        &#125;</span><br><span class="line">        if (document.createEvent) &#123;</span><br><span class="line">            var e &#x3D; document.createEvent(&#39;MouseEvents&#39;);</span><br><span class="line">            e.initEvent(&#39;click&#39;, true, true);</span><br><span class="line">            link.dispatchEvent(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (url.indexOf(&#39;?&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">        url +&#x3D; &#39;?download&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    window.open(url, &#39;_self&#39;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>29.el是否包含某个class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const hasClass &#x3D; (el, className) &#x3D;&gt; &#123;</span><br><span class="line">    let reg &#x3D; new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;)</span><br><span class="line">    return reg.test(el.className)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>30.el添加某个class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const addClass &#x3D; (el, className) &#x3D;&gt; &#123;</span><br><span class="line">    if (hasClass(el, className)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let newClass &#x3D; el.className.split(&#39; &#39;)</span><br><span class="line">    newClass.push(className)</span><br><span class="line">    el.className &#x3D; newClass.join(&#39; &#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>31.el去除某个class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const removeClass &#x3D; (el, className) &#x3D;&gt; &#123;</span><br><span class="line">    if (!hasClass(el, className)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let reg &#x3D; new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;, &#39;g&#39;)</span><br><span class="line">    el.className &#x3D; el.className.replace(reg, &#39; &#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32.获取滚动的坐标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const getScrollPosition &#x3D; (el &#x3D; window) &#x3D;&gt; (&#123;</span><br><span class="line">    x: el.pageXOffset !&#x3D;&#x3D; undefined ? el.pageXOffset : el.scrollLeft,</span><br><span class="line">    y: el.pageYOffset !&#x3D;&#x3D; undefined ? el.pageYOffset : el.scrollTop</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>33.滚动到顶部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const scrollToTop &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const c &#x3D; document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">    if (c &gt; 0) &#123;</span><br><span class="line">        window.requestAnimationFrame(scrollToTop);</span><br><span class="line">        window.scrollTo(0, c - c &#x2F; 8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>34.el是否在视口范围内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const elementIsVisibleInViewport &#x3D; (el, partiallyVisible &#x3D; false) &#x3D;&gt; &#123;</span><br><span class="line">    const &#123; top, left, bottom, right &#125; &#x3D; el.getBoundingClientRect();</span><br><span class="line">    const &#123; innerHeight, innerWidth &#125; &#x3D; window;</span><br><span class="line">    return partiallyVisible</span><br><span class="line">        ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;</span><br><span class="line">        ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth))</span><br><span class="line">        : top &gt;&#x3D; 0 &amp;&amp; left &gt;&#x3D; 0 &amp;&amp; bottom &lt;&#x3D; innerHeight &amp;&amp; right &lt;&#x3D; innerWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>35.洗牌算法随机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const shuffle &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    var result &#x3D; [],</span><br><span class="line">        random;</span><br><span class="line">    while (arr.length &gt; 0) &#123;</span><br><span class="line">        random &#x3D; Math.floor(Math.random() * arr.length);</span><br><span class="line">        result.push(arr[random])</span><br><span class="line">        arr.splice(random, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>36.劫持粘贴板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const copyTextToClipboard &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">    var textArea &#x3D; document.createElement(&quot;textarea&quot;);</span><br><span class="line">    textArea.style.background &#x3D; &#39;transparent&#39;;</span><br><span class="line">    textArea.value &#x3D; value;</span><br><span class="line">    document.body.appendChild(textArea);</span><br><span class="line">    textArea.select();</span><br><span class="line">    try &#123;</span><br><span class="line">        var successful &#x3D; document.execCommand(&#39;copy&#39;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.log(&#39;Oops, unable to copy&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    document.body.removeChild(textArea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>37.判断类型集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const checkStr &#x3D; (str, type) &#x3D;&gt; &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;phone&#39;:   &#x2F;&#x2F;手机号码</span><br><span class="line">            return &#x2F;^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$&#x2F;.test(str);</span><br><span class="line">        case &#39;tel&#39;:     &#x2F;&#x2F;座机</span><br><span class="line">            return &#x2F;^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$&#x2F;.test(str);</span><br><span class="line">        case &#39;card&#39;:    &#x2F;&#x2F;身份证</span><br><span class="line">            return &#x2F;(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)&#x2F;.test(str);</span><br><span class="line">        case &#39;pwd&#39;:     &#x2F;&#x2F;密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线</span><br><span class="line">            return &#x2F;^[a-zA-Z]\w&#123;5,17&#125;$&#x2F;.test(str)</span><br><span class="line">        case &#39;postal&#39;:  &#x2F;&#x2F;邮政编码</span><br><span class="line">            return &#x2F;[1-9]\d&#123;5&#125;(?!\d)&#x2F;.test(str);</span><br><span class="line">        case &#39;QQ&#39;:      &#x2F;&#x2F;QQ号</span><br><span class="line">            return &#x2F;^[1-9][0-9]&#123;4,9&#125;$&#x2F;.test(str);</span><br><span class="line">        case &#39;email&#39;:   &#x2F;&#x2F;邮箱</span><br><span class="line">            return &#x2F;^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$&#x2F;.test(str);</span><br><span class="line">        case &#39;money&#39;:   &#x2F;&#x2F;金额(小数点2位)</span><br><span class="line">            return &#x2F;^\d*(?:\.\d&#123;0,2&#125;)?$&#x2F;.test(str);</span><br><span class="line">        case &#39;URL&#39;:     &#x2F;&#x2F;网址</span><br><span class="line">            return &#x2F;(http|ftp|https):\&#x2F;\&#x2F;[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^&#x3D;%&amp;:&#x2F;~\+#]*[\w\-\@?^&#x3D;%&amp;&#x2F;~\+#])?&#x2F;.test(str)</span><br><span class="line">        case &#39;IP&#39;:      &#x2F;&#x2F;IP</span><br><span class="line">            return &#x2F;((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))&#x2F;.test(str);</span><br><span class="line">        case &#39;date&#39;:    &#x2F;&#x2F;日期时间</span><br><span class="line">            return &#x2F;^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$&#x2F;.test(str) || &#x2F;^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$&#x2F;.test(str)</span><br><span class="line">        case &#39;number&#39;:  &#x2F;&#x2F;数字</span><br><span class="line">            return &#x2F;^[0-9]$&#x2F;.test(str);</span><br><span class="line">        case &#39;english&#39;: &#x2F;&#x2F;英文</span><br><span class="line">            return &#x2F;^[a-zA-Z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;chinese&#39;: &#x2F;&#x2F;中文</span><br><span class="line">            return &#x2F;^[\\u4E00-\\u9FA5]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;lower&#39;:   &#x2F;&#x2F;小写</span><br><span class="line">            return &#x2F;^[a-z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;upper&#39;:   &#x2F;&#x2F;大写</span><br><span class="line">            return &#x2F;^[A-Z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;HTML&#39;:    &#x2F;&#x2F;HTML标记</span><br><span class="line">            return &#x2F;&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;&#x2F;.test(str);</span><br><span class="line">        default:</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>38.严格的身份证校验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isCardID &#x3D; (sId) &#x3D;&gt; &#123;</span><br><span class="line">    if (!&#x2F;(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)&#x2F;.test(sId)) &#123;</span><br><span class="line">        console.log(&#39;你输入的身份证长度或格式错误&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;身份证城市</span><br><span class="line">    var aCity &#x3D; &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125;;</span><br><span class="line">    if (!aCity[parseInt(sId.substr(0, 2))]) &#123;</span><br><span class="line">        console.log(&#39;你的身份证地区非法&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 出生日期验证</span><br><span class="line">    var sBirthday &#x3D; (sId.substr(6, 4) + &quot;-&quot; + Number(sId.substr(10, 2)) + &quot;-&quot; + Number(sId.substr(12, 2))).replace(&#x2F;-&#x2F;g, &quot;&#x2F;&quot;),</span><br><span class="line">        d &#x3D; new Date(sBirthday)</span><br><span class="line">    if (sBirthday !&#x3D; (d.getFullYear() + &quot;&#x2F;&quot; + (d.getMonth() + 1) + &quot;&#x2F;&quot; + d.getDate())) &#123;</span><br><span class="line">        console.log(&#39;身份证上的出生日期非法&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 身份证号码校验</span><br><span class="line">    var sum &#x3D; 0,</span><br><span class="line">        weights &#x3D; [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],</span><br><span class="line">        codes &#x3D; &quot;10X98765432&quot;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; sId.length - 1; i++) &#123;</span><br><span class="line">        sum +&#x3D; sId[i] * weights[i];</span><br><span class="line">    &#125;</span><br><span class="line">    var last &#x3D; codes[sum % 11]; &#x2F;&#x2F;计算出来的最后一位身份证号码</span><br><span class="line">    if (sId[sId.length - 1] !&#x3D; last) &#123;</span><br><span class="line">        console.log(&#39;你输入的身份证号非法&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>39.随机数范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const random &#x3D; (min, max) &#x3D;&gt; &#123;</span><br><span class="line">    if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return Math.floor(min + Math.random() * ((max + 1) - min))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>40.将阿拉伯数字翻译成中文的大写数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const numberToChinese &#x3D; (num) &#x3D;&gt; &#123;</span><br><span class="line">    var AA &#x3D; new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;);</span><br><span class="line">    var BB &#x3D; new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;);</span><br><span class="line">    var a &#x3D; (&quot;&quot; + num).replace(&#x2F;(^0*)&#x2F;g, &quot;&quot;).split(&quot;.&quot;),</span><br><span class="line">        k &#x3D; 0,</span><br><span class="line">        re &#x3D; &quot;&quot;;</span><br><span class="line">    for (var i &#x3D; a[0].length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        switch (k) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                re &#x3D; BB[7] + re;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                if (!new RegExp(&quot;0&#123;4&#125;&#x2F;&#x2F;d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;)</span><br><span class="line">                    .test(a[0]))</span><br><span class="line">                    re &#x3D; BB[4] + re;</span><br><span class="line">                break;</span><br><span class="line">            case 8:</span><br><span class="line">                re &#x3D; BB[5] + re;</span><br><span class="line">                BB[7] &#x3D; BB[5];</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k % 4 &#x3D;&#x3D; 2 &amp;&amp; a[0].charAt(i + 2) !&#x3D; 0 &amp;&amp; a[0].charAt(i + 1) &#x3D;&#x3D; 0)</span><br><span class="line">            re &#x3D; AA[0] + re;</span><br><span class="line">        if (a[0].charAt(i) !&#x3D; 0)</span><br><span class="line">            re &#x3D; AA[a[0].charAt(i)] + BB[k % 4] + re;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (a.length &gt; 1) &#x2F;&#x2F; 加上小数部分(如果有小数部分)</span><br><span class="line">    &#123;</span><br><span class="line">        re +&#x3D; BB[6];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; a[1].length; i++)</span><br><span class="line">            re +&#x3D; AA[a[1].charAt(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    if (re &#x3D;&#x3D; &#39;一十&#39;)</span><br><span class="line">        re &#x3D; &quot;十&quot;;</span><br><span class="line">    if (re.match(&#x2F;^一&#x2F;) &amp;&amp; re.length &#x3D;&#x3D; 3)</span><br><span class="line">        re &#x3D; re.replace(&quot;一&quot;, &quot;&quot;);</span><br><span class="line">    return re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>41.将数字转换为大写金额</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const changeToChinese &#x3D; (Num) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;判断如果传递进来的不是字符的话转换为字符</span><br><span class="line">    if (typeof Num &#x3D;&#x3D; &quot;number&quot;) &#123;</span><br><span class="line">        Num &#x3D; new String(Num);</span><br><span class="line">    &#125;;</span><br><span class="line">    Num &#x3D; Num.replace(&#x2F;,&#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换tomoney()中的“,”</span><br><span class="line">    Num &#x3D; Num.replace(&#x2F; &#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换tomoney()中的空格</span><br><span class="line">    Num &#x3D; Num.replace(&#x2F;￥&#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换掉可能出现的￥字符</span><br><span class="line">    if (isNaN(Num)) &#123; &#x2F;&#x2F;验证输入的字符是否为数字</span><br><span class="line">        &#x2F;&#x2F;alert(&quot;请检查小写金额是否正确&quot;);</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;字符处理完毕后开始转换，采用前后两部分分别转换</span><br><span class="line">    var part &#x3D; String(Num).split(&quot;.&quot;);</span><br><span class="line">    var newchar &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;小数点前进行转化</span><br><span class="line">    for (var i &#x3D; part[0].length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        if (part[0].length &gt; 10) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">            &#x2F;&#x2F;若数量超过拾亿单位，提示</span><br><span class="line">        &#125;</span><br><span class="line">        var tmpnewchar &#x3D; &quot;&quot;</span><br><span class="line">        var perchar &#x3D; part[0].charAt(i);</span><br><span class="line">        switch (perchar) &#123;</span><br><span class="line">            case &quot;0&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;零&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;1&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;壹&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;2&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;贰&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;3&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;叁&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;4&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;肆&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;5&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;伍&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;6&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;陆&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;7&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;柒&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;8&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;捌&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;9&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;玖&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (part[0].length - i - 1) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                tmpnewchar &#x3D; tmpnewchar + &quot;元&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;佰&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;仟&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                tmpnewchar &#x3D; tmpnewchar + &quot;万&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;佰&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;仟&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 8:</span><br><span class="line">                tmpnewchar &#x3D; tmpnewchar + &quot;亿&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 9:</span><br><span class="line">                tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        var newchar &#x3D; tmpnewchar + newchar;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;小数点之后进行转化</span><br><span class="line">    if (Num.indexOf(&quot;.&quot;) !&#x3D; -1) &#123;</span><br><span class="line">        if (part[1].length &gt; 2) &#123;</span><br><span class="line">            &#x2F;&#x2F; alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;);</span><br><span class="line">            part[1] &#x3D; part[1].substr(0, 2)</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 0; i &lt; part[1].length; i++) &#123;</span><br><span class="line">            tmpnewchar &#x3D; &quot;&quot;</span><br><span class="line">            perchar &#x3D; part[1].charAt(i)</span><br><span class="line">            switch (perchar) &#123;</span><br><span class="line">                case &quot;0&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;零&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;1&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;壹&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;2&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;贰&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;3&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;叁&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;4&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;肆&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;5&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;伍&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;6&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;陆&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;7&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;柒&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;8&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;捌&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;9&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;玖&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &#x3D;&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;角&quot;;</span><br><span class="line">            if (i &#x3D;&#x3D; 1) tmpnewchar &#x3D; tmpnewchar + &quot;分&quot;;</span><br><span class="line">            newchar &#x3D; newchar + tmpnewchar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;替换所有无用汉字</span><br><span class="line">    while (newchar.search(&quot;零零&quot;) !&#x3D; -1)</span><br><span class="line">        newchar &#x3D; newchar.replace(&quot;零零&quot;, &quot;零&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零亿&quot;, &quot;亿&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;亿万&quot;, &quot;亿&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零万&quot;, &quot;万&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零元&quot;, &quot;元&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零角&quot;, &quot;&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零分&quot;, &quot;&quot;);</span><br><span class="line">    if (newchar.charAt(newchar.length - 1) &#x3D;&#x3D; &quot;元&quot;) &#123;</span><br><span class="line">        newchar &#x3D; newchar + &quot;整&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return newchar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>42.判断一个元素是否在数组中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const contains &#x3D; (arr, val) &#x3D;&gt; &#123;</span><br><span class="line">    return arr.indexOf(val) !&#x3D; -1 ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>43.数组排序，<code>{type} 1：从小到大 2：从大到小 3：随机</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const sort &#x3D; (arr, type &#x3D; 1) &#x3D;&gt; &#123;</span><br><span class="line">    return arr.sort((a, b) &#x3D;&gt; &#123;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                return a - b;</span><br><span class="line">            case 2:</span><br><span class="line">                return b - a;</span><br><span class="line">            case 3:</span><br><span class="line">                return Math.random() - 0.5;</span><br><span class="line">            default:</span><br><span class="line">                return arr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>44.去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const unique &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    if (Array.hasOwnProperty(&#39;from&#39;)) &#123;</span><br><span class="line">        return Array.from(new Set(arr));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var n &#x3D; &#123;&#125;, r &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (!n[arr[i]]) &#123;</span><br><span class="line">                n[arr[i]] &#x3D; true;</span><br><span class="line">                r.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>45.求两个集合的并集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const union &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">    var newArr &#x3D; a.concat(b);</span><br><span class="line">    return this.unique(newArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>46.求两个集合的交集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const intersect &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    a &#x3D; this.unique(a);</span><br><span class="line">    return this.map(a, function (o) &#123;</span><br><span class="line">        return _this.contains(b, o) ? o : null;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>47.删除其中一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const remove &#x3D; (arr, ele) &#x3D;&gt; &#123;</span><br><span class="line">    var index &#x3D; arr.indexOf(ele);</span><br><span class="line">    if (index &gt; -1) &#123;</span><br><span class="line">        arr.splice(index, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>48.将类数组转换为数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const formArray &#x3D; (ary) &#x3D;&gt; &#123;</span><br><span class="line">    var arr &#x3D; [];</span><br><span class="line">    if (Array.isArray(ary)) &#123;</span><br><span class="line">        arr &#x3D; ary;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        arr &#x3D; Array.prototype.slice.call(ary);</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>49.最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const max &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    return Math.max.apply(null, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>50.最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const min &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    return Math.min.apply(null, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>51.求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const sum &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    return arr.reduce((pre, cur) &#x3D;&gt; &#123;</span><br><span class="line">        return pre + cur</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>52.平均值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const average &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    return this.sum(arr) &#x2F; arr.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>53.去除空格,<code>type: 1-所有空格 2-前后空格 3-前空格 4-后空格</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const trim &#x3D; (str, type) &#x3D;&gt; &#123;</span><br><span class="line">    type &#x3D; type || 1</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            return str.replace(&#x2F;\s+&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 2:</span><br><span class="line">            return str.replace(&#x2F;(^\s*)|(\s*$)&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 3:</span><br><span class="line">            return str.replace(&#x2F;(^\s*)&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 4:</span><br><span class="line">            return str.replace(&#x2F;(\s*$)&#x2F;g, &quot;&quot;);</span><br><span class="line">        default:</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>54.字符转换，<code>type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const changeCase &#x3D; (str, type) &#x3D;&gt; &#123;</span><br><span class="line">    type &#x3D; type || 4</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            return str.replace(&#x2F;\b\w+\b&#x2F;g, function (word) &#123;</span><br><span class="line">                return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        case 2:</span><br><span class="line">            return str.replace(&#x2F;\b\w+\b&#x2F;g, function (word) &#123;</span><br><span class="line">                return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();</span><br><span class="line">            &#125;);</span><br><span class="line">        case 3:</span><br><span class="line">            return str.split(&#39;&#39;).map(function (word) &#123;</span><br><span class="line">                if (&#x2F;[a-z]&#x2F;.test(word)) &#123;</span><br><span class="line">                    return word.toUpperCase();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return word.toLowerCase()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).join(&#39;&#39;)</span><br><span class="line">        case 4:</span><br><span class="line">            return str.toUpperCase();</span><br><span class="line">        case 5:</span><br><span class="line">            return str.toLowerCase();</span><br><span class="line">        default:</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>55.检测密码强度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const checkPwd &#x3D; (str) &#x3D;&gt; &#123;</span><br><span class="line">    var Lv &#x3D; 0;</span><br><span class="line">    if (str.length &lt; 6) &#123;</span><br><span class="line">        return Lv</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[0-9]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[a-z]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[A-Z]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[\.|-|_]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    return Lv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>56.函数节流器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const debouncer &#x3D; (fn, time, interval &#x3D; 200) &#x3D;&gt; &#123;</span><br><span class="line">    if (time - (window.debounceTimestamp || 0) &gt; interval) &#123;</span><br><span class="line">        fn &amp;&amp; fn();</span><br><span class="line">        window.debounceTimestamp &#x3D; time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>57.在字符串中插入新字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const insertStr &#x3D; (soure, index, newStr) &#x3D;&gt; &#123;</span><br><span class="line">    var str &#x3D; soure.slice(0, index) + newStr + soure.slice(index);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>58.判断两个对象是否键值相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isObjectEqual &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">    var aProps &#x3D; Object.getOwnPropertyNames(a);</span><br><span class="line">    var bProps &#x3D; Object.getOwnPropertyNames(b);</span><br><span class="line"></span><br><span class="line">    if (aProps.length !&#x3D;&#x3D; bProps.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; aProps.length; i++) &#123;</span><br><span class="line">        var propName &#x3D; aProps[i];</span><br><span class="line"></span><br><span class="line">        if (a[propName] !&#x3D;&#x3D; b[propName]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>59.16进制颜色转RGBRGBA字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const colorToRGB &#x3D; (val, opa) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    var pattern &#x3D; &#x2F;^(#?)[a-fA-F0-9]&#123;6&#125;$&#x2F;; &#x2F;&#x2F;16进制颜色值校验规则</span><br><span class="line">    var isOpa &#x3D; typeof opa &#x3D;&#x3D; &#39;number&#39;; &#x2F;&#x2F;判断是否有设置不透明度</span><br><span class="line"></span><br><span class="line">    if (!pattern.test(val)) &#123; &#x2F;&#x2F;如果值不符合规则返回空字符</span><br><span class="line">        return &#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var v &#x3D; val.replace(&#x2F;#&#x2F;, &#39;&#39;); &#x2F;&#x2F;如果有#号先去除#号</span><br><span class="line">    var rgbArr &#x3D; [];</span><br><span class="line">    var rgbStr &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        var item &#x3D; v.substring(i * 2, i * 2 + 2);</span><br><span class="line">        var num &#x3D; parseInt(item, 16);</span><br><span class="line">        rgbArr.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rgbStr &#x3D; rgbArr.join();</span><br><span class="line">    rgbStr &#x3D; &#39;rgb&#39; + (isOpa ? &#39;a&#39; : &#39;&#39;) + &#39;(&#39; + rgbStr + (isOpa ? &#39;,&#39; + opa : &#39;&#39;) + &#39;)&#39;;</span><br><span class="line">    return rgbStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>60.追加url参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const appendQuery &#x3D; (url, key, value) &#x3D;&gt; &#123;</span><br><span class="line">    var options &#x3D; key;</span><br><span class="line">    if (typeof options &#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">        options &#x3D; &#123;&#125;;</span><br><span class="line">        options[key] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    options &#x3D; $.param(options);</span><br><span class="line">    if (url.includes(&#39;?&#39;)) &#123;</span><br><span class="line">        url +&#x3D; &#39;&amp;&#39; + options</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        url +&#x3D; &#39;?&#39; + options</span><br><span class="line">    &#125;</span><br><span class="line">    return url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="61">
<li>禁止网页复制粘贴</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const html &#x3D; document.querySelector(&#39;html&#39;)</span><br><span class="line"> html.oncopy &#x3D; () &#x3D;&gt; false</span><br><span class="line"> html.onpaste &#x3D; () &#x3D;&gt; false</span><br></pre></td></tr></table></figure>

<ol start="62">
<li>input框限制只能输入中文</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const input &#x3D; document.querySelector(&#39;input[type&#x3D;&quot;text&quot;]&#39;)</span><br><span class="line"> const clearText &#x3D; target &#x3D;&gt; &#123;</span><br><span class="line">     const &#123;</span><br><span class="line">         value</span><br><span class="line">     &#125; &#x3D; target</span><br><span class="line">     target.value &#x3D; value.replace(&#x2F;[^\u4e00-\u9fa5]&#x2F;g, &#39;&#39;)</span><br><span class="line"> &#125;</span><br><span class="line"> input.onfocus &#x3D; (&#123;target&#125;) &#x3D;&gt; &#123;</span><br><span class="line">     clearText(target)</span><br><span class="line"> &#125;</span><br><span class="line"> input.onkeyup &#x3D; (&#123;target&#125;) &#x3D;&gt; &#123;</span><br><span class="line">     clearText(target)</span><br><span class="line"> &#125;</span><br><span class="line"> input.onblur &#x3D; (&#123;target&#125;) &#x3D;&gt; &#123;</span><br><span class="line">     clearText(target)</span><br><span class="line"> &#125;</span><br><span class="line"> input.oninput &#x3D; (&#123;target&#125;) &#x3D;&gt; &#123;</span><br><span class="line">     clearText(target)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="63">
<li>计算目录树的深度</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tree &#x3D; &#123;</span><br><span class="line">  name: &#39;root&#39;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; name: &#39;叶子1-1&#39; &#125;,</span><br><span class="line">    &#123; name: &#39;叶子1-2&#39; &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#39;叶子2-1&#39;,</span><br><span class="line">      children: [&#123;</span><br><span class="line">        name: &#39;叶子3-1&#39;,</span><br><span class="line">        children: [&#123;</span><br><span class="line">          name: &#39;叶子4-1&#39;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDepth(tree) &#123;</span><br><span class="line">  let depth &#x3D; 0</span><br><span class="line"></span><br><span class="line">  if (tree) &#123;</span><br><span class="line">    let arr &#x3D; [tree]</span><br><span class="line">    let temp &#x3D; arr</span><br><span class="line">    while (temp.length) &#123;</span><br><span class="line">      arr &#x3D; temp</span><br><span class="line">      temp &#x3D; []</span><br><span class="line">      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i].children &amp;&amp; arr[i].children.length) &#123;</span><br><span class="line">          for (let j &#x3D; 0; j &lt; arr[i].children.length; j++) &#123;</span><br><span class="line">            temp.push(arr[i].children[j])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      depth++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return depth</span><br><span class="line">&#125;</span><br><span class="line">console.log(getDepth(tree)); &#x2F;&#x2F;输出4</span><br></pre></td></tr></table></figure>



<p>参考链接 <a href="https://mp.weixin.qq.com/s/a_hBJdIxnqrzcx28K56VXA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/a_hBJdIxnqrzcx28K56VXA</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js方法（二）</title>
    <url>/2020/07/30/js%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="js方法记录"><a href="#js方法记录" class="headerlink" title="js方法记录"></a>js方法记录</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="1-数组交集"><a href="#1-数组交集" class="headerlink" title="1.数组交集"></a>1.数组交集</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5 , 8 ,9],arr2 &#x3D; [5, 6, 7, 8, 9];</span><br><span class="line">const intersection &#x3D; arr1.filter(function (val) &#123; return arr2.indexOf(val) &gt; -1 &#125;)</span><br><span class="line">console.log(intersection) &#x2F;&#x2F;[5, 8, 9]</span><br><span class="line"></span><br><span class="line">const intersection &#x3D; (list, ...args) &#x3D;&gt; list.filter(item &#x3D;&gt; args.every(list &#x3D;&gt; list.includes(item)))</span><br><span class="line">console.log(intersection([2, 1], [2, 3])) &#x2F;&#x2F; [2]</span><br><span class="line">console.log(intersection([1, 2], [3, 4])) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>数组对象<br>数组对象目前仅针对value值为简单的Number，String，Boolan数据类型 文中JSON.stringif比较对象是简写方法，完整的对象比较请看技巧24.对象是否相等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">const arr2 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">const result &#x3D; arr2.filter(function (v) &#123;</span><br><span class="line">  return arr1.some(n &#x3D;&gt; JSON.stringify(n) &#x3D;&#x3D;&#x3D; JSON.stringify(v))</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result); &#x2F;&#x2F; [&#123; name: &#39;name1&#39;, id: 1 &#125;,&#123; name: &#39;name2&#39;, id: 2 &#125;,&#123; name: &#39;name3&#39;, id: 3 &#125;,&#123; name: &#39;name5&#39;, id: 5 &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="2-数组并集"><a href="#2-数组并集" class="headerlink" title="2.数组并集"></a>2.数组并集</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5, 8, 9]</span><br><span class="line">const arr2 &#x3D; [5, 6, 7, 8, 9];</span><br><span class="line">const result &#x3D; arr1.concat(arr2.filter(v &#x3D;&gt; !arr1.includes(v)))</span><br><span class="line">console.log(result) &#x2F;&#x2F;[1, 2, 3, 4, 5, 8, 9, 6, 7]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;];</span><br><span class="line">const arr2 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">let arr3 &#x3D; arr1.concat(arr2);</span><br><span class="line">let result &#x3D; [];</span><br><span class="line">let obj &#x3D; [];</span><br><span class="line">result &#x3D; arr3.reduce(function (prev, cur, index, arr) &#123;</span><br><span class="line">  obj[cur.id] ? &#39;&#39; : obj[cur.id] &#x3D; true &amp;&amp; prev.push(cur);</span><br><span class="line">  return prev;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(result); &#x2F;&#x2F;[&#123; name: &#39;name1&#39;, id: 1 &#125;,&#123; name: &#39;name2&#39;, id: 2 &#125;,&#123; name: &#39;name3&#39;, id: 3 &#125;,&#123; name: &#39;name4&#39;, id: 4 &#125;,&#123; name: &#39;name5&#39;, id: 5 &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="3-数组差集"><a href="#3-数组差集" class="headerlink" title="3.数组差集"></a>3.数组差集</h4><p>数组arr1相对于arr2所没有的<br>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5, 8, 9]</span><br><span class="line">const arr2 &#x3D; [5, 6, 7, 8, 9];</span><br><span class="line">const diff &#x3D; arr1.filter(item &#x3D;&gt; !new Set(arr2).has(item))</span><br><span class="line">console.log(diff) &#x2F;&#x2F;[ 1, 2, 3, 4 ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象数组</span><br><span class="line">let arr1 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;];</span><br><span class="line">let arr2 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">let result &#x3D; arr1.filter(function (v) &#123;</span><br><span class="line">  return arr2.every(n &#x3D;&gt; JSON.stringify(n) !&#x3D;&#x3D; JSON.stringify(v))</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result); &#x2F;&#x2F; [ &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125; ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-数组补集"><a href="#4-数组补集" class="headerlink" title="4.数组补集"></a>4.数组补集</h4><p>两个数组各自没有的集合<br>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5, 8, 9]</span><br><span class="line">const arr2 &#x3D; [5, 6, 7, 8, 9];</span><br><span class="line">const difference &#x3D; Array.from(new Set(arr1.concat(arr2).filter(v &#x3D;&gt; !new Set(arr1).has(v) || !new Set(arr2).has(v)))) </span><br><span class="line">console.log(difference) &#x2F;&#x2F;[ 1, 2, 3, 4, 6, 7 ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;];</span><br><span class="line">let arr2 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">let arr3 &#x3D; arr1.concat(arr2);</span><br><span class="line">let result &#x3D; arr3.filter(function (v) &#123;</span><br><span class="line">  return arr1.every(n &#x3D;&gt; JSON.stringify(n) !&#x3D;&#x3D; JSON.stringify(v)) || arr2.every(n &#x3D;&gt; JSON.stringify(n) !&#x3D;&#x3D; JSON.stringify(v))</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result); &#x2F;&#x2F; [&#123; name: &#39;name2&#39;, id: 2 &#125;,&#123; name: &#39;name3&#39;, id: 3 &#125;,&#123; name: &#39;name4&#39;, id: 4 &#125;,&#123; name: &#39;name5&#39;, id: 5 &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>总结一下，差集就是数组arr1相对于arr2所没有的集合，补集是两个数组各自没有的集合</p>
<h4 id="5-数组去重"><a href="#5-数组去重" class="headerlink" title="5.数组去重"></a>5.数组去重</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Array.from(new Set([1, 2, 3, 3, 4, 4]))) &#x2F;&#x2F;[1,2,3,4]</span><br><span class="line">console.log([...new Set([1, 2, 3, 3, 4, 4])]) &#x2F;&#x2F;[1,2,3,4]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;, &#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line"> const result &#x3D; [];</span><br><span class="line"> arr.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">    !result.some(v &#x3D;&gt; JSON.stringify(v) &#x3D;&#x3D;&#x3D; JSON.stringify(item)) &amp;&amp; result.push(item)</span><br><span class="line"> &#125;)</span><br><span class="line"> console.log(result) &#x2F;&#x2F;[&#123; name: &#39;name1&#39;, id: 1 &#125;,&#123; name: &#39;name2&#39;, id: 2 &#125;,&#123; name: &#39;name3&#39;, id: 3 &#125;,&#123; name: &#39;name4&#39;, id: 4 &#125;,&#123; name: &#39;name5&#39;, id: 5 &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="6-数组排序"><a href="#6-数组排序" class="headerlink" title="6.数组排序"></a>6.数组排序</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([1, 2, 3, 4].sort((a, b) &#x3D;&gt; a - b)); &#x2F;&#x2F; [1, 2,3,4] 升序</span><br><span class="line">console.log([1, 2, 3, 4].sort((a, b) &#x3D;&gt; b - a)); &#x2F;&#x2F; [4,3,2,1] 降序</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [&#123; name: &quot;Rom&quot;, age: 12 &#125;, &#123; name: &quot;Bob&quot;, age: 22 &#125;].sort((a, b) &#x3D;&gt; &#123; return a.age - b.age &#125;)&#x2F;&#x2F;升序</span><br><span class="line">const arr2 &#x3D; [&#123; name: &quot;Rom&quot;, age: 12 &#125;, &#123; name: &quot;Bob&quot;, age: 22 &#125;].sort((a, b) &#x3D;&gt; &#123; return -a.age + b.age &#125;)&#x2F;&#x2F;降序</span><br><span class="line">console.log(arr2) &#x2F;&#x2F; [&#123; name: &#39;Bob&#39;, age:22 &#125;, &#123; name: &#39;Rom&#39;, age: 12 &#125;]</span><br><span class="line">console.log(arr1) &#x2F;&#x2F; [ &#123; name: &#39;Rom&#39;, age: 12 &#125;, &#123; name: &#39;Bob&#39;, age: 22 &#125; ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>两个种类型数组都可以使用sort排序，sort是浏览器内置方法；<br>默认是升序排序，默认返回一个函数，有两个参数：<br>(a, b) =&gt; a - b 是升序；<br>(a, b) =&gt; b - a 是降序。</p>
<h4 id="7-最大值"><a href="#7-最大值" class="headerlink" title="7.最大值"></a>7.最大值</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.max(...[1, 2, 3, 4]) &#x2F;&#x2F;4</span><br><span class="line">Math.max.apply(this, [1, 2, 3, 4]) &#x2F;&#x2F;4</span><br><span class="line">[1, 2, 3, 4].reduce((prev, cur, curIndex, arr) &#x3D;&gt; &#123;</span><br><span class="line">   return Math.max(prev, cur);</span><br><span class="line">&#125;, 0) &#x2F;&#x2F;4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>取数组对象中id的最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&#123; id: 1, name: &#39;jack&#39; &#125;,&#123; id: 2, name: &#39;may&#39; &#125;,&#123; id: 3, name: &#39;shawn&#39; &#125;,&#123; id: 4, name: &#39;tony&#39; &#125;]</span><br><span class="line">const arr1 &#x3D; Math.max.apply(Math, arr.map(item &#x3D;&gt; &#123; return item.id &#125;))</span><br><span class="line">const arr2 &#x3D; arr.sort((a, b) &#x3D;&gt; &#123; return b.id - a.id &#125;)[0].id</span><br><span class="line">console.log(arr1) &#x2F;&#x2F; 4</span><br><span class="line">console.log(arr2) &#x2F;&#x2F; 4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="8-数组求和"><a href="#8-数组求和" class="headerlink" title="8.数组求和"></a>8.数组求和</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4].reduce(function (prev, cur) &#123;</span><br><span class="line">  return prev + cur;</span><br><span class="line">&#125;, 0) &#x2F;&#x2F;10 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sum &#x3D; [&#123;age:1&#125;,&#123;age:2&#125;].reduce(function (prev, cur) &#123;</span><br><span class="line">  return prev + cur.age;</span><br><span class="line">&#125;, 0) &#x2F;&#x2F;3</span><br><span class="line">console.log(sum)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="9-数组合并"><a href="#9-数组合并" class="headerlink" title="9.数组合并"></a>9.数组合并</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D;[1, 2, 3, 4].concat([5, 6]) &#x2F;&#x2F;[1,2,3,4,5,6]</span><br><span class="line">const arr2 &#x3D;[...[1, 2, 3, 4],...[4, 5]] &#x2F;&#x2F;[1,2,3,4,5,6]</span><br><span class="line">const arrA &#x3D; [1, 2], arrB &#x3D; [3, 4]</span><br><span class="line">const arr3 &#x3D;[].concat.apply(arrA, arrB)&#x2F;&#x2F;arrA值为[1,2,3,4]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr4 &#x3D; [&#123; age: 1 &#125;].concat([&#123; age: 2 &#125;])</span><br><span class="line">const arr5 &#x3D; [...[&#123; age: 1 &#125;],...[&#123; age: 2 &#125;]]</span><br><span class="line">console.log(arr4) &#x2F;&#x2F;[ &#123; age: 1 &#125;, &#123; age: 2 &#125; ]</span><br><span class="line">console.log(arr5) &#x2F;&#x2F; [ &#123; age: 1 &#125;, &#123; age: 2 &#125; ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="10-数组是否包含值"><a href="#10-数组是否包含值" class="headerlink" title="10.数组是否包含值"></a>10.数组是否包含值</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([1, 2, 3].includes(4)) &#x2F;&#x2F;false</span><br><span class="line">console.log([1, 2, 3].indexOf(4)) &#x2F;&#x2F;-1 如果存在换回索引</span><br><span class="line">console.log([1, 2, 3].find((item) &#x3D;&gt; item &#x3D;&#x3D;&#x3D; 3)) &#x2F;&#x2F;3 如果数组中无值返回undefined</span><br><span class="line">console.log([1, 2, 3].findIndex((item) &#x3D;&gt; item &#x3D;&#x3D;&#x3D; 3)) &#x2F;&#x2F;2 如果数组中无值返回-1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag &#x3D; [&#123;age:1&#125;,&#123;age:2&#125;].some(v&#x3D;&gt;JSON.stringify(v)&#x3D;&#x3D;&#x3D;JSON.stringify(&#123;age:2&#125;))</span><br><span class="line">console.log(flag)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="11-数组每一项都满足"><a href="#11-数组每一项都满足" class="headerlink" title="11.数组每一项都满足"></a>11.数组每一项都满足</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].every(item &#x3D;&gt; &#123; return item &gt; 2 &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&#123; age: 3 &#125;, &#123; age: 4 &#125;, &#123; age: 5 &#125;]</span><br><span class="line">arr.every(item &#x3D;&gt; &#123; return item.age &gt; 2 &#125;) &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="12-数组有一项满足"><a href="#12-数组有一项满足" class="headerlink" title="12.数组有一项满足"></a>12.数组有一项满足</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].some(item &#x3D;&gt; &#123; return item &gt; 2 &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&#123; age: 3 &#125;, &#123; age: 4 &#125;, &#123; age: 5 &#125;]</span><br><span class="line">arr.some(item &#x3D;&gt; &#123; return item.age &lt; 4 &#125;) &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="13-版本号排序"><a href="#13-版本号排序" class="headerlink" title="13.版本号排序"></a>13.版本号排序</h4><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sortNumber(a, b) &#123;</span><br><span class="line">  return a - b</span><br><span class="line">&#125;</span><br><span class="line">const b &#x3D; [1,2,3,7,5,6]</span><br><span class="line">const a &#x3D; [&quot;1.5&quot;, &quot;1.5&quot;, &quot;1.40&quot;, &quot;1.25&quot;, &quot;1.1000&quot;, &quot;1.1&quot;];</span><br><span class="line"></span><br><span class="line">console.log(a.sort(sortNumber)); &#x2F;&#x2F; [ 1, 2, 3, 5, 6, 7 ]</span><br><span class="line">console.log(b.sort(sortNumber)); &#x2F;&#x2F;[ &#39;1.1000&#39;, &#39;1.1&#39;, &#39;1.25&#39;, &#39;1.40&#39;, &#39;1.5&#39;, &#39;1.5&#39; ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可见sort排序对整数可以，类似版本号这个格式就不适用了，因为sort函数在比较字符串的时候，是比较字符串的Unicode进行排序的。</p>
<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;假定字符串的每节数都在5位以下</span><br><span class="line">&#x2F;&#x2F;去除数组空值||空格</span><br><span class="line">if (!Array.prototype.trim) &#123;</span><br><span class="line">  Array.prototype.trim &#x3D; function () &#123;</span><br><span class="line">    let arr &#x3D; []; this.forEach(function (e) &#123;</span><br><span class="line">      if (e.match(&#x2F;\S+&#x2F;)) arr.push(e);</span><br><span class="line">    &#125;)</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提取数字部分</span><br><span class="line">function toNum(a) &#123;</span><br><span class="line">  let d &#x3D; a.toString();</span><br><span class="line">  let c &#x3D; d.split(&#x2F;\D&#x2F;).trim();</span><br><span class="line">  let num_place &#x3D; [&quot;&quot;, &quot;0&quot;, &quot;00&quot;, &quot;000&quot;, &quot;0000&quot;], r &#x3D; num_place.reverse();</span><br><span class="line">  for (let i &#x3D; 0; i &lt; c.length; i++) &#123;</span><br><span class="line">    let len &#x3D; c[i].length;</span><br><span class="line">    c[i] &#x3D; r[len] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  let res &#x3D; c.join(&#39;&#39;);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提取字符</span><br><span class="line">function toChar(a) &#123;</span><br><span class="line">  let d &#x3D; a.toString();</span><br><span class="line">  let c &#x3D; d.split(&#x2F;\.|\d&#x2F;).join(&#39;&#39;);</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sortVersions(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let _a1 &#x3D; toNum(a), _b1 &#x3D; toNum(b);</span><br><span class="line">  if (_a1 !&#x3D;&#x3D; _b1) return _a1 - _b1;</span><br><span class="line">  else &#123;</span><br><span class="line">    _a2 &#x3D; toChar(a).charCodeAt(0).toString(16);</span><br><span class="line">    _b2 &#x3D; toChar(b).charCodeAt(0).toString(16);</span><br><span class="line">    return _a2 - _b2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr1 &#x3D; [&quot;10&quot;, &quot;5&quot;, &quot;40&quot;, &quot;25&quot;, &quot;1000&quot;, &quot;1&quot;];</span><br><span class="line">let arr2 &#x3D; [&quot;1.10&quot;, &quot;1.5&quot;, &quot;1.40&quot;, &quot;1.25&quot;, &quot;1.1000&quot;, &quot;1.1&quot;];</span><br><span class="line">let arr3 &#x3D; [&quot;1.10c&quot;, &quot;1.10b&quot;, &quot;1.10C&quot;, &quot;1.25&quot;, &quot;1.1000&quot;, &quot;1.10A&quot;];</span><br><span class="line">console.log(arr1.sort(sortVersions)) &#x2F;&#x2F;[ &#39;1&#39;, &#39;5&#39;, &#39;10&#39;, &#39;25&#39;, &#39;40&#39;, &#39;1000&#39; ]</span><br><span class="line">console.log(arr2.sort(sortVersions)) &#x2F;&#x2F;[ &#39;1.1&#39;, &#39;1.5&#39;, &#39;1.10&#39;, &#39;1.25&#39;, &#39;1.40&#39;, &#39;1.1000&#39; ]</span><br><span class="line">console.log(arr3.sort(sortVersions)) &#x2F;&#x2F; [ &#39;1.10A&#39;, &#39;1.10C&#39;, &#39;1.10b&#39;, &#39;1.10c&#39;, &#39;1.25&#39;, &#39;1.1000&#39; ]</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看出这个函数均兼容整数，非整数，字母；<br>字母排序是根据Unicode排序的，所以1.10b在1.10C的后面</p>
<h4 id="14-对象转数组"><a href="#14-对象转数组" class="headerlink" title="14. 对象转数组"></a>14. 对象转数组</h4><p>将数组的key和value转化成数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.keys(&#123; name: &#39;张三&#39;, age: 14 &#125;) &#x2F;&#x2F;[&#39;name&#39;,&#39;age&#39;]</span><br><span class="line">Object.values(&#123; name: &#39;张三&#39;, age: 14 &#125;) &#x2F;&#x2F;[&#39;张三&#39;,14]</span><br><span class="line">Object.entries(&#123; name: &#39;张三&#39;, age: 14 &#125;) &#x2F;&#x2F;[[name,&#39;张三&#39;],[age,14]]</span><br><span class="line">Object.fromEntries([name, &#39;张三&#39;], [age, 14]) &#x2F;&#x2F;ES10的api,Chrome不支持 , firebox输出&#123;name:&#39;张三&#39;,age:14&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="15-数组转对象"><a href="#15-数组转对象" class="headerlink" title="15.数组转对象"></a>15.数组转对象</h4><p>将数组的值转化为对象的value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arrName &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]</span><br><span class="line">const arrAge&#x3D;[&#39;20&#39;,&#39;30&#39;,&#39;40&#39;]</span><br><span class="line">const arrDec &#x3D; [&#39;描述1&#39;, &#39;描述2&#39;, &#39;描述3&#39;]</span><br><span class="line">const obj &#x3D; arrName.map((item,index)&#x3D;&gt;&#123;</span><br><span class="line">  return &#123; name: item, age: arrAge[index],dec:arrDec[index]&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(obj) &#x2F;&#x2F; [&#123; name: &#39;张三&#39;, age: &#39;20&#39;, dec: &#39;描述1&#39; &#125;,&#123; name: &#39;李四&#39;, age: &#39;30&#39;, dec: &#39;描述2&#39; &#125;,&#123; name: &#39;王五&#39;, age: &#39;40&#39;, dec: &#39;描述3&#39; &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="16-数组解构"><a href="#16-数组解构" class="headerlink" title="16.数组解构"></a>16.数组解构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr&#x3D;[1,2]; &#x2F;&#x2F;后面一定要加分号，因为不加解释器会认为在读数组</span><br><span class="line">[arr[1], arr[0]] &#x3D; [arr[0], arr[1]]; &#x2F;&#x2F; [2,1]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="17-对象变量属性"><a href="#17-对象变量属性" class="headerlink" title="17.对象变量属性"></a>17.对象变量属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag &#x3D; true;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    a: 0,</span><br><span class="line">    [flag ? &quot;c&quot; : &quot;d&quot;]: 2</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; obj &#x3D;&gt; &#123; a: 0, c: 2 &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="18-对象多余属性删除"><a href="#18-对象多余属性删除" class="headerlink" title="18.对象多余属性删除"></a>18.对象多余属性删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; name, age, ...obj &#125; &#x3D; &#123; name: &#39;张三&#39;, age: 13, dec: &#39;描述1&#39;, info: &#39;信息&#39; &#125;</span><br><span class="line">console.log(name)  &#x2F;&#x2F; 张三</span><br><span class="line">console.log(age)  &#x2F;&#x2F; 13</span><br><span class="line">console.log(obj)  &#x2F;&#x2F; &#123;dec: &#39;描述1&#39;, info: &#39;信息&#39; &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="19-对象嵌套属性解构"><a href="#19-对象嵌套属性解构" class="headerlink" title="19.对象嵌套属性解构"></a>19.对象嵌套属性解构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; info:&#123; dec&#125; &#125; &#x3D; &#123; name: &#39;张三&#39;, age: 13, info:&#123;dec: &#39;描述1&#39;, info: &#39;信息&#39; &#125;&#125;</span><br><span class="line">console.log(dec) &#x2F;&#x2F; 描述1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="20-解构对象属性别名"><a href="#20-解构对象属性别名" class="headerlink" title="20.解构对象属性别名"></a>20.解构对象属性别名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; name:newName &#125; &#x3D; &#123; name: &#39;张三&#39;, age: 13 &#125;</span><br><span class="line">console.log(newName)  &#x2F;&#x2F; 张三</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="21-解构对象属性默认值"><a href="#21-解构对象属性默认值" class="headerlink" title="21.解构对象属性默认值"></a>21.解构对象属性默认值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; dec&#x3D;&#39;这是默认dec值&#39; &#125; &#x3D; &#123; name: &#39;张三&#39;, age: 13 &#125;</span><br><span class="line">console.log(dec) &#x2F;&#x2F;这是默认dec值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="22-拦截对象"><a href="#22-拦截对象" class="headerlink" title="22.拦截对象"></a>22.拦截对象</h4><p>利用Object.defineProperty拦截对象<br>无法拦截数组的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123; name: &#39;&#39;, age: &#39;&#39;, sex: &#39;&#39; &#125;,</span><br><span class="line">  defaultName &#x3D; [&quot;这是姓名默认值1&quot;, &quot;这是年龄默认值1&quot;, &quot;这是性别默认值1&quot;];</span><br><span class="line">Object.keys(obj).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123; &#x2F;&#x2F; 拦截整个object 对象，并通过get获取值，set设置值，vue 2.x的核心就是这个来监听</span><br><span class="line">    get() &#123;</span><br><span class="line">      return defaultName;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">      defaultName &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(obj.name); &#x2F;&#x2F; [ &#39;这是姓名默认值1&#39;, &#39;这是年龄默认值1&#39;, &#39;这是性别默认值1&#39; ]</span><br><span class="line">console.log(obj.age); &#x2F;&#x2F; [ &#39;这是姓名默认值1&#39;, &#39;这是年龄默认值1&#39;, &#39;这是性别默认值1&#39; ]</span><br><span class="line">console.log(obj.sex); &#x2F;&#x2F; [ &#39;这是姓名默认值1&#39;, &#39;这是年龄默认值1&#39;, &#39;这是性别默认值1&#39; ]</span><br><span class="line">obj.name &#x3D; &quot;这是改变值1&quot;;</span><br><span class="line">console.log(obj.name); &#x2F;&#x2F; 这是改变值1</span><br><span class="line">console.log(obj.age);  &#x2F;&#x2F; 这是改变值1</span><br><span class="line">console.log(obj.sex); &#x2F;&#x2F; 这是改变值1</span><br><span class="line"></span><br><span class="line">let objOne &#x3D; &#123;&#125;, defaultNameOne &#x3D; &quot;这是默认值2&quot;;</span><br><span class="line">Object.defineProperty(obj, &#39;name&#39;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return defaultNameOne;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(value) &#123;</span><br><span class="line">    defaultNameOne &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(objOne.name); &#x2F;&#x2F; undefined</span><br><span class="line">objOne.name &#x3D; &quot;这是改变值2&quot;;</span><br><span class="line">console.log(objOne.name); &#x2F;&#x2F; 这是改变值2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>利用proxy拦截对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123; name: &#39;&#39;, age: &#39;&#39;, sex: &#39;&#39; &#125;</span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  get(target, key, receiver) &#123;</span><br><span class="line">    console.log(&quot;get&quot;, key); </span><br><span class="line">    return Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value, receiver) &#123;</span><br><span class="line">    console.log(&quot;set&quot;, key, value); &#x2F;&#x2F; set name 李四  &#x2F;&#x2F; set age 24</span><br><span class="line">    return Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let proxy &#x3D; new Proxy(obj, handler);</span><br><span class="line">proxy.name &#x3D; &quot;李四&quot;;</span><br><span class="line">proxy.age &#x3D; 24;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>defineProterty和proxy的对比：<br>1.defineProterty是es5的标准,proxy是es6的标准;<br>2.proxy可以监听到数组索引赋值,改变数组长度的变化;<br>3.proxy是监听对象,不用深层遍历,defineProterty是监听属性;<br>4.利用defineProterty实现双向数据绑定(vue2.x采用的核心)</p>
<h4 id="23-对象深度拷贝"><a href="#23-对象深度拷贝" class="headerlink" title="23.对象深度拷贝"></a>23.对象深度拷贝</h4><p>JSON.stringify深度克隆对象;<br>1.无法对函数 、RegExp等特殊对象的克隆;<br>2.会抛弃对象的constructor,所有的构造函数会指向Object;<br>3.对象有循环引用,会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapTag &#x3D; &#39;[object Map]&#39;;</span><br><span class="line">const setTag &#x3D; &#39;[object Set]&#39;;</span><br><span class="line">const arrayTag &#x3D; &#39;[object Array]&#39;;</span><br><span class="line">const objectTag &#x3D; &#39;[object Object]&#39;;</span><br><span class="line">const argsTag &#x3D; &#39;[object Arguments]&#39;;</span><br><span class="line"></span><br><span class="line">const boolTag &#x3D; &#39;[object Boolean]&#39;;</span><br><span class="line">const dateTag &#x3D; &#39;[object Date]&#39;;</span><br><span class="line">const numberTag &#x3D; &#39;[object Number]&#39;;</span><br><span class="line">const stringTag &#x3D; &#39;[object String]&#39;;</span><br><span class="line">const symbolTag &#x3D; &#39;[object Symbol]&#39;;</span><br><span class="line">const errorTag &#x3D; &#39;[object Error]&#39;;</span><br><span class="line">const regexpTag &#x3D; &#39;[object RegExp]&#39;;</span><br><span class="line">const funcTag &#x3D; &#39;[object Function]&#39;;</span><br><span class="line"></span><br><span class="line">const deepTag &#x3D; [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function forEach(array, iteratee) &#123;</span><br><span class="line">  let index &#x3D; -1;</span><br><span class="line">  const length &#x3D; array.length;</span><br><span class="line">  while (++index &lt; length) &#123;</span><br><span class="line">    iteratee(array[index], index);</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isObject(target) &#123;</span><br><span class="line">  const type &#x3D; typeof target;</span><br><span class="line">  return target !&#x3D;&#x3D; null &amp;&amp; (type &#x3D;&#x3D;&#x3D; &#39;object&#39; || type &#x3D;&#x3D;&#x3D; &#39;function&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getType(target) &#123;</span><br><span class="line">  return Object.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getInit(target) &#123;</span><br><span class="line">  const Ctor &#x3D; target.constructor;</span><br><span class="line">  return new Ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneSymbol(targe) &#123;</span><br><span class="line">  return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneReg(targe) &#123;</span><br><span class="line">  const reFlags &#x3D; &#x2F;\w*$&#x2F;;</span><br><span class="line">  const result &#x3D; new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">  result.lastIndex &#x3D; targe.lastIndex;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneFunction(func) &#123;</span><br><span class="line">  const bodyReg &#x3D; &#x2F;(?&lt;&#x3D;&#123;)(.|\n)+(?&#x3D;&#125;)&#x2F;m;</span><br><span class="line">  const paramReg &#x3D; &#x2F;(?&lt;&#x3D;\().+(?&#x3D;\)\s+&#123;)&#x2F;;</span><br><span class="line">  const funcString &#x3D; func.toString();</span><br><span class="line">  if (func.prototype) &#123;</span><br><span class="line">    const param &#x3D; paramReg.exec(funcString);</span><br><span class="line">    const body &#x3D; bodyReg.exec(funcString);</span><br><span class="line">    if (body) &#123;</span><br><span class="line">      if (param) &#123;</span><br><span class="line">        const paramArr &#x3D; param[0].split(&#39;,&#39;);</span><br><span class="line">        return new Function(...paramArr, body[0]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return new Function(body[0]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return eval(funcString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneOtherType(targe, type) &#123;</span><br><span class="line">  const Ctor &#x3D; targe.constructor;</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case boolTag:</span><br><span class="line">    case numberTag:</span><br><span class="line">    case stringTag:</span><br><span class="line">    case errorTag:</span><br><span class="line">    case dateTag:</span><br><span class="line">      return new Ctor(targe);</span><br><span class="line">    case regexpTag:</span><br><span class="line">      return cloneReg(targe);</span><br><span class="line">    case symbolTag:</span><br><span class="line">      return cloneSymbol(targe);</span><br><span class="line">    case funcTag:</span><br><span class="line">      return cloneFunction(targe);</span><br><span class="line">    default:</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clone(target, map &#x3D; new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 克隆原始类型</span><br><span class="line">  if (!isObject(target)) &#123;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 初始化</span><br><span class="line">  const type &#x3D; getType(target);</span><br><span class="line">  let cloneTarget;</span><br><span class="line">  if (deepTag.includes(type)) &#123;</span><br><span class="line">    cloneTarget &#x3D; getInit(target, type);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return cloneOtherType(target, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 防止循环引用</span><br><span class="line">  if (map.get(target)) &#123;</span><br><span class="line">    return map.get(target);</span><br><span class="line">  &#125;</span><br><span class="line">  map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 克隆set</span><br><span class="line">  if (type &#x3D;&#x3D;&#x3D; setTag) &#123;</span><br><span class="line">    target.forEach(value &#x3D;&gt; &#123;</span><br><span class="line">      cloneTarget.add(clone(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 克隆map</span><br><span class="line">  if (type &#x3D;&#x3D;&#x3D; mapTag) &#123;</span><br><span class="line">    target.forEach((value, key) &#x3D;&gt; &#123;</span><br><span class="line">      cloneTarget.set(key, clone(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 克隆对象和数组</span><br><span class="line">  const keys &#x3D; type &#x3D;&#x3D;&#x3D; arrayTag ? undefined : Object.keys(target);</span><br><span class="line">  forEach(keys || target, (value, key) &#x3D;&gt; &#123;</span><br><span class="line">    if (keys) &#123;</span><br><span class="line">      key &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    cloneTarget[key] &#x3D; clone(target[key], map);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return cloneTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(clone(&#123;</span><br><span class="line">  name: &#39;张三&#39;, age: 23,</span><br><span class="line">  obj: &#123; name: &#39;李四&#39;, age: 46 &#125;,</span><br><span class="line">  arr: [1, 2, 3]</span><br><span class="line">&#125;)) &#x2F;&#x2F; &#123; name: &#39;张三&#39;, age: 23, obj: &#123; name: &#39;李四&#39;, age: 46 &#125;, arr: [ 1, 2, 3 ] &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对象深度克隆实际上就是要兼容Array，RegExp，Date，Function类型；<br>克隆函数可以用正则取出函数体和参数，再定义一个函数将取出来的值赋值进去<br>详细请戳对象深度拷贝</p>
<h4 id="24-对象是否相等"><a href="#24-对象是否相等" class="headerlink" title="24.对象是否相等"></a>24.对象是否相等</h4><p>如果用JSON.stringify转化属性顺序不同，也不相等；<br>而且不支持无法对函数 、RegExp等特殊对象的克隆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepCompare(x, y) &#123;</span><br><span class="line">  var i, l, leftChain, rightChain;</span><br><span class="line"></span><br><span class="line">  function compare2Objects(x, y) &#123;</span><br><span class="line">    var p;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; remember that NaN &#x3D;&#x3D;&#x3D; NaN returns false</span><br><span class="line">    &#x2F;&#x2F; and isNaN(undefined) returns true</span><br><span class="line">    if (isNaN(x) &amp;&amp; isNaN(y) &amp;&amp; typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39; &amp;&amp; typeof y &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Compare primitives and functions.     </span><br><span class="line">    &#x2F;&#x2F; Check if both arguments link to the same object.</span><br><span class="line">    &#x2F;&#x2F; Especially useful on the step where we compare prototypes</span><br><span class="line">    if (x &#x3D;&#x3D;&#x3D; y) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Works in case when functions are created in constructor.</span><br><span class="line">    &#x2F;&#x2F; Comparing dates is a common scenario. Another built-ins?</span><br><span class="line">    &#x2F;&#x2F; We can even handle functions passed across iframes</span><br><span class="line">    if ((typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof y &#x3D;&#x3D;&#x3D; &#39;function&#39;) ||</span><br><span class="line">      (x instanceof Date &amp;&amp; y instanceof Date) ||</span><br><span class="line">      (x instanceof RegExp &amp;&amp; y instanceof RegExp) ||</span><br><span class="line">      (x instanceof String &amp;&amp; y instanceof String) ||</span><br><span class="line">      (x instanceof Number &amp;&amp; y instanceof Number)) &#123;</span><br><span class="line">      return x.toString() &#x3D;&#x3D;&#x3D; y.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; At last checking prototypes as good as we can</span><br><span class="line">    if (!(x instanceof Object &amp;&amp; y instanceof Object)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (x.constructor !&#x3D;&#x3D; y.constructor) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (x.prototype !&#x3D;&#x3D; y.prototype) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check for infinitive linking loops</span><br><span class="line">    if (leftChain.indexOf(x) &gt; -1 || rightChain.indexOf(y) &gt; -1) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Quick checking of one object being a subset of another.</span><br><span class="line">    &#x2F;&#x2F; todo: cache the structure of arguments[0] for performance</span><br><span class="line">    for (p in y) &#123;</span><br><span class="line">      if (y.hasOwnProperty(p) !&#x3D;&#x3D; x.hasOwnProperty(p)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125; else if (typeof y[p] !&#x3D;&#x3D; typeof x[p]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (p in x) &#123;</span><br><span class="line">      if (y.hasOwnProperty(p) !&#x3D;&#x3D; x.hasOwnProperty(p)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125; else if (typeof y[p] !&#x3D;&#x3D; typeof x[p]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (typeof (x[p])) &#123;</span><br><span class="line">        case &#39;object&#39;:</span><br><span class="line">        case &#39;function&#39;:</span><br><span class="line"></span><br><span class="line">          leftChain.push(x);</span><br><span class="line">          rightChain.push(y);</span><br><span class="line"></span><br><span class="line">          if (!compare2Objects(x[p], y[p])) &#123;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          leftChain.pop();</span><br><span class="line">          rightChain.pop();</span><br><span class="line">          break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">          if (x[p] !&#x3D;&#x3D; y[p]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (arguments.length &lt; 1) &#123;</span><br><span class="line">    return true; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (i &#x3D; 1, l &#x3D; arguments.length; i &lt; l; i++) &#123;</span><br><span class="line"></span><br><span class="line">    leftChain &#x3D; []; &#x2F;&#x2F;Todo: this can be cached</span><br><span class="line">    rightChain &#x3D; [];</span><br><span class="line"></span><br><span class="line">    if (!compare2Objects(arguments[0], arguments[i])) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj1 &#x3D; &#123; </span><br><span class="line">  name: &#39;张三&#39;, age: 23, </span><br><span class="line">  obj: &#123; name: &#39;李四&#39;, age: 46 &#125;, </span><br><span class="line">  arr: [1, 2, 3],</span><br><span class="line">  date:new Date(23),</span><br><span class="line">  reg: new RegExp(&#39;abc&#39;),</span><br><span class="line">  fun: ()&#x3D;&gt;&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">const obj2 &#x3D; &#123; </span><br><span class="line">  name: &#39;张三&#39;, age: 23, </span><br><span class="line">  obj: &#123; name: &#39;李四&#39;, age: 46 &#125;, </span><br><span class="line">  arr: [1, 2, 3],</span><br><span class="line">  date: new Date(23),</span><br><span class="line">  reg: new RegExp(&#39;abc&#39;),</span><br><span class="line">  fun: ()&#x3D;&gt;&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">console.log(deepCompare(obj1,obj2)) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>判断对象是否相等，实际上就是要处理Array，Date，RegExp，Object，Function的特殊类型是否相等</p>
<h4 id="25-对象转化为字符串"><a href="#25-对象转化为字符串" class="headerlink" title="25.对象转化为字符串"></a>25.对象转化为字符串</h4><p>通过字符串+Object 的方式来转化对象为字符串(实际上是调用 .toString() 方法)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;the Math object:&#39; + Math.ceil(3.4)                &#x2F;&#x2F; &quot;the Math object:4&quot;</span><br><span class="line">&#39;the JSON object:&#39; + &#123;name:&#39;曹操&#39;&#125;              &#x2F;&#x2F; &quot;the JSON object:[object Object]&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>覆盖对象的toString和valueOf方法来自定义对象的类型转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2  * &#123; valueOf: ()&#x3D;&gt;&#39;4&#39; &#125;                &#x2F;&#x2F; 8</span><br><span class="line">&#39;J&#39; + &#123; toString: ()&#x3D;&gt;&#39;ava&#39; &#125;                &#x2F;&#x2F; &quot;Java&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当+用在连接字符串时，当一个对象既有toString方法又有valueOf方法时候，JS通过盲目使用valueOf方法来解决这种含糊;<br>对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39; + &#123;toString:()&#x3D;&gt;&#39;S&#39;,valueOf:()&#x3D;&gt;&#39;J&#39;&#125;  &#x2F;&#x2F;J</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><h4 id="26-函数隐式返回值"><a href="#26-函数隐式返回值" class="headerlink" title="26.函数隐式返回值"></a>26.函数隐式返回值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(()&#x3D;&gt;3)()  &#x2F;&#x2F;3</span><br><span class="line">(()&#x3D;&gt;(</span><br><span class="line">   3</span><br><span class="line">))()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>函数省略大括号，或者将大括号改成小括号可以确保代码以单个语句的形式进行求值</p>
<h4 id="27-函数自执行"><a href="#27-函数自执行" class="headerlink" title="27.函数自执行"></a>27.函数自执行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Func &#x3D; function() &#123;&#125;(); &#x2F;&#x2F; 常用</span><br><span class="line"></span><br><span class="line">(function() &#123;&#125;)(); &#x2F;&#x2F; 常用</span><br><span class="line">(function() &#123;&#125;()); &#x2F;&#x2F; 常用</span><br><span class="line">[function() &#123;&#125;()];</span><br><span class="line"></span><br><span class="line">new function() &#123;&#125;;</span><br><span class="line">new function() &#123;&#125;();</span><br><span class="line">void function() &#123;&#125;();</span><br><span class="line">typeof function() &#123;&#125;();</span><br><span class="line">delete function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">+ function() &#123;&#125;();</span><br><span class="line">- function() &#123;&#125;();</span><br><span class="line">~ function() &#123;&#125;();</span><br><span class="line">! function() &#123;&#125;();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="28-函数异步执行"><a href="#28-函数异步执行" class="headerlink" title="28.函数异步执行"></a>28.函数异步执行</h4><p>Promise</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.reject(&#39;这是第二个 reject 值&#39;).then((data)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;).catch(data&#x3D;&gt;&#123;</span><br><span class="line">  console.log(data) &#x2F;&#x2F;这是第二个 reject 值</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* gen(x) &#123;</span><br><span class="line">  const y &#x3D; yield x + 6;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; yield 如果用在另外一个表达式中,要放在()里面</span><br><span class="line">&#x2F;&#x2F; 像上面如果是在&#x3D;右边就不用加()</span><br><span class="line">function* genOne(x) &#123;</span><br><span class="line">  const y &#x3D; &#96;这是第一个 yield 执行:$&#123;yield x + 1&#125;&#96;;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const g &#x3D; gen(1);</span><br><span class="line">&#x2F;&#x2F;执行 Generator 会返回一个Object,而不是像普通函数返回return 后面的值</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: 7, done: false &#125;</span><br><span class="line">&#x2F;&#x2F;调用指针的 next 方法,会从函数的头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式或return语句暂停,也就是执行yield 这一行</span><br><span class="line">&#x2F;&#x2F; 执行完成会返回一个 Object,</span><br><span class="line">&#x2F;&#x2F; value 就是执行 yield 后面的值,done 表示函数是否执行完毕</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br><span class="line">&#x2F;&#x2F; 因为最后一行 return y 被执行完成,所以done 为 true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Async/Await</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getSomething() &#123;</span><br><span class="line">    return &quot;something&quot;;</span><br><span class="line">&#125;</span><br><span class="line">async function testAsync() &#123;</span><br><span class="line">    return Promise.resolve(&quot;hello async&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    const v1 &#x3D; await getSomething();</span><br><span class="line">    const v2 &#x3D; await testAsync();</span><br><span class="line">    console.log(v1, v2); &#x2F;&#x2F;something 和 hello async</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="29-字符串翻转"><a href="#29-字符串翻转" class="headerlink" title="29.字符串翻转"></a>29.字符串翻转</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function reverseStr(str &#x3D; &quot;&quot;) &#123;</span><br><span class="line">  return str.split(&quot;&quot;).reduceRight((t, v) &#x3D;&gt; t + v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const str &#x3D; &quot;reduce123&quot;;</span><br><span class="line">console.log(reverseStr(str)); &#x2F;&#x2F; &quot;321recuder&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="30-url参数序列化"><a href="#30-url参数序列化" class="headerlink" title="30.url参数序列化"></a>30.url参数序列化</h4><p>将对象序列化成url参数传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function stringifyUrl(search &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  return Object.entries(search).reduce(</span><br><span class="line">    (t, v) &#x3D;&gt; &#96;$&#123;t&#125;$&#123;v[0]&#125;&#x3D;$&#123;encodeURIComponent(v[1])&#125;&amp;&#96;,</span><br><span class="line">    Object.keys(search).length ? &quot;?&quot; : &quot;&quot;</span><br><span class="line">  ).replace(&#x2F;&amp;$&#x2F;, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(stringifyUrl(&#123; age: 27, name: &quot;YZW&quot; &#125;)); &#x2F;&#x2F; &quot;?age&#x3D;27&amp;name&#x3D;YZW&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="31-url参数反序列化"><a href="#31-url参数反序列化" class="headerlink" title="31.url参数反序列化"></a>31.url参数反序列化</h4><p>一般会通过location.search拿到路由传递的参数，并进行反序列化得到对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parseUrlSearch() &#123;</span><br><span class="line">  const search &#x3D; &#39;?age&#x3D;25&amp;name&#x3D;TYJ&#39;</span><br><span class="line">  return search.replace(&#x2F;(^\?)|(&amp;$)&#x2F;g, &quot;&quot;).split(&quot;&amp;&quot;).reduce((t, v) &#x3D;&gt; &#123;</span><br><span class="line">    const [key, val] &#x3D; v.split(&quot;&#x3D;&quot;);</span><br><span class="line">    t[key] &#x3D; decodeURIComponent(val);</span><br><span class="line">    return t;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(parseUrlSearch()); &#x2F;&#x2F; &#123; age: &quot;25&quot;, name: &quot;TYJ&quot; &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="32-转化为字符串"><a href="#32-转化为字符串" class="headerlink" title="32.转化为字符串"></a>32.转化为字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const val &#x3D; 1 + &quot;&quot;; &#x2F;&#x2F; 通过+ &#39;&#39;空字符串转化</span><br><span class="line">console.log(val); &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">console.log(typeof val); &#x2F;&#x2F; &quot;string&quot;</span><br><span class="line"></span><br><span class="line">const val1 &#x3D; String(1);</span><br><span class="line">console.log(val1); &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">console.log(typeof val1); &#x2F;&#x2F; &quot;string&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h4 id="33-数字千分位"><a href="#33-数字千分位" class="headerlink" title="33.数字千分位"></a>33.数字千分位</h4><p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function thousandNum(num &#x3D; 0) &#123;</span><br><span class="line">  const str &#x3D; (+num).toString().split(&quot;.&quot;);</span><br><span class="line">  const int &#x3D; nums &#x3D;&gt; nums.split(&quot;&quot;).reverse().reduceRight((t, v, i) &#x3D;&gt; t + (i % 3 ? v : &#96;$&#123;v&#125;,&#96;), &quot;&quot;).replace(&#x2F;^,|,$&#x2F;g, &quot;&quot;);</span><br><span class="line">  const dec &#x3D; nums &#x3D;&gt; nums.split(&quot;&quot;).reduce((t, v, i) &#x3D;&gt; t + ((i + 1) % 3 ? v : &#96;$&#123;v&#125;,&#96;), &quot;&quot;).replace(&#x2F;^,|,$&#x2F;g, &quot;&quot;);</span><br><span class="line">  return str.length &gt; 1 ? &#96;$&#123;int(str[0])&#125;.$&#123;dec(str[1])&#125;&#96; : int(str[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thousandNum(1234); &#x2F;&#x2F; &quot;1,234&quot;</span><br><span class="line">thousandNum(1234.00); &#x2F;&#x2F; &quot;1,234&quot;</span><br><span class="line">thousandNum(0.1234); &#x2F;&#x2F; &quot;0.123,4&quot;</span><br><span class="line">console.log(thousandNum(1234.5678)); &#x2F;&#x2F; &quot;1,234.567,8&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;1234567890&#39;.replace(&#x2F;\B(?&#x3D;(\d&#123;3&#125;)+(?!\d))&#x2F;g, &quot;,&quot;))</span><br><span class="line">console.log((1234567890).toLocaleString())</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="34-字符串转数字"><a href="#34-字符串转数字" class="headerlink" title="34.字符串转数字"></a>34.字符串转数字</h4><p>方法一<br>用*1来转化为数字,实际上是调用.valueOf方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;32&#39; * 1            &#x2F;&#x2F; 32</span><br><span class="line">&#39;ds&#39; * 1            &#x2F;&#x2F; NaN</span><br><span class="line">null * 1            &#x2F;&#x2F; 0</span><br><span class="line">undefined * 1    &#x2F;&#x2F; NaN</span><br><span class="line">1  * &#123; valueOf: ()&#x3D;&gt;&#39;3&#39; &#125;        &#x2F;&#x2F; 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ &#39;123&#39;            &#x2F;&#x2F; 123</span><br><span class="line">+ &#39;ds&#39;               &#x2F;&#x2F; NaN</span><br><span class="line">+ &#39;&#39;                    &#x2F;&#x2F; 0</span><br><span class="line">+ null              &#x2F;&#x2F; 0</span><br><span class="line">+ undefined    &#x2F;&#x2F; NaN</span><br><span class="line">+ &#123; valueOf: ()&#x3D;&gt;&#39;3&#39; &#125;    &#x2F;&#x2F; 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="35-判断小数是否相等"><a href="#35-判断小数是否相等" class="headerlink" title="35.判断小数是否相等"></a>35.判断小数是否相等</h4><p>肯定有人会说这还不简单，直接用’===’比较；<br>实际上0.1+0.2 !==0.3，因为计算机不能精确表示0.1， 0.2这样的浮点数，所以相加就不是0.3了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number.EPSILON&#x3D;(function()&#123;   &#x2F;&#x2F;解决兼容性问题</span><br><span class="line">    return Number.EPSILON?Number.EPSILON:Math.pow(2,-52);</span><br><span class="line">&#125;)();</span><br><span class="line">&#x2F;&#x2F;上面是一个自调用函数，当JS文件刚加载到内存中，就会去判断并返回一个结果</span><br><span class="line">function numbersequal(a,b)&#123; </span><br><span class="line">    return Math.abs(a-b)&lt;Number.EPSILON;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;接下来再判断   </span><br><span class="line">const a&#x3D;0.1+0.2, b&#x3D;0.3;</span><br><span class="line">console.log(numbersequal(a,b)); &#x2F;&#x2F;这里就为true了</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="36-双位运算符"><a href="#36-双位运算符" class="headerlink" title="36.双位运算符"></a>36.双位运算符</h4><p>双位运算符比Math.floor(),Math.ceil()速度快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~7.5                &#x2F;&#x2F; 7</span><br><span class="line">Math.ceil(7.5)       &#x2F;&#x2F; 8</span><br><span class="line">Math.floor(7.5)      &#x2F;&#x2F; 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~-7.5          &#x2F;&#x2F; -7</span><br><span class="line">Math.floor(-7.5)     &#x2F;&#x2F; -8</span><br><span class="line">Math.ceil(-7.5)      &#x2F;&#x2F; -7</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以负数时，双位运算符和Math.ceil结果一致，正数时和Math.floor结果一致</p>
<h4 id="37-取整和奇偶性判断"><a href="#37-取整和奇偶性判断" class="headerlink" title="37.取整和奇偶性判断"></a>37.取整和奇偶性判断</h4><p>取整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.3 | 0         &#x2F;&#x2F; 3</span><br><span class="line">-3.9 | 0        &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">parseInt(3.3)  &#x2F;&#x2F; 3</span><br><span class="line">parseInt(-3.3) &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 四舍五入取整</span><br><span class="line">Math.round(3.3) &#x2F;&#x2F; 3</span><br><span class="line">Math.round(-3.3) &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向上取整</span><br><span class="line">Math.ceil(3.3) &#x2F;&#x2F; 4</span><br><span class="line">Math.ceil(-3.3) &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向下取整</span><br><span class="line">Math.floor(3.3) &#x2F;&#x2F; 3</span><br><span class="line">Math.floor(-3.3) &#x2F;&#x2F; -4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>判断奇偶数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const num&#x3D;5;</span><br><span class="line">!!(num &amp; 1) &#x2F;&#x2F; true</span><br><span class="line">!!(num % 2) &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h4 id="38-判断数据类型"><a href="#38-判断数据类型" class="headerlink" title="38.判断数据类型"></a>38.判断数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dataTypeJudge(val, type) &#123;</span><br><span class="line">  const dataType &#x3D; Object.prototype.toString.call(val).replace(&#x2F;\[object (\w+)\]&#x2F;, &quot;$1&quot;).toLowerCase();</span><br><span class="line">  return type ? dataType &#x3D;&#x3D;&#x3D; type : dataType;</span><br><span class="line">&#125;</span><br><span class="line">console.log(dataTypeJudge(&quot;young&quot;)); &#x2F;&#x2F; &quot;string&quot;</span><br><span class="line">console.log(dataTypeJudge(20190214)); &#x2F;&#x2F; &quot;number&quot;</span><br><span class="line">console.log(dataTypeJudge(true)); &#x2F;&#x2F; &quot;boolean&quot;</span><br><span class="line">console.log(dataTypeJudge([], &quot;array&quot;)); &#x2F;&#x2F; true</span><br><span class="line">console.log(dataTypeJudge(&#123;&#125;, &quot;array&quot;)); &#x2F;&#x2F; false</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可判断类型：undefined、null、string、number、boolean、array、object、symbol、date、regexp、function、asyncfunction、arguments、set、map、weakset、weakmap</p>
<h4 id="39-使用Boolean过滤数组假值"><a href="#39-使用Boolean过滤数组假值" class="headerlink" title="39.使用Boolean过滤数组假值"></a>39.使用Boolean过滤数组假值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const compact &#x3D; arr &#x3D;&gt; arr.filter(Boolean)</span><br><span class="line">compact([0, 1, false, 2, &#39;&#39;, 3, &#39;a&#39;, &#39;e&#39; * 23, NaN, &#39;s&#39;, 34])  &#x2F;&#x2F;[ 1, 2, 3, &#39;a&#39;, &#39;s&#39;, 34 ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="40-短路运算"><a href="#40-短路运算" class="headerlink" title="40.短路运算"></a>40.短路运算</h4><p>||（或）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag &#x3D; false || true &#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F; 某个值为假时可以给默认值</span><br><span class="line">const arr &#x3D; false || []</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>&amp;&amp;（与）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag1 &#x3D; false &amp;&amp; true &#x2F;&#x2F;false</span><br><span class="line">const flag2 &#x3D; true &amp;&amp; true &#x2F;&#x2F;true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="41-switch-简写"><a href="#41-switch-简写" class="headerlink" title="41.switch 简写"></a>41.switch 简写</h4><p>可以用对象替代switch，提高代码可读性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch(a) &#123;</span><br><span class="line">  case &#39;张三&#39;:</span><br><span class="line">    return &#39;age是12&#39;</span><br><span class="line">  case &#39;李四&#39;:</span><br><span class="line">    return &#39;age是120&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用对象替换后</span><br><span class="line">const obj &#x3D;&#123;</span><br><span class="line">  &#39;张三&#39;: &#39;age12&#39;,</span><br><span class="line">  &#39;李四&#39;: &#39;age120&#39;,</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj[&#39;张三&#39;])</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>源码地址 <a href="https://github.com/lanzhsh/react-vue-koa/tree/master/js/skill；" target="_blank" rel="noopener">https://github.com/lanzhsh/react-vue-koa/tree/master/js/skill；</a><br>原创码字不易，欢迎start！</p>
<h2 id="给一个函数-Bind-对象"><a href="#给一个函数-Bind-对象" class="headerlink" title="给一个函数 Bind 对象"></a>给一个函数 Bind 对象</h2><p>我们经常需要将一个对象绑定到一个方法的 this 上。在 JS 中，如果你想要调用一个函数并指定它的 this 时可以使用 bind 方法。</p>
<p>Bind 语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<p>参数</p>
<p>thisArg</p>
<p>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。</p>
<p>arg1, arg2, …</p>
<p>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</p>
<p>返回值</p>
<p>返回由指定的this值和初始化参数改造的原函数拷贝</p>
<a id="more"></a>

<h2 id="JS-中的实例"><a href="#JS-中的实例" class="headerlink" title="JS 中的实例"></a>JS 中的实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myCar &#x3D; &#123; brand: &#39;Ford&#39;, type: &#39;Sedan&#39;, color: &#39;Red&#39;&#125;;</span><br><span class="line">const getBrand &#x3D; function () &#123; console.log(this.brand);&#125;;</span><br><span class="line">const getType &#x3D; function () &#123; console.log(this.type);&#125;;</span><br><span class="line">const getColor &#x3D; function () &#123; console.log(this.color);&#125;;</span><br><span class="line">getBrand(); &#x2F;&#x2F; object not bind,undefined</span><br><span class="line">getBrand(myCar); &#x2F;&#x2F; object not bind,undefined</span><br><span class="line">getType.bind(myCar)(); &#x2F;&#x2F; Sedan</span><br><span class="line">let boundGetColor &#x3D; getColor.bind(myCar);boundGetColor(); &#x2F;&#x2F; Red</span><br></pre></td></tr></table></figure>

<h2 id="获取文件拓展名"><a href="#获取文件拓展名" class="headerlink" title="获取文件拓展名"></a>获取文件拓展名</h2><p>解决方法 1: 正则表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFileExtension1(filename) &#123;  return (&#x2F;[.]&#x2F;.exec(filename)) ? &#x2F;[^.]+$&#x2F;.exec(filename)[0] : undefined;&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法 2: String的split方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFileExtension2(filename) &#123;  return filename.split(&#39;.&#39;).pop();&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法 3: String的slice、lastIndexOf方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFileExtension3(filename) &#123;  return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2);&#125;</span><br><span class="line">console.log(getFileExtension3(&#39;&#39;));                            &#x2F;&#x2F; &#39;&#39;console.log(getFileExtension3(&#39;filename&#39;));                    &#x2F;&#x2F; &#39;&#39;console.log(getFileExtension3(&#39;filename.txt&#39;));                &#x2F;&#x2F; &#39;txt&#39;console.log(getFileExtension3(&#39;.hiddenfile&#39;));                 &#x2F;&#x2F; &#39;&#39;console.log(getFileExtension3(&#39;filename.with.many.dots.ext&#39;)); &#x2F;&#x2F; &#39;ext&#39;</span><br></pre></td></tr></table></figure>

<p><strong>*这是如何实现的呢?*</strong></p>
<p><strong>**</strong></p>
<ul>
<li>String.lastIndexOf() 方法返回指定值（本例中的’.’）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</li>
<li>对于’filename’和’.hiddenfile’，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。</li>
<li>String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为””。</li>
</ul>
<h2 id="预防unapply攻击"><a href="#预防unapply攻击" class="headerlink" title="预防unapply攻击"></a>预防unapply攻击</h2><p>重写内置对象的原型方法，外部代码可以通过重写代码达到暴漏和修改已绑定参数的函数。这在es5的方法下使用polyfill时是一个严重的安全问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bind polyfill 示例function bind(fn) &#123;  var prev &#x3D; Array.prototype.slice.call(arguments, 1);  return function bound() &#123;    var curr &#x3D; Array.prototype.slice.call(arguments, 0);    var args &#x3D; Array.prototype.concat.apply(prev, curr);    return fn.apply(null, args);  &#125;;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; unapply攻击function unapplyAttack() &#123;  var concat &#x3D; Array.prototype.concat;  Array.prototype.concat &#x3D; function replaceAll() &#123;    Array.prototype.concat &#x3D; concat; &#x2F;&#x2F; restore the correct version    var curr &#x3D; Array.prototype.slice.call(arguments, 0);    var result &#x3D; concat.apply([], curr);    return result;  &#125;;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数声明忽略了函数bind的prev参数，意味着调用unapplyAttack之后首次调用.concat将会抛出错误。</p>
<p>使用Object.freeze，可以使对象不可变，你可以防止任何内置对象原型方法被重写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function freezePrototypes() &#123;  if (typeof Object.freeze !&#x3D;&#x3D; &#39;function&#39;) &#123;    throw new Error(&#39;Missing Object.freeze&#39;);  &#125;  Object.freeze(Object.prototype);  Object.freeze(Array.prototype);  Object.freeze(Function.prototype);&#125;());</span><br></pre></td></tr></table></figure>

<p>点击这里，你可以阅读更多关于unapply攻击。</p>
<p>##给缓存设置过期时间</p>
<p>方案一（通用）：ES5扩展Storage<a href="https://www.cnblogs.com/ricolee/p/localstorage-expiretime.html#341252870" target="_blank" rel="noopener">#</a></p>
<p>思路很简单，存储的值加一个时间戳，下次取值时验证时间戳。</p>
<p>注意： localStorage只能存储字符，存入时将对象转为json字符串,读取时也要解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;localStorage 设置的值不能为对象,转为json字符串</span><br><span class="line">Storage.prototype.setExpire &#x3D; (key, value, expire) &#x3D; &gt;&#123;</span><br><span class="line">    let obj &#x3D; &#123;</span><br><span class="line">        data: value,</span><br><span class="line">        time: Date.now(),</span><br><span class="line">        expire: expire</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    localStorage.setItem(key, JSON.stringify(obj));</span><br><span class="line">&#125;</span><br><span class="line">Storage.prototype.getExpire &#x3D; key &#x3D; &gt;&#123;</span><br><span class="line">    let val &#x3D; localStorage.getItem(key);</span><br><span class="line">    if (!val) &#123;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">    val &#x3D; JSON.parse(val);</span><br><span class="line">    if (Date.now() - val.time &gt; val.expire) &#123;</span><br><span class="line">        localStorage.removeItem(key);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return val.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试一下：</p>
<p>Copy</p>
<p>localStorage.setExpire(‘userId’,’zhangsan’,5000);</p>
<p>window.setInterval(()=&gt;{  console.log(localStorage.getExpire(“userId”));},1000)</p>
<p>前5秒还是有值的，之后即为null</p>
<p>方案二：ES6扩展Storage<a href="https://www.cnblogs.com/ricolee/p/localstorage-expiretime.html#3576419538" target="_blank" rel="noopener">#</a></p>
<p>大体思路和方案一是一样的只不过是用了ES6的最新语法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Storage &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        this.props &#x3D; props || &#123;&#125;</span><br><span class="line">        this.source &#x3D; this.props.source || window.localStorage this.initRun();</span><br><span class="line">    &#125;</span><br><span class="line">    initRun() &#123;</span><br><span class="line">        &#x2F;*        </span><br><span class="line">        * set 存储方法</span><br><span class="line">        * @ param &#123;String&#125; key 键        </span><br><span class="line">        * @ param &#123;String&#125; value 值，存储的值可能是数组&#x2F;对象，不能直接存储，需要转换 JSON.stringify </span><br><span class="line">        * @ param &#123;String&#125; expired 过期时间，以分钟为单位        *&#x2F;</span><br><span class="line">        const reg &#x3D; new RegExp(&quot;__expires__&quot;);</span><br><span class="line">        let data &#x3D; this.source;</span><br><span class="line">        let list &#x3D; Object.keys(data);</span><br><span class="line">        if (list.length &gt; 0) &#123;</span><br><span class="line">            list.map((key, v) &#x3D; &gt;&#123;</span><br><span class="line">                if (!reg.test(key)) &#123;</span><br><span class="line">                    let now &#x3D; Date.now();</span><br><span class="line">                    let expires &#x3D; data[&#96;$ &#123;</span><br><span class="line">                        key</span><br><span class="line">                    &#125;</span><br><span class="line">                    __expires__&#96;] || Date.now + 1;</span><br><span class="line">                    if (now &gt;&#x3D; expires) &#123;</span><br><span class="line">                        this.remove(key);</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                return key;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    set(key, value, expired) &#123;</span><br><span class="line">        &#x2F;*	    </span><br><span class="line">        * set 存储方法	    </span><br><span class="line">        * @ param &#123;String&#125;     key 键	    </span><br><span class="line">        * @ param &#123;String&#125;     value 值，	    </span><br><span class="line">        * @ param &#123;String&#125;     expired 过期时间，以毫秒为单位，非必须</span><br><span class="line">        *&#x2F;</span><br><span class="line">        let source &#x3D; this.source;</span><br><span class="line">        source[key] &#x3D; JSON.stringify(value);</span><br><span class="line">        if (expired) &#123;</span><br><span class="line">            source[&#96;$ &#123;</span><br><span class="line">                key</span><br><span class="line">            &#125;</span><br><span class="line">            __expires__&#96;] &#x3D; Date.now() + expired</span><br><span class="line">        &#125;;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    get(key) &#123;</span><br><span class="line">        &#x2F;*        </span><br><span class="line">        * get 获取方法        </span><br><span class="line">        * @ param &#123;String&#125;     key 键        </span><br><span class="line">        * @ param &#123;String&#125;     expired 存储时为非必须字段，所以有可能取不到，默认为 Date.now+1        		*&#x2F;</span><br><span class="line">        const source &#x3D; this.source,</span><br><span class="line">        expired &#x3D; source[&#96;$ &#123;</span><br><span class="line">            key</span><br><span class="line">        &#125;</span><br><span class="line">        __expires__&#96;] || Date.now + 1;</span><br><span class="line">        const now &#x3D; Date.now();</span><br><span class="line">        if (now &gt;&#x3D; expired) &#123;</span><br><span class="line">            this.remove(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        const value &#x3D; source[key] ? JSON.parse(source[key]) : source[key];</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        const data &#x3D; this.source,</span><br><span class="line">        value &#x3D; data[key];</span><br><span class="line">        delete data[key];</span><br><span class="line">        delete data[&#96;$ &#123;</span><br><span class="line">            key</span><br><span class="line">        &#125;</span><br><span class="line">        __expires__&#96;];</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中set(),get(),remove()方法可以理解用来存、取、删, initRun()做什么用呢？过期的值只有取时才能知道是不是过期，不取一直存着。initRun()和constructor只是在初始化时实现清理，也不是一定即时。另外写一个定时器去清理貌似也不值当，所以觉得做到这样已经够用了。</p>
<p>使用如下代码进行测试一下,效果和方案一相同</p>
<p>var ls=new Storage();</p>
<p>ls.set(‘userId’,’zhangsan’,5000);</p>
<p>window.setInterval(()=&gt;{console.log(ls.get(“userId”));},1000)</p>
<h2 id="valueOf方法"><a href="#valueOf方法" class="headerlink" title="valueOf方法"></a>valueOf方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valueOf()方法的使用</span><br><span class="line"></span><br><span class="line">undefined和null没有valueOf()方法，使用会报错；</span><br><span class="line">布尔类型true和false会返回原值；</span><br><span class="line">字符串类型会返回原值；</span><br><span class="line">数字：</span><br><span class="line">如果是整数，需要用小括号将数字包起来再使用valueOf()方法，直接在数字后面跟.valueOf()会报错；</span><br><span class="line">如果是小数会返回原值；</span><br><span class="line">对象Object类型及自定义对象类型会返回原对象（注意花括号可能会被当作代码块的问题）；</span><br><span class="line">函数function类型返回原函数；</span><br><span class="line">数组Array类型返回原数组；</span><br><span class="line">Date对象类型返回数字（1970年1月1日00：00：00至现在的毫秒数）；</span><br><span class="line">正则表达式RegExp类型返回正则对象；</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h2><p><code>Symbol.toPrimitive</code> 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。</p>
<p>下面的例子展示了， <code>Symbol.toPrimitive</code> 属性是如何干扰一个对象转换为原始值时输出的结果的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(+obj1);     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj1&#125;</span>`</span>); <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 + <span class="string">""</span>); <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(+obj2);     <span class="comment">// 10      -- hint 参数值是 "number"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj2&#125;</span>`</span>); <span class="comment">// "hello" -- hint 参数值是 "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2 + <span class="string">""</span>); <span class="comment">// "true"  -- hint 参数值是 "default"</span></span><br></pre></td></tr></table></figure>

<h2 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h2><ol>
<li><p>单词不一样。</p>
<p>方法的英文是method，函数的英文是Function。</p>
</li>
<li><p>位置不一样。</p>
<p>写在外面（直接写在<code>&lt;script&gt;</code>标签里面的）的叫函数，比如这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   function abc()&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>写在类里面的叫方法，因为方法和某个实例或对象是绑定的。比如这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">   &#x2F;&#x2F;写在Person里面的叫方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><strong>高阶函数</strong></h2><p>接收函数作为参数或者返回函数的函数，都可成为高阶函数。所以常见的方法有：map,filter,bind,apply等。</p>
<h2 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h2><p><code>arguments</code>对象是所有（非箭头）函数中都可用的<strong>局部变量</strong></p>
<p>　　拥有四个属性（按照规范来说只有三个了—-caller）</p>
<ul>
<li>　　arguments.callee—指向<strong>当前执行</strong>的函数</li>
<li>　　agruments.caller—-指向调用<strong>当前函数的函数 （已移除）</strong></li>
<li>　　arguments.length—指向传递给<strong>当前函数</strong>的参数数量</li>
<li>　　arguments.arguments— 返回一个新的Array迭代器对象，该对象包含参数中每个索引的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func(...args)&#123;</span><br><span class="line">    return args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(1,2,3)   &#x2F;&#x2F; [1,2,3]</span><br><span class="line"></span><br><span class="line">&#x2F;* --------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">function func(a) &#123; </span><br><span class="line">  arguments[0] &#x3D; 99;   &#x2F;&#x2F; 更新了arguments[0] 同样更新了a</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">func(10); &#x2F;&#x2F; 99</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;use strict&quot; </span><br><span class="line">func(10); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">&#x2F;* --------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">function func(a) &#123; </span><br><span class="line">  a &#x3D; 99;              &#x2F;&#x2F; 更新了a 同样更新了arguments[0] </span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">func(10); &#x2F;&#x2F; 99</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot; </span><br><span class="line">func(10); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">&#x2F;* --------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">function func(a &#x3D; 55) &#123; </span><br><span class="line">  arguments[0] &#x3D; 99; &#x2F;&#x2F;  更新了arguments[0]不会更新a</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">func(10); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">&#x2F;* --------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">function func(a &#x3D; 55) &#123; </span><br><span class="line">  a &#x3D; 99; &#x2F;&#x2F; 更新了a不会更新arguments[0]</span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">func(10); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">不在严格模式下，arguments[0]改变，会使相对应的形参也发生改变，</span><br><span class="line">修改形参，arguments[0]也会相应被修改</span><br><span class="line">而在严格模式和有形参的情况下则不会被修改</span><br></pre></td></tr></table></figure>



<h2 id="按位或运算符可以这样写："><a href="#按位或运算符可以这样写：" class="headerlink" title="按位或运算符可以这样写："></a>按位或运算符可以这样写：</h2><p>如果希望将浮点数转换为整数，可以使用<code>Math.floor()</code>、<code>Math.ceil()</code>或<code>Math.round()</code>。但是还有一种更快的方法可以使用|(位或运算符)将浮点数截断为整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(23.9 | 0);  </span><br><span class="line">&#x2F;&#x2F; Result: 23</span><br><span class="line">console.log(-23.9 | 0);</span><br><span class="line">&#x2F;&#x2F; Result: -23</span><br><span class="line"></span><br><span class="line">console.log(1553&#x2F;10 | 0)  </span><br><span class="line">&#x2F;&#x2F; Result: 155</span><br><span class="line">console.log(1553&#x2F;100 | 0)  </span><br><span class="line">&#x2F;&#x2F; Result: 15</span><br><span class="line">console.log(1553&#x2F;1000 | 0)  </span><br><span class="line">&#x2F;&#x2F; Result: 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>mdUse</title>
    <url>/2020/07/14/mdUse/</url>
    <content><![CDATA[<h3 id="标题-号越多字越小"><a href="#标题-号越多字越小" class="headerlink" title="标题(#号越多字越小)"></a>标题(#号越多字越小)</h3><p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/620e64aa6522f5eaeb788a8b5f1faa5c10f74_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<hr>
<a id="more"></a>

<h3 id="列表（无序用‘-’有序用‘1-’）"><a href="#列表（无序用‘-’有序用‘1-’）" class="headerlink" title="列表（无序用‘*/-/+’有序用‘1.’）"></a>列表（无序用‘*/-/+’有序用‘1.’）</h3><p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/a72338b96cf4bfc1dacd610756786ae310f75_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<hr>
<h3 id="引用一小段别处的句子-使用’-gt-’"><a href="#引用一小段别处的句子-使用’-gt-’" class="headerlink" title="引用一小段别处的句子(使用’&gt;’)"></a>引用一小段别处的句子(使用’&gt;’)</h3><blockquote>
<p>引用一小段别处的句子</p>
</blockquote>
<blockquote>
<p>一级</p>
<blockquote>
<p>二级</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>三级</p>
</blockquote>
</blockquote>
</blockquote>
<p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/07bd8bf6fd38ea7d3bffdc3cae04f6f210f76_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<hr>
<h3 id="图片与链接-区别在于有无’-’"><a href="#图片与链接-区别在于有无’-’" class="headerlink" title="图片与链接(区别在于有无’!’)"></a>图片与链接(区别在于有无’!’)</h3><p>备注：插入图片的地址需要图床，这里推荐 CloudApp 的服务，生成URL地址即可。</p>
<p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/f96c892fc63933ab186235f7c910753b10f77_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<hr>
<h3 id="粗体与斜体与删除-左右两个-‘-’-左右一个-‘-’-左右两个‘-’"><a href="#粗体与斜体与删除-左右两个-‘-’-左右一个-‘-’-左右两个‘-’" class="headerlink" title="粗体与斜体与删除(左右两个 ‘*’ /左右一个 ‘ *’/左右两个‘~~’)"></a>粗体与斜体与删除(左右两个 ‘*’ /左右一个 ‘ *’/左右两个‘~~’)</h3><blockquote>
<p><strong>我加粗了</strong>  <em>我是斜体</em>    <del>删除</del></p>
</blockquote>
<hr>
<h3 id="代码框（用’-’包裹）"><a href="#代码框（用’-’包裹）" class="headerlink" title="代码框（用’`’包裹）"></a>代码框（用’`’包裹）</h3><p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/0135456d6a3c1051f0ed54e37cef070010f78_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意java前面有空格</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="分割线（三个‘-’）"><a href="#分割线（三个‘-’）" class="headerlink" title="分割线（三个‘***’）"></a>分割线（三个‘***’）</h3><hr>
<h3 id="表格-默认左对齐"><a href="#表格-默认左对齐" class="headerlink" title="表格(默认左对齐)"></a>表格(默认左对齐)</h3><table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<hr>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>你可以在需要插入脚注标号的位置写 <code>[^ number ]</code> ，再在下方通过 <code>[^ number ]:</code> 在文档中插入脚注。注意不要遗漏了脚注编号 <code>number</code> 前后的空格。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/5f82606e6d89fe1eb24705c4ca6b895d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>这里是脚注<a href="https://www.baidu.com" target="_blank" rel="noopener">^1</a></p>
<hr>
<h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><p>在 Typora 中，你可以用 <code>:emoji:</code> 的形式来打出 emoji，软件会自动给出图形的提示，还是比较好用的。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/ff26eeb5ff2d6fae16cab163ebfcd096.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>:horse:</p>
<hr>
<h3 id="常用弥补Markdown的Html标签"><a href="#常用弥补Markdown的Html标签" class="headerlink" title="常用弥补Markdown的Html标签"></a>常用弥补Markdown的Html标签</h3><p><span style="color:red">This is red</span></p>
<p align="left">居左文本</p>
<p align="center">居中文本</p> 
<p align="right">居右文本</p>

<p>换行<br></p>
<p>换行后</p>
<p><u>我是下划线<u></u></u></p>
<hr>
<h3 id="打开全局搜索"><a href="#打开全局搜索" class="headerlink" title="打开全局搜索"></a>打开全局搜索</h3><p>ctrl+shift+F</p>
<h3 id="几款主流好用的markdown编辑器介绍"><a href="#几款主流好用的markdown编辑器介绍" class="headerlink" title="几款主流好用的markdown编辑器介绍"></a>几款主流好用的markdown编辑器介绍</h3><ol>
<li><p>Mou</p>
<p> Mou 是一款由国人开发的Markdown 编辑器，支持实时预览，但是仅支持 苹果操作系统，可以说是目前最好用的免费 Markdown 编辑器，对汉字兼容性非常好。提供语法高亮、在线预览、同步滚动、全屏模式，支持自定保存、自动匹配，允许自定义主题等等。支持 CSS，HTML 和 PDF 导出等功能。</p>
<p>   　Mou是独立的软件。</p>
<p>   　更多介绍及下载：<a href="http://25.io/mou/" target="_blank" rel="noopener">http://25.io/mou/</a></p>
</li>
<li><p>MarkdownPad</p>
<p> MarkdownPad被很多人称赞为windows下最好用的Markdown编辑器之一，不过仅支持windows。它有免费版和收费版（MarkdownPad Pro），一般情况下免费版就够用了，想用pro版的可以自行网上下载，强大的国人crack无处不在的~ ~。</p>
<p>   　MarkdownPad支持键盘快捷键和工具栏操作，即可添加标记也可移除，支持即时HTML预览、支持自定义配色方案、字体、大小和布局、支持音乐视频，可以导出HTML和PDF。</p>
<p>   　MarkdownPad是独立的软件。</p>
<p>   　更多介绍及下载：<a href="http://markdownpad.com/" target="_blank" rel="noopener">http://markdownpad.com/</a></p>
</li>
<li><p>Typora (本文就是用的这个软件哦)</p>
<p> Typora也是非常用名，非常好用的markdown编辑器，它的设计理念很不一样，是真正的即时预览型编辑器，不同于左右两个窗口的编辑器。Typora的设计理念就是极致简洁，它将「写字」和「预览」这两件事情合并了。</p>
<p>   　如果要修改已经写好的markdown标记可以点击切换到“源代码模式”。</p>
<p>   　Typora 同样支持 Windows、OS X 和 Linux多个操作系统，支持数学编辑，可与 Word 直接格式转换，可以进行多种文档格式转换。Typora 流畅度和反应速度很快，特别适合那些手速快的人。</p>
<p>   　Typora是独立的软件。</p>
<p>   　更多介绍及下载：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p>
</li>
<li><p>Atom</p>
<p> Atom 可以说是专门为程序员推出的一个文本编辑器，界面简洁，支持实时预览。功能非常多，除了Markdown同时支持CSS，HTML，JavaScript等网页编程语言，还支持宏定义，自动分屏功能等。Atom还具有语义输入模式，比例输入code即会自动开启代码模式。</p>
<p>   　Atom支持windows、苹果、linux等多种操作系统。Atom是由著名的github平台出品的。</p>
<p>   　Atom是独立的软件，也支持插件方式。</p>
<p>   　更多介绍及下载：<a href="https://atom.io/" target="_blank" rel="noopener">https://atom.io/</a></p>
</li>
<li><p>Haroopad</p>
<p> Haroopad也是一款非常流行的编辑器，来自韩国。Haroopad支持 Windows、Mac OS X 和 Linux三大操作系统。Haroopad的特色是主题样式丰富，语法高亮支持无数种编程语言，几乎你能想到的编程语言他都支持。Ubuntu/Linux 用户使用该工具比例很高，Haroopad 也是开源免费的。Haroopad也支持导出HTML、PDF，也支持数学公式和流程图。</p>
<p>   　Haroopad是独立的软件。</p>
<p>   　更多介绍及下载：<a href="http://pad.haroopress.com/user.html" target="_blank" rel="noopener">http://pad.haroopress.com/user.html</a></p>
</li>
</ol>
<p>参考文档：<a href="https://sspai.com/post/54912" target="_blank" rel="noopener">typora</a></p>
]]></content>
      <categories>
        <category>mysoft</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>less</title>
    <url>/2020/07/27/less/</url>
    <content><![CDATA[<h3 id="less高级用法记录"><a href="#less高级用法记录" class="headerlink" title="less高级用法记录"></a>less高级用法记录</h3><ul>
<li><p>注意</p>
<p><img src="/2020/07/27/less/clipboard.png" alt="clipboard"></p>
</li>
</ul>
<a id="more"></a>

<p>![clipboard (1)](less.assets/clipboard (1).png)</p>
<ul>
<li>例如（变量的延迟加载，会加载作用域中最后一个变量的值）</li>
</ul>
<p>![clipboard (2)](less.assets/clipboard (2).png)</p>
<ul>
<li>普通混合（输出到css里）</li>
</ul>
<p>![clipboard (3)](less.assets/clipboard (3).png)</p>
<ul>
<li>不带参数的混合（不会输出到css里）</li>
</ul>
<p>![clipboard (4)](less.assets/clipboard (4).png)</p>
<ul>
<li>带有参数的混合</li>
</ul>
<p>![clipboard (5)](less.assets/clipboard (5).png)</p>
<ul>
<li>带有默认参数的混合</li>
</ul>
<p>![clipboard (6)](less.assets/clipboard (6).png)</p>
<ul>
<li>命名参数，指定参数给谁</li>
</ul>
<p>![clipboard (7)](less.assets/clipboard (7).png)</p>
<ul>
<li>@argruments(参数匹配时全部替换)</li>
</ul>
<p>![clipboard (10)](less.assets/clipboard (10).png)</p>
<ul>
<li>继承 （all继承所有.juzhong中的属性）</li>
</ul>
<p>![clipboard (11)](less.assets/clipboard (11).png)</p>
<ul>
<li>避免编译，让浏览器去编译，加上~“string”就可以=</li>
</ul>
<p>![clipboard (12)](less.assets/clipboard (12)-1599546053799.png)</p>
<ul>
<li><h5 id="混合的匹配模式"><a href="#混合的匹配模式" class="headerlink" title="混合的匹配模式"></a>混合的匹配模式</h5><p>就是通过混合的第一个字符串形参,来确定具体要执行哪一个同名混合</p>
</li>
<li><h5 id="通用的匹配模式"><a href="#通用的匹配模式" class="headerlink" title="通用的匹配模式"></a>通用的匹配模式</h5><p>无论同名的哪一个混合被匹配了, 都会先执行通用匹配模式中的代码<br>@_: 表示通用的匹配模式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>我赛季刚开始就港口建设控股<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>我赛季刚开始就港口建设控股<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>我赛季刚开始就港口建设控股<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box4"</span>&gt;</span>我赛季刚开始就港口建设控股<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="keyword">@_</span>, @width, @color) &#123;</span></span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-style: solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="selector-tag">Bottom</span>, <span class="keyword">@width</span>, @color) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-width</span>: <span class="keyword">@width</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-color</span>: <span class="keyword">@color</span> transparent transparent transparent;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="selector-tag">Left</span>, <span class="keyword">@width</span>, @color) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-width</span>: <span class="keyword">@width</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="keyword">@color</span> transparent transparent;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="selector-tag">Top</span>, <span class="keyword">@width</span>, @color) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-width</span>: <span class="keyword">@width</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="keyword">@color</span> transparent;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="selector-tag">Right</span>, <span class="keyword">@width</span>, @color) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-width</span>: <span class="keyword">@width</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="keyword">@color</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.triangle</span>(<span class="selector-tag">Top</span>, 50<span class="selector-tag">px</span>, <span class="selector-tag">skyblue</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.triangle</span>(<span class="selector-tag">Bottom</span>, 50<span class="selector-tag">px</span>, <span class="selector-tag">skyblue</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.box3</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.triangle</span>(<span class="selector-tag">Left</span>, 50<span class="selector-tag">px</span>, <span class="selector-tag">skyblue</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.box4</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.triangle</span>(<span class="selector-tag">Right</span>, 50<span class="selector-tag">px</span>, <span class="selector-tag">skyblue</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title>mock语法</title>
    <url>/2020/07/30/mock%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="设置迟延时间"><a href="#设置迟延时间" class="headerlink" title="设置迟延时间"></a>设置迟延时间</h2><p>我们可以使用 Mock.setup 来设置模拟数据时的延迟时间，单位：毫秒。可以设置一个固定的时间，也可以使用-设置一个时间段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 延迟4秒</span><br><span class="line">Mock.setup(&#123;</span><br><span class="line">    timeout: 4000</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 延迟3~9秒</span><br><span class="line">Mock.setup(&#123;</span><br><span class="line">    timeout: &#39;3000-9000&#39;</span><br><span class="line">&#125;)</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="模拟数据"><a href="#模拟数据" class="headerlink" title="模拟数据"></a>模拟数据</h2><p>可以使用 Mock.mock 生成模拟数据。</p>
<ol>
<li>直接生成模拟数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mock.mock(模板|function)</span><br></pre></td></tr></table></figure>

<ol>
<li>为接口地址模拟数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mock.mock(url,模板|function)</span><br></pre></td></tr></table></figure>

<ol>
<li>为接口以及请求方式模拟数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mock.mock(url,type,模板|function)</span><br></pre></td></tr></table></figure>

<p>说明：url也可以是一个字符串也可以是一个正则。</p>
<p><img src="https://img-blog.csdnimg.cn/20181122001426963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>模拟数据时要根据模板来模拟，模板是一个对象类型的值，格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;名称|规则&#39;:&#39;值&#39;</span><br></pre></td></tr></table></figure>

<p>名称：模拟的数据的名字。<br>值：模拟的数据的值。<br>规则：模拟出数据的规则，常用的几个规则：</p>
<ol>
<li>min-max：生成的范围</li>
<li>count：生成的数量</li>
<li>+step：递增step<br><img src="https://img-blog.csdnimg.cn/2018112200152730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>如果值是一个数组，规则代表数组中元素的个数：</p>
<p><img src="https://img-blog.csdnimg.cn/20181122001606812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果希望生成的ID自增可以使用+1</p>
<p><img src="https://img-blog.csdnimg.cn/20181122001616852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="生成随机数据"><a href="#生成随机数据" class="headerlink" title="生成随机数据"></a>生成随机数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们一般在模拟数据时都希望生成一些随机的数据，mock中内置了很多种不同类型的随机数据，我们可以使用它们生成各种类型的随机数据：</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Type</th>
<th>Method</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>boolean, natural, integer, float, character, string, range, date, time, datetime, now</td>
</tr>
<tr>
<td>图片</td>
<td>image, dataImage</td>
</tr>
<tr>
<td>颜色</td>
<td>color</td>
</tr>
<tr>
<td>文本</td>
<td>paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle</td>
</tr>
<tr>
<td>姓名</td>
<td>first, last, name, cfirst, clast, cname</td>
</tr>
<tr>
<td>网站</td>
<td>url, domain, email, ip, tld</td>
</tr>
<tr>
<td>地址</td>
<td>area, region</td>
</tr>
<tr>
<td>编号</td>
<td>guid, id</td>
</tr>
</tbody></table>
<p>使用时我们只需要把值设置成 <strong>@方法名</strong> 即可，比如，生成一个随机的 Email：</p>
<p><img src="https://img-blog.csdnimg.cn/2018112200163380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="生成boolean"><a href="#生成boolean" class="headerlink" title="生成boolean"></a>生成boolean</h1><p>@boolean</p>
<h1 id="生成数字"><a href="#生成数字" class="headerlink" title="生成数字"></a>生成数字</h1><h2 id="自然数-gt-0整数"><a href="#自然数-gt-0整数" class="headerlink" title="自然数(&gt;=0整数)"></a>自然数(&gt;=0整数)</h2><p>@natural<br>@natural(min,max)</p>
<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>@integer<br>@integer(min,max)</p>
<h2 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h2><p>@float<br>@float(min,max,dmin,dmax)<br>dmin：小数部分位数最小值<br>dmax：小数部分位数最大值</p>
<h2 id="整数整组"><a href="#整数整组" class="headerlink" title="整数整组"></a>整数整组</h2><p>@range(min,max)<br>@range(min,max,step)<br> step：递增的步长</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@range(10)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">@range(3, 7)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; [3, 4, 5, 6]</span><br><span class="line">@range(1, 10, 2)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; [1, 3, 5, 7, 9]</span><br><span class="line">@range(1, 10, 3)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; [1, 4, 7]</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<h1 id="生成文本"><a href="#生成文本" class="headerlink" title="生成文本"></a>生成文本</h1><h2 id="单个字符"><a href="#单个字符" class="headerlink" title="单个字符"></a>单个字符</h2><p>@character<br>@character(‘lower/upper/number/symbol’)<br>@character(pool)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果传入了 &#96;&#39;lower&#39;&#96; 或 &#96;&#39;upper&#39;&#96;、&#96;&#39;number&#39;&#96;、&#96;&#39;symbol&#39;&#96;，表示从内置的字符池中选取一个字符：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    lower: &quot;abcdefghijklmnopqrstuvwxyz&quot;,</span><br><span class="line">    upper: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,</span><br><span class="line">    number: &quot;0123456789&quot;,</span><br><span class="line">    symbol: &quot;!@#$%^&amp;*()[]&quot;</span><br><span class="line">&#125;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>@string<br>@string(length)<br>@string(min,max)</p>
<h2 id="英文单词"><a href="#英文单词" class="headerlink" title="英文单词"></a>英文单词</h2><p>@word<br>@word(length)<br>@word(min,max)</p>
<h2 id="英文句子"><a href="#英文句子" class="headerlink" title="英文句子"></a>英文句子</h2><p>@sentence<br>@sentence(len)<br>@sentence(min,max)</p>
<h2 id="英文段落"><a href="#英文段落" class="headerlink" title="英文段落"></a>英文段落</h2><p>@paragraph<br>@paragraph(len)<br>@paragraph(min,max)</p>
<h2 id="中文汉字"><a href="#中文汉字" class="headerlink" title="中文汉字"></a>中文汉字</h2><p>@cword<br>@cword(pool)<br>@cword(len)<br>@cword(pool,len)<br>@cword(min,max)<br>@cword(pool,min,max)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@cword()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;干&quot;</span><br><span class="line">@cword(&#39;零一二三四五六七八九十&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;六&quot;</span><br><span class="line">@cword(3)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;别金提&quot;</span><br><span class="line">@cword(&#39;零一二三四五六七八九十&#39;, 3)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;&quot;七七七&quot;&quot;</span><br><span class="line">@cword(5, 7)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;设过证全争听&quot;</span><br><span class="line">@cword(&#39;零一二三四五六七八九十&#39;, 5, 7)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;九七七零四&quot;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<h2 id="中文句子"><a href="#中文句子" class="headerlink" title="中文句子"></a>中文句子</h2><p>@csentence<br>@csentence(len)<br>@csentence(min,max)</p>
<h2 id="中文段落"><a href="#中文段落" class="headerlink" title="中文段落"></a>中文段落</h2><p>@cparagraph<br>@cparagraph(len)<br>@cparagraph(min,max)</p>
<h2 id="中文标题"><a href="#中文标题" class="headerlink" title="中文标题"></a>中文标题</h2><p>@ctitle<br>@ctitle(len)<br>@ctitle(min,max)</p>
<h1 id="生成名字"><a href="#生成名字" class="headerlink" title="生成名字"></a>生成名字</h1><h2 id="英文名"><a href="#英文名" class="headerlink" title="英文名"></a>英文名</h2><p>@first<br>名<br>@last<br> 姓<br>@name<br> 姓名<br>@name(middle)<br> middle：是否生成中间名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@name()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;Larry Wilson&quot;</span><br><span class="line">@name(true)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;Helen Carol Martinez&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h2 id="中文名"><a href="#中文名" class="headerlink" title="中文名"></a>中文名</h2><p>@cfirst<br> 姓<br>@clast<br> 名<br>@cname<br> 姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@cname()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;袁军&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><h2 id="生成一个IP"><a href="#生成一个IP" class="headerlink" title="生成一个IP"></a>生成一个IP</h2><p>@ip</p>
<h2 id="生成一个Email"><a href="#生成一个Email" class="headerlink" title="生成一个Email"></a>生成一个Email</h2><p>@email<br>@email(domain)<br> domain：指定域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@email()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;x.davis@jackson.edu&quot;</span><br><span class="line">@email(&#39;nuysoft.com&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;h.pqpneix@nuysoft.com&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h2 id="生成域名"><a href="#生成域名" class="headerlink" title="生成域名"></a>生成域名</h2><p>@domain</p>
<h2 id="生成URL"><a href="#生成URL" class="headerlink" title="生成URL"></a>生成URL</h2><p>@url<br>@url(protocol,host)<br> protocol：指定协议，例如HTTP<br> host：指定域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@url()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;mid:&#x2F;&#x2F;axmg.bg&#x2F;bhyq&quot;</span><br><span class="line">@url(&#39;http&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;splap.yu&#x2F;qxzkyoubp&quot;</span><br><span class="line">@url(&#39;http&#39;, &#39;nuysoft.com&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;nuysoft.com&#x2F;ewacecjhe&quot;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h1 id="生成时间"><a href="#生成时间" class="headerlink" title="生成时间"></a>生成时间</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>@date<br>@time<br>@datetime</p>
<h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><p>可以通过 format 参数设置时间的格式</p>
<p>@date(format)<br>@time(format)<br>@datetime(format)</p>
<table>
<thead>
<tr>
<th>Format</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>yyyy</td>
<td>A full numeric representation of a year, 4 digits</td>
<td>1999 or 2003</td>
</tr>
<tr>
<td>yy</td>
<td>A two digit representation of a year</td>
<td>99 or 03</td>
</tr>
<tr>
<td>y</td>
<td>A two digit representation of a year</td>
<td>99 or 03</td>
</tr>
<tr>
<td>MM</td>
<td>Numeric representation of a month, with leading zeros</td>
<td>01 to 12</td>
</tr>
<tr>
<td>M</td>
<td>Numeric representation of a month, without leading zeros</td>
<td>1 to 12</td>
</tr>
<tr>
<td>dd</td>
<td>Day of the month, 2 digits with leading zeros</td>
<td>01 to 31</td>
</tr>
<tr>
<td>d</td>
<td>Day of the month without leading zeros</td>
<td>1 to 31</td>
</tr>
<tr>
<td>HH</td>
<td>24-hour format of an hour with leading zeros</td>
<td>00 to 23</td>
</tr>
<tr>
<td>H</td>
<td>24-hour format of an hour without leading zeros</td>
<td>0 to 23</td>
</tr>
<tr>
<td>hh</td>
<td>12-hour format of an hour without leading zeros</td>
<td>1 to 12</td>
</tr>
<tr>
<td>h</td>
<td>12-hour format of an hour with leading zeros</td>
<td>01 to 12</td>
</tr>
<tr>
<td>mm</td>
<td>Minutes, with leading zeros</td>
<td>00 to 59</td>
</tr>
<tr>
<td>m</td>
<td>Minutes, without leading zeros</td>
<td>0 to 59</td>
</tr>
<tr>
<td>ss</td>
<td>Seconds, with leading zeros</td>
<td>00 to 59</td>
</tr>
<tr>
<td>s</td>
<td>Seconds, without leading zeros</td>
<td>0 to 59</td>
</tr>
<tr>
<td>SS</td>
<td>Milliseconds, with leading zeros</td>
<td>000 to 999</td>
</tr>
<tr>
<td>S</td>
<td>Milliseconds, without leading zeros</td>
<td>0 to 999</td>
</tr>
<tr>
<td>A</td>
<td>Uppercase Ante meridiem and Post meridiem</td>
<td>AM or PM</td>
</tr>
<tr>
<td>a</td>
<td>Lowercase Ante meridiem and Post meridiem</td>
<td>am or pm</td>
</tr>
<tr>
<td>T</td>
<td>Milliseconds, since 1970-1-1 00:00:00 UTC</td>
<td>759883437303</td>
</tr>
</tbody></table>
<h1 id="生成地址"><a href="#生成地址" class="headerlink" title="生成地址"></a>生成地址</h1><h2 id="生成中国大区"><a href="#生成中国大区" class="headerlink" title="生成中国大区"></a>生成中国大区</h2><p>@region</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@region()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;华北&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h2 id="生成省份"><a href="#生成省份" class="headerlink" title="生成省份"></a>生成省份</h2><p>@province</p>
<h2 id="生成城市"><a href="#生成城市" class="headerlink" title="生成城市"></a>生成城市</h2><p>@city<br>@city(prefix)<br> prefix：布尔值，是否生成所属的省</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@city()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;唐山市&quot;</span><br><span class="line">@city(true)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;福建省 漳州市&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h2 id="生成县"><a href="#生成县" class="headerlink" title="生成县"></a>生成县</h2><p>@county<br>@county(prefix)<br> prefix：布尔值，是否生成所属省、市</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@county()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;上杭县&quot;</span><br><span class="line">@county(true)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;甘肃省 白银市 会宁县&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h2 id="生成邮政编码"><a href="#生成邮政编码" class="headerlink" title="生成邮政编码"></a>生成邮政编码</h2><p>@zip</p>
<h1 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h1><h2 id="身份证"><a href="#身份证" class="headerlink" title="身份证"></a>身份证</h2><p>@ID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@id()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;420000200710091854&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h2 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h2><p>@guid</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@guid()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;662C63B4-FD43-66F4-3328-C54E3FF0D56E&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h1 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h1><h2 id="图片URL"><a href="#图片URL" class="headerlink" title="图片URL"></a>图片URL</h2><p>@image()<br>@image( size )<br>@image( size, background )<br>@image( size, background, text )<br>@image( size, background, foreground, text )<br>@image( size, background, foreground, format, text )<br> size：尺寸，格式为：‘宽x高’<br> background：背景色，格式为：#FFFFFF<br> text：图片上显示的文本<br> foreground：广本颜色<br> format：图片格式，可选值包括：png、gif、jpg。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@image()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;125x125&quot;</span><br><span class="line">@image(&#39;200x100&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&quot;</span><br><span class="line">@image(&#39;200x100&#39;, &#39;#fb0a2a&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&#x2F;fb0a2a&quot;</span><br><span class="line">@image(&#39;200x100&#39;, &#39;#02adea&#39;, &#39;Hello&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&#x2F;02adea&amp;text&#x3D;Hello&quot;</span><br><span class="line">@image(&#39;200x100&#39;, &#39;#00405d&#39;, &#39;#FFF&#39;, &#39;Mock.js&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&#x2F;00405d&#x2F;FFF&amp;text&#x3D;Mock.js&quot;</span><br><span class="line">@image(&#39;200x100&#39;, &#39;#ffcc33&#39;, &#39;#FFF&#39;, &#39;png&#39;, &#39;!&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&#x2F;ffcc33&#x2F;FFF.png&amp;text&#x3D;!&quot;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<h2 id="Base64图片编码"><a href="#Base64图片编码" class="headerlink" title="Base64图片编码"></a>Base64图片编码</h2><p>@dataImage<br>@dataImage(size)<br>@dataImage(size,text)</p>
<h1 id="生成颜色"><a href="#生成颜色" class="headerlink" title="生成颜色"></a>生成颜色</h1><p>@color<br>@hex<br>@rgb<br>@rgba<br>@hsl<br><img src="https://img-blog.csdnimg.cn/20181122001849623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>mock</tag>
        <tag>mock语法</tag>
      </tags>
  </entry>
  <entry>
    <title>momentJs</title>
    <url>/2020/07/30/momentJs/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>UTC、GMT、时间戳之间的关系</p>
<p>时区</p>
<p>世界时区的划分以本初子午线为标准，向东12个时区，向西12个时区，子午线所在区为0时区，东十二区和西十二区重合，所以一共是24个时区。</p>
</li>
<li><p>GMT和UTC</p>
<p>GMT： 即格林威治时间（Greenwich Mean Time），也是0时区的标准时间。指太阳横穿格林威治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致GMT不精确，现在已经不再作为世界标准时间使用。</p>
<p>UTC： 即协调世界时间（Coordinated Universal Time）。UTC是以原子时秒长为基础，在时刻上尽量接近于GMT的一种时间计量系统。UTC现在作为世界标准时间使用。</p>
<p>所以，UTC与GMT基本上等同，误差不超过0.9秒。</p>
</li>
<li><p>时间戳</p>
<p>UNIX时间戳：是从UTC时间1970年1月1日起到现在的秒数，不考虑闰秒，一天有86400秒，它是和时区无关的，无论在地球上的那个角落，同一时刻，UNIX时间戳都是一样的，计算机的本地时间就是根据 Unix时间戳 + 时区差 转换而来的。</p>
</li>
<li><p>本地时间</p>
<p>本地时间 = UTC + 时区差</p>
<p>时区差：东为正，西为负。在此，把东八区时区差记为 +0800， UTC 是标准时间参照，GMT（格林威治时间）、CST（北京时间）、PST（太平洋时间）等等是具体的时区，兑换如下：</p>
<p>GMT: UTC +0    =    GMT: GMT +0CST: UTC +8    =    CST: GMT +8PST: UTC -8    =    PST: GMT -8</p>
</li>
</ul>
<a id="more"></a>

<h3 id="Moment安装与挂载"><a href="#Moment安装与挂载" class="headerlink" title="Moment安装与挂载"></a>Moment安装与挂载</h3><p>安装webpack</p>
<p>npm install moment</p>
<p>main.js 挂载</p>
<p>import moment from ‘moment’//导入文件</p>
<p>Vue.prototype.$moment = moment;//赋值使用</p>
<p>国际化，设置为简体中文，中文的星期是以星期一开始</p>
<p>moment.locale(“zh-cn”);</p>
<p>常用使用方法</p>
<h3 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h3><ul>
<li>Start of Time</li>
</ul>
<p>moment().startOf(String)</p>
<ul>
<li><ul>
<li>获取今天0时0分0秒</li>
</ul>
</li>
</ul>
<p>moment().startOf(‘day’)</p>
<ul>
<li><ul>
<li>获取本周第一天(周日)0时0分0秒</li>
</ul>
</li>
</ul>
<p>moment().startOf(‘week’)</p>
<ul>
<li><ul>
<li>获取本周周一0时0分0秒</li>
</ul>
</li>
</ul>
<p>moment().startOf(‘isoWeek’)</p>
<ul>
<li><ul>
<li>获取当前月第一天0时0分0秒</li>
</ul>
</li>
</ul>
<p>moment().startOf(‘month’)</p>
<ul>
<li>End of Time</li>
</ul>
<p>moment().endOf(String)</p>
<ul>
<li><ul>
<li>获取今天23时59分59秒</li>
</ul>
</li>
</ul>
<p>moment().endOf(‘day’)</p>
<ul>
<li><ul>
<li>获取本周最后一天(周六)23时59分59秒</li>
</ul>
</li>
</ul>
<p>moment().endOf(‘week’)</p>
<ul>
<li><ul>
<li>获取本周周日23时59分59秒</li>
</ul>
</li>
</ul>
<p>moment().endOf(‘isoWeek’)</p>
<ul>
<li><ul>
<li>获取当前月最后一天23时59分59秒</li>
</ul>
</li>
</ul>
<p>moment().endOf(‘month’)</p>
<ul>
<li><p>Days in Month</p>
</li>
<li><ul>
<li>获取当前月的总天数</li>
</ul>
</li>
</ul>
<p>moment().daysInMonth() </p>
<ul>
<li>Timestamp</li>
</ul>
<ul>
<li><ul>
<li>获取时间戳(以秒为单位)</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().format(‘X’) // 返回值为字符串类型</li>
<li>moment().unix() // 返回值为数值型</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取时间戳(以毫秒为单位)</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().format(‘x’) // 返回值为字符串类型</li>
<li>moment().valueOf() // 返回值为数值型</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li>Get Time</li>
</ul>
<ul>
<li><ul>
<li>获取年份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().year()</li>
<li>moment().get(‘year’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取月份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().month() (0~11, 0: January, 11: December)</li>
<li>moment().get(‘month’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取一个月中的某一天</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().date()</li>
<li>moment().get(‘date’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取一个星期中的某一天</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().day() (0~6, 0: Sunday, 6: Saturday)</li>
<li>moment().weekday() (0~6, 0: Sunday, 6: Saturday)</li>
<li>moment().isoWeekday() (1~7, 1: Monday, 7: Sunday)</li>
<li>moment().get(‘day’)</li>
<li>mment().get(‘weekday’)</li>
<li>moment().get(‘isoWeekday’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取小时</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().hours()</li>
<li>moment().get(‘hours’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取分钟</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().minutes()</li>
<li>moment().get(‘minutes’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取秒数</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().seconds()</li>
<li>moment().get(‘seconds’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取当前的年月日时分秒</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().toArray() // [years, months, date, hours, minutes, seconds, milliseconds]</li>
<li>moment().toObject() // {years: xxxx, months: x, date: xx …}</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>设置时间</p>
<ul>
<li>Set Time</li>
</ul>
<ul>
<li><ol>
<li>moment().year(Number), moment().month(Number)…</li>
<li>moment().set(String, Int)</li>
<li>moment().set(Object)</li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>设置年份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().year(2019)</li>
<li>moment().set(‘year’, 2019)</li>
<li>moment().set({year: 2019})</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置月份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().month(11) (0~11, 0: January, 11: December)</li>
<li>moment().set(‘month’, 11) </li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置某个月中的某一天</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().date(15)</li>
<li>moment().set(‘date’, 15)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置某个星期中的某一天</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().weekday(0) // 设置日期为本周第一天（周日）</li>
<li>moment().isoWeekday(1) // 设置日期为本周周一</li>
<li>moment().set(‘weekday’, 0)</li>
<li>moment().set(‘isoWeekday’, 1)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置小时</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().hours(12)</li>
<li>moment().set(‘hours’, 12)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置分钟</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().minutes(30)</li>
<li>moment().set(‘minutes’, 30)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置秒数</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().seconds(30)</li>
<li>moment().set(‘seconds’, 30)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li>Add Time（通过增加时间来改变原始的 moment，传入要增加的时间的键、以及要增加的数量）</li>
</ul>
<ul>
<li><ol>
<li>moment().add(Number, String)</li>
<li>moment().add(Object)</li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>增加年份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().add(1, ‘years’)</li>
<li>moment().add({years: 1})</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>增加月份</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘months’)</p>
<ul>
<li><ul>
<li>增加日期</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘days’)</p>
<ul>
<li><ul>
<li>增加星期</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘weeks’)</p>
<ul>
<li><ul>
<li>增加小时</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘hours’)</p>
<ul>
<li><ul>
<li>增加分钟</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘minutes’)</p>
<ul>
<li><ul>
<li>增加秒数</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘seconds’)</p>
<ul>
<li>Subtract Time(通过减去时间来改变原始的 moment)</li>
</ul>
<ul>
<li><ol>
<li>moment().subtract(Number, String)</li>
<li>moment().subtract(Object)</li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>减去年份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().subtract(1, ‘years’)</li>
<li>moment().subtract({years: 1})</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>减去月份</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘months’)</p>
<ul>
<li><ul>
<li>减去日期</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘days’)</p>
<ul>
<li><ul>
<li>减去星期</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘weeks’)</p>
<ul>
<li><ul>
<li>减去小时</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘hours’)</p>
<ul>
<li><ul>
<li>减去分钟</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘minutes’)</p>
<ul>
<li><ul>
<li>减去秒数</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘seconds’)</p>
<p>格式化时间</p>
<ul>
<li>Format Time</li>
</ul>
<ul>
<li><ol>
<li>moment().format()</li>
<li>moment().format(String)</li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>格式化年月日： ‘xxxx年xx月xx日’</li>
</ul>
</li>
</ul>
<p>moment().format(‘YYYY年MM月DD日’)</p>
<ul>
<li><ul>
<li>格式化年月日： ‘xxxx-xx-xx’</li>
</ul>
</li>
</ul>
<p>moment().format(‘YYYY-MM-DD’)</p>
<ul>
<li><ul>
<li>格式化时分秒(24小时制)： ‘xx时xx分xx秒’</li>
</ul>
</li>
</ul>
<p>moment().format(‘HH时mm分ss秒’)</p>
<ul>
<li><ul>
<li>格式化时分秒(12小时制)：’xx:xx:xx am/pm’</li>
</ul>
</li>
</ul>
<p>moment().format(‘hh:mm:ss a’)</p>
<ul>
<li><ul>
<li>格式化时间戳(以秒为单位)</li>
</ul>
</li>
</ul>
<p>moment().format(‘X’) // 返回值为字符串类型</p>
<ul>
<li><ul>
<li>格式化时间戳(以毫秒为单位)</li>
</ul>
</li>
</ul>
<p>moment().format(‘x’) // 返回值为字符串类型</p>
<p>比较时间</p>
<ul>
<li>Difference</li>
</ul>
<p>moment().diff(Moment|String|Number|Date|Array)</p>
<ul>
<li><ul>
<li>获取两个日期之间的时间差</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>let start_date = moment().subtract(1, ‘weeks’)</li>
<li>let end_date = moment()</li>
<li>end_date.diff(start_date) // 返回毫秒数</li>
<li>end_date.diff(start_date, ‘months’) // 0</li>
<li>end_date.diff(start_date, ‘weeks’) // 1</li>
<li>end_date.diff(start_date, ‘days’) // 7</li>
<li>start_date.diff(end_date, ‘days’) // -7</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>将毫秒数转为时分秒</p>
<p>const msTime = 4800000;        //80分钟 </p>
<p>moment.duration(msTime).hours();       //转为小时，值为1</p>
<p>moment.duration(msTime).minutes();     //转为分钟，值为20</p>
<p>moment.duration(msTime).seconds();     //转为秒，值为0</p>
<p>转为其他单位：</p>
<p>moment.duration(msTime, ‘seconds’);        //转为秒</p>
<p>moment.duration(msTime, ‘minutes’);        //转为分</p>
<p>moment.duration(msTime, ‘hours’);          //转为小时</p>
<p>moment.duration(msTime, ‘days’);           //转为天</p>
<p>moment.duration(msTime, ‘weeks’);          //转为周</p>
<p>moment.duration(msTime, ‘months’);         //转为月</p>
<p>moment.duration(msTime, ‘years’);          //转为年</p>
<ol start="10">
<li>判断一个日期是否在两个日期之前  isBetween</li>
</ol>
<p>语法： this.moment().isBetween(moment-like, moment-like, String, String);</p>
<p>a. 不包含起始这两个日期（只有两个参数）   ==&gt;&gt; 中文网只有两个参数</p>
<p>this.moment(‘2010-10-20’).isBetween(‘2010-10-19’, ‘2010-10-25’); // true</p>
<p>this.moment(‘2010-10-19’).isBetween(‘2010-10-19’, ‘2010-10-25’); // false</p>
<p>this.moment(‘2010-10-25’).isBetween(‘2010-10-19’, ‘2010-10-25’); // false</p>
<p>b. 自定义是否包含起始日期（四个参数，主要是第四个参数）   ==&gt;&gt; 英文网才有四个参数</p>
<p>第三个参数，固定为null；</p>
<p>第四个参数，字符串，( ) 表示不包含，[ ] 表示包含。左括号制开始日期，右括号控制结束日期</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-10-30’, ‘2016-12-30’, null, ‘()’); //false</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-10-30’, ‘2016-12-30’, null, ‘[)’); //true</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-01-01’, ‘2016-10-30’, null, ‘()’); //false</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-01-01’, ‘2016-10-30’, null, ‘(]’); //true</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-10-30’, ‘2016-10-30’, null, ‘[]’); //true</p>
]]></content>
      <categories>
        <category>moment</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>插件</tag>
        <tag>moment</tag>
      </tags>
  </entry>
  <entry>
    <title>mpVue</title>
    <url>/2020/07/30/mpVue/</url>
    <content><![CDATA[<p>前段时间，美团开源了<code>mpvue</code>这个项目，使得我们又多了一种用来开发小程序的框架选项。由于<code>mpvue</code>框架是完全基于Vue框架的（重写了其runtime和compiler），因此在用法上面是高度和Vue一致的（某些功能由于受限于小程序环境本身的原因而不能使用），这给使用过Vue开发Web应用的前端开发者提供了极低的切换门槛来开发小程序。</p>
<p>如果之前还未曾用过Vue这个框架的话，建议你可以快速浏览一下Vue的官方文档(<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2F" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a>)，或者通过下面的几个视频教程来了解下Vue的基本用法。</p>
<blockquote>
<p>Vue基础教程视频：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25142267" target="_blank" rel="noopener">https://www.bilibili.com/video/av25142267</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25143408" target="_blank" rel="noopener">https://www.bilibili.com/video/av25143408</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25144006" target="_blank" rel="noopener">https://www.bilibili.com/video/av25144006</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25148349" target="_blank" rel="noopener">https://www.bilibili.com/video/av25148349</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25148832" target="_blank" rel="noopener">https://www.bilibili.com/video/av25148832</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25649895" target="_blank" rel="noopener">https://www.bilibili.com/video/av25649895</a></p>
</blockquote>
<a id="more"></a>

<h4 id="起手式：必要的开发环境"><a href="#起手式：必要的开发环境" class="headerlink" title="起手式：必要的开发环境"></a>起手式：必要的开发环境</h4><p>工欲善其事必先利其器！在开始写代码之前，请确保你已经安装了必要的开发环境和工具，以下是几个必需的和可选的工具：</p>
<p>1）node.js<br>现在，前端工具链基本都依赖Node.js，所以请率先安装它吧。</p>
<p>下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2Fdownload%2F" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
<p>安装完成后，打开你的命令行输入如下命令，验证安装是否成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node --version</span><br><span class="line">&#x2F;&#x2F;成功的话输出类似：v10.6.0</span><br><span class="line"></span><br><span class="line">npm --version</span><br><span class="line">&#x2F;&#x2F;成功的话输出类似：6.1.0</span><br></pre></td></tr></table></figure>

<p>然后，我们需要执行以下命令，将npm的下载源切换到国内淘宝的镜像，以提高下载时的速度和成功率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>2）vue-cli<br><code>vue-cli</code>是一个vue专用的项目脚手架工具，可以用于方便的创建vue项目骨架代码，包括我们要讲到的mpvue的项目代码。我们可以通过安装node.js后里面包含的npm工具来安装vue-cli，在命令行输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入如下命令进行验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 成功的话会输出如下内容：</span><br><span class="line">&#x2F;&#x2F; Usage: vue &lt;command&gt; [options]</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Options:</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    -V, --version  output the version number</span><br><span class="line">&#x2F;&#x2F;    -h, --help     output usage information</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Commands:</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    init           generate a new project from a template</span><br><span class="line">&#x2F;&#x2F;    list           list available official templates</span><br><span class="line">&#x2F;&#x2F;    build          prototype a new project</span><br><span class="line">&#x2F;&#x2F;    create         (for v3 warning only)</span><br><span class="line">&#x2F;&#x2F;    help [cmd]     display help for [cmd]</span><br></pre></td></tr></table></figure>

<p>3）微信开发者工具<br>这个工具是开发、调试和模拟运行微信小程序的最核心的工具了，所以必须安装。</p>
<p>下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fdownload.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>
<p>4）Visual Studio Code + Vetur<br>Visual Studio Code（简称vscode）是现在非常流行的一个轻量级代码编辑器，拥有非常多好用的辅助开发插件，在我的文章中我都会使用这个编辑器来编辑代码。当然，好用的代码编辑器有很多，比如Sublime Text、WebStorm等，同样可以达到我们的开发目的，你也尽管用你自己最喜欢的代码编辑器来写代码就行了。</p>
<p>下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcode.visualstudio.com" target="_blank" rel="noopener">https://code.visualstudio.com</a></p>
<p>安装完vscode后，在它的插件管理器中，查找<code>Vetur</code>并安装，然后重启一下vscode后，插件即生效：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-0d192ef619fc6cbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>安装Vetur插件</p>
<p>Vetur是一款可以提供Vue语法高亮、语法检查和代码快捷输入等功能的插件，可以为我们的开发过程提供很多便利。</p>
<h4 id="创建第一个基于mpvue的小程序项目代码"><a href="#创建第一个基于mpvue的小程序项目代码" class="headerlink" title="创建第一个基于mpvue的小程序项目代码"></a>创建第一个基于mpvue的小程序项目代码</h4><p>花了点时间装好了必要的开发环境，下面我们就来创建我们的第一个mpvue小程序项目。这里将用到前面已安装的vue-cli：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init mpvue&#x2F;mpvue-quickstart firstapp</span><br></pre></td></tr></table></figure>

<p>命令行将一步步的引导我们选择或填写项目的配置信息，如果你还不太明白这些内容的含义，可以先直接全部按回车：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? Project name firstapp</span><br><span class="line">? wxmp appid touristappid</span><br><span class="line">? Project description A Mpvue project</span><br><span class="line">? Author kevinzhang &lt;kevin.zhang@moredist.com&gt;</span><br><span class="line">? Vue build runtime</span><br><span class="line">? Use Vuex? Yes</span><br><span class="line">? Use ESLint to lint your code? Yes</span><br><span class="line">? Pick an ESLint preset Standard</span><br><span class="line">? 小程序测试，敬请关注最新微信开发者工具的“测试报告”功能 </span><br><span class="line"></span><br><span class="line">   vue-cli · Generated &quot;firstapp&quot;.</span><br><span class="line"></span><br><span class="line">   To get started:</span><br><span class="line">   </span><br><span class="line">     cd firstapp</span><br><span class="line">     npm install</span><br><span class="line">     npm run dev</span><br><span class="line">   </span><br><span class="line">   Documentation can be found at http:&#x2F;&#x2F;mpvue.com</span><br></pre></td></tr></table></figure>

<p>这个过程vue-cli主要是先从远程的代码仓库中下载了一份注册名为<code>mpvue/mpvue-quickstart</code>的模板代码，然后根据开发者在命令行提示过程中输入的信息，生成一份经过配置后的代码。</p>
<p>这份代码暂时还运行不起来，因为它还缺少依赖的库，我们需要执行以下命令进行依赖库的安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd firstapp </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>经过几分钟的下载安装，依赖库安装到了firstapp目录下，你可以看到该目录下多出了一个node_modules目录。</p>
<p>然后，执行命令让这个代码运行起来，进入开发模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>成功运行后，这个项目代码就进入开发模式，一旦有源代码发生修改，就会触发自动编译。因为mpvue使用的是Vue + HTML Web的开发方式开发小程序，它最终还是需要被转换成小程序的代码才可以在小程序环境运行，所以这里的自动编译的目的就是要把Web代码编译成小程序代码。编译后的代码会在<code>dist</code>目录下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-3572faed43dbdab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/668/format/webp" alt="img"></p>
<h4 id="运行并查看结果"><a href="#运行并查看结果" class="headerlink" title="运行并查看结果"></a>运行并查看结果</h4><p>上面的步骤中，我们开启开发模式后，其实并不能看到小程序的执行效果，要真正看小程序的运行界面的话，我们还是要借助微信开发者工具。</p>
<p>打开微信开发者工具，选择新增项目：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-3ceb36e7472d3ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>项目目录选择指向firstapp目录：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-b2d50fa4a653930e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/818/format/webp" alt="img"></p>
<p>点击“确定”按钮，进入小程序开发主界面，在左边的小程序模拟器中就能看到firstapp小程序的执行结果了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-fbc41e23b7cb9995.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/938/format/webp" alt="img"></p>
<p>【提醒】记得在微信开发者工具的菜单》设置 》编辑设置 中，将“保存时自动编译小程序”勾选上，这样当mpvue的代码自动编译完成后，模拟器才会自动刷新界面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-9b492a2bf48c8162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/878/format/webp" alt="img"></p>
<p>在Visual Studio Code里面打开项目文件夹，我们可以看到类似如下的文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstapp</span><br><span class="line">├── package.json</span><br><span class="line">├── project.config.json       </span><br><span class="line">├── static            </span><br><span class="line">├── src</span><br><span class="line">│    ├── components</span><br><span class="line">│    ├── pages</span><br><span class="line">│    ├── utils</span><br><span class="line">│    ├── App.vue</span><br><span class="line">│    └── main.js</span><br><span class="line">├── config</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── dev.env.js</span><br><span class="line">│   └── prod.env.js</span><br><span class="line">└── build</span><br></pre></td></tr></table></figure>

<h6 id="1）package-json文件"><a href="#1）package-json文件" class="headerlink" title="1）package.json文件"></a>1）package.json文件</h6><p>package.json是项目的主配置文件，里面包含了mpvue项目的基本描述信息、项目所依赖的各种第三方库以及版本信息、以及可执行的脚本信息。</p>
<p>我们看到该文件中的<code>scripts</code>部分配置了4个可执行的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;node build&#x2F;dev-server.js&quot;,</span><br><span class="line">&quot;start&quot;: &quot;node build&#x2F;dev-server.js&quot;,</span><br><span class="line">&quot;build&quot;: &quot;node build&#x2F;build.js&quot;,</span><br><span class="line">&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dev</code>和<code>start</code>是两个等价的命令，执行其中之一都可以将项目以开发模式启动。执行方式是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm start</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lint</code>指令是使用ESLint来进行代码语法和格式检查，以及修复一些可自动修复的问题。执行方式是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run lint  #检查语法和格式</span><br><span class="line">npm run lint -- --fix #检查代码语法和格式，并修复可自动修复的问题</span><br></pre></td></tr></table></figure>

<ul>
<li><code>build</code>指令是用于生成发布用代码的，它会对代码进行一些压缩优化处理。当小程序开发完成后，将要提交审核时，请使用<code>build</code>来生成发布的代码。</li>
</ul>
<h6 id="2）project-config-json文件"><a href="#2）project-config-json文件" class="headerlink" title="2）project.config.json文件"></a>2）project.config.json文件</h6><p><code>project.config.json</code>文件是用于管理微信开发者工具的小程序项目的配置文件，其中记录了小程序的appid、代码主目录、以及编译选项等等信息，在微信开发者工具中导入小程序项目的时候主要是通过该配置文件读取和写入配置信息。</p>
<h6 id="3）static目录"><a href="#3）static目录" class="headerlink" title="3）static目录"></a>3）static目录</h6><p><code>static</code>目录可以用于存放各种小程序本地静态资源，如图片、文本文件等。代码中可通过相对路径或绝对路径进行访问， 如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;static&#x2F;button.png&quot; &#x2F;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;static&#x2F;button.png&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h6 id="4）build目录"><a href="#4）build目录" class="headerlink" title="4）build目录"></a>4）build目录</h6><p><code>build</code>目录下是一些用于项目编译打包的node.js脚本和webpack配置文件。一般情况下不需要修改这些文件。</p>
<h6 id="5）config目录"><a href="#5）config目录" class="headerlink" title="5）config目录"></a>5）config目录</h6><p><code>config</code>目录下包含了用于开发和生产环境下的不同配置，<code>dev.env.js</code>用于开发环境，<code>prod.env.js</code>用于生产环境，你可以将开发阶段和生产阶段不一样的信息（如后台API的url地址等）配置到这两个文件中去，然后在代码中以变量的形式进行引用。例如，这2个文件中分别配置了不同的<code>API_BASE_URL</code>值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dev.env.js</span><br><span class="line">module.exports &#x3D; merge(prodEnv, &#123;</span><br><span class="line">  NODE_ENV: &#39;&quot;development&quot;&#39;,</span><br><span class="line">  API_BASE_URL: &#39;&quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&quot;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; prod.env.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  NODE_ENV: &#39;&quot;production&quot;&#39;,</span><br><span class="line">  API_BASE_URL: &#39;&quot;https:&#x2F;&#x2F;www.my-domain.com&#x2F;api&quot;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那你在编写请求后端API的代码时，你就可以使用这个环境配置，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const baseURL &#x3D; process.env.API_BASE_URL</span><br><span class="line">wx.request(&#123;</span><br><span class="line">  url: &#96;$&#123;baseURL&#125;&#x2F;products&#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样一来，开发阶段和上线发布阶段的环境可以清楚的区分开来。</p>
<h6 id="5）src目录"><a href="#5）src目录" class="headerlink" title="5）src目录"></a>5）src目录</h6><p><code>src</code>目录是我们主要进行小程序功能编写的地方。默认生成的demo代码为我们创建了几个子目录：<code>components</code>、<code>pages</code>和<code>utils</code>，还有2个文件：<code>App.vue</code>和<code>main.js</code>。其实它们都不是必须的，可以按照自己的风格进行定义和配置。不过默认创建的这个结构基本上是一个约定俗成的结构了，比较易于理解，所以我们可以遵循这个结构进行开发。</p>
<ul>
<li>components：在实际开发中，我们可以尽量将界面上可复用的部分，提取成vue组件放入该目录</li>
<li>pages：存放小程序的页面。请遵循每个小程序页面放入一个单独子目录的组织形式</li>
<li>utils：可选（可删）。可以将代码中一些公用工具函数组织成模块放入该目录下</li>
<li>可新建其他目录，存放你希望组织起来的代码。比如公用的业务逻辑代码、请求后台API的代码等等</li>
<li>main.js + App.vue：这两个是入口文件，相当于原生小程序框架中的<code>app.json</code>和<code>app.js</code>的复合体。</li>
</ul>
<p>为了清楚起见，我们将要对vue-cli生成的代码做一个清理工作，具体如下：</p>
<ul>
<li>删掉<code>src/components</code>、<code>src/pages</code>、<code>src/utils</code>三个目录下的所有代码文件</li>
<li>将<code>src/App.vue</code>文件中的内容重置成：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>将<code>src/main.js</code>文件中的内容重置成：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">App.mpType &#x3D; &#39;app&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; new Vue(App)</span><br><span class="line">app.$mount()</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    pages: [],</span><br><span class="line">    window: &#123;</span><br><span class="line">      backgroundTextStyle: &#39;light&#39;,</span><br><span class="line">      navigationBarBackgroundColor: &#39;#fff&#39;,</span><br><span class="line">      navigationBarTitleText: &#39;第一个小程序&#39;,</span><br><span class="line">      navigationBarTextStyle: &#39;black&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的代码就成了一个小程序页面都没有的初始状态。</p>
<h4 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h4><p>学习过使用小程序原生框架开发的朋友都知道，一个小程序的入口应该包含这三个最重要的部分：<br>1）app.json<br>2）app.js<br>3）首页</p>
<p>有了这三个部分，才能成功运行起一个最简单的小程序。</p>
<h6 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h6><p><code>app.json</code>是小程序的全局配置文件，其包含了小程序的页面文件路径配置、窗口的全局样式信息、底部选项卡式菜单栏的配置，以及一些小程序网络超时的配置等等。<code>app.json</code>的配置详情我们可以<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fconfig.html" target="_blank" rel="noopener">查阅参考小程序的官方文档来作进一步了解</a>。那么，在mpvue中我们如何来做与之等价的配置呢？</p>
<p>其实在<code>src/main.js</code>中，我们就可以完整的进行这些信息的配置，具体可以查看该文件的最底部代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 这部分相当于原生小程序的 app.json</span><br><span class="line">  config: &#123;</span><br><span class="line">    pages: [],</span><br><span class="line">    window: &#123;</span><br><span class="line">      backgroundTextStyle: &#39;light&#39;,</span><br><span class="line">      navigationBarBackgroundColor: &#39;#fff&#39;,</span><br><span class="line">      navigationBarTitleText: &#39;第一个小程序&#39;,</span><br><span class="line">      navigationBarTextStyle: &#39;black&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该代码中通过<code>export default</code>导出的对象的<code>config</code>属性下的值，就是这些小程序的配置信息了。</p>
<h6 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h6><p><code>app.js</code>中包含了小程序的各种原生生命周期方法，如<code>onLaunch</code>、<code>onShow</code>等等。而在mpvue中，它使用了一个简单的Vue组件<code>App.vue</code>来实现等价的功能。我们在这个<code>App.vue</code>组件中可以编写小程序的生命周期方法（通常使用Vue的生命周期方法，但也兼容原生的生命周期方法），也可以在其中加入小程序的全局样式（等价于原生方式下的<code>app.wxss</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;* 这部分相当于原生小程序的 app.js *&#x2F;</span><br><span class="line">export default &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    console.log(&#39;miniapp created!!!&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&#x2F;* 这部分相当于原生小程序的 app.wxss *&#x2F;</span><br><span class="line">.container &#123;</span><br><span class="line">  background-color: #cccccc;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>接着，这个<code>App.vue</code>组件被<code>src/main.js</code>引入并被设置了一个<code>mpType</code>的属性值，其值为<code>app</code>。这个值是为了与后面要讲的小程序页面组件所区分开来，因为小程序页面组件和这个<code>App.vue</code>组件的写法和引入方式是一致的，为了区分两者，需要设置<code>mpType</code>值。引入这个<code>App.vue</code>组件后，会用它作为参数来创建一个<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Finstance.html" target="_blank" rel="noopener">Vue的实例</a>，并调用<code>$mount()</code>方法加载。下面是这个过程的关键代码行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App.mpType &#x3D; &#39;app&#39;</span><br><span class="line">const app &#x3D; new Vue(App)</span><br><span class="line">app.$mount()</span><br></pre></td></tr></table></figure>

<h6 id="首页、以及其他页面"><a href="#首页、以及其他页面" class="headerlink" title="首页、以及其他页面"></a>首页、以及其他页面</h6><p>每个小程序都需要至少有一个页面，第一个展示的页面被叫做<em>首页</em>。因为前面已经把所有的页面代码都删完了，所以我们现在要新建一个首页。在<code>src/pages</code>目录下，我们新建一个名为<code>index</code>的子目录（请遵循每个页面放入一个子目录的良好习惯），然后在该子目录下，新建2个文件：一个用于实现页面主体功能的<code>index.vue</code>组件，另一个则用于将这个页面组件生成Vue实例并加载的<code>main.js</code>。以后的每一个mpvue页面组件都会拥有这样的结构。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-db653d8b653c1824.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/542/format/webp" alt="img"></p>
<p>然后在<code>main.js</code>中编写如下代码，非常简单的一段代码，它的功能是引入<code>index.vue</code>并创建Vue实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; new Vue(App)</span><br><span class="line">app.$mount()</span><br></pre></td></tr></table></figure>

<p>当然了，你也可以像在<code>src/main.js</code>中一样去导出一个页面级别的配置，因为小程序的每个页面都可以有一些单独的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; new Vue(App)</span><br><span class="line">app.$mount()</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    &#x2F;&#x2F; 注意，页面级可配置属性相当于只是&#96;src&#x2F;main.js&#96;中配置里的&#96;window&#96;部分</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;文章列表页面&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们需要实现<code>index.vue</code>页面组件，它的写法是最典型的Vue组件写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;Hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickHandle () &#123;</span><br><span class="line">      this.msg &#x3D; &#39;Clicked!!!!!!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.message &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个组件完全看不到小程序写法的影子，而是全部由Vue开发Web应用的写法来完成：数据绑定、事件处理、scoped局部样式、以及使用HTML标签来构建界面。这样最大化的保持和网页应用开发一致，减少了前端人员切换到小程序的学习理解成本，也为原先使用Vue开发的网页应用移植到小程序平台提供了降低迁移成本的可能。</p>
<p>模板部分我们通常可以用HTML标签来写，比如<code>div</code>、<code>span</code>等，它们会在编译的时候被自动转换成小程序的原生组件<code>view</code>、<code>text</code>之类；而那些小程序特有的组件如<code>swiper</code>、<code>rich-text</code>等，可以直接在模板中使用。</p>
<p>在原生小程序的页面（Page）中包含了很多页面的生命周期方法，如<code>onLoad</code>、<code>onUnload</code>、<code>onShow</code>、<code>onHide</code>、<code>onPullDownRefresh</code>等等，mpvue中推荐使用Vue组件生命周期方法，而像<code>onPullDownRefresh</code>、<code>onReachBottom</code>这类特殊功能的生命周期则需直接使用原生的。</p>
<p>回头再来看，当我们实现了这个<code>index.vue</code>页面组件后，其实还缺最后一个步骤，就是需要将这个页面组件指定为首页。如果我们的小程序只有一个页面的话，其实也可以省略这一步，因为mpvue会自动将<code>src/pages</code>目录下的页面组件路径添加到最终编译出来的小程序配置文件中去（可以打开<code>dist/app.json</code>文件观察一下）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pages&quot;: [</span><br><span class="line">    &quot;pages&#x2F;index&#x2F;main&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;window&quot;: &#123;</span><br><span class="line">    &quot;backgroundTextStyle&quot;: &quot;light&quot;,</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;第一个小程序&quot;,</span><br><span class="line">    &quot;navigationBarTextStyle&quot;: &quot;black&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，大多数情况下我们的小程序会由很多个页面组成，在<code>src/pages</code>目录下编写多个页面组件后，mpvue也会自动把它们都添加进配置文件，但是由于小程序有一个机制：</p>
<blockquote>
<p>配置文件中pages数组里的第一个page路径会被当做是首页</p>
</blockquote>
<p>如果你期望的首页组件并没有被mpvue添加到第一个路径的话，就不会被当做首页显示。比如有多个页面，并在<code>dist/app.json</code>里生成的是下面的序列，则第一个<code>pages/articles/main</code>页面会被当做首页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;pages&quot;: [</span><br><span class="line">  &quot;pages&#x2F;articles&#x2F;main&quot;,</span><br><span class="line">  &quot;pages&#x2F;authors&#x2F;main&quot;,</span><br><span class="line">  &quot;pages&#x2F;index&#x2F;main&quot;,</span><br><span class="line">  &quot;pages&#x2F;kickstart&#x2F;main&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>为了解决这种情况，我们需要显式的去指定首页。可以在<code>src/main.js</code>的配置里，加入这样一行配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages: [</span><br><span class="line">  &#39;^pages&#x2F;index&#x2F;main&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注意：以上配置中指定为首页的路径前面有个<code>^</code>符号。</p>
<p>加入这行配置之后，<code>pages/index/main</code>总是会在最终生成的<code>dist/app.json</code>中排在第一个位置，成为首页。</p>
<p>既然<code>mpvue</code>是基于Vue的，那么就没有理由不进一步学习一下Vue最核心的东西：<em>组件</em>。组件系统是Vue应用开发中最具价值的特性之一，在前文中其实我们就已经有在使用组件了，比如<code>App.vue</code>和首页<code>index.vue</code>就是两个Vue组件。</p>
<p>组件是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树，若干的小组件可以聚合成一个完整的界面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-63a928c25e48b726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>一个好的组件系统一定会有这些特点：封装性、复用性、扩展性。对于Vue的组件来说，这几点都算是实现的比较的优秀的。</p>
<h4 id="组件的封装性"><a href="#组件的封装性" class="headerlink" title="组件的封装性"></a>组件的封装性</h4><p>Vue组件的写法可以避免将属于一个独立逻辑单位的代码散落在各处，可以将界面（DOM）、样式（CSS）、行为（JS）三部分的代码很好的组织在一起（推荐的实践是使用<code>.vue</code>文件）。在设计编写一个组件时，我们要记住的原则就是：</p>
<blockquote>
<p>避免向外部暴露过多的东西，只暴露必要的外部交互接口（组件属性、事件、方法等）。</p>
</blockquote>
<p>下面我们来在原先的代码基础上，创建一个简单的按钮点击计数器组件，它将实现的功能是：点击按钮并展示已点击按钮次数、点击清零按钮实现点击次数的归零。在<code>src/components</code>目录下，新建一个<code>click-counter.vue</code>组件文件，并编写如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;click-counter&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;counter-num&quot;&gt;次数：&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-btn&quot; @click&#x3D;&quot;handleClick&quot;&gt;点我呀！&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-reset-btn&quot; @click&#x3D;&quot;handleResetClick&quot;&gt;清零&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      this.num +&#x3D; 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleResetClick() &#123;</span><br><span class="line">      this.num &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.click-counter &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #ffffff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.counter-num,</span><br><span class="line">.counter-btn,</span><br><span class="line">.counter-reset-btn &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  margin: 3px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>编写完这个组件后，我们来尝试在首页组件<code>src/pages/index/index.vue</code>文件中使用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 使用 click-counter 组件 --&gt;</span><br><span class="line">    &lt;click-counter &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 导入 click-counter 组件</span><br><span class="line">import ClickCounter from &quot;@&#x2F;components&#x2F;click-counter&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明在当前组件下使用 counter-click 组件</span><br><span class="line">  components: &#123; ClickCounter &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;Hello&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickHandle() &#123;</span><br><span class="line">      this.msg &#x3D; &quot;Clicked!!!!!!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.message &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>完成上面两个步骤后，记得重新运行一下命令行<code>npm run dev</code>（注意点：新增文件必须重新运行该命令，编译器不会自动检测新加入的文件）。成功后通过微信开发者工具的模拟器查看，结果界面将会是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-c8f38ba44e45af23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/377/format/webp" alt="img"></p>
<p>点击“点我呀！”按钮，计数器就会累加点击次数并更新界面上的数字；而点击“清零”按钮，则会将统计数字归零。</p>
<p>回到代码上来看，对于<code>click-counter.vue</code>的使用者<code>index.vue</code>来说，它并不关心太多<code>click-counter.vue</code>的实现细节，引入该组件文件并进行声明，就可以通过标签的形式来使用它了，非常简单明了。而且，这样一个<code>click-counter.vue</code>组件也可以被拿到其他的Vue/mpvue代码中使用，其他使用者也并不需要关注它的实现细节，而只需要关心它能实现什么功能就行了。这就是组件封装带来的好处。</p>
<p>不过，目前的这个click-counter组件还没有跟它的父组件之间有什么交互或通信，没有体现出“暴露接口”的特性，那让我们来增加点代码，了解下这一特性。首先解释一下我们要实现的功能：组件可以接收一个外部设置的初始点击次数值，在点击“点我呀！”按钮的时候，从这个初始值开始进行累加；并且点击按钮后，可以通知组件的使用者（即父组件）当前的点击统计值。</p>
<p>修改<code>click-counter.vue</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;click-counter&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;counter-num&quot;&gt;次数：&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-btn&quot; @click&#x3D;&quot;handleClick&quot;&gt;点我呀！&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-reset-btn&quot; @click&#x3D;&quot;handleResetClick&quot;&gt;清零&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 增加一个可从外部传入的属性initNum</span><br><span class="line">  props: &#123;</span><br><span class="line">    initNum: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: this.initNum &#x2F;&#x2F;使用传入的initNum值作为初始的点击数</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      this.num +&#x3D; 1;</span><br><span class="line">      this.notifyNum();</span><br><span class="line">    &#125;,</span><br><span class="line">    handleResetClick() &#123;</span><br><span class="line">      this.num &#x3D; 0;</span><br><span class="line">      this.notifyNum();</span><br><span class="line">    &#125;,</span><br><span class="line">    notifyNum() &#123;</span><br><span class="line">      &#x2F;&#x2F;触发自定义事件 clicknum</span><br><span class="line">      this.$emit(&quot;clicknum&quot;, &#123;</span><br><span class="line">        num: this.num</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.click-counter &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #ffffff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.counter-num,</span><br><span class="line">.counter-btn,</span><br><span class="line">.counter-reset-btn &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  margin: 3px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>修改<code>index.vue</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 使用 click-counter 组件 --&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;10&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 导入 click-counter 组件</span><br><span class="line">import ClickCounter from &quot;@&#x2F;components&#x2F;click-counter&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明在当前组件下使用 counter-click 组件</span><br><span class="line">  components: &#123; ClickCounter &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;Hello&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickHandle() &#123;</span><br><span class="line">      this.msg &#x3D; &quot;Clicked!!!!!!&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClickNum(data) &#123;</span><br><span class="line">      console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, data.num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.message &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>观察以上修改后的代码可以发现，在<code>click-couter.vue</code>中的主要变化是：</p>
<ol>
<li>使用<code>props</code>定义了一个名为<code>initNum</code>的数字型组件属性（且初始值为0）。它可用于接收使用组件外部传入的值。然后，这个<code>initNum</code>值被赋值到<code>data</code>中的属性<code>num</code>上作为它的初始值。</li>
<li>在两个按钮的click事件处理方法中，额外调用了一个<code>notifyNum()</code>方法，它向组件触发了一个自定义事件<code>clicknum</code>并携带了当前点击次数值。</li>
</ol>
<p>而在<code>index.vue</code>中的主要变化是实例化<code>click-counter</code>组件的这行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;click-counter :init-num&#x3D;&quot;10&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>实例化组件的时候，为组件传入了<code>initNum</code>属性值<code>10</code>；并且添加了一个对自定义事件<code>clicknum</code>的监听方法。</p>
<p>这样一个结构实现了数据进入组件/数据传出组件的机制，父子组件之间就能实现数据通信。通过有限的通信点进行数据互换，而不是直接进行函数调用，可以使得代码结构更优雅、更易维护。</p>
<h4 id="组件的复用性"><a href="#组件的复用性" class="headerlink" title="组件的复用性"></a>组件的复用性</h4><p>组件的复用性就好理解的多了，创建组件的目的，大多数时候就是希望这个组件可以被多个地方、多次使用，避免编写重复的代码。比如我们前面的计数器组件，有可能一个项目中的多个页面会用到，也可能一个页面就会使用多次。</p>
<p>Vue组件的复用也是很容易的，比如我们要在前面例子中的<code>index.vue</code>中复用计数器组件，创建3个计数器，那么直接在模板部分编写3个标签就行了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 创建 3个 click-counter 组件 --&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;10&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;20&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;30&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>运行后的效果如下图所示，这三个计数器都能独立统计各自的点击数量：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-fc10dbe6b6f4c08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/379/format/webp" alt="img"></p>
<h4 id="组件的扩展性"><a href="#组件的扩展性" class="headerlink" title="组件的扩展性"></a>组件的扩展性</h4><p>谈到扩展性，有面向对象编程经验的开发者就会想到“继承(extends)”。继承是一种比较有效的扩展机制，不过随着继承的层次变深，代码也会变得难以理解。在Vue组件中，没有采用继承的机制，而是推荐使用“组合”的方式。</p>
<p>在组合理念下，我们尽量将想复用性高的组件设计到最小可拆分单位，比如按钮、输入框、单选框等等，然后再将这些低层组件放入更高层组件中，一层一层，慢慢拼装出满足需求的业务界面。</p>
<p>除了组合，Vue组件还提供了插槽(Slot)功能，相当于在一个组件中挖出了一个或多个坑，在具体使用这些具有插槽的组件时，可以选择往坑里面填什么内容（其他组件）。</p>
<p>举个例子，在计数器组件中，我们在清零按钮后面用<code>&lt;slot&gt;&lt;/slot&gt;</code>挖了一个坑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;click-counter&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;counter-num&quot;&gt;次数：&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-btn&quot; @click&#x3D;&quot;handleClick&quot;&gt;点我呀！&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-reset-btn&quot; @click&#x3D;&quot;handleResetClick&quot;&gt;清零&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>而后，在<code>index.vue</code>中使用计数器组件时，在<code>&lt;click-counter&gt;</code>标签体中放入了额外的内容，会被传入该组件中去用于填坑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 使用 click-counter 组件 --&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;10&quot; @clicknum&#x3D;&quot;handleClickNum&quot;&gt;</span><br><span class="line">      &lt;!-- 填坑用... --&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;checkbox&quot; &#x2F;&gt; 禁用</span><br><span class="line">    &lt;&#x2F;click-counter&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>从运行结果可以看到，清零按钮后面已经多出了我们传入的复选框和文字内容:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-af53245a3d9a569a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/381/format/webp" alt="img"></p>
<p>插槽其实可以理解为是另一种形式的组件属性：普通组件属性传入的是比较简单类型的数据；而插槽传入的可以是更复杂的界面组件而已。</p>
<p>由于mpvue采用的是Vue框架的基础设施，所以大部分的功能都是和<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2F" target="_blank" rel="noopener">Vue</a>一致的。但是，mpvue的代码毕竟最终还是要转译成小程序原生框架下的代码的，由于小程序框架本身存在的一些功能限制，导致有些功能不能被翻译过去，也就是说有些标准的Vue功能在mpvue下是不可以使用或有特殊限制的。</p>
<p>今天我们就来罗列一下，在使用mpvue的时候那些需要特别注意的点。</p>
<h4 id="1-在模板中，动态插入HTML的v-html指令不可用"><a href="#1-在模板中，动态插入HTML的v-html指令不可用" class="headerlink" title="1. 在模板中，动态插入HTML的v-html指令不可用"></a>1. 在模板中，动态插入HTML的<code>v-html</code>指令不可用</h4><p>这条很好理解，小程序的界面并不是基于浏览器的BOM/DOM的，所以不能动态的在界面模板里直接插入HTML片段来显示。</p>
<p>题外话，如果有在小程序里插入html片段的需求怎么办？可以用<code>&lt;rich-text&gt;</code>组件或者<code>wxParse</code>(<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ficindy%2FwxParse" target="_blank" rel="noopener">https://github.com/icindy/wxParse</a>)来实现。</p>
<h4 id="2-在模板中，用于数据绑定的双括号语法插值表达式中的表达式功能存在诸多限制"><a href="#2-在模板中，用于数据绑定的双括号语法插值表达式中的表达式功能存在诸多限制" class="headerlink" title="2. 在模板中，用于数据绑定的双括号语法插值表达式中的表达式功能存在诸多限制"></a>2. 在模板中，用于数据绑定的双括号语法<code>插值表达式</code>中的表达式功能存在诸多限制</h4><p>在Vue本身的模板内双括号语法中，我们可以对绑定变量进行比较丰富的处理，比如：</p>
<ul>
<li>可以调用<code>methods</code>下的函数， 例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; formatMessage(msg) &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;Hello,World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    formatMessage(str) &#123;</span><br><span class="line">      return str.trim().split(&#39;,&#39;).join(&#39;#&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果变量是对象的话，也可以调用对象的成员方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; msg.trim().split(&#39;,&#39;).join(&#39;#&#39;) &#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用过滤器来处理变量，最有用的场景算是格式化数据了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; msg | format &#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>以上这些好用的功能，在mpvue中，记得都是通通不能用的哦！！！</p>
<p>我们只能在双括号中使用一些简单的运算符运算（<code>+ - * % ?: ! == === &gt; &lt; [] .</code>）。</p>
<p>但是也得找些可用的替代方案呐，大伙先考虑使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomputed.html" target="_blank" rel="noopener">计算属性(computed)</a>来做吧。</p>
<h4 id="3-在模板中，除事件监听外，其余地方都不能调用methods下的函数"><a href="#3-在模板中，除事件监听外，其余地方都不能调用methods下的函数" class="headerlink" title="3. 在模板中，除事件监听外，其余地方都不能调用methods下的函数"></a>3. 在模板中，除事件监听外，其余地方都不能调用<code>methods</code>下的函数</h4><p>在Vue中，模板里调用<code>methods</code>部分定义的函数是非常常见的，比如下面这段代码所示，在<code>v-if</code>指令中调用函数<code>getErrorNum()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if&#x3D;&quot;getErrorNum() &gt; 0  &amp;&amp; code &#x3D;&#x3D; 10001&quot; class&#x3D;&quot;error&quot;&gt;&#123;&#123; errorMsg &#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>可是，在mpvue里就是不可以用！因为在小程序原生模板<code>wxml</code>里就不支持这种函数调用，导致mpvue没有很好的方式转译过去（虽然小程序有<code>wxs</code>，但是感觉翻译过去mpvue要做的工作会比较复杂）。</p>
<p>所以，可用的替代方案可能还是计算属性了。</p>
<h4 id="4-在模板中，不支持直接绑定一个对象到style或class属性上"><a href="#4-在模板中，不支持直接绑定一个对象到style或class属性上" class="headerlink" title="4. 在模板中，不支持直接绑定一个对象到style或class属性上"></a>4. 在模板中，不支持直接绑定一个对象到<code>style</code>或<code>class</code>属性上</h4><p>在Vue中我们可以为HTML元素的<code>class</code>或<code>style</code>绑定一个对象，并按照对象内的属性值来决定是否添加对应的属性名到HTML元素的样式名。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class&#x3D;&quot;classObject&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      classObject: &#123;</span><br><span class="line">        active: true,</span><br><span class="line">        &#39;text-danger&#39;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的运行后生成的HTML将是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;active&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>但是在mpvue下面这个特性也不能用，按官方说法是由于涉及到一些性能相关的原因。那如果要动态改变组件的<code>class</code>该怎么写呢？官方给出的方式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :class&#x3D;&quot;&#123; active: classObject.active, &#39;text-danger&#39;: classObject[&#39;text-danger&#39;]&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>其实改动不大，稍微多打了一些字而已，相当于在模板的<code>class</code>里再定义一个对象罢了。但是据文档中说这样会提升性能。好吧，为了性能，这点麻烦还是能忍受的。但是它又说了：从性能考虑，建议不要过度依赖此……看来即使这样，也还是有性能问题。</p>
<p>看来最好一点的方案，还是得使用计算属性，直接生成一串样式的字符串，绑定到<code>class</code>或<code>style</code>上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class&#x3D;&quot;classStr&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      classObject: &#123;</span><br><span class="line">        active: true,</span><br><span class="line">        &#39;text-danger&#39;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    classStr() &#123;</span><br><span class="line">      let arr &#x3D; []</span><br><span class="line">      for (let p in this.classObject) &#123;</span><br><span class="line">        if (this.classObject[p]) &#123;</span><br><span class="line">          arr.push(p)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr.join(&#39; &#39;) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-在模板中，嵌套使用v-for时，必须指定索引index"><a href="#5-在模板中，嵌套使用v-for时，必须指定索引index" class="headerlink" title="5. 在模板中，嵌套使用v-for时，必须指定索引index"></a>5. 在模板中，嵌套使用<code>v-for</code>时，必须指定索引<code>index</code></h4><p>通常，我们在Vue模板中嵌套循环渲染数组的时候，一般是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul v-for&#x3D;&quot;category in categories&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;product in category.products&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>但在mpvue中使用这种嵌套结构的<code>v-for</code>时，则必须每层的<code>v-for</code>上都给出索引，且索引需取不同名字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul v-for&#x3D;&quot;(category, index) in categories&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;(product, productIndex) in category.products&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-事件处理中的注意点"><a href="#6-事件处理中的注意点" class="headerlink" title="6. 事件处理中的注意点"></a>6. 事件处理中的注意点</h4><p>在mpvue中，一般可以使用Web的DOM事件名来绑定事件，mpvue会将Web事件名映射成对应的小程序事件名，对应列表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 左侧为WEB事件 : 右侧为对应的小程序事件</span><br><span class="line">&#123;</span><br><span class="line">    click: &#39;tap&#39;,</span><br><span class="line">    touchstart: &#39;touchstart&#39;,</span><br><span class="line">    touchmove: &#39;touchmove&#39;,</span><br><span class="line">    touchcancel: &#39;touchcancel&#39;,</span><br><span class="line">    touchend: &#39;touchend&#39;,</span><br><span class="line">    tap: &#39;tap&#39;,</span><br><span class="line">    longtap: &#39;longtap&#39;,</span><br><span class="line">    input: &#39;input&#39;,</span><br><span class="line">    change: &#39;change&#39;,</span><br><span class="line">    submit: &#39;submit&#39;,</span><br><span class="line">    blur: &#39;blur&#39;,</span><br><span class="line">    focus: &#39;focus&#39;,</span><br><span class="line">    reset: &#39;reset&#39;,</span><br><span class="line">    confirm: &#39;confirm&#39;,</span><br><span class="line">    columnchange: &#39;columnchange&#39;,</span><br><span class="line">    linechange: &#39;linechange&#39;,</span><br><span class="line">    error: &#39;error&#39;,</span><br><span class="line">    scrolltoupper: &#39;scrolltoupper&#39;,</span><br><span class="line">    scrolltolower: &#39;scrolltolower&#39;,</span><br><span class="line">    scroll: &#39;scroll&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的之外，Web表单组件<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>的change事件会被转为blur事件。</p>
<p>然后，像<code>keydown</code>、<code>keypress</code>之类的键盘事件也没有了，因为小程序没有键盘，所以不需要这些事件。</p>
<p>还有，Vue里面绑定事件的时候，可以指定事件修饰符，但是在mpvue里，官方给出了一些注意信息：</p>
<blockquote>
<ul>
<li>.stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！【这个亲测了一下，感觉是最新版本里修复了还是怎么的，没有文档里说的这个问题了】</li>
<li>.prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面【也就是不需要支持】</li>
<li>.capture 支持 1.0.9 【也就是在 mpvue 1.0.9及以后版本支持】</li>
<li>.self 没有可以判断的标识 【也就是不支持】</li>
<li>.once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑【也就是不支持】</li>
</ul>
</blockquote>
<p>所以呢，总之当你在遇到事件相关的问题，请回来查看一下文档，看看自己是否已经掉在坑里了。</p>
<h4 id="7-对于表单，请直接使用小程序原生的表单组件"><a href="#7-对于表单，请直接使用小程序原生的表单组件" class="headerlink" title="7. 对于表单，请直接使用小程序原生的表单组件"></a>7. 对于表单，请直接使用小程序原生的表单组件</h4><p>一句话，表单组件又多又复杂，框架可能Hold不住。所以在实际开发中，推荐直接使用小程序的表单组件标签来写，而不是使用Web的表单组件标签来写。当然了，在mpvue中使用了小程序的组件标签，数据绑定功能还是完全可以用的。给个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;picker @change&#x3D;&quot;handlePickerChange&quot; :value&#x3D;&quot;selectedIndex&quot; :range&#x3D;&quot;messages&quot;&gt;</span><br><span class="line">      &lt;view class&#x3D;&quot;picker&quot;&gt;当前消息：&#123;&#123; messages[selectedIndex] &#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;picker&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      selectedIndex: 0,</span><br><span class="line">      messages: [&#39;Hello&#39;, &#39;World&#39;, &#39;Haha&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handlePickerChange (e) &#123;</span><br><span class="line">      console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><p>另外，在Vue开发Web应用的时候，通常使用<code>vue-router</code>来进行页面路由。但是在mpvue小程序开发中，不能用这种方式，请使用<code>&lt;a&gt;</code>标签和小程序原生API <code>wx.navigateTo</code>等来做路由功能。</p>
<p>还有就是请求后端数据，我们通常在Web开发中使用<code>axios</code>等ajax库来实现，但是在小程序开发中也是不能用的，也请使用小程序的原生API <code>wx.request</code>等来进行。</p>
<p>如果你使用过原生的小程序框架，你一定经历过或思考过怎么解决以下的问题：</p>
<ul>
<li>怎么存放可全局访问的变量？</li>
<li>页面跳转的时候，怎么传递参数到下一个页面比较好？</li>
<li>页面返回上一页的时候，怎么传递当前页的数据到上一页？</li>
<li>多个页面间需要同步数据，怎么做比较好？</li>
</ul>
<p>网上一搜，解决的方法通常也是五花八门的，什么通过app上的globalData啊、通过存取storage啊、通过一个单独的模块(module)啊、通过Page路由栈啊、通过引入自定义事件啊、通过引入redux啊，等等等等……</p>
<p>在原生小程序框架里，确实没有提供什么太统一的方式来指导开发者解决这个问题，大家只能各自用着暂时能解决当前问题的方案。</p>
<p>不过，既然我们用了Vue/mpvue，遇到这种情况，自然而然的就会想到一个方案，那就是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" target="_blank" rel="noopener">Vuex</a>。Vuex 是一个专为 Vue 应用程序开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>通过使用Vuex，我们可以在mpvue里很方便的对需要在app、页面、组件之间共享的数据进行很好的统一管理，可以更方便有效的在各个代码部分对这些共享数据进行访问，同时可以使得你的代码条理变得更加清晰。</p>
<p>我们知道，Vuex一般有2种用法，当创建好store后：</p>
<ul>
<li>第一种用法是将store绑定到需要访问store内容的Vue实例上，然后通过该Vue实例下组件的<code>this.$store</code>来引用；或通过<code>mapState</code>等一系列映射函数将store中的state、getters、mutations、actions等映射成组件的计算属性或methods方法来使用；</li>
<li>第二种用法是直接在组件中通过<code>import</code>导入store所在的模块文件，然后调用该store上的相关方法和属性，比如<code>commit()</code>、<code>dispatch()</code>等方法来操作store中的内容。</li>
</ul>
<p>经过我的实测，上面的这两种方式在mpvue中也都是可用的。但是，由于mpvue不像Vue Web单页应用那种单Vue实例的结构，而是采用了多Vue实例的结构（app和各个页面都会由单独的Vue实例来管理），所以我个人推荐采用上面所说的第二种用法，这种方式会更加灵活和简单一些。</p>
<p>让我们开始写代码，先在<code>src</code>目录下新建一个stores目录，接着在stores目录下新建一个名为<code>global-store.js</code>的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment: (state) &#x3D;&gt; &#123;</span><br><span class="line">      state.count +&#x3D; 1</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: (state) &#x3D;&gt; &#123;</span><br><span class="line">      state.count -&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个代码中，我们新建了一个<code>Store</code>实例，管理了一个名为<code>count</code>的数字类型的状态，并定义了2个mutations去操作（增减）这个状态值。</p>
<p>接着，我们要在2个页面中访问这个store。让我们在<code>src/pages</code>目录下编写2个页面：index和test1。</p>
<p>这是<code>pages/index/index.vue</code>的代码内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;计数结果：&#123;&#123;count&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;&#x2F;pages&#x2F;test1&#x2F;main&quot; class&#x3D;&quot;navlink&quot;&gt;进入计数器页面&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import globalStore from &quot;..&#x2F;..&#x2F;stores&#x2F;global-store&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return globalStore.state.count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.navlink &#123;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>这是<code>pages/test1/index.vue</code>的代码内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container btns&quot;&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;calbtn&quot; @click&#x3D;&quot;hanleDecrement&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;calnum&quot;&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;calbtn&quot; @click&#x3D;&quot;hanleIncrement&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import globalStore from &quot;..&#x2F;..&#x2F;stores&#x2F;global-store&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return globalStore.state.count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    hanleIncrement() &#123;</span><br><span class="line">      globalStore.commit(&quot;increment&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    hanleDecrement() &#123;</span><br><span class="line">      globalStore.commit(&quot;decrement&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.btns &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.calnum &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  font-size: 32px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>这样，我们就有了2个使用了我们定义的global-store的页面，这些页面都会从store中获取<code>count</code>状态值并显示；在test1页面中，还会调用<code>increment</code>和<code>decrement</code>两个mutations去更新<code>count</code>值。</p>
<p>运行小程序，可以看到初始进入index页面时是这样的，页面上显示的计数结果是0：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-4a8524c7edf600c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/736/format/webp" alt="img"></p>
<p>index页面</p>
<p>然后点击“进入计数器页面”进到test1页面，并在这个页面上点击加减按钮操作一下，当中显示的count数会发生改变：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-aa5b58bdb9a7949b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/738/format/webp" alt="img"></p>
<p>test1页面</p>
<p>最后，点击左上角返回按钮返回index页面，你将发现这个页面上的计数结果也已经发生了改变，自动同步成前面操作后的结果了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-37a8bffb4252c0ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/740/format/webp" alt="img"></p>
<p>返回index页面</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过这个例子，是不是感觉到使用Vuex做页面间的传值和数据同步特别简单？另外，你也可以在<code>src/stores</code>目录下按需创建多个store模块，独立管理不同业务范围的数据，并按需导入页面组件使用。</p>
<p>Vuex是开发中一件非常得力的工具，希望你能尽快掌握它。更多的用法可以参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" target="_blank" rel="noopener">官方文档</a>。</p>
<p>参考链接 <a href="https://www.jianshu.com/p/462494e458c2" target="_blank" rel="noopener">https://www.jianshu.com/p/462494e458c2</a></p>
]]></content>
      <categories>
        <category>mpvue</category>
      </categories>
      <tags>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title>npm是什么最全记录</title>
    <url>/2020/07/29/npm%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%80%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="npm是什么？"><a href="#npm是什么？" class="headerlink" title="npm是什么？"></a>npm是什么？</h3><p>npm全称Node Package Manager，是node.js的模块依赖管理工具，它有一个日益强大的对手叫yarn，yarn是Facebook发布的一款依赖管理工具。</p>
<a id="more"></a>

<h3 id="npm的使用场景："><a href="#npm的使用场景：" class="headerlink" title="npm的使用场景："></a>npm的使用场景：</h3><p>上传分享自己写的程序代码（包），下载别人写的程序代码（包）。</p>
<h3 id="npm的组成："><a href="#npm的组成：" class="headerlink" title="npm的组成："></a>npm的组成：</h3><ul>
<li>npm官网（<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" rel="noopener">https://www.npmjs.com/</a>），用来管理设置上面的代码程序包</li>
<li>一个大数据库，大家分享的程序就放在那里</li>
<li>命令行工具（CLI），我们通过CLI来与npm交流</li>
</ul>
<h3 id="npm怎么安装与升级"><a href="#npm怎么安装与升级" class="headerlink" title="npm怎么安装与升级"></a>npm怎么安装与升级</h3><p>与NodeJs一起集成安装，安装NodeJS时自动安装npm。</p>
<h3 id="查看npm版本"><a href="#查看npm版本" class="headerlink" title="查看npm版本"></a>查看npm版本</h3><p>npm -v#6.5.0</p>
<h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><p>npm help <command></p>
<h3 id="升级npm"><a href="#升级npm" class="headerlink" title="升级npm"></a>升级npm</h3><p>npm install npm -gnpm install npm@latest -g #升级到最新版本</p>
<h3 id="包是什么？"><a href="#包是什么？" class="headerlink" title="包是什么？"></a>包是什么？</h3><p>npm的核心是包，npm将它管理的程序都叫包，每个包里有个package.json文件，位于包的根目录下，用于定义包的属性（配置信息），比如包的名称、版本、许可证等等。</p>
<p>在进行npm install命令时，就是根据这个配置文件，来自动下载这个包所需的模块，配置项目所需的运行和开发环境。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json是一个JSON对象，每一个键值对就是当面包的一个配置。</p>
<p>一个package.json常用字段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Hello World&quot;, &#x2F;&#x2F;包名   </span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,&#x2F;&#x2F;包的版本号，主版本.次版本.补丁版本    </span><br><span class="line">  &quot;author&quot;: &quot;张三&quot;,&#x2F;&#x2F;包的作者，格式设置：Your Name &lt;email@example.com&gt; (http:&#x2F;&#x2F;example.com)    </span><br><span class="line">  &quot;description&quot;: &quot;第一个node.js程序&quot;,&#x2F;&#x2F;包的描述    </span><br><span class="line">  &quot;keywords&quot;: [&quot;node.js&quot;, &quot;javascript&quot;],&#x2F;&#x2F;包的关键词        </span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,&#x2F;&#x2F;main 字段指定了程序的主入口文件，require(&#39;moduleName&#39;) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。   </span><br><span class="line">  &quot;repository&quot;: &#123;&#x2F;&#x2F; 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。   </span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;https:&#x2F;&#x2F;path&#x2F;to&#x2F;url&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,&#x2F;&#x2F;包的版权协议  </span><br><span class="line">  &quot;engines&quot;: &#123; &quot;node&quot;: &quot;0.10.x&quot; &#125;,&#x2F;&#x2F;该模块运行的平台，比如 Node 的某个版本或者浏览器</span><br><span class="line">  &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;http:&#x2F;&#x2F;path&#x2F;to&#x2F;bug&quot;, &quot;email&quot;: &quot;bug@example.com&quot; &#125;,</span><br><span class="line">  &quot;contributors&quot;: [&#123; &quot;name&quot;: &quot;李四&quot;, &quot;email&quot;: &quot;lisi@example.com&quot; &#125;],&#x2F;&#x2F;包的其他贡献者姓名  </span><br><span class="line">  &quot;scripts&quot;: &#123;&#x2F;&#x2F;运行脚本命令的npm命令行缩写，执行命令：npm run &lt;命令名&gt;  </span><br><span class="line">    &quot;start&quot;: &quot;node index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;config&quot;: &#123;&#x2F;&#x2F;添加命令行的环境变量      </span><br><span class="line">    &quot;port&quot;: &quot;8080&quot;&#x2F;&#x2F;可以在js中通过process.env.npm_package_config_port获取，可以通过npm config set &lt;包名&gt;:port 80修改        &#125;, </span><br><span class="line">    &quot;browser&quot;: &#123;&#x2F;&#x2F;供浏览器使用的版本       </span><br><span class="line">      &quot;tipso&quot;: &quot;.&#x2F;node_modules&#x2F;tipso&#x2F;src&#x2F;tipso.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;&#x2F;&#x2F;项目运行依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 * node_module 目录下    </span><br><span class="line">      &quot;express&quot;: &quot;latest&quot;,</span><br><span class="line">      &quot;mongoose&quot;: &quot;~3.8.3&quot;,</span><br><span class="line">      &quot;handlebars-runtime&quot;: &quot;~1.0.12&quot;,</span><br><span class="line">      &quot;express3-handlebars&quot;: &quot;~0.5.0&quot;,</span><br><span class="line">      &quot;MD5&quot;: &quot;~1.2.0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;devDependencies&quot;: &#123;&#x2F;&#x2F;项目开发依赖包列表   </span><br><span class="line">      &quot;bower&quot;: &quot;~1.2.8&quot;,</span><br><span class="line">      &quot;grunt&quot;: &quot;~0.4.1&quot;,</span><br><span class="line">      &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,</span><br><span class="line">      &quot;grunt-contrib-jshint&quot;: &quot;~0.7.2&quot;,</span><br><span class="line">      &quot;grunt-contrib-uglify&quot;: &quot;~0.2.7&quot;,</span><br><span class="line">      &quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;,</span><br><span class="line">      &quot;browserify&quot;: &quot;2.36.1&quot;,</span><br><span class="line">      &quot;grunt-browserify&quot;: &quot;~1.3.0&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="依赖包版本格式"><a href="#依赖包版本格式" class="headerlink" title="依赖包版本格式:"></a>依赖包版本格式:</h3><ol>
<li><p>指定：1.2.2</p>
</li>
<li><p><del>+指定：</del>1.2.2，表示安装1.2.x的最新版本（不低于1.2.2，小于1.3.x）</p>
</li>
<li><p>^ + 指定版本：^1.2.2，表示安装1.x.x的最新版本，（不低于1.2.2，小于2.x.x）</p>
</li>
<li><p>latest：最新版本</p>
</li>
</ol>
<h3 id="package-json生成方式："><a href="#package-json生成方式：" class="headerlink" title="package.json生成方式："></a>package.json生成方式：</h3><ol>
<li>手写</li>
<li>执行npm init生成</li>
</ol>
<h3 id="依赖包写入package-json"><a href="#依赖包写入package-json" class="headerlink" title="依赖包写入package.json"></a>依赖包写入package.json</h3><p>不在package.json的包要写入，使用–save 或者–save-dev</p>
<p>npm install express –save     # 将该模块写入dependencies属性</p>
<p>npm install express –save-dev   #将该模块写入devDependencies属性</p>
<h3 id="下载安装、卸载、更新包"><a href="#下载安装、卸载、更新包" class="headerlink" title="下载安装、卸载、更新包"></a>下载安装、卸载、更新包</h3><p>安装方式（全局安装与本地安装）</p>
<p>npm install express       //本地安装</p>
<p>npm i express         //简写     </p>
<p>npm install express -g   //全局安装</p>
<ul>
<li>全局安装：安装包放在 /usr/local 下或者你 node 的安装目录，可以在命令行直接使用</li>
<li>本地安装：安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），没有时会自动创建，通过 require() 来引入本地安装的包</li>
</ul>
<h3 id="引用下载的包"><a href="#引用下载的包" class="headerlink" title="引用下载的包"></a>引用下载的包</h3><p>//var <Module name>= require(‘<Module name>‘);</Module></Module></p>
<p>var express = require(‘express’);</p>
<h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><p>npm uninstall express   //删除node_modules目录下面的包</p>
<p>npm uninstall –save express      //删除node_modules的包和package.json中的运行时依赖</p>
<p>npm uninstall –save-dev express      //删除node_modules的包和package.json中的开发依赖</p>
<p>npm uninstall -g express #全局卸载</p>
<h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><p>npm update expressnpm update express -g //更新全局包</p>
<h3 id="package-json中的依赖全部更新成最新的"><a href="#package-json中的依赖全部更新成最新的" class="headerlink" title="package.json中的依赖全部更新成最新的"></a>package.json中的依赖全部更新成最新的</h3><p>npm i -g npm-check-updates</p>
<p>ncu -u</p>
<p>npm install</p>
<h3 id="npm-version"><a href="#npm-version" class="headerlink" title="npm version"></a>npm version</h3><p><code>npm version --help</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease [--preid&#x3D;&lt;prerelease-id&gt;] | from-git]</span><br><span class="line">(run in package dir)</span><br><span class="line">&#39;npm -v&#39; or &#39;npm --version&#39; to print npm version (6.4.1)</span><br><span class="line">&#39;npm view &lt;pkg&gt; version&#39; to view a package&#39;s published version</span><br><span class="line">&#39;npm ls&#39; to inspect current package&#x2F;dependency versions</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p><code>npm version</code>获取当前的详细版本信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &#39;npm-version-test&#39;: &#39;1.0.0&#39;,</span><br><span class="line">  npm: &#39;6.4.1&#39;,</span><br><span class="line">  ares: &#39;1.14.0&#39;,</span><br><span class="line">  cldr: &#39;33.1&#39;,</span><br><span class="line">  http_parser: &#39;2.8.0&#39;,</span><br><span class="line">  icu: &#39;62.1&#39;,</span><br><span class="line">  modules: &#39;64&#39;,</span><br><span class="line">  napi: &#39;3&#39;,</span><br><span class="line">  nghttp2: &#39;1.33.0&#39;,</span><br><span class="line">  node: &#39;10.10.0&#39;,</span><br><span class="line">  openssl: &#39;1.1.0i&#39;,</span><br><span class="line">  tz: &#39;2018e&#39;,</span><br><span class="line">  unicode: &#39;11.0&#39;,</span><br><span class="line">  uv: &#39;1.23.0&#39;,</span><br><span class="line">  v8: &#39;6.8.275.30-node.24&#39;,</span><br><span class="line">  zlib: &#39;1.2.11&#39; &#125;</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>版本号有三位</p>
<blockquote>
<p>   <strong>major.minor.patch</strong></p>
<p>   主版本号.次版本号.修补版本号</p>
<ul>
<li>patch：修复bug，兼容老版本</li>
<li>minor：新增功能，兼容老版本</li>
<li>major：新的架构调整，不兼容老版本</li>
</ul>
</blockquote>
<h5 id="prerelease"><a href="#prerelease" class="headerlink" title="prerelease"></a>prerelease</h5><ol>
<li><code>npm version prerelease</code><br>package.json 中的版本号<code>1.0.0</code>变为 <code>1.0.1-0</code></li>
<li>再次执行 <code>npm version prerelease</code><br>package.json 中的版本号<code>1.0.1-0</code>变为 <code>1.0.1-1</code></li>
</ol>
<blockquote>
<p>5,6操作说明 当执行<code>npm version prerelease</code>时，如果没有预发布号，则增加minor，同时prerelease 设为0；<br>如果有prerelease， 则prerelease 增加1。</p>
</blockquote>
<h5 id="prepatch"><a href="#prepatch" class="headerlink" title="prepatch"></a>prepatch</h5><ol>
<li><code>npm version prepatch</code><br>package.json 中的版本号<code>1.0.1-1</code>变为 <code>1.0.2-0</code></li>
</ol>
<blockquote>
<p>prepatch - 直接升级小号，增加预发布号为0。</p>
</blockquote>
<h5 id="preminor"><a href="#preminor" class="headerlink" title="preminor"></a>preminor</h5><ol>
<li><code>npm version preminor</code><br>package.json 中的版本号<code>1.0.2-0</code>变为 <code>1.1.0-0</code></li>
</ol>
<blockquote>
<p>preminor - 直接升级中号，小号置为0，增加预发布号为0。</p>
</blockquote>
<ol>
<li><code>npm version premajor</code><br>package.json 中的版本号<code>1.1.0-0</code>变为 <code>2.0.0-0</code></li>
</ol>
<blockquote>
<p>premajor - 直接升级大号，中号、小号置为0，增加预发布号为0。</p>
</blockquote>
<h5 id="patch-主要目的升级patch"><a href="#patch-主要目的升级patch" class="headerlink" title="patch: 主要目的升级patch"></a>patch: 主要目的升级patch</h5><ol>
<li><code>npm version patch</code><br>package.json 中的版本号<code>2.0.0-0</code>变为 <code>2.0.0</code>;</li>
<li>再次执行<code>npm version patch</code><br>package.json 中的版本号<code>2.0.0</code>变为 <code>2.0.1</code>;</li>
</ol>
<blockquote>
<p>10,11 操作说明，patch：如果有prerelease ，则去掉prerelease ，其他保持不变；<br>如果没有prerelease ，则升级minor.</p>
</blockquote>
<h5 id="minor：-主要目的升级minor"><a href="#minor：-主要目的升级minor" class="headerlink" title="minor： 主要目的升级minor"></a>minor： 主要目的升级minor</h5><ol>
<li><code>npm version minor</code><br>package.json 中的版本号<code>2.0.1</code>变为 <code>2.1.0</code>;</li>
</ol>
<blockquote>
<p>如果没有prerelease，直接升级minor， 同时patch设置为0；</p>
</blockquote>
<ol>
<li><code>npm version premajor</code> <code>2.1.0</code>–&gt; <code>3.0.0-0</code>;</li>
<li><code>npm version minor</code> <code>3.0.0-0</code>–&gt; <code>3.0.0</code>;</li>
<li><code>npm version prepatch</code> <code>3.0.0</code>–&gt;<code>3.0.1-0</code>;</li>
<li><code>npm version minor</code> <code>3.0.1-0</code>–&gt;<code>3.1.0</code>;</li>
</ol>
<blockquote>
<p>如果有prerelease， 首先需要去掉prerelease；如果patch为0，则不升级minor：如<code>14</code>；<br>如果patch不为0， 则升级minor，同时patch设为0，如<code>16</code>。</p>
</blockquote>
<h5 id="major-：主要目的升级major"><a href="#major-：主要目的升级major" class="headerlink" title="major ：主要目的升级major"></a>major ：主要目的升级major</h5><ol>
<li><code>npm version major</code> : <code>3.1.0</code> –&gt;<code>4.0.0</code></li>
</ol>
<blockquote>
<p>如果没有prelease，则直接升级major，其他位都置为0；</p>
</blockquote>
<ol>
<li><code>npm version premajor</code>: <code>4.0.0</code> –&gt; <code>5.0.0-0</code>;</li>
</ol>
<blockquote>
<p>如果有预发布号： minor和patch都为0，则不升级major，只将prerelease 去掉。</p>
</blockquote>
<ol>
<li><code>npm version preminor</code> : <code>5.0.0-0</code>–&gt; <code>5.1.0-0</code></li>
<li><code>npm version major</code> : <code>5.1.0-0</code> –&gt;<code>6.0.0</code></li>
</ol>
<h3 id="查看安装包信息"><a href="#查看安装包信息" class="headerlink" title="查看安装包信息"></a>查看安装包信息</h3><p>npm list    #查看本地安装包信息</p>
<p>npm list -g  #查看全局安装包信息</p>
<p>npm list express #查看某个安装包信息</p>
<p>npm ls    #npm list简写</p>
<p><img src="http://upload-images.jianshu.io/upload_images/15009210-77025bd3552afff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327/format/webp" alt="img"></p>
<h3 id="提升下载包的速度"><a href="#提升下载包的速度" class="headerlink" title="提升下载包的速度"></a>提升下载包的速度</h3><p>由于npm的包大多是在国外数据库，下载速度会受到影响，我们想快一点，可以使用国内的淘宝镜像。</p>
<p>淘宝NPM镜像是一个完成的npmjs.org镜像，基本与官网服务一致。</p>
<h3 id="镜像地址"><a href="#镜像地址" class="headerlink" title="镜像地址"></a>镜像地址</h3><h4 id="淘宝镜像："><a href="#淘宝镜像：" class="headerlink" title="淘宝镜像："></a>淘宝镜像：</h4><ul>
<li>搜索地址：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fnpm.taobao.org%2F" target="_blank" rel="noopener">http://npm.taobao.org/</a></li>
<li>registry地址：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fregistry.npm.taobao.org%2F" target="_blank" rel="noopener">http://registry.npm.taobao.org/</a></li>
</ul>
<h4 id="官网镜像："><a href="#官网镜像：" class="headerlink" title="官网镜像："></a>官网镜像：</h4><ul>
<li>搜索地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" rel="noopener">https://www.npmjs.com/</a></li>
<li>registry地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fregistry.npmjs.org%2F" target="_blank" rel="noopener">https://registry.npmjs.org/</a></li>
</ul>
<h4 id="使用淘宝镜像"><a href="#使用淘宝镜像" class="headerlink" title="使用淘宝镜像"></a>使用淘宝镜像</h4><p>//临时使用淘宝镜像</p>
<p>#安装包时临时制定镜像地址 npm –registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> </p>
<p>install express</p>
<p>//持久使用淘宝镜像</p>
<p>先配置npm镜像，然后再安装包</p>
<ul>
<li><p>配置镜像：</p>
<p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>  #设置成淘宝镜像</p>
<p>npm config set registry <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a>    #设置成官网的</p>
</li>
<li><p>监测是否设置成功</p>
<p>npm config get registry   #查询镜像地址</p>
<p>npm info express #查询镜像地址</p>
</li>
<li><p>使用cnpm来使用淘宝镜像</p>
</li>
<li><p>安装cnpm</p>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</li>
<li><p>使用cnpm安装包</p>
<p>cnpm install [name]</p>
</li>
<li><p>使用nrm来管理切换npm源</p>
<p>nrm专门用来管理和快速切换私人配置的registry。</p>
</li>
<li><p>安装</p>
<p>npm install -g nrm</p>
</li>
<li><p>列出可选源</p>
<p>nrm ls</p>
</li>
<li><p>切换源</p>
<p>nrm use taobao</p>
</li>
<li><p>增加源</p>
<p>nrm add &lt;源名称&gt; &lt;源地址&gt;   #比如企业或组织有自己的私有源（镜像）时</p>
</li>
<li><p>删除源</p>
<p>nrm del</p>
</li>
<li><p>测试源响应</p>
<p>nrm test   #测试所有源nrm test npm  #测试npm官方源</p>
</li>
</ul>
<h3 id="如何创建和发布自己的包"><a href="#如何创建和发布自己的包" class="headerlink" title="如何创建和发布自己的包"></a>如何创建和发布自己的包</h3><ul>
<li><p>创建模块</p>
<p>npm init</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/15009210-39b52d3d66dece35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp" alt="img"></p>
<p>​    此时，生成了package.json配置文件</p>
<ul>
<li><p>增加入口文件</p>
<p>默认的入口文件是根目录下的index.js，在根目录下创建index.js</p>
<p>//index.js</p>
<p>exports.printMsg = function() {    </p>
<p>​    console.log(“This is a message from the demo package”);</p>
<p>}</p>
</li>
</ul>
<ul>
<li><p>登录或注册npm账号</p>
<p>npm adduser  #注册npm账号</p>
<p>npm login #登录npm账号</p>
</li>
</ul>
<ul>
<li><p>发布包</p>
<p>发布包之前，我们需要做两步：</p>
</li>
</ul>
<ol>
<li><p>修改CHANGE.MD，这里记录了我们包发布的版本变化情况，格式自定</p>
</li>
<li><p>修改package.json中的version字段，表示这次发布的包的版本，如果不修改，发布会报错。</p>
<p>发布包：</p>
<p>npm publish</p>
</li>
</ol>
<ul>
<li><p>撤销发布</p>
<p>撤销发布自己发布过的某个版本代码</p>
<p>npm unpublish <package>@<version></version></package></p>
<p>发布成功之后，这个包就可以通过npm install命令来进行安装了。</p>
</li>
<li><p>管理包的版本</p>
<p>当我们下载和发布我们的包时，都会关注到包的版本号，npm使用语义版本号来管理包。</p>
<p>语义版本号组成：X.Y.Z</p>
<ul>
<li>X代表主版本号，表示有大变动，向下不兼容</li>
<li>Y代表次版本号，表示新增功能，向下兼容</li>
<li>Z代表补丁版本号，表示修复BUG</li>
</ul>
</li>
</ul>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul>
<li>卸载nodejs</li>
</ul>
<p>C:\ProgramData\Microsoft\Windows\Start Menu这个路径下面有个uninstall node.js点击运行在安装就行了，正常卸载才能重装</p>
<ul>
<li>清除缓存</li>
</ul>
<p>npm cache clean –force</p>
<ul>
<li><p>show和update</p>
<p>npm show xxx  //显示模块详情<br>npm update  //升级当前目录下的项目的所有模块<br>npm update xxx  //升级当前目录下的项目的指定模块<br>npm update -g xxx  //升级全局安装的指定模块</p>
</li>
</ul>
<ul>
<li><p>安装/卸载 babel</p>
<p>npm install <a href="mailto:babel-loader@7.1.5">babel-loader@7.1.5</a></p>
<p>npm uninstall babel-loader</p>
</li>
<li><p>install细讲</p>
<p>npm install xxx  //安装模块如不指定版本号，默认会安装最新的版本，安装但不写package.json<br>npm install xxx 0.0.1  //安装指定版本的模块<br>npm install –save xxx //安装并把模块的版本信息保存到dependencies（生产环境依赖）中，即你的package.json文件的dependencies字段中<br>npm install –global xxx<br>npm install –save-dev xxx //安装并把模块版本信息保存到devDependencies（开发环境依赖）中，即你的package.json文件的devDependencies字段中<br>npm install –save-optional xxx //安装并把模块安装到optionalDependencies（可选环境依赖）中，即你的package.json文件的optionalDependencies字段中<br>npm install –save-exact xxx //精确的安装指定版本的模块，dependencies字段里每个模块版本号前面的^会取消掉</p>
</li>
<li><p>常见安装</p>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<p>npm国内淘宝的镜像（因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。” ）</p>
</li>
</ul>
<p>  npm install -g express</p>
<p>  全局安装express模块</p>
<p>  npm install -g vue-cli</p>
<p>  全局安装vue-cli模块</p>
<p>  npm install -g supervisor</p>
<p>  用于服务器上Node.js应用崩溃的时候，自动重新启动。当然它也可以监控你的项目的js文件变化，自动重启来方便调试。</p>
<p>  npm install -g pm2</p>
<p>  PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>
<p>  npm install -s mongoose</p>
<p>  Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具,可以简单理解为链接、操作MongoDB数据库</p>
<p>  npm install -s md5</p>
<p>  这个就不解释了，MD5数据加密</p>
<p>  npm install -s express-session</p>
<p>  操作服务器端的session</p>
<p>  npm install -s connect-flash</p>
<p>  connect-flash是nodejs中的一个模块，flash是一个暂存器，而且暂存器里面的值使用过一次便被清空，适合用来做网站的提示信息。</p>
<p>  npm install -s multer</p>
<p>  Multer是一个node.js中间件，用于处理multipart/form-data，主要用于上传文件。</p>
<h3 id="‘gulp’不是内部或外部命令，也没是可运行的程序或批处理文件-问题解决方法"><a href="#‘gulp’不是内部或外部命令，也没是可运行的程序或批处理文件-问题解决方法" class="headerlink" title="‘gulp’不是内部或外部命令，也没是可运行的程序或批处理文件,问题解决方法"></a>‘gulp’不是内部或外部命令，也没是可运行的程序或批处理文件,问题解决方法</h3><p>解决方法：</p>
<p><strong>解决方法一</strong>：设置环境变量</p>
<p>1.计算机(右击)-&gt;属性-&gt;高级系统设置 -&gt; 高级-&gt;环境变量</p>
<p>2.找到node全局文件路径，输入npm config get prefix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure>

<p>C:\Users\Administrator\AppData\Roaming\npm 这个路径就是node全局文件路径</p>
<p><img src="https://images2015.cnblogs.com/blog/1119043/201704/1119043-20170405172531019-1392920719.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/1119043/201704/1119043-20170405172858613-839239581.png" alt="img"></p>
<p>3.关闭命令行窗口，重新打开</p>
<p><strong>解决方法二</strong>：全局安装gulp(简单快速，推荐)</p>
<p>1.说明：全局安装gulp的目的是通过它执行gulp任务</p>
<p>2.安装：命令提示符执行npm install gulp -g</p>
<p>3.命令提示符执行gulp -v ，验证一下是否正确安装</p>
<p>出现版本号，说明问题已经解决，可以使用gulp-v、gulp less、gulp build等执行操作</p>
<p><img src="https://images2015.cnblogs.com/blog/1119043/201704/1119043-20170405173920191-1512489935.png" alt="img"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1.两种方法配置完成之后，命令提示符都需关闭之后，再重新打开，才能起作用。</p>
<p>2.没有安装全局的gulp，只安装了本地gulp,命令行无法执行gulp-v，也无法执行gulp其它的相关命令。</p>
<p>参考资料：</p>
<p>官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com.cn%2Fgetting-started%2Finstalling-npm-packages-locally%2F" target="_blank" rel="noopener">https://www.npmjs.com.cn/getting-started/installing-npm-packages-locally/</a></p>
<p>菜鸟教程：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-npm.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-npm.html</a></p>
<p>npm脚本使用：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F10%2Fnpm_scripts.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a></p>
<p>package.json说明：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fnodejs%2Fpackagejson.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/packagejson.html</a></p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>packageJson</tag>
      </tags>
  </entry>
  <entry>
    <title>postman</title>
    <url>/2020/07/30/postman/</url>
    <content><![CDATA[<h3 id="Postman介绍"><a href="#Postman介绍" class="headerlink" title="Postman介绍"></a>Postman介绍</h3><p>Postman是google开发的一款功能强大的网页调试与发送网页HTTP请求，并能运行测试用例的的Chrome插件。其主要功能包括：</p>
<ul>
<li><strong>模拟各种HTTP requests</strong></li>
</ul>
<p>从常用的 GET、POST 到 RESTful 的 PUT 、 DELETE …等等。 甚至还可以发送文件、送出额外的 header。</p>
<ul>
<li><strong>Collection 功能（测试集合）</strong></li>
</ul>
<a id="more"></a>

<p>Collection 是 requests的集合，在做完一個测试的時候， 你可以把這次的 request 存到特定的 Collection 里面，如此一來，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API.而且 Collection 还可以 Import 或是 Share 出來，让团队里面的所有人共享你建立起來的 Collection。</p>
<ul>
<li><strong>人性化的Response整理</strong></li>
</ul>
<p>一般在用其他工具來测试的時候，response的内容通常都是纯文字的 raw， 但如果是 JSON ，就是塞成一整行的 JSON。这会造成阅读的障碍 ，而 Postman 可以针对response内容的格式自动美化。 JSON、 XML 或是 HTML 都會整理成我们可以阅读的格式</p>
<ul>
<li><strong>内置测试脚本语言</strong></li>
</ul>
<p>Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果</p>
<ul>
<li><strong>设定变量与环境</strong></li>
</ul>
<p>Postman 可以自由 设定变量与Environment，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我們可能会有多种环境， development 、 staging 或 local， 而这几种环境中的 request URL 也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。</p>
<h3 id="安装Postman"><a href="#安装Postman" class="headerlink" title="安装Postman"></a>安装Postman</h3><p>Postman作为一个chrome的插件，你可以打开chrome，在chrome webstore里面找到。当然，如果是在国内，你需要翻墙，否则的话，你只能百度一下，搜索postman的安装包自己安装到chrome上（这里就不赘述了，有很多类似的文章）。这里需要提一下的是，你可以不用打开chrome而直接使用Postman，具体的方法是：</p>
<p>选项-&gt;更多工具-&gt;扩展程序</p>
<p><img src="https://img-blog.csdn.net/20160601165759918" alt="img"></p>
<p>详细信息-&gt;创建快捷方式-&gt;‘全部勾上’<br><img src="https://img-blog.csdn.net/20160601165947779" alt="img"><br>这样你就可以在任何地方启动你的Postman了</p>
<h3 id="Postman-sending-requests"><a href="#Postman-sending-requests" class="headerlink" title="Postman sending requests"></a>Postman sending requests</h3><p>安装好之后，我们先打开Postman，可以看到界面分成左右两个部分，右边是我们后头要讲的collection，左边是现在要讲的request builder。在request builder中，我们可以通过Postman快速的随意组装出我们希望的request。一般来说，所有的HTTP Request都分成4个部分，URL, method, headers和body。而Postman针对这几部分都有针对性的工具。</p>
<p><img src="https://img-blog.csdn.net/20160601170546927" alt="img"></p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>要组装一条Request, URL永远是你首先要填的内容，在Postman里面你曾输入过的URL是可以通过下拉自动补全的哦。如果你点击<strong>Params</strong>按钮，Postman会弹出一个键值编辑器，你可以在哪里输入URL的Parameter，Postman会帮你自动加入到URL当中，反之，如果你的URL当中已经有了参数，那Postman会在你打开键值编辑器的时候把参数自动载入</p>
<p><img src="https://img-blog.csdn.net/20160601171111335" alt="这里写图片描述"></p>
<h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h4><p>点击’Headers’按钮，Postman同样会弹出一个键值编辑器。在这里，你可以随意添加你想要的Header attribute，同样Postman为我们通过了很贴心的auto-complete功能，敲入一个字母，你可以从下拉菜单里选择你想要的标准atrribute</p>
<p><img src="https://img-blog.csdn.net/20160601172202011" alt="这里写图片描述"></p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>要选择Request的Method是很简单的，Postman支持所有的Method，而一旦你选择了Method，Postman的request body编辑器会根据的你选择，自动的发生改变</p>
<p><img src="https://img-blog.csdn.net/20160601172720544" alt="这里写图片描述"></p>
<h4 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a>Request Body</h4><p>如果我们要创建的request是类似于POST，那我们就需要编辑Request Body，Postman根据body type的不同，提供了4中编辑方式：</p>
<ul>
<li>form-data</li>
<li>x-www-form-urlencoded</li>
<li>raw</li>
<li>binary</li>
<li><img src="https://img-blog.csdn.net/20160601173348297" alt="img"></li>
</ul>
<p>（我们这里是可以传文件的哦）</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>我这里创建一条发送给google geocode的request，看看是啥结果：</p>
<p><img src="https://img-blog.csdn.net/20160601173955815" alt="这里写图片描述"></p>
<p>注意，在URL里面我使用了变量googleMaps，并用插值表达式调用它，这里是类似于AngulaJs的语法（果然是同一家人），其返回值是：<a href="http://maps.googleapis.com/maps/api/geocode/json" target="_blank" rel="noopener">http://maps.googleapis.com/maps/api/geocode/json</a>。而这个变量我是定义在我的环境GoogleApiTest里面的。这部分的内容会在接下来的文章里面讲到。</p>
<p>点击了Send之后，可以在Postman上直接看到response的内容，内容很漂亮，Postman根据内容检索自动按JSON的格式显示出来，同时我们可以清楚的看到status code和花费的时间。</p>
<p><img src="https://img-blog.csdn.net/20160601174202429" alt="这里写图片描述"></p>
<p>写到这，我想大家已经能够了解如何用Postman组装Request并且查看Response的内容了，那我们怎么用Postman去做测试呢，且听下回分解</p>
<p>我们已经知道如何用Postman组装并发送消息，那我们如何根据需求用Postman来做测试呢？在这开始之前，我们先来看看Postman的左边面板：</p>
<p><img src="https://img-blog.csdn.net/20160601175613918" alt="这里写图片描述"></p>
<p>这里包含了History和Collection，我们可以在History里面看到我们曾经发送过的HTTP Request, 我们可以很方便的通过点击上面的项重新构建我们的request。而右边的Request Builder面板上，还有两个按钮，Pre-request Script和Tests。</p>
<ul>
<li>Pre-request Script<br>定义我们在发送request之前需要运行的一些脚本，应用场景主要是设置全局变量和环境变量</li>
<li>Tests<br>定义发送Request之后，需要用脚本检测的内容，也就是Test case的内容。</li>
</ul>
<p>这里的的Tests是我们关键。</p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>打开Tests，我们可以看到窗口分成两部分，一部分是左边的代码窗口和右边的Snippet窗口，点击对应的snippet，postman会在左边的窗口为我们生成对应的代码，在下面的图中，我选择了“Response body: is equal to a String”和“Response time is less than 200ms”，可以看到Postman在代码窗口为我加载对应的语句，这里我把希望的responseBody改成了“No valid parameters!!”.<br>这样我就完成一条简单的测试用例：</p>
<ul>
<li>当HTTP Get request没有带任何参数的时候，希望response的body返回字符串“No valid parameters!!”</li>
<li>responseTime小于200ms</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160602113359840" alt="这里写图片描述"></p>
<h3 id="Variables-and-Environment"><a href="#Variables-and-Environment" class="headerlink" title="Variables and Environment"></a>Variables and Environment</h3><p>另外，这里大家可以看到在URL输入框中，我使用了，那我们如何定义变量呢，首先，我们得创建一个Environment，点击Environment那个button（在这里是“SampleEnv”那个button，因为我将其选择我当前使用的Environment）</p>
<p><img src="https://img-blog.csdn.net/20160602124514851" alt="这里写图片描述"></p>
<p>在Postman里面：</p>
<ul>
<li>Environements包含global Environment，即全局的Environment，里面定义的变量在任何地方地方都可以看到</li>
<li>local Environment, 里面定义的变量只有在当前Environment里面才可以看到，这里，我定义了一个“SampleEnv”</li>
<li>Environment可以被share，通过你的postman账号或者google账号</li>
<li>Environment可以通过文件import</li>
</ul>
<p>点击之后，选择Manage Environments。若要新建，选择Add。若要编辑global Environment, 选择Globals</p>
<p><img src="https://img-blog.csdn.net/20160602113947217" alt="这里写图片描述"></p>
<p>我们来看看我已经创建好的SampleEnv，这里只创建了一个变量myLocalHost，也就是我们之前看到的在URL里的那个变量，这个变量在URL里可以用，在test script里面可以用，任何其他地方你都可以通过插值表达式符号获得它的值。</p>
<p><img src="https://img-blog.csdn.net/20160602125204573" alt="这里写图片描述"></p>
<p>这里稍微举例一下变量的好处，比如你把APP部署在自己的机器上时使用的域名是localhost，而部署在服务器上时，域名就是具体的服务器ip。为了在两种不同环境上测试你的API，你在构建request的时候就需要输入不同的url，但如果你使用了变量，你就可以使用变量来复用你的url，你只需在不同的environment里面给url赋不同的值，那你的request就完全不需要变。同理，在tests里面也是一样的。这里就不赘述</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>定义好了test case （写好的Request和定义好结果检查tests）,我们就需要运行，你可以简单点击send按钮查看结果，但这时候你不会明显的看到测试的结果，你需要把这条request加入到collection当中。我们先创建一个collection:</p>
<p><img src="https://img-blog.csdn.net/20160602130152503" alt="这里写图片描述"></p>
<p>在弹出的窗口中创建你的collection，命名为你test suite的名字：</p>
<p><img src="https://img-blog.csdn.net/20160602130316608" alt="这里写图片描述"></p>
<p>创建collection之后，把已经写好的request(test case)保存到collection（test suite）当中。</p>
<ul>
<li>点击save，把Request Name改成你的test case的名字，比如“test_NoParameter_Expect_WarningInfo”;</li>
<li>save to exist collection，选择之前创建好的collection, “TestParameters”;</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160602130547344" alt="这里写图片描述"></p>
<p>点击窗口中的save之后我们就可以在左界面上看到我们的这个collection和collection中的request了：</p>
<p><img src="https://img-blog.csdn.net/20160602131229470" alt="这里写图片描述"></p>
<p>点击 ‘&gt;’按钮（点击了之后会变成 ‘&lt;’）,我们就会看到弹出的窗口中有一个‘Run’，运行一下，就会弹出一个collection runner的窗口。点击一下start test，你就可以看到运行的结果，这里我选择了运行100次，在左边窗口你还可以看到之前的运行记录：</p>
<p><img src="https://img-blog.csdn.net/20160602131658457" alt="这里写图片描述"></p>
<p>加入我把App的接口改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    protected void doGet( HttpServletRequest request, HttpServletResponse response )</span><br><span class="line">        throws ServletException,</span><br><span class="line">            IOException</span><br><span class="line">    &#123;</span><br><span class="line">        if( request.getParameter( &quot;name&quot; ) !&#x3D; null )</span><br><span class="line">        &#123;</span><br><span class="line">            response.getWriter().print( &quot;lex&quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            response.getWriter().print( &quot;No valid parameters???&quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<p>这会导致response body的比较不匹配 No valid parameters??? ！= No valid parameters！！</p>
<p><img src="https://img-blog.csdn.net/20160602132110919" alt="这里写图片描述"></p>
<p>那你就会看到 Body is correct case是FAIL的.</p>
<p>怎么样？学会了吗？</p>
<p>参考链接<a href="https://blog.csdn.net/u013613428/article/details/51557804" target="_blank" rel="noopener">https://blog.csdn.net/u013613428/article/details/51557804</a></p>
<p>参考链接<a href="https://blog.csdn.net/u013613428/article/details/51557914" target="_blank" rel="noopener">https://blog.csdn.net/u013613428/article/details/51557914</a></p>
<h3 id="拓展-（postwoman）"><a href="#拓展-（postwoman）" class="headerlink" title="拓展 （postwoman）"></a>拓展 （postwoman）</h3><p><code>Postwoman</code> 就非常方便，直接运行在浏览器</p>
<h4 id="在线访问"><a href="#在线访问" class="headerlink" title="在线访问"></a>在线访问</h4><p>chorme插件（应用商店下载）</p>
<h4 id="部署到本地"><a href="#部署到本地" class="headerlink" title="部署到本地"></a>部署到本地</h4><h5 id="Git-部署"><a href="#Git-部署" class="headerlink" title="Git 部署"></a>Git 部署</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> https:<span class="comment">//github.com/liyasthomas/postwoman.git</span></span><br><span class="line">cd postwoman</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>打开浏览器输入 <code>http://localhost:3000</code> 即可。</p>
<h5 id="docker-compose-部署"><a href="#docker-compose-部署" class="headerlink" title="docker-compose 部署"></a>docker-compose 部署</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> https:<span class="comment">//github.com/liyasthomas/postwoman.git</span></span><br><span class="line">cd postwoman</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p>同理也是 <code>http://localhost:3000</code> 端口访问。</p>
<h5 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pull</span></span><br><span class="line">docker pull liyasthomas/postwoman</span><br><span class="line"></span><br><span class="line"><span class="comment">#run</span></span><br><span class="line">docker run -p <span class="number">3000</span>:<span class="number">3000</span> liyasthomas/postwoman:latest</span><br><span class="line"></span><br><span class="line"><span class="comment">#build</span></span><br><span class="line">docker build -t postwoman:latest</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>postman</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>postman</tag>
        <tag>Chrome插件</tag>
      </tags>
  </entry>
  <entry>
    <title>nrm切换仓库源</title>
    <url>/2020/07/30/nrm%E5%88%87%E6%8D%A2%E4%BB%93%E5%BA%93%E6%BA%90/</url>
    <content><![CDATA[<h2 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h2><p>先描述一下没有nrm时我们是怎样使用npm源的</p>
<p>查看npm源地址，终端中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure>

<p>可以看到npm源</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">metrics-registry &#x3D; &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>如果需要修改registry地址，例如切换到国内的淘宝源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>如果要删除这个源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config rm registry</span><br></pre></td></tr></table></figure>

<p>这种方式缺乏对源的管理，切换源需要每次配置地址。如果使用中切换源比较频繁，那么步骤也很繁琐，所以我引入nrm这一源管理器。</p>
<h2 id="1-nrm是什么"><a href="#1-nrm是什么" class="headerlink" title="1. nrm是什么"></a>1. nrm是什么</h2><p>nrm 是一个 npm 源管理器，允许你快速地在 npm 源间切换。</p>
<p>什么意思呢，npm默认情况下是使用npm官方源（使用npm config ls命令可以查看），在国内用这个源肯定是不靠谱的，一般我们都会用淘宝npm源：<a href="https://registry.npm.taobao.org/，修改源的方式也很简单，在终端输入：" target="_blank" rel="noopener">https://registry.npm.taobao.org/，修改源的方式也很简单，在终端输入：</a></p>
<p>npm set registry <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a></p>
<p>再npm config ls查看，已经切换成功。</p>
<h2 id="2-安装nrm"><a href="#2-安装nrm" class="headerlink" title="2. 安装nrm"></a>2. 安装nrm</h2><p>在命令行执行如下命令，全局安装nrm。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure>

<h2 id="3-添加新的源"><a href="#3-添加新的源" class="headerlink" title="3. 添加新的源"></a>3. 添加新的源</h2><p>执行命令 nrm add <registry> <url>，其中 registry 为源名，<code>url</code>为源的路径。例如下面添加公司的私有源。</url></registry></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm add yuxxxx http:&#x2F;&#x2F;sinxxx.yuxxxx.cn:4123&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="4-切换源"><a href="#4-切换源" class="headerlink" title="4. 切换源"></a>4. 切换源</h2><p>执行命令 nrm use <registry>切换源。</registry></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm use yuxxxx</span><br></pre></td></tr></table></figure>

<h2 id="5-查看源"><a href="#5-查看源" class="headerlink" title="5. 查看源"></a>5. 查看源</h2><p>用nrm ls命令查看默认配置，带*号即为当前使用的源。可以看出切换已生效。</p>
<p><img src="https://img2018.cnblogs.com/blog/1001990/201905/1001990-20190515011742654-110730281.png" alt="img"></p>
<h2 id="6-测试源响应时间"><a href="#6-测试源响应时间" class="headerlink" title="6. 测试源响应时间"></a>6. 测试源响应时间</h2><p>通过nrm test <registry>测试相应源的响应时间。</registry></p>
<h2 id="7-删除源"><a href="#7-删除源" class="headerlink" title="7. 删除源"></a>7. 删除源</h2><p>执行命令 nrm del <registry> 删除对应的源。</registry></p>
<h2 id="8-使用zpm私有仓库源"><a href="#8-使用zpm私有仓库源" class="headerlink" title="8. 使用zpm私有仓库源"></a>8. 使用zpm私有仓库源</h2><p>举例</p>
<p>全局安装nrm</p>
<p>npm i nrm -g</p>
<p>添加仓库源<br>nrm add zpm <a href="http://119.45.186.39:4873/" target="_blank" rel="noopener">http://119.45.186.39:4873/</a></p>
<p>删除仓库源<br>nrm del zpm</p>
<p>登录用户<br>npm login</p>
<p>注册用户<br>npm adduser –registry <a href="http://119.45.186.39:4873/" target="_blank" rel="noopener">http://119.45.186.39:4873/</a></p>
<p>接下来会提示用户名，密码，邮箱，请记住这些，因为接下来还会用到<br>打开浏览器访问 <a href="http://119.45.186.39:4873/" target="_blank" rel="noopener">http://119.45.186.39:4873/</a><br>点击右上角登录，输入用户名密码，这时展示臻旅提供的包则说明可以下载<br>使用私有仓库源<br>nrm use zpm</p>
<p>补充说明：<br>nrm 命令报错（无法加载文件 C:\Users\hc\AppData\Roaming\npm\nrm.ps1 ，因为在此系统上禁止运行脚本。）<br>解决方式如下：<br>1.win+s 搜索powershell 以管理身份运行<br>2.使用set-ExecutionPolicy RemoteSigned命令将计算机上的执行策略更改为 RemoteSigned,输入Y确定<br>3.查看计算机执行策略get-ExecutionPolicy<br>4.执行命令：Set-ExecutionPolicy RemoteSigned -Scope Process再次输入Y问题解`</p>
]]></content>
      <categories>
        <category>nrm</category>
      </categories>
      <tags>
        <tag>nrm</tag>
        <tag>zpm</tag>
        <tag>仓库源</tag>
      </tags>
  </entry>
  <entry>
    <title>react之井字棋</title>
    <url>/2020/09/25/react%E4%B9%8B%E4%BA%95%E5%AD%97%E6%A3%8B/</url>
    <content><![CDATA[<p>见下文</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Square(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button className&#x3D;&quot;square&quot; onClick&#x3D;&#123;props.onClick&#125;&gt;</span><br><span class="line">      &#123;props.value&#125;</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Board extends React.Component &#123;</span><br><span class="line">  renderSquare(i) &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Square</span><br><span class="line">        value&#x3D;&#123;this.props.squares[i]&#125;</span><br><span class="line">        onClick&#x3D;&#123;() &#x3D;&gt; this.props.onClick(i)&#125;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(0)&#125;</span><br><span class="line">          &#123;this.renderSquare(1)&#125;</span><br><span class="line">          &#123;this.renderSquare(2)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(3)&#125;</span><br><span class="line">          &#123;this.renderSquare(4)&#125;</span><br><span class="line">          &#123;this.renderSquare(5)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(6)&#125;</span><br><span class="line">          &#123;this.renderSquare(7)&#125;</span><br><span class="line">          &#123;this.renderSquare(8)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Game extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      history: [</span><br><span class="line">        &#123;</span><br><span class="line">          squares: Array(9).fill(null)</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      stepNumber: 0,</span><br><span class="line">      xIsNext: true</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(i) &#123;</span><br><span class="line">    const history &#x3D; this.state.history.slice(0, this.state.stepNumber + 1);</span><br><span class="line">    const current &#x3D; history[history.length - 1];</span><br><span class="line">    const squares &#x3D; current.squares.slice();</span><br><span class="line">    if (calculateWinner(squares) || squares[i]) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    squares[i] &#x3D; this.state.xIsNext ? &quot;X&quot; : &quot;O&quot;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      history: history.concat([</span><br><span class="line">        &#123;</span><br><span class="line">          squares: squares</span><br><span class="line">        &#125;</span><br><span class="line">      ]),</span><br><span class="line">      stepNumber: history.length,</span><br><span class="line">      xIsNext: !this.state.xIsNext</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jumpTo(step) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      stepNumber: step,</span><br><span class="line">      xIsNext: (step % 2) &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const history &#x3D; this.state.history;</span><br><span class="line">    const current &#x3D; history[this.state.stepNumber];</span><br><span class="line">    const winner &#x3D; calculateWinner(current.squares);</span><br><span class="line"></span><br><span class="line">    const moves &#x3D; history.map((step, move) &#x3D;&gt; &#123;</span><br><span class="line">      const desc &#x3D; move ?</span><br><span class="line">        &#39;Go to move #&#39; + move :</span><br><span class="line">        &#39;Go to game start&#39;;</span><br><span class="line">      return (</span><br><span class="line">        &lt;li key&#x3D;&#123;move&#125;&gt;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.jumpTo(move)&#125;&gt;&#123;desc&#125;&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let status;</span><br><span class="line">    if (winner) &#123;</span><br><span class="line">      status &#x3D; &quot;Winner: &quot; + winner;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      status &#x3D; &quot;Next player: &quot; + (this.state.xIsNext ? &quot;X&quot; : &quot;O&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;game&quot;&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;game-board&quot;&gt;</span><br><span class="line">          &lt;Board</span><br><span class="line">            squares&#x3D;&#123;current.squares&#125;</span><br><span class="line">            onClick&#x3D;&#123;i &#x3D;&gt; this.handleClick(i)&#125;</span><br><span class="line">          &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;game-info&quot;&gt;</span><br><span class="line">          &lt;div&gt;&#123;status&#125;&lt;&#x2F;div&gt;</span><br><span class="line">          &lt;ol&gt;&#123;moves&#125;&lt;&#x2F;ol&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Game &#x2F;&gt;, document.getElementById(&quot;root&quot;));</span><br><span class="line"></span><br><span class="line">function calculateWinner(squares) &#123;</span><br><span class="line">  const lines &#x3D; [</span><br><span class="line">    [0, 1, 2],</span><br><span class="line">    [3, 4, 5],</span><br><span class="line">    [6, 7, 8],</span><br><span class="line">    [0, 3, 6],</span><br><span class="line">    [1, 4, 7],</span><br><span class="line">    [2, 5, 8],</span><br><span class="line">    [0, 4, 8],</span><br><span class="line">    [2, 4, 6]</span><br><span class="line">  ];</span><br><span class="line">  for (let i &#x3D; 0; i &lt; lines.length; i++) &#123;</span><br><span class="line">    const [a, b, c] &#x3D; lines[i];</span><br><span class="line">    if (squares[a] &amp;&amp; squares[a] &#x3D;&#x3D;&#x3D; squares[b] &amp;&amp; squares[a] &#x3D;&#x3D;&#x3D; squares[c]) &#123;</span><br><span class="line">      return squares[a];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>井字棋</tag>
      </tags>
  </entry>
  <entry>
    <title>overflow</title>
    <url>/2020/07/30/overflow/</url>
    <content><![CDATA[<h3 id="overflow详解"><a href="#overflow详解" class="headerlink" title="overflow详解"></a>overflow详解</h3><p>为使 overflow 有效果，块级容器必须有一个指定的高度（height或者max-height）或者将white-space设置为nowrap。</p>
<p>注意:  设置一个轴为visible（默认值），同时设置另一个轴为不同的值，会导致设置visible的轴的行为会变成auto。 </p>
<p>注意: 即使将overflow设置为hidden，也可以使用JavaScript <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/API/Element/scrollTop" target="_blank" rel="noopener">Element.scrollTop</a> 属性来滚动HTML元素。</p>
<a id="more"></a>

<p>语法</p>
<p>/* 默认值。内容不会被修剪，会呈现在元素框之外 <em>/overflow: visible;/</em> 内容会被修剪，并且其余内容不可见 <em>/overflow: hidden;/</em> 内容会被修剪，浏览器会显示滚动条以便查看其余内容 <em>/overflow: scroll;/</em> 由浏览器定夺，如果内容被修剪，就会显示滚动条 <em>/overflow: auto;/</em> 规定从父元素继承overflow属性的值 */overflow: inherit;</p>
<p> 从下面列表中选出一个或两个关键字来指定overflow 属性。如果指定了两个关键字，第一个关键字应用于overflow-x，第二个关键字应用于overflow-y。否则，overflow-x和overflow-y都设置为相同的值。</p>
<p>注意: 在Firefox 63之前，这些值是反向的，第一个值应用于overflow-y，第二个值应用于overflow-x。Firefox 63更新了这个顺序，以匹配对<a href="https://www.fxsitecompat.com/en-CA/docs/2018/overflow-shorthand-syntax-has-been-updated-to-swap-2-values/" target="_blank" rel="noopener">规范的更改</a>。此更改是为了匹配使用新逻辑属性overflow-block和overflow-inline时的顺序。</p>
<p>overflow-x: scroll;overflow-y: hidden;</p>
<p>/* On Firefox 61 and 62, this is the same as <em>/  overflow: hidden scroll;</em></p>
<p>/* But on Firefox 63 and later, it will be */   overflow: scroll hidden;</p>
<p>值</p>
<p>visible</p>
<p>默认值。内容不会被修剪，可以呈现在元素框之外。</p>
<p>hidden</p>
<p>如果需要，内容将被剪裁以适合填充框。 不提供滚动条。</p>
<p>scroll</p>
<p>如果需要，内容将被剪裁以适合填充框。 浏览器显示滚动条，无论是否实际剪切了任何内容。 （这可以防止滚动条在内容更改时出现或消失。）打印机仍可能打印溢出的内容。</p>
<p>auto</p>
<p>取决于用户代理。 如果内容适合填充框内部，则它看起来与可见内容相同，但仍会建立新的块格式化上下文。 如果内容溢出，桌面浏览器会提供滚动条。</p>
<p>overlay  </p>
<p>行为与auto相同，但滚动条绘制在内容之上而不是占用空间。 仅在基于WebKit（例如，Safari）和基于Blink的（例如，Chrome或Opera）浏览器中受支持。</p>
<p>Mozilla 扩展</p>
<p>-moz-scrollbars-none <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow#Deprecated" target="_blank" rel="noopener">[1]</a></p>
<p>使用 overflow:hidden 代替.</p>
<p>-moz-scrollbars-horizontal <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow#Deprecated" target="_blank" rel="noopener">[1]</a></p>
<p>推荐使用 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow-x" target="_blank" rel="noopener">overflow-x</a> 和 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow-y" target="_blank" rel="noopener">overflow-y</a> .</p>
<p>-moz-scrollbars-vertical <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow#Deprecated" target="_blank" rel="noopener">[1]</a></p>
<p>推荐使用 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow-x" target="_blank" rel="noopener">overflow-x</a> 和 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow-y" target="_blank" rel="noopener">overflow-y</a> .</p>
<p>-moz-hidden-unscrollable </p>
<p>主要用于内部和主题。禁用 方向键 和 鼠标滚轮 来滚动XML跟元素以及<HTML>和<body>元素。</body></HTML></p>
]]></content>
      <categories>
        <category>overflow</category>
      </categories>
      <tags>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title>this之常见的四种用法</title>
    <url>/2020/09/27/this%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><span style="color:red;">箭头函数的this指向window！！！！！！！！</span></p>
<p>1.在一般函数方法中使用 this 指代全局对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">　　　　this.x &#x3D; 1;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>2.作为对象方法调用，this 指代上级对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">情况一</span><br><span class="line">var x&#x3D;10</span><br><span class="line">function test()&#123;</span><br><span class="line">　　alert(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line">o.x &#x3D; 1;</span><br><span class="line">o.m &#x3D; test;</span><br><span class="line">o.m(); &#x2F;&#x2F; 1 this指的是对象</span><br><span class="line"></span><br><span class="line">情况二</span><br><span class="line">var x&#x3D;10</span><br><span class="line">function test()&#123;</span><br><span class="line">　　alert(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line">o.x &#x3D; 1;</span><br><span class="line">o.m &#x3D; test;</span><br><span class="line">var qa&#x3D;o.m</span><br><span class="line">qa(); &#x2F;&#x2F; 10 this指的是window</span><br></pre></td></tr></table></figure>



<p>3.作为构造函数调用，this 指代new 出的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x &#x3D; 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o &#x3D; new test();</span><br><span class="line">　　alert(o.x); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：</span><br><span class="line">　　var x &#x3D; 2;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x &#x3D; 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o &#x3D; new test();</span><br><span class="line">　　alert(x); &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>



<p>4.apply 调用 ，apply方法作用是改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this指代第一个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　var x &#x3D; 0;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o&#x3D;&#123;&#125;;</span><br><span class="line">　　o.x &#x3D; 1;</span><br><span class="line">　　o.m &#x3D; test;</span><br><span class="line">　　o.m.apply(); &#x2F;&#x2F;0</span><br><span class="line">&#x2F;&#x2F;apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为</span><br><span class="line"></span><br><span class="line">　　o.m.apply(o); &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向详解</title>
    <url>/2020/07/30/this%E6%8C%87%E5%90%91%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="前端面试之彻底搞懂this指向"><a href="#前端面试之彻底搞懂this指向" class="headerlink" title="前端面试之彻底搞懂this指向"></a>前端面试之彻底搞懂this指向</h3><p>this是JavaScript中的一个关键字，但是又一个相对比较特别的关键字，不像function、var、for、if这些关键字一样，可以很清楚的搞清楚它到底是如何使用的。</p>
<p>this会在执行上下文中绑定一个对象，但是是根据什么条件绑定的呢？在不同的执行条件下会绑定不同的对象，这也是让人捉摸不定的地方。</p>
<p>这一次，我们一起来彻底搞定this到底是如何绑定的吧！</p>
<a id="more"></a>

<p>一. 理解this</p>
<p>1.1. 为什么使用this</p>
<p>在常见的编程语言中，几乎都有this这个关键字（Objective-C中使用的是self），但是JavaScript中的this和常见的面向对象语言中的this不太一样：</p>
<ul>
<li>常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在类的方法中。</li>
<li>也就是你需要有一个类，类中的方法（特别是实例方法）中，this代表的是当前调用对象。</li>
<li>但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义。</li>
</ul>
<p>使用this有什么意义呢？下面的代码中，我们通过对象字面量创建出来一个对象，当我们调用对象的方法时，希望将对象的名称一起进行打印。</p>
<p>如果没有this，那么我们的代码会是下面的写法：</p>
<ul>
<li>在方法中，为了能够获取到name名称，必须通过obj的引用（变量名称）来获取。</li>
<li>但是这样做有一个很大的弊端：如果我将obj的名称换成了info，那么所有的方法中的obj都需要换成info。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  running: function () &#123;</span><br><span class="line">    console.log(obj.name + &quot; running&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  eating: function () &#123;</span><br><span class="line">    console.log(obj.name + &quot; eating&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  studying: function () &#123;</span><br><span class="line">    console.log(obj.name + &quot; studying&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>事实上，上面的代码，在实际开发中，我们都会使用this来进行优化：</p>
<ul>
<li>当我们通过obj去调用running、eating、studying这些方法时，this就是指向的obj对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  running: function () &#123;</span><br><span class="line">    console.log(this.name + &quot; running&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  eating: function () &#123;</span><br><span class="line">    console.log(this.name + &quot; eating&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  studying: function () &#123;</span><br><span class="line">    console.log(this.name + &quot; studying&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>  name: “why”,</p>
<p>  running: function() {</p>
<p>​    console.log(this.name + “ running”);</p>
<p>  },</p>
<p>  eating: function() {</p>
<p>​    console.log(this.name + “ eating”);</p>
<p>  },</p>
<p>  studying: function() {</p>
<p>​    console.log(this.name + “ studying”);</p>
<p>  }</p>
<p>}</p>
<p>所以我们会发现，在某些函数或者方法的编写中，this可以让我们更加便捷的方式来引用对象，在进行一些API设计时，代码更加的简洁和易于复用。</p>
<p>当然，上面只是应用this的一个场景而已，开发中使用到this的场景到处都是，这也是为什么它不容易理解的原因。</p>
<p>1.2. this指向什么</p>
<p>我们先说一个最简单的，this在全局作用域下指向什么？</p>
<ul>
<li>这个问题非常容易回答，在浏览器中测试就是指向window</li>
<li>所以，在全局作用域下，我们可以认为this就是指向的window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;why&quot;;</span><br><span class="line"></span><br><span class="line">console.log(this.name); &#x2F;&#x2F; why</span><br><span class="line"></span><br><span class="line">console.log(window.name); &#x2F;&#x2F; why</span><br></pre></td></tr></table></figure>



<p>但是，开发中很少直接在全局作用域下去使用this，通常都是在函数中使用。</p>
<p>所有的函数在被调用时，都会创建一个执行上下文：</p>
<ul>
<li>这个上下文中记录着函数的调用栈、函数的调用方式、传入的参数信息等；</li>
<li>this也是其中的一个属性；</li>
</ul>
<p>我们先来看一个让人困惑的问题：</p>
<ul>
<li>定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个函数</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1.调用方式一: 直接调用</span><br><span class="line">foo(); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.调用方式二: 将foo放到一个对象中,再调用</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() &#x2F;&#x2F; obj对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.调用方式三: 通过call&#x2F;apply调用</span><br><span class="line">foo.call(&quot;abc&quot;); &#x2F;&#x2F; String &#123;&quot;abc&quot;&#125;对象</span><br></pre></td></tr></table></figure>

<p>上面的案例可以给我们什么样的启示呢？</p>
<ul>
<li>1.函数在调用时，JavaScript会默认给this绑定一个值；</li>
<li>2.this的绑定和定义的位置（编写的位置）没有关系；</li>
<li>3.this的绑定和调用方式以及调用的位置有关系；</li>
<li>4.this是在运行时被绑定的；</li>
</ul>
<p>那么this到底是怎么样的绑定规则呢？一起来学习一下吧</p>
<p>二. this绑定规则</p>
<p>我们现在已经知道this无非就是在函数调用时被绑定的一个对象，我们就需要知道它在不同的场景下的绑定规则即可。</p>
<p>2.1. 默认绑定</p>
<p>什么情况下使用默认绑定呢？独立函数调用。</p>
<ul>
<li>独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用；</li>
</ul>
<p>案例一：普通函数调用</p>
<ul>
<li>该函数直接被调用，并没有进行任何的对象关联；</li>
<li>这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的this指向全局对象（window）；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>



<p>案例二：函数调用链（一个函数又调用另外一个函数）</p>
<ul>
<li>所有的函数调用都没有被绑定到某个对象上；</li>
</ul>
<p>// 2.案例二:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test1() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">  test2();</span><br><span class="line">&#125;</span><br><span class="line">function test2() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">  test3()</span><br><span class="line">&#125;</span><br><span class="line">function test3() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br></pre></td></tr></table></figure>



<p>案例三：将函数作为参数，传入到另一个函数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(func) &#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br><span class="line">foo(bar);</span><br></pre></td></tr></table></figure>



<p>我们对案例进行一些修改，考虑一下打印结果是否会发生变化：</p>
<ul>
<li>这里的结果依然是window，为什么呢？</li>
<li>原因非常简单，在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(func) &#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  bar: function() &#123;</span><br><span class="line">    console.log(this); &#x2F;&#x2F; window</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(obj.bar);</span><br></pre></td></tr></table></figure>



<p>2.2. 隐式绑定</p>
<p>另外一种比较常见的调用方式是通过某个对象进行调用的：</p>
<ul>
<li>也就是它的调用位置中，是通过某个对象发起的函数调用。</li>
</ul>
<p>案例一：通过对象调用函数</p>
<ul>
<li>foo的调用位置是obj.foo()方式进行调用的</li>
<li>那么foo调用时this会隐式的被绑定到obj对象上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; obj对象</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>



<p>案例二：案例一的变化</p>
<ul>
<li>我们通过obj2又引用了obj1对象，再通过obj1对象调用foo函数；</li>
<li>那么foo调用的位置上其实还是obj1被绑定了this；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; obj对象</span><br><span class="line">&#125;</span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj2&quot;,</span><br><span class="line">  obj1: obj1</span><br><span class="line">&#125;</span><br><span class="line">obj2.obj1.foo();</span><br></pre></td></tr></table></figure>



<p>案例三：隐式丢失</p>
<ul>
<li>结果最终是window，为什么是window呢？</li>
<li>因为foo最终被调用的位置是bar，而bar在进行调用时没有绑定任何的对象，也就没有形成隐式绑定；</li>
<li>相当于是一种默认绑定；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 讲obj1的foo赋值给bar</span><br><span class="line">var bar &#x3D; obj1.foo;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>



<p>2.3. 显示绑定</p>
<p>隐式绑定有一个前提条件：</p>
<ul>
<li>必须在调用的对象内部有一个对函数的引用（比如一个属性）；</li>
<li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误；</li>
<li>正是通过这个引用，间接的将this绑定到了这个对象上；</li>
</ul>
<p>如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？</p>
<ul>
<li>JavaScript所有的函数都可以使用call和apply方法（这个和Prototype有关）。</li>
</ul>
<ul>
<li><ul>
<li>它们两个的区别这里不再展开；</li>
<li>其实非常简单，第一个参数是相同的，后面的参数，apply为数组，call为参数列表；</li>
</ul>
</li>
</ul>
<ul>
<li>这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给this准备的。</li>
<li>在调用这个函数时，会将this绑定到这个传入的对象上。</li>
</ul>
<p>因为上面的过程，我们明确的绑定了this指向的对象，所以称之为 显示绑定。</p>
<p>2.3.1. call、apply</p>
<p>通过call或者apply绑定this对象</p>
<ul>
<li>显示绑定后，this就会明确的指向绑定的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(window); &#x2F;&#x2F; window</span><br><span class="line">foo.call(&#123;name: &quot;why&quot;&#125;); &#x2F;&#x2F; &#123;name: &quot;why&quot;&#125;</span><br><span class="line">foo.call(123); &#x2F;&#x2F; Number对象,存放时123</span><br></pre></td></tr></table></figure>



<p>2.3.2. bind函数</p>
<p>如果我们希望一个函数总是显示的绑定到一个对象上，可以怎么做呢？</p>
<p>方案一：自己手写一个辅助函数（了解）</p>
<ul>
<li>我们手动写了一个bind的辅助函数</li>
<li>这个辅助函数的目的是在执行foo时，总是让它的this绑定到obj对象上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;</span><br><span class="line">&#125;</span><br><span class="line">function bind(func, obj) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    return func.apply(obj, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var bar &#x3D; bind(foo, obj);</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br></pre></td></tr></table></figure>



<p>方案二：使用Function.prototype.bind</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;</span><br><span class="line">&#125;</span><br><span class="line">var bar &#x3D; foo.bind(obj);</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br></pre></td></tr></table></figure>



<p>2.3.3. 内置函数</p>
<p>有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数。</p>
<ul>
<li>这些内置函数会要求我们传入另外一个函数；</li>
<li>我们自己并不会显示的调用这些函数，而且JavaScript内部或者第三方库内部会帮助我们执行；</li>
<li>这些函数中的this又是如何绑定的呢？</li>
</ul>
<p>案例一：setTimeout</p>
<ul>
<li>setTimeout中会传入一个函数，这个函数中的this通常是window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>



<p>为什么这里是window呢？</p>
<ul>
<li>这个和setTimeout源码的内部调用有关；</li>
<li>setTimeout内部是通过apply进行绑定的this对象，并且绑定的是全局对象；</li>
</ul>
<p>案例二：数组的forEach</p>
<p>数组有一个高阶函数forEach，用于函数的遍历：</p>
<ul>
<li>在forEach中传入的函数打印的也是Window对象；</li>
<li>这是因为默认情况下传入的函数是自动调用函数（默认绑定）；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var names &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line">names.forEach(function(item) &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; 三次window</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>我们是否可以改变该函数的this指向呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forEach参数</span><br><span class="line">var names &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line">var obj &#x3D; &#123;name: &quot;why&quot;&#125;;</span><br><span class="line">names.forEach(function(item) &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; 三次obj对象</span><br><span class="line">&#125;, obj);</span><br></pre></td></tr></table></figure>



<p>案例三：div的点击</p>
<p>如果我们有一个div元素：</p>
<ul>
<li><p>注意：省略了部分代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>获取元素节点，并且监听点击：</p>
<ul>
<li>在点击事件的回调中，this指向谁呢？box对象；</li>
<li>这是因为在发生点击时，执行传入的回调函数被调用时，会将box对象绑定到该函数中；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var box &#x3D; document.querySelector(&quot;.box&quot;);</span><br><span class="line">box.onclick &#x3D; function() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; box对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以传入到内置函数的回调函数this如何确定呢？</p>
<ul>
<li>某些内置的函数，我们很难确定它内部是如何调用传入的回调函数；</li>
<li>一方面可以通过分析源码来确定，另一方面我们可以通过经验（见多识广）来确定；</li>
<li>但是无论如何，通常都是我们之前讲过的规则来确定的；</li>
</ul>
<p>2.4. new绑定</p>
<p>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。</p>
<p>使用new关键字来调用函数时，会执行如下的操作：</p>
<ul>
<li>1.创建一个全新的对象；</li>
<li>2.这个新对象会被执行Prototype连接；</li>
<li>3.这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；</li>
<li>4.如果函数没有返回其他对象，表达式会返回这个新对象；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建Person</span><br><span class="line"></span><br><span class="line">function Person(name) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this); &#x2F;&#x2F; Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">  this.name &#x3D; name; &#x2F;&#x2F; Person &#123;name: &quot;why&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new Person(&quot;why&quot;);</span><br><span class="line"></span><br><span class="line">console.log(p);</span><br></pre></td></tr></table></figure>



<p>2.5. 规则优先级</p>
<p>学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？</p>
<p>1.默认规则的优先级最低</p>
<p>毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this</p>
<p>2.显示绑定优先级高于隐式绑定</p>
<p>显示绑定和隐式绑定哪一个优先级更高呢？这个我们可以测试一下：</p>
<ul>
<li>结果是obj2，说明是显示绑定生效了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line"></span><br><span class="line">  foo: foo</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj2&quot;,</span><br><span class="line"></span><br><span class="line">  foo: foo</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定</span><br><span class="line"></span><br><span class="line">obj1.foo(); &#x2F;&#x2F; obj1</span><br><span class="line"></span><br><span class="line">obj2.foo(); &#x2F;&#x2F; obj2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定和显示绑定同时存在</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2); &#x2F;&#x2F; obj2, 说明隐式绑定优先级更高</span><br></pre></td></tr></table></figure>



<p>3.new绑定优先级高于隐式绑定</p>
<ul>
<li>结果是foo，说明是new绑定生效了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line"></span><br><span class="line">  foo: foo</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new obj.foo(); &#x2F;&#x2F; foo对象, 说明new绑定优先级更高</span><br></pre></td></tr></table></figure>



<p>4.new绑定优先级高于bind</p>
<p>new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new foo.call(obj);</span><br></pre></td></tr></table></figure>



<p>new和call同时使用</p>
<p>但是new绑定是否可以和bind后的函数同时使用呢？可以</p>
<ul>
<li>结果显示为foo，那么说明是new绑定生效了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; var foo &#x3D; new foo.call(obj);</span><br><span class="line"></span><br><span class="line">var bar &#x3D; foo.bind(obj);</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new bar(); &#x2F;&#x2F; 打印foo, 说明使用的是new绑定</span><br></pre></td></tr></table></figure>



<p>优先级总结：</p>
<ul>
<li>new绑定 &gt; 显示绑定（bind）&gt; 隐式绑定 &gt; 默认绑定</li>
</ul>
<p>三. this规则之外</p>
<p>我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外。（神话故事和动漫中总是有类似这样的人物）</p>
<p>3.1. 忽略显示绑定</p>
<p>如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;why&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj); &#x2F;&#x2F; obj对象</span><br><span class="line"></span><br><span class="line">foo.call(null); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">foo.call(undefined); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">var bar &#x3D; foo.bind(null);</span><br><span class="line"></span><br><span class="line">bar(); &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure>



<p>3.2. 间接函数引用</p>
<p>另外一种情况，创建一个函数的 间接引用，这种情况使用默认绑定规则。</p>
<p>我们先来看下面的案例结果是什么？</p>
<ul>
<li>(num2 = num1)的结果是num1的值；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num1 &#x3D; 100;</span><br><span class="line"></span><br><span class="line">var num2 &#x3D; 0;</span><br><span class="line"></span><br><span class="line">var result &#x3D; (num2 &#x3D; num1);</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; 100</span><br></pre></td></tr></table></figure>



<p>我们来下面的函数赋值结果：</p>
<ul>
<li>赋值(obj2.foo = obj1.foo)的结果是foo函数；</li>
<li>foo函数被直接调用，那么是默认绑定；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line"></span><br><span class="line">  foo: foo</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj2&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo(); &#x2F;&#x2F; obj1对象</span><br><span class="line"></span><br><span class="line">(obj2.foo &#x3D; obj1.foo)();  &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure>



<p>3.3. ES6箭头函数</p>
<p>在ES6中新增一个非常好用的函数类型：箭头函数</p>
<ul>
<li>这里不再具体介绍箭头函数的用法，可以自行学习。</li>
</ul>
<p>箭头函数不使用this的四种标准规则（也就是不绑定this），而是根据外层作用域来决定this。</p>
<p>我们来看一个模拟网络请求的案例：</p>
<ul>
<li>这里我使用setTimeout来模拟网络请求，请求到数据后如何可以存放到data中呢？</li>
<li>我们需要拿到obj对象，设置data；</li>
<li>但是直接拿到的this是window，我们需要在外层定义：var _this = this</li>
<li>在setTimeout的回调函数中使用_this就代表了obj对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  data: [],</span><br><span class="line"></span><br><span class="line">  getData: function() &#123;</span><br><span class="line"></span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 模拟获取到的数据</span><br><span class="line"></span><br><span class="line">      var res &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line"></span><br><span class="line">      _this.data.push(...res);</span><br><span class="line"></span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure>



<p>上面的代码在ES6之前是我们最常用的方式，从ES6开始，我们会使用箭头函数：</p>
<ul>
<li>为什么在setTimeout的回调函数中可以直接使用this呢？</li>
<li>因为箭头函数并不绑定this对象，那么this引用就会从上层作用域中找到对应的this</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  data: [],</span><br><span class="line"></span><br><span class="line">  getData: function() &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 模拟获取到的数据</span><br><span class="line"></span><br><span class="line">      var res &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line"></span><br><span class="line">      this.data.push(...res);</span><br><span class="line"></span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure>



<p>思考：如果getData也是一个箭头函数，那么setTimeout中的回调函数中的this指向谁呢？</p>
<ul>
<li>答案是window；</li>
<li>依然是不断的从上层作用域找，那么找到了全局作用域；</li>
<li>在全局作用域内，this代表的就是window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  data: [],</span><br><span class="line"></span><br><span class="line">  getData: () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure>



<p>四. this面试题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.1. 面试题一：</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;person&quot;,</span><br><span class="line"></span><br><span class="line">  sayName: function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(this.name);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function sayName() &#123;</span><br><span class="line"></span><br><span class="line">  var sss &#x3D; person.sayName;</span><br><span class="line"></span><br><span class="line">  sss(); </span><br><span class="line"></span><br><span class="line">  person.sayName(); </span><br><span class="line"></span><br><span class="line">  (person.sayName)(); </span><br><span class="line"></span><br><span class="line">  (b &#x3D; person.sayName)(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayName();</span><br><span class="line"></span><br><span class="line">这道面试题非常简单，无非就是绕一下，希望把面试者绕晕：</span><br><span class="line"></span><br><span class="line">function sayName() &#123;</span><br><span class="line"></span><br><span class="line">  var sss &#x3D; person.sayName;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 独立函数调用，没有和任何对象关联</span><br><span class="line"></span><br><span class="line">  sss(); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 关联</span><br><span class="line"></span><br><span class="line">  person.sayName(); &#x2F;&#x2F; person</span><br><span class="line"></span><br><span class="line">  (person.sayName)(); &#x2F;&#x2F; person</span><br><span class="line"></span><br><span class="line">  (b &#x3D; person.sayName)(); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.2. 面试题二：</span><br><span class="line"></span><br><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &#39;person1&#39;,</span><br><span class="line"></span><br><span class="line">  foo1: function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(this.name)</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  foo2: () &#x3D;&gt; console.log(this.name),</span><br><span class="line"></span><br><span class="line">  foo3: function () &#123;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this.name)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  foo4: function () &#123;</span><br><span class="line"></span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this.name)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person2 &#x3D; &#123; name: &#39;person2&#39; &#125;</span><br><span class="line"></span><br><span class="line">person1.foo1(); </span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2); </span><br><span class="line"></span><br><span class="line">person1.foo2();</span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2);</span><br><span class="line"></span><br><span class="line">person1.foo3()();</span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)();</span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2);</span><br><span class="line"></span><br><span class="line">person1.foo4()();</span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)();</span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2);</span><br><span class="line"></span><br><span class="line">下面是代码解析：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定，肯定是person1</span><br><span class="line"></span><br><span class="line">person1.foo1(); &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定和显示绑定的结合，显示绑定生效，所以是person2</span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2); &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()是一个箭头函数，不适用所有的规则</span><br><span class="line"></span><br><span class="line">person1.foo2() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2依然是箭头函数，不适用于显示绑定的规则</span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2) &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到foo3，但是调用位置是全局作用于下，所以是默认绑定window</span><br><span class="line"></span><br><span class="line">person1.foo3()() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo3显示绑定到person2中</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 但是拿到的返回函数依然是在全局下调用，所以依然是window</span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo3返回的函数，通过显示绑定到person2中，所以是person2</span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4()的函数返回的是一个箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数的执行找上层作用域，是person1</span><br><span class="line"></span><br><span class="line">person1.foo4()() &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4()显示绑定到person2中，并且返回一个箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数找上层作用域，是person2</span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4返回的是箭头函数，箭头函数只看上层作用域</span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2) &#x2F;&#x2F; person1</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.3. 面试题三:</span><br><span class="line"></span><br><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line"></span><br><span class="line">function Person (name) &#123;</span><br><span class="line"></span><br><span class="line">  this.name &#x3D; name</span><br><span class="line"></span><br><span class="line">  this.foo1 &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(this.name)</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  this.foo2 &#x3D; () &#x3D;&gt; console.log(this.name),</span><br><span class="line"></span><br><span class="line">  this.foo3 &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this.name)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  this.foo4 &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this.name)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; new Person(&#39;person1&#39;)</span><br><span class="line"></span><br><span class="line">var person2 &#x3D; new Person(&#39;person2&#39;)</span><br><span class="line"></span><br><span class="line">person1.foo1()</span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo2()</span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo3()()</span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo4()()</span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2)</span><br><span class="line"></span><br><span class="line">下面是代码解析：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定</span><br><span class="line"></span><br><span class="line">person1.foo1() &#x2F;&#x2F; peron1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示绑定优先级大于隐式绑定</span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo是一个箭头函数，会找上层作用域中的this，那么就是person1</span><br><span class="line"></span><br><span class="line">person1.foo2() &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo是一个箭头函数，使用call调用不会影响this的绑定，和上面一样向上层查找</span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2) &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用位置是全局直接调用，所以依然是window（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.foo3()() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终还是拿到了foo3返回的函数，在全局直接调用（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo3返回的函数后，通过call绑定到person2中进行了调用</span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4返回了箭头函数，和自身绑定没有关系，上层找到person1</span><br><span class="line"></span><br><span class="line">person1.foo4()() &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4调用时绑定了person2，返回的函数是箭头函数，调用时，找到了上层绑定的person2</span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4调用返回的箭头函数，和call调用没有关系，找到上层的person1</span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2) &#x2F;&#x2F; person1</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.4. 面试题四：</span><br><span class="line"></span><br><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line"></span><br><span class="line">function Person (name) &#123;</span><br><span class="line"></span><br><span class="line">  this.name &#x3D; name</span><br><span class="line"></span><br><span class="line">  this.obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">    name: &#39;obj&#39;,</span><br><span class="line"></span><br><span class="line">    foo1: function () &#123;</span><br><span class="line"></span><br><span class="line">      return function () &#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    foo2: function () &#123;</span><br><span class="line"></span><br><span class="line">      return () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; new Person(&#39;person1&#39;)</span><br><span class="line"></span><br><span class="line">var person2 &#x3D; new Person(&#39;person2&#39;)</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()()</span><br><span class="line"></span><br><span class="line">person1.obj.foo1.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.obj.foo1().call(person2)</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()()</span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.obj.foo2().call(person2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面是代码解析：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj.foo1()返回一个函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终还是拿到一个返回的函数（虽然多了一步call的绑定）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.obj.foo1.call(person2)() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">person1.obj.foo1().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo2()的返回值，是一个箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，就是obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()() &#x2F;&#x2F; obj</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数，但是在执行foo2时绑定了person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，找到的是person2</span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数通过call调用是不会绑定this，所以找上层作用域下的this是obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo2().call(person2) &#x2F;&#x2F; obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()()</span><br><span class="line"></span><br><span class="line">person1.obj.foo1.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.obj.foo1().call(person2)</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()()</span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.obj.foo2().call(person2)</span><br><span class="line"></span><br><span class="line">下面是代码解析：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj.foo1()返回一个函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终还是拿到一个返回的函数（虽然多了一步call的绑定）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.obj.foo1.call(person2)() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">person1.obj.foo1().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo2()的返回值，是一个箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，就是obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()() &#x2F;&#x2F; obj</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数，但是在执行foo2时绑定了person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，找到的是person2</span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数通过call调用是不会绑定this，所以找上层作用域下的this是obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo2().call(person2) &#x2F;&#x2F; obj</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>packageJson</title>
    <url>/2020/07/30/packageJson/</url>
    <content><![CDATA[<h3 id="packageJson"><a href="#packageJson" class="headerlink" title="packageJson"></a>packageJson</h3><p>随着前端由多页面到单页面，由零散的文件到模块化开发，在一个完整的项目中，package.json 文件无处不在。首先，在项目根目录会有，其次在 node_modules 中也频现。那么这个文件到底是干嘛的，又有什么作用，今天给大家揭晓。</p>
<h3 id="一、package-json-文件作用"><a href="#一、package-json-文件作用" class="headerlink" title="一、package.json 文件作用"></a>一、package.json 文件作用</h3><p>package.json 文件其实就是对项目或者模块包的描述，里面包含许多元信息。比如项目名称，项目版本，项目执行入口文件，项目贡献者等等。npm install 命令会根据这个文件下载所有依赖模块。</p>
<a id="more"></a>

<h3 id="二、package-json-文件创建"><a href="#二、package-json-文件创建" class="headerlink" title="二、package.json 文件创建"></a>二、package.json 文件创建</h3><p>package.json 文件创建有两种方式，手动创建或者自动创建。</p>
<p>手动创建</p>
<p>直接在项目根目录新建一个 package.json 文件，然后输入相关的内容。</p>
<p>自动创建</p>
<p>也是在项目根目录下执行 npm init，然后根据提示一步步输入相应的内容完成后即可自动创建。</p>
<h3 id="三、package-json-文件示例"><a href="#三、package-json-文件示例" class="headerlink" title="三、package.json 文件示例"></a>三、package.json 文件示例</h3><p><img src="/2020/07/30/packageJson/clipboard.png" alt="clipboard"></p>
<h3 id="四、package-json-文件配置说明"><a href="#四、package-json-文件配置说明" class="headerlink" title="四、package.json 文件配置说明"></a>四、package.json 文件配置说明</h3><ul>
<li>name：项目/模块名称，长度必须小于等于214个字符，不能以”.”(点)或者”_”(下划线)开头，不能包含大写字母。</li>
<li>version：项目版本。</li>
<li>author：项目开发者，它的值是你在<a href="https://npmjs.org网站的有效账户名，遵循“账户名" target="_blank" rel="noopener">https://npmjs.org网站的有效账户名，遵循“账户名</a>&lt;邮件&gt;”的规则，例如：zhangsan <a href="mailto:zhangsan@163.com">zhangsan@163.com</a>。</li>
<li>description：项目描述，是一个字符串。它可以帮助人们在使用npm search时找到这个包。</li>
<li>keywords：项目关键字，是一个字符串数组。它可以帮助人们在使用npm search时找到这个包。</li>
<li>private：是否私有，设置为 true 时，npm 拒绝发布。</li>
<li>license：软件授权条款，让用户知道他们的使用权利和限制。</li>
<li>bugs：bug 提交地址。</li>
<li>contributors：项目贡献者 。</li>
<li>repository：项目仓库地址。</li>
<li>homepage：项目包的官网 URL。</li>
<li>dependencies：生产环境下，项目运行所需依赖。</li>
<li>devDependencies：开发环境下，项目所需依赖。</li>
<li>scripts：执行 npm 脚本命令简写，比如 “start”: “react-scripts start”, 执行 npm start 就是运行 “react-scripts start”。</li>
<li>bin：内部命令对应的可执行文件的路径。</li>
<li>main：项目默认执行文件，比如 require(‘webpack’)；就会默认加载 lib 目录下的 webpack.js 文件，如果没有设置，则默认加载项目跟目录下的 index.js 文件。</li>
<li>module：是以 ES Module(也就是 ES6)模块化方式进行加载，因为早期没有 ES6 模块化方案时，都是遵循 CommonJS 规范，而 CommonJS 规范的包是以 main 的方式表示入口文件的，为了区分就新增了 module 方式，但是 ES6 模块化方案效率更高，所以会优先查看是否有 module 字段，没有才使用 main 字段。</li>
<li>eslintConfig：EsLint 检查文件配置，自动读取验证。</li>
<li>engines：项目运行的平台。</li>
<li>browserslist：供浏览器使用的版本列表。</li>
<li>style：供浏览器使用时，样式文件所在的位置；样式文件打包工具parcelify，通过它知道样式文件的打包位置。</li>
<li>files：被项目包含的文件名数组。</li>
</ul>
<p>补充（<a href="http://www.w3cbus.com/nodejs/packagejson.html#toc11" target="_blank" rel="noopener">http://www.w3cbus.com/nodejs/packagejson.html#toc11</a>）</p>
<ul>
<li><p>man字段</p>
<p>man用来指定当前模块的man文档的位置。</p>
<p>“man” :[ “./doc/calc.1” ]</p>
</li>
<li><p>preferGlobal字段</p>
</li>
<li><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>
</li>
<li><p>browser字段</p>
<p>browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。</p>
<p>“browser”: {  “tipso”: “./node_modules/tipso/src/tipso.js”},</p>
</li>
<li><p>config字段</p>
<p>config字段用于向环境变量输出值。</p>
</li>
</ul>
<p>下面是一个package.json文件。</p>
<p>{  “name” : “foo”,  “config” : { “port” : “8080” },  “scripts” : { “start” : “node server.js” }}</p>
<p>然后，在server.js脚本就可以引用config字段的值。</p>
<p>http.createServer(…).listen(process.env.npm_package_config_port)</p>
<p>用户可以改变这个值。</p>
<p>$ npm config set foo:port 80</p>
<p>peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。</p>
<p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。</p>
<p>大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>
<p>最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。</p>
<p>{  “name”: “chai-as-promised”,  “peerDependencies”: {    “chai”: “1.x”  }}</p>
<p>上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。</p>
<p>注意，从npm 3.0版开始，peerDependencies不再会默认安装了。</p>
<p>![clipboard (1)](packageJson.assets/clipboard (1).png)</p>
]]></content>
      <categories>
        <category>packageJson</category>
      </categories>
      <tags>
        <tag>packageJson</tag>
      </tags>
  </entry>
  <entry>
    <title>vantweapp</title>
    <url>/2020/07/22/vantweapp/</url>
    <content><![CDATA[<h3 id="小程序插件–vantWeapp"><a href="#小程序插件–vantWeapp" class="headerlink" title="小程序插件–vantWeapp"></a>小程序插件–vantWeapp</h3><blockquote>
<ol>
<li>新建个项目</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>找到项目文件夹 npm init 初始化一个叫package.json的文件一路回车即可</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>继续执行命令安装 Vant Weapp<br><code>npm i @vant/weapp -S --production</code> </li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>点击 开发者菜单里面的工具 &gt;构建npm 如下图</li>
</ol>
</blockquote>
<a id="more"></a>

<p><img src="http://upload-images.jianshu.io/upload_images/7211385-9510055e041611cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/939/format/webp" alt="img"></p>
<blockquote>
<ol start="5">
<li>还是开发者工具里面的详情 使用npm模块勾选上</li>
</ol>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/7211385-d50190f6a674c31d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/684/format/webp" alt="img"></p>
<blockquote>
<ol start="6">
<li>在引用的页面json或者app.json里添加引入的组件名字</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;usingComponents&quot;: &#123;</span><br><span class="line">  &quot;van-button&quot;: &quot;@vant&#x2F;weapp&#x2F;button&#x2F;index&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="http://upload-images.jianshu.io/upload_images/7211385-6163f82f17c59fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/984/format/webp" alt="img"></p>
<blockquote>
<ol start="7">
<li>最后就是在你的页面用使用了 如下图：</li>
</ol>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/7211385-d2fbd97f8301d40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><a href="https://www.jianshu.com/p/a63f21206b91" target="_blank" rel="noopener">参考链接</a></p>
<p><a href="https://youzan.github.io/vant-weapp/#/intro" target="_blank" rel="noopener">官网地址</a></p>
]]></content>
      <categories>
        <category>plugins</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>vs和vsCode的plugins</title>
    <url>/2020/07/17/vs%E5%92%8CvsCode%E7%9A%84plugins/</url>
    <content><![CDATA[<h3 id="vs和vsCode插件"><a href="#vs和vsCode插件" class="headerlink" title="vs和vsCode插件"></a>vs和vsCode插件</h3><a id="more"></a>

<ol>
<li><p>vs</p>
<blockquote>
<ul>
<li>web compiler  将less和js编译成css和es5</li>
<li>force UTF-8 （No Bom）  将文档编译成utf-8的文档格式输出(也可以用记事本打开另存为,解决页面打开出现&amp;#65279，显示多余空白)</li>
<li>force UTF-8 （With Bom）</li>
</ul>
</blockquote>
</li>
</ol>
<ol start="2">
<li><blockquote>
<ul>
<li>Auto Close Tag  自动闭合标签</li>
<li>Auto Rename Tag 自动重命名标签</li>
<li>Auto-Save on Window Change 关闭窗口自动保存</li>
<li>Chinese (Simplified) Language Pack for Visual Studio Code 中文包</li>
<li>CSS Tree 选中标签生成css文件树（Ctrl + shift + p选择 Generate CSS tree）</li>
<li>Easy LESS 可直接生成小程序wxss</li>
<li>filesize 查看文件大小</li>
<li>Path Intellisense 自动提示文件路径</li>
<li>Git Histroy/Local Histroy 文件历史记录</li>
<li>Material Icon Theme 文件图标</li>
<li>vscode-icons 图标插件</li>
<li>Bracket Pair Colorizer 括号颜色高亮</li>
<li>open in browser 在浏览器中打开</li>
<li>vscode-fileheader 文件头部信息</li>
<li>Vue 2 Snippets vue代码片段提示</li>
<li>vetur  vue语法高亮/格式化/代码片段/语法检查等</li>
<li>minapp 微信小程序标签、属性的智能补全（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）</li>
<li>Stylus Language  基于Node.js的CSS的预处理框架</li>
<li>live-server 实时简易服务器</li>
<li>Live Share 实时共享（vs 和vscode）</li>
<li>Live Share Audio 实时共享音频</li>
</ul>
</blockquote>
</li>
</ol>
<p><a href="https://marketplace.visualstudio.com/search?term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%8A%A9%E6%89%8B&target=VSCode&category=Programming%20Languages&sortBy=Relevance">插件官网地址</a></p>
<p><a href="https://mp.weixin.qq.com/s/LAe29D9nZvCcvs_Kr_PWZQ" target="_blank" rel="noopener">更多插件</a></p>
]]></content>
      <categories>
        <category>vs和vsCode</category>
      </categories>
      <tags>
        <tag>vs</tag>
        <tag>plugins</tag>
        <tag>vsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>verdaccio私服搭建</title>
    <url>/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="1-安装verdaccio"><a href="#1-安装verdaccio" class="headerlink" title="1 安装verdaccio"></a>1 安装verdaccio</h3><p><code>$ npm install --global verdaccio</code></p>
<h4 id="1-1-verdaccio目录结构"><a href="#1-1-verdaccio目录结构" class="headerlink" title="1.1 verdaccio目录结构"></a>1.1 verdaccio目录结构</h4><p>安装后的文件在：C:\Users(用户名)\AppData\Roaming\verdaccio下</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/01.png" alt="01"></p>
<a id="more"></a>

<h4 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h4><hr>
<p>1、配置npm仓库的位置，找一个位置新建一个目录，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/02.png" alt="01"></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/02.png" alt="01"></p>
<p>2、找到配置文件的storage选项，然后把仓库的位置填写进去，注意是用斜线，而不是反斜线，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/03.png" alt="01"></p>
<h3 id="2-本地localhost启动"><a href="#2-本地localhost启动" class="headerlink" title="2 本地localhost启动"></a>2 本地localhost启动</h3><p><code>$ verdaccio</code></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/04.png" alt="01"><br>直接打开 <a href="http://localhost:4873/" target="_blank" rel="noopener">http://localhost:4873/</a></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/05.png" alt="01"></p>
<h3 id="3-创建用户"><a href="#3-创建用户" class="headerlink" title="3 创建用户"></a>3 创建用户</h3><p><code>$ npm adduser --registry http://localhost:4873</code><br>然后我们在<a href="http://localhost:4873/上面直接点Login就可以登陆了" target="_blank" rel="noopener">http://localhost:4873/上面直接点Login就可以登陆了</a></p>
<p><strong>这里，如果我们已经装了nrm ，可以简便上面这句操作：我们直接利用nrm把镜像源切换到我们的<a href="http://localhost:4873/上面，然后$" target="_blank" rel="noopener">http://localhost:4873/上面，然后$</a> npm adduser就可以了</strong></p>
<h5 id="nrm操作方法"><a href="#nrm操作方法" class="headerlink" title="nrm操作方法"></a>nrm操作方法</h5><ul>
<li><p><code>$ npm install -g nrm</code><br>全局安装nrm</p>
</li>
<li><p><code>$ nrm ls</code><br>用来查看npm源</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/06.png" alt="01"></p>
<p>名称前有* 的是当前用npm下载包的时候的地址，比如截图里面，当我<code>npm install</code>以后，就会从<a href="http://localhost:4873/上面下载包，而不是从npm网站上面下载" target="_blank" rel="noopener">http://localhost:4873/上面下载包，而不是从npm网站上面下载</a></p>
</li>
<li><p><code>$ nrm use 源名称</code><br>设置当前npm源</p>
</li>
<li><p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/07.png" alt="01"><br>这里我就把npm源换成了npmjs，当然咱们安装node以后，npm默认就是从这里下载。</p>
</li>
<li><p><code>$ nrm add 名称 地址</code><br>创建新的源</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/08.png" alt="01"></p>
</li>
<li><p><code>$ nrm del 名称</code><br>删除源</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/09.png" alt="01"></p>
</li>
</ul>
<ul>
<li><p>这些记不住都没关系，直接<code>$ nrm</code>全都可以查看</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/10.png" alt="01"></p>
</li>
</ul>
<h3 id="4-发布包"><a href="#4-发布包" class="headerlink" title="4 发布包"></a>4 发布包</h3><p><code>$ npm publish --registry http://localhost:4873</code><br>这里我随便新建一个文件夹，通过npm init新建一个项目，然后在这个目录下，<code>npm publish --registry http://localhost:4873</code></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/11.png" alt="01"></p>
<p>此时，文件里面有了package.json</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/12.png" alt="01"></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/13.png" alt="01"></p>
<h3 id="5-在需要的项目中引入包"><a href="#5-在需要的项目中引入包" class="headerlink" title="5 在需要的项目中引入包"></a>5 在需要的项目中引入包</h3><ol>
<li>新建一个目录，npm init </li>
<li>npm install 包的名字（在package.json中加上包的名字和版本，npm i）</li>
</ol>
<h3 id="6-配置成任意ip，别的电脑可以访问私有包"><a href="#6-配置成任意ip，别的电脑可以访问私有包" class="headerlink" title="6 配置成任意ip，别的电脑可以访问私有包"></a>6 配置成任意ip，别的电脑可以访问私有包</h3><p>1、在配置文件的末尾添加listen: 0.0.0.0:4873，配置此选项则是允许任何外部的所有IP都可以访问到此服务，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/14.png" alt="01"></p>
<p>2、然后重新启动verdaccio，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/15.png" alt="01"></p>
<p>3、然后在另外一台电脑即可打开，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/16.png" alt="01"></p>
<p>4、由于电脑的Ip是自动获取的，当电脑重启IP有可能会改变，因此最好需要手动设置一个IP，然后使用nrm add localnpm <a href="http://192.168.1.250:4873添加到npm源中，如下图所示：">http://192.168.1.250:4873添加到npm源中，如下图所示：</a></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/17.png" alt="01"></p>
<p>5、然后通过nrm use localnpm来切换源，如下图所示，我们就切换到我们刚刚添加的源了：</p>
<h3 id="报错记录"><a href="#报错记录" class="headerlink" title="报错记录"></a>报错记录</h3><p>npm adduser报错Unable to authenticate和npm publish报错404</p>
<p>解决办法：就是用户名已经被注册了，换个用户名</p>
]]></content>
      <categories>
        <category>verdaccio</category>
      </categories>
      <tags>
        <tag>私有服务器</tag>
        <tag>verdaccio</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-lottie动画</title>
    <url>/2020/07/30/vue-lottie%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>安装vue-lottie包</p>
<p>npm install –save vue-lottie</p>
<a id="more"></a>

<p>引用vue-lottie</p>
<p>在main.js引入并全局注册组件</p>
<p>import lottie from ‘vue-lottie’;</p>
<p>Vue.component(‘lottie’, lottie)</p>
<p>引入Lottie动画资源</p>
<p>将我们在<a href="https://www.lottiefiles.com/popular" target="_blank" rel="noopener">Lottiefiles</a>下载下来的相应动画资源保存到项目中并映入</p>
<p>// 第一步：script中引入资源import * as animationData from “../assets/lottie/loading.json”;</p>
<p>// 第二步：使用组件</p>
<lottie :options="defaultOptions" :height="200" :width="200" v-on:animcreated="handleAnimation">

<p>// 第三步：data里面添加相应属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        defaultOptions: &#123;</span><br><span class="line">            animationData: animationData</span><br><span class="line">        &#125;,</span><br><span class="line">        animationSpeed: <span class="number">1</span>,</span><br><span class="line">        anim: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//第四步：定义方法</span></span><br><span class="line">methods: &#123;    </span><br><span class="line">	handleAnimation: <span class="function"><span class="keyword">function</span>(<span class="params">anim</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.anim = anim;        </span><br><span class="line">		<span class="built_in">console</span>.log(anim); <span class="comment">//这里可以看到 lottie 对象的全部属性    </span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</lottie>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>lottie</tag>
      </tags>
  </entry>
  <entry>
    <title>v-lazy</title>
    <url>/2020/07/27/v-lazy/</url>
    <content><![CDATA[<h3 id="vue图片懒加载插件–v-lazy"><a href="#vue图片懒加载插件–v-lazy" class="headerlink" title="vue图片懒加载插件–v-lazy"></a>vue图片懒加载插件–v-lazy</h3><ol>
<li><p>安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-lazyload --save-dev</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ol>
<ol>
<li><p>main.js引入插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueLazyLoad from &#39;vue-lazyload&#39;</span><br><span class="line">Vue.use(VueLazyLoad,&#123;</span><br><span class="line">    error:&#39;.&#x2F;static&#x2F;error.png&#39;,</span><br><span class="line">    loading:&#39;.&#x2F;static&#x2F;loading.png&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>vue文件中将需要懒加载的图片绑定 v-bind:src 修改为 v-lazy </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img class&#x3D;&quot;item-pic&quot; v-lazy&#x3D;&quot;newItem.picUrl&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>v-lazy</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>插件</tag>
        <tag>v-lazy</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-devtools</title>
    <url>/2020/07/30/vue-devtools/</url>
    <content><![CDATA[<h3 id="Vue-js-devtools"><a href="#Vue-js-devtools" class="headerlink" title="Vue.js devtools"></a>Vue.js devtools</h3><p>Vue.js devtools是基于google chrome浏览器的一款调试vue.js应用的开发者浏览器扩展，可以在浏览器开发者工具下调试代码。</p>
<a id="more"></a>

<p>1）首先在github下载devtools源码，地址：<a href="https://github.com/vuejs/vue-devtools%E3%80%82" target="_blank" rel="noopener">https://github.com/vuejs/vue-devtools。</a></p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919205434540-2015837660.png" alt="img"></p>
<p>2）下载好后进入vue-devtools-master工程 执行cnpm install, 下载依赖，然后执行npm run build，编译源程序。</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919191704853-826104445.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919191820884-273399978.png" alt="img"></p>
<p>3）编译完成后，目录结构如下：<br><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919191916743-1974845966.png" alt="img"></p>
<p>修改shells、chrome目录下的mainifest.json 中的persistant为true：</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919192429618-1364706689.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919192727806-166414555.png" alt="img"></p>
<p> 4）打开谷歌浏览器的设置—&gt;扩展程序，并勾选开发者模式</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919203319915-287514806.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919203457306-737425079.png" alt="img"></p>
<p>然后将刚刚编译后的工程中的shells目录下，chrome的整个文件夹直接拖拽到当前浏览器中，并选择启用，即可将插件安装到浏览器。</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919203631071-371299784.png" alt="img"></p>
<p>5）打开一个已有的vue项目，运行项目，然后在浏览器中—&gt;设置—&gt;更多工具—&gt;开发者工具，进入调试模式：</p>
<p>发现vue.js is not detected  ，可以调整一下webpack.config.js的代码，</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919204337603-2116004923.png" alt="img"></p>
<hr>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919205246228-260599521.png" alt="img"></p>
<p>最后，重启一下你的vue项目应该就可以使用了。</p>
<p> <img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919205319915-1870577461.png" alt="img"></p>
<p> 参考链接：<a href="https://www.cnblogs.com/tanyongli/p/7554045.html" target="_blank" rel="noopener">https://www.cnblogs.com/tanyongli/p/7554045.html</a></p>
]]></content>
      <categories>
        <category>devtools</category>
      </categories>
      <tags>
        <tag>devtools</tag>
      </tags>
  </entry>
  <entry>
    <title>totalcontrol</title>
    <url>/2020/09/04/totalcontrol/</url>
    <content><![CDATA[<h1 id="Total-Control，电脑与手机初次连接详细教程听语音"><a href="#Total-Control，电脑与手机初次连接详细教程听语音" class="headerlink" title="Total Control，电脑与手机初次连接详细教程听语音"></a>Total Control，电脑与手机初次连接详细教程听语音</h1><p>对于很多使用手机群控软件的用户而言，Total Control 绝对都不陌生。但是，不论谁都是从小白经历过来的，一开始也不知道 Total Control 怎么用。这篇教程会以酷派 5952 为例给大家详细解析手机初次连接时可能遇到的问题，并提供对应的解决方法，供大家参考使用。</p>
<p>注：此教程仅适用于手机与 Total Control 无法自动连接的情况。</p>
<h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul>
<li>电脑</li>
<li>安卓手机</li>
<li>Total Control手机群控软件</li>
</ul>
<a id="more"></a>

<h2 id="打开手机-USB-调试"><a href="#打开手机-USB-调试" class="headerlink" title="打开手机 USB 调试"></a>打开手机 USB 调试</h2><ol>
<li><p>1</p>
<p>下载 Total Control 手机群控软件。官方网址为：<a href="http://tc.sigma-rt.com.cn/" target="_blank" rel="noopener">http://tc.sigma-rt.com.cn/</a></p>
<p><img src="https://exp-picture.cdn.bcebos.com/cd93a56651598540371b2d51b5a23a42a17ac487.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>2</p>
<p>打开 Total Control 电脑控制手机软件，点击[新设备向导]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/a31e1214c27bd282b3b888f53cb1eef97ebd3684.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>3</p>
<p>点击[连接向导]，按照连接向导中的步骤指示进行操作；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/7efc527c34b33c410e8bfaf2887de137c8762e84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>4</p>
<p>首先，将手机的 USB 线与电脑断开连接；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/7c84d1672b5fd54642a791a77fd0b503c9d22484.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>5</p>
<p>断开 USB 连接之后，进行下一步的设置：打开手机端的 USB 调试选项。</p>
<p>（温馨提示：请不要将手机设置为省电模式，否则可能导致连接失败。）</p>
<p><img src="https://exp-picture.cdn.bcebos.com/b57fb6db574afa32c4ad054454b2dc19cf2c1484.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>6</p>
<p>点击[设置]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/f59dbe39131fceecb1e840c679c4ec9958430b84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>7</p>
<p>选择[关于手机]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/49bf00425d6b04d12518b33bb213e8e5edee0184.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>8</p>
<p>在[手机配置信息]中找到[版本号]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/3852f6e5eceeadbccc1e6ec3cd18dfdae53b7b84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>9</p>
<p>拉到屏幕最下方，找到 [版本号]，快速点击 5-7 下；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/4e168d5653bbf82019cabfb8ba21056105a36e84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>10</p>
<p>此时屏幕上会显示“您现在处于开发者模式！”；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/82eff6d7592ae3ef67493d8254b6326c56666484.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>11</p>
<p>返回到设置界面,点击进入[开发者选项]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/38332303bbea3e86a87948f05cd4483105eb5584.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>12</p>
<p>选择[ USB 调试]并打开；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/f7e6410f822b74eebd0362abda2c8cf1d9a74a84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>13</p>
<p>点击[确定]后，此时手机的 USB 调试已经设置完毕。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/49c5d3e34b2c56eed04eafbdf775e5f4fdf54084.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
<p>END</p>
</li>
</ol>
<h2 id="安装通用驱动"><a href="#安装通用驱动" class="headerlink" title="安装通用驱动"></a>安装通用驱动</h2><ol>
<li><p>1</p>
<p><strong>一部分用户在完成以上操作之后，就可以正常将手机与 Total Control 连接并使用。但如果仍然没有解决您的问题，请继续按照下面的指示进行操作，安装通用驱动</strong>。</p>
</li>
<li><p>2</p>
<p>点击[安装驱动]下的[查看如何安装]进入步骤一；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/ef4c24ceaad7726bb8d34c54bf0f64781523b984.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>3</p>
<p>步骤一：点击[设备管理器]，找到你需要卸载的设备，</p>
<p><img src="https://exp-picture.cdn.bcebos.com/bff8683e21c2bbd65ce1445b116186254093ae84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>4</p>
<p>点击鼠标右键，选择[卸载]，点击[确定]，开始卸载驱动；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/555acf0ff2260d9af93f3e2a622abab84340a584.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>5</p>
<p>步骤二：点击[安装通用驱动]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/430174fec314f1c545df68723c27ac5307889d84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>6</p>
<p>跟着安装向导安装通用驱动即可；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/07c98f2ca5cadce84879294ffcf7980e5e209584.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
<p>END</p>
</li>
</ol>
<h2 id="安装手机专属的-USB-驱动"><a href="#安装手机专属的-USB-驱动" class="headerlink" title="安装手机专属的 USB 驱动"></a>安装手机专属的 USB 驱动</h2><ol>
<li><p>1</p>
<p><strong>安装通用驱动以后，又会解决掉一部分用户的问题，但如果依旧不能顺利连接并使用 Total Control 手机群控软件，则需要安装对应手机型号的专属 USB 驱动。这里以酷派 5952 为例为大家演示。</strong></p>
</li>
<li><p>2</p>
<p>在浏览器中搜索“酷派 usb 驱动下载”；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/5e615d715fdb3620590be43aabc5260f89358d84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>3</p>
<p>下载对应手机驱动，并安装；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/c6b994775ddd884c107b06946cef28066a01f684.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
<p>END</p>
</li>
</ol>
<h2 id="检测驱动是否安装正常"><a href="#检测驱动是否安装正常" class="headerlink" title="检测驱动是否安装正常"></a>检测驱动是否安装正常</h2><ol>
<li><p><strong>驱动安装成功后，我们提供两种方式来检测驱动是否安装完成。</strong></p>
<p><strong>方式一：打开命令行窗口，执行 adb devices 命令检测；</strong></p>
<p><strong>方式二：通过找到 Total Control 手机群控软件所在的文件夹地址粘贴到命令行窗口执行 adb devices 命令来检测。</strong></p>
</li>
<li><p>方式一： 点击开始，选择[运行]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/9881b1fce186242fab40bdac35e434daf15ee884.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>输入“cmd” 打开命令行窗口，执行 adb devices 命令；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/ff5c88d818196120a9ff25dd70f202b374d7df84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>如果能正常显示下图中的串号，则证明驱动识别正常。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/7496877bbbf4da5864e8f7faea0f8b56ac04d784.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>方式二：打开 Total Control 所在的文件夹，复制 Total Control 所在文件夹地址；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/ac45306817e951e110ca71e55e3da824d9e9cf84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>将地址粘贴到命令行窗口中，执行 adb devices 命令，如果显示下图中的串号，则驱动安装正常；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/5917cb3da824d8e9efe092d5da598540112ac884.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>7</p>
<p><strong>以上步骤完成后，将手机与电脑连接，连接成功后，电脑端就会显示手机已经和 Total Control 电脑控制手机软件成功匹配，此时手机已经成功连接到了 Total Control 上，可以正式使用手机群控的软件了！以上就是我为大家整理的详细的 Total Control 电脑与手机初次连接教程，你学会了吗？</strong></p>
</li>
</ol>
<p>   <img src="https://exp-picture.cdn.bcebos.com/84010e2a04e23ea2107089c92b10bc33ed38c384.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
]]></content>
  </entry>
  <entry>
    <title>vue-filter</title>
    <url>/2020/08/04/vue-filter/</url>
    <content><![CDATA[<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ol>
<li>全局过滤方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;全局过滤器控制浮点数计算显示几位小数，默认2位</span><br><span class="line">main.js</span><br><span class="line">Vue.filter(&#39;tofixed&#39;, function (value,num&#x3D;2) &#123;</span><br><span class="line">  if (!value) return 0</span><br><span class="line">  return value.toFixed(num)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">页面使用</span><br><span class="line">&lt;span&gt;&#123;&#123;(vipData.DiscountRate*10) | tofixed(1)&#125;&#125;&lt;&#x2F;span</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>局部过滤器</p>
<a id="more"></a>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      that:this,</span><br><span class="line">      searchValue: &quot;&quot;,</span><br><span class="line">      searchResult: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters:&#123;</span><br><span class="line">    brightenKeyword(val,that)&#123;</span><br><span class="line">      const Reg &#x3D; new RegExp(that.searchValue, &#39;ig&#39;);</span><br><span class="line">      return val.replace(Reg, &#96;&lt;span class&#x3D;&quot;redColor&quot;&gt;$&#123;that.searchValue&#125;&lt;&#x2F;span&gt;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">页面使用</span><br><span class="line"> &lt;li v-for&#x3D;&quot;item in searchResult&quot; :key&#x3D;&quot;item&quot; v-html&#x3D;&quot;$options.filters.brightenKeyword(item,that)&quot;&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>注册全局组件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常注册全局组件的时候，第二个参数应该是对象。全局组件必须写在Vue实例创建之前，才在该根元素下面生效；</span><br><span class="line">Vue.component(&#39;public1&#39;, &#123;</span><br><span class="line"> template: &#39;&lt;div&gt;正常的组件模式&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>私有组件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app1&quot;&gt;</span><br><span class="line">    &lt;child-component&gt;&lt;&#x2F;child-component&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#app1&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;child-component&quot;:&#123;</span><br><span class="line">                template:&quot;&lt;h1&gt;我是局部组件&lt;&#x2F;h1&gt;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>filter</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-mixin</title>
    <url>/2020/07/30/vue-mixin/</url>
    <content><![CDATA[<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><h4 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h4><p>1.创建mixin的js文件</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const info&#x3D;&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &quot;curry&quot;,</span><br><span class="line">            sex: &quot;man&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.引入创建的js文件（花括号必须写，mixins，s不能忘）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;info&#125; from &#39;mixin文件的路径&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">	mixins:[info]　 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.使用mixin中的数据（组件中直接使用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this.name) &#x2F;&#x2F;curry</span><br></pre></td></tr></table></figure>



<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p><strong>方法一</strong>：在工程的main.js中直接注册，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line"></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&#39;全局混入的钩子函数&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>方法二</strong>：</p>
<p>模块化注册，新建mixin.js文件并添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      created() &#123;</span><br><span class="line">        console.log(&#39;全局混入的钩子函数&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main.js中引入该文件并使用use方法进行注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import myMixin from &#39;.&#x2F;mixin.js&#39;;</span><br><span class="line"></span><br><span class="line">Vue.use(myMixin);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mixin</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>mixin</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-mock</title>
    <url>/2020/07/30/vue-mock/</url>
    <content><![CDATA[<h3 id="vue中使用mock"><a href="#vue中使用mock" class="headerlink" title="vue中使用mock"></a>vue中使用mock</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>npm install mockjs –save</p>
<p>npm install axios –save</p>
<p>安装axios是为了能模拟后台接口。</p>
<a id="more"></a>

<h3 id="建立目录结构如下："><a href="#建立目录结构如下：" class="headerlink" title="建立目录结构如下："></a>建立目录结构如下：</h3><p><img src="https://img-blog.csdn.net/20180731124828244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFvamllMTIzMjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="在main-js引入mockjs"><a href="#在main-js引入mockjs" class="headerlink" title="在main.js引入mockjs"></a>在main.js引入mockjs</h3><p><img src="https://img-blog.csdn.net/20180731125441827?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFvamllMTIzMjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="mock-js"><a href="#mock-js" class="headerlink" title="mock.js"></a>mock.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span> <span class="comment">// 引入mockjs</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> Random = Mock.Random <span class="comment">// Mock.Random 是一个工具类，用于生成各种随机数据</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> data = [] <span class="comment">// 用于接受生成数据的数组</span></span><br><span class="line"><span class="keyword">let</span> size = [</span><br><span class="line">  <span class="string">'300x250'</span>, <span class="string">'250x250'</span>, <span class="string">'240x400'</span>, <span class="string">'336x280'</span>, </span><br><span class="line">  <span class="string">'180x150'</span>, <span class="string">'720x300'</span>, <span class="string">'468x60'</span>, <span class="string">'234x60'</span>, </span><br><span class="line">  <span class="string">'88x31'</span>, <span class="string">'120x90'</span>, <span class="string">'120x60'</span>, <span class="string">'120x240'</span>, </span><br><span class="line">  <span class="string">'125x125'</span>, <span class="string">'728x90'</span>, <span class="string">'160x600'</span>, <span class="string">'120x600'</span>, </span><br><span class="line">  <span class="string">'300x600'</span></span><br><span class="line">] <span class="comment">// 定义随机值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123; <span class="comment">// 可自定义生成的个数</span></span><br><span class="line">  <span class="keyword">let</span> template = &#123;</span><br><span class="line">    <span class="string">'Boolean'</span>: Random.boolean, <span class="comment">// 可以生成基本数据类型</span></span><br><span class="line">    <span class="string">'Natural'</span>: Random.natural(<span class="number">1</span>, <span class="number">10</span>), <span class="comment">// 生成1到100之间自然数</span></span><br><span class="line">    <span class="string">'Integer'</span>: Random.integer(<span class="number">1</span>, <span class="number">100</span>), <span class="comment">// 生成1到100之间的整数</span></span><br><span class="line">    <span class="string">'Float'</span>: Random.float(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">5</span>), <span class="comment">// 生成0到100之间的浮点数,小数点后尾数为0到5位</span></span><br><span class="line">    <span class="string">'Character'</span>: Random.character(), <span class="comment">// 生成随机字符串,可加参数定义规则</span></span><br><span class="line">    <span class="string">'String'</span>: Random.string(<span class="number">2</span>, <span class="number">10</span>), <span class="comment">// 生成2到10个字符之间的字符串</span></span><br><span class="line">    <span class="string">'Range'</span>: Random.range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>), <span class="comment">// 生成一个随机数组</span></span><br><span class="line">    <span class="string">'Date'</span>: Random.date(), <span class="comment">// 生成一个随机日期,可加参数定义日期格式</span></span><br><span class="line">    <span class="string">'Image'</span>: Random.image(Random.size, <span class="string">'#02adea'</span>, <span class="string">'Hello'</span>), <span class="comment">// Random.size表示将从size数据中任选一个数据</span></span><br><span class="line">    <span class="string">'Color'</span>: Random.color(), <span class="comment">// 生成一个颜色随机值</span></span><br><span class="line">    <span class="string">'Paragraph'</span>:Random.paragraph(<span class="number">2</span>, <span class="number">5</span>), <span class="comment">//生成2至5个句子的文本</span></span><br><span class="line">    <span class="string">'Name'</span>: Random.name(), <span class="comment">// 生成姓名</span></span><br><span class="line">    <span class="string">'Url'</span>: Random.url(), <span class="comment">// 生成web地址</span></span><br><span class="line">    <span class="string">'Address'</span>: Random.province() <span class="comment">// 生成地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  data.push(template)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Mock.mock(<span class="string">'/data/index'</span>, <span class="string">'post'</span>, data) <span class="comment">// 根据数据模板生成模拟数据</span></span><br></pre></td></tr></table></figure>

<h3 id="api-js"><a href="#api-js" class="headerlink" title="api.js"></a>api.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"> </span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 封装axios的post请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.post(url, params)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(response.data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mockdata(url, params) &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(url, params);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mock-vue"><a href="#mock-vue" class="headerlink" title="mock.vue"></a>mock.vue</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./../axios/api.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Mock'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      dataShow: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.getdata()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      api.mockdata(<span class="string">'/data/index'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="keyword">this</span>.dataShow = res.data;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="控制台打印出的数据"><a href="#控制台打印出的数据" class="headerlink" title="控制台打印出的数据"></a>控制台打印出的数据</h3><p><img src="https://img-blog.csdn.net/20180731125545864?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFvamllMTIzMjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>以上是使用mockjs生成的模拟数据，基本可以满足平时开发的需要，不过mockjs还有其他的用法未能一一列出来，建议各位朋友们去mock官网的文档了解更多，地址：<a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a> 。</p>
]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-nextTick</title>
    <url>/2020/08/06/vue-nextTick/</url>
    <content><![CDATA[<h4 id="异步更新队列："><a href="#异步更新队列：" class="headerlink" title="异步更新队列："></a>异步更新队列：</h4><p>请记住：<strong>vue是依靠数据驱动视图更新的，该更新的过程是异步的。</strong>即：当侦听到你的数据发生变化时， Vue将开启一个队列（该队列被Vue官方称为异步更新队列）。视图需要等队列中所有数据变化完成之后，再统一进行更新。示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;myApp&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点我呀&quot; @click&#x3D;&quot;changeStr&quot;&gt;</span><br><span class="line">    &lt;p ref&#x3D;&quot;myP&quot;&gt;&#123;&#123;str&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#myApp&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            str:&quot;公众号 张培跃，关注它的人很少！&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            changeStr()&#123;</span><br><span class="line">                this.str &#x3D; &quot;欢迎关注公众号 张培跃，收看更多精彩内容！&quot;;</span><br><span class="line">                &#x2F;&#x2F; 输出结果：公众号 张培跃，关注它的人很少！</span><br><span class="line">                console.log(this.$refs.myP.innerText)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>通过以上示例的输出结果可以有力证明：<strong>Vue 实现的响应式并不是数据发生变化之后视图立即变化。</strong></p>
<p>更改上个示例中的changeStr方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">changeStr()&#123;</span><br><span class="line">    this.str &#x3D; &quot;欢迎关注公众号 张培跃，收看更多精彩内容！&quot;;</span><br><span class="line">    this.$nextTick(()&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; 输出结果：我爱你中国，我亲爱的母亲！</span><br><span class="line">        console.log(this.$refs.myP.innerText);</span><br><span class="line">    &#125;);</span><br><span class="line">    this.str &#x3D; &quot;我爱你中国，我亲爱的母亲！&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出的结果可以看出：我们可以通过<code>$nextTick()</code> 获取到更新之后的<code>DOM</code>。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>1、如果要在<code>created()</code>钩子函数中进行的<code>DOM</code>操作，由于<code>created()</code>钩子函数中还未对DOM进行任何渲染，所以无法直接操作，需要通过<code>$nextTick()</code>来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    this.$nextTick(()&#x3D;&gt;&#123;</span><br><span class="line">        this.$refs.myP.innerText &#x3D; &quot;我是一只小小小小鸟，想要飞，却怎么样也飞不高！&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注：在<code>created()</code>钩子函数中进行的<code>DOM</code>操作，不使用<code>$nextTick()</code>会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  Error in created hook: &quot;TypeError: Cannot set property &#39;innerText&#39; of undefined&quot;</span><br><span class="line">created()&#123;</span><br><span class="line">    this.$refs.myP.innerText &#x3D; &quot;我是一只小小小小鸟，想要飞，却怎么样也飞不高！&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、更新数据后，想要使用js对新的视图进行操作时。</p>
<p>3、在使用某些第三方插件时 ，这些插件需要dom动态变化后重新应用该插件，这时候就需要使用<code>$nextTick()</code>来重新应用插件的方法。示例（略）</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-ref</title>
    <url>/2020/08/06/vue-ref/</url>
    <content><![CDATA[<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>在原生里获取DOM元素，需document.querySelector（”.input1”）获取这个dom节点，然后在获取input1的值。</p>
<p>但是用ref绑定之后，我们就不需要在获取dom节点了，直接在上面的input上绑定input1，然后$refs里面调用就行。</p>
<p>然后在javascript里面这样调用：this.$refs.input1  这样就可以减少获取dom节点的消耗了</p>
<a id="more"></a>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>ref 有三种用法：</p>
<p>　　1、ref 加在普通的元素上，用this.$refs.name 获取到的是dom元素</p>
<p>　　2、ref 加在子组件上，用his.$refs.name 获取到的是<strong>组件实例，可以使用组件的所有方法</strong>。</p>
<p>​    3、<strong>ref 需要在dom渲染完成后才会有</strong>，在使用的时候确保dom已经渲染完成。比如在生命周期 <strong>mounted(){} 钩子中调用</strong>，或者<strong>在 this.$nextTick(()=&gt;{}) 中调用</strong>。</p>
<p>　　4、如果ref 是循环出来的，<strong>有多个重名，那么ref的值会是一个数组</strong> ，此时要拿到单个的ref 只需要循环就可以了。</p>
<p><img src="https://images2018.cnblogs.com/blog/1158910/201808/1158910-20180801214632214-356594092.png" alt="img"></p>
<h3 id="一、ref使用在外面的组件上"><a href="#一、ref使用在外面的组件上" class="headerlink" title="一、ref使用在外面的组件上"></a>一、ref使用在外面的组件上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;ref-outside-component&quot; v-on:click&#x3D;&quot;consoleRef&quot;&gt;</span><br><span class="line">    &lt;component-father ref&#x3D;&quot;outsideComponentRef&quot;&gt;</span><br><span class="line">    &lt;&#x2F;component-father&gt;</span><br><span class="line">    &lt;p&gt;ref在外面的组件上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refoutsidecomponentTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39;&gt;&lt;h5&gt;我是子组件&lt;&#x2F;h5&gt;&lt;&#x2F;div&gt;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refoutsidecomponent&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-outside-component&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refoutsidecomponentTem</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F; #ref-outside-component     vue实例</span><br><span class="line">                console.log(this.$refs.outsideComponentRef);  &#x2F;&#x2F; div.childComp vue实例，组件实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h3 id="二、ref作用在外面元素上"><a href="#二、ref作用在外面元素上" class="headerlink" title="二、ref作用在外面元素上"></a>二、ref作用在外面元素上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在外面的元素上</span><br><span class="line">&lt;div id&#x3D;&quot;ref-outside-dom&quot; v-on:click&#x3D;&quot;consoleRef&quot; &gt;</span><br><span class="line">   &lt;component-father&gt;</span><br><span class="line">   &lt;&#x2F;component-father&gt;</span><br><span class="line">   &lt;p ref&#x3D;&quot;outsideDomRef&quot;&gt;ref在外面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refoutsidedomTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39;&gt;&lt;h5&gt;我是子组件&lt;&#x2F;h5&gt;&lt;&#x2F;div&gt;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refoutsidedom&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-outside-dom&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refoutsidedomTem</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F; #ref-outside-dom    vue实例</span><br><span class="line">                console.log(this.$refs.outsideDomRef);  &#x2F;&#x2F;  &lt;p&gt;标签dom元素 ref在外面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>[</p>
<h3 id="三、ref使用在里面的元素上–局部注册组件"><a href="#三、ref使用在里面的元素上–局部注册组件" class="headerlink" title="三、ref使用在里面的元素上–局部注册组件"></a>三、ref使用在里面的元素上–局部注册组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在里面的元素上</span><br><span class="line">&lt;div id&#x3D;&quot;ref-inside-dom&quot;&gt;</span><br><span class="line">    &lt;component-father&gt;</span><br><span class="line">    &lt;&#x2F;component-father&gt;</span><br><span class="line">    &lt;p&gt;ref在里面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refinsidedomTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39; v-on:click&#x3D;&#39;consoleRef&#39;&gt;&quot; +</span><br><span class="line">                       &quot;&lt;h5 ref&#x3D;&#39;insideDomRef&#39;&gt;我是子组件&lt;&#x2F;h5&gt;&quot; +</span><br><span class="line">                  &quot;&lt;&#x2F;div&gt;&quot;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this);  &#x2F;&#x2F; div.childComp   vue实例 </span><br><span class="line">                console.log(this.$refs.insideDomRef);  &#x2F;&#x2F; &lt;h5 &gt;我是子组件&lt;&#x2F;h5&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refinsidedom&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-inside-dom&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refinsidedomTem</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);[</span><br></pre></td></tr></table></figure>

<h3 id="四、ref使用在里面的元素上–全局注册组件"><a href="#四、ref使用在里面的元素上–全局注册组件" class="headerlink" title="四、ref使用在里面的元素上–全局注册组件"></a>四、ref使用在里面的元素上–全局注册组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在里面的元素上--全局注册</span><br><span class="line">&lt;div id&#x3D;&quot;ref-inside-dom-all&quot;&gt;</span><br><span class="line">    &lt;ref-inside-dom-quanjv&gt;&lt;&#x2F;ref-inside-dom-quanjv&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    Vue.component(&quot;ref-inside-dom-quanjv&quot;,&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;insideFather&#39;&gt; &quot; +</span><br><span class="line">                    &quot;&lt;input type&#x3D;&#39;text&#39; ref&#x3D;&#39;insideDomRefAll&#39; v-on:input&#x3D;&#39;showinsideDomRef&#39;&gt;&quot; +</span><br><span class="line">                    &quot;  &lt;p&gt;ref在里面的元素上--全局注册 &lt;&#x2F;p&gt; &quot; +</span><br><span class="line">                  &quot;&lt;&#x2F;div&gt;&quot;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            showinsideDomRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F;这里的this其实还是div.insideFather</span><br><span class="line">                console.log(this.$refs.insideDomRefAll); &#x2F;&#x2F; &lt;input  type&#x3D;&quot;text&quot;&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    var refinsidedomall&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-inside-dom-all&quot;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ref</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router</title>
    <url>/2020/08/05/vue-router/</url>
    <content><![CDATA[<h3 id="Vue路由（vue-router）详细讲解指南"><a href="#Vue路由（vue-router）详细讲解指南" class="headerlink" title="Vue路由（vue-router）详细讲解指南"></a><a href="https://www.cnblogs.com/dengyao-blogs/p/11562257.html" target="_blank" rel="noopener">Vue路由（vue-router）详细讲解指南</a></h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>中文文档：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">https://router.vuejs.org/zh/</a></p>
<p>Vue Router 是 <a href="http://cn.vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。路由实际上就是可以理解为指向，就是我在页面上点击一个按钮需要跳转到对应的页面，这就是路由跳转；</p>
<a id="more"></a>

<h4 id="单词解析"><a href="#单词解析" class="headerlink" title="单词解析"></a>单词解析</h4><p>首先我们来学习三个单词（route，routes，router）：</p>
<p>　　<strong>route</strong>：首先它是个单数，译为路由，即我们可以理解为单个路由或者某一个路由；<strong>可以获取 name ， path ，params，query等；</strong></p>
<p>　　<strong>router</strong>：译为路由器，上面都是路由，这个是路由器，我们可以理解为一个容器包含上述两个或者说它是一个管理者，负责管理上述两个；举个常见的场景的例子：当用户在页面上点击按钮的时候，这个时候router就会去routes中去查找route，就是说路由器会去路由集合中找对应的路由；<strong>$router.push可以跳转页面</strong>，<strong>$router.go则返回上一个页面</strong></p>
<p>　　<strong>routes</strong>：它是个复数，表示多个的集合才能为复数；即我们可以理解为多个路由的集合，JS中表示多种不同状态的集合的形式只有数组和对象两种，事实上官方定义routes是一个数组；所以我们记住了，routes表示多个数组的集合；<strong>route.js中routes存放的路由集合</strong></p>
<h4 id="安装项目"><a href="#安装项目" class="headerlink" title="安装项目"></a>安装项目</h4><p>　　首先需要安装vue-cli来构建一个vue的开发环境，安装完vue-cli之后，我们的项目目录结构如下：</p>
<p>　　　<img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921113853486-2102414267.png" alt="img"></p>
<p> 　　然后我们在命令行中输入npm install vue-router -g来安装vue-router，安装完之后我们可以打开package.json看到vue-router的版本号</p>
<h5 id="简单跳转"><a href="#简单跳转" class="headerlink" title="简单跳转"></a>简单跳转</h5><p>我们在src目录下新建三个文件，分别为page1.vue和page2.vue以及router.js：</p>
<p>page1.vue：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;page1&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;我是page1组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p> page2.vue：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;page2&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;我是page2组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p>router.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入vue</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引入vue-router</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三方库需要use一下才能用</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引用page1页面</span><br><span class="line">import page1  from &#39;.&#x2F;page1.vue&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引用page2页面</span><br><span class="line">import page2  from &#39;.&#x2F;page2.vue&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义routes路由的集合，数组类型</span><br><span class="line">const routes&#x3D;[</span><br><span class="line">    &#x2F;&#x2F;单个路由均为对象类型，path代表的是路径，component代表组件</span><br><span class="line">    &#123;path:&#39;&#x2F;page1&#39;,component:page1&#125;,</span><br><span class="line">    &#123;path:&quot;&#x2F;page2&quot;,component:page2&#125;,</span><br><span class="line">    &#x2F;&#x2F;懒加载写法</span><br><span class="line">    &#123;path:&quot;&#x2F;page3&quot;,component:() &#x3D;&gt; import(&#39;.&#x2F;page3.vue&#39;)&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例化VueRouter并将routes添加进去</span><br><span class="line">const router&#x3D;new VueRouter(&#123;</span><br><span class="line">&#x2F;&#x2F;ES6简写，等于routes：routes</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;抛出这个这个实例对象方便外部读取以及访问</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<p>这里我们再修改一下main.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">&#x2F;&#x2F;引用router.js</span><br><span class="line">import router from &#39;.&#x2F;router.js&#39;</span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">&#x2F;&#x2F;一定要注入到vue的实例对象上</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>修改App.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">	&#x2F;&#x2F;router-link定义页面中点击触发部分　　</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page1&quot;&gt;Page1&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page2&quot;&gt;Page2&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">	&#x2F;&#x2F;router-view定义页面中显示部分</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>就这样，我们的页面就可以进行路由跳转和切换了，路由的基本使用就完成了；但是有个问题就是我们第一次进去是看不到路由页面的，这是因为我们没有设置默认值，我们首次进入的时候路径是为空的，那么我们可以这么解决：</p>
<p>router.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">import page1  from &#39;.&#x2F;page1.vue&#39;;</span><br><span class="line">import page2  from &#39;.&#x2F;page2.vue&#39;;</span><br><span class="line">import user   from &#39;.&#x2F;user.vue&#39;</span><br><span class="line"></span><br><span class="line">const routes&#x3D;[</span><br><span class="line">    &#123;path:&#39;&#x2F;page1&#39;,component:page1&#125;,</span><br><span class="line">    &#123;path:&quot;&#x2F;page2&quot;,component:page2&#125;,</span><br><span class="line">    &#x2F;&#x2F;可以配置重定向</span><br><span class="line">    &#123;path:&#39;&#39;,redirect:&quot;page1&quot;&#125;</span><br><span class="line">    &#x2F;&#x2F;或者重新写个路径为空的路由</span><br><span class="line">    &#123;path:&quot;&quot;,component:page1&#125;</span><br><span class="line">]</span><br><span class="line">const router&#x3D;new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>



<p>上面的两种解决方案都是可以解决的，配置重定向的意思就是当匹配到路径为空的时候，就会重定向到page1，执行page1的路由；或者我们也可以重新配置个路由，路径为空的时候router-view展示page1的页面；</p>
<p>用重定向和单独配置路由的区别：</p>
<p>　　重定向实际上是当匹配到路径符合条件的时候去执行对应的路由，当然这个时候的url上面的地址显示的是对应的路由，页面也是对应的路由页面；</p>
<p>　　重新配置路由是当匹配到路径符合条件的时候，router-view页面展示部分负责拿符合条件路由的页面来展示，实际上url是没有发生变化的；</p>
<h5 id="动态路由匹配："><a href="#动态路由匹配：" class="headerlink" title="动态路由匹配："></a>动态路由匹配：</h5><p>　　其实我们的生活中有很多这样的例子，不知道大家留意没有？比如一个网站或者后台管理系统中，在我们登录之后，是不是通常会有一个欢迎回来，XXX之类的提示语，这个我们就可以通过动态路由来实现这个效果；</p>
<p>首先在src目录下新建一个user.vue文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;user&lt;&#x2F;h1&gt;</span><br><span class="line">       &#x2F;&#x2F;这里可以通过$route.params.name来获取路由的参数</span><br><span class="line">        &lt;p&gt;欢迎回来,&#123;&#123;$route.params.name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;我是page1组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p>然后我们修改App.vue文件的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page1&quot;&gt;Page1&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page2&quot;&gt;Page2&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加两个router-link标签</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;xianyu&quot;&gt;动态路由咸鱼&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;mengxiang&quot;&gt;动态路由梦想&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>修改我们的router.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">import page1  from &#39;.&#x2F;page1.vue&#39;;</span><br><span class="line">import page2  from &#39;.&#x2F;page2.vue&#39;;</span><br><span class="line">import user   from &#39;.&#x2F;user.vue&#39;</span><br><span class="line"></span><br><span class="line">const routes&#x3D;[</span><br><span class="line">    &#123;path:&#39;&#x2F;page1&#39;,component:page1&#125;,</span><br><span class="line">    &#123;path:&quot;&#x2F;page2&quot;,component:page2&#125;,</span><br><span class="line">    &#x2F;&#x2F; &#123;path:&#39;&#39;,redirect:&quot;page1&quot;&#125;</span><br><span class="line">    &#123;path:&quot;&quot;,component:page1&#125;,</span><br><span class="line"> 	&#x2F;&#x2F;使用冒号标记，当匹配到的时候，参数值会被设置到this.$route.params中</span><br><span class="line">    &#123;path:&quot;&#x2F;user&#x2F;:name&quot;,component:user&#125;</span><br><span class="line">    </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const router&#x3D;new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<p>配置好了，不出意外是能正常运行的，我们来看一下效果：</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921135641595-1931722345.png" alt="img"></p>
<p> 动态路由匹配给我们提供了方便，使得我们通过配置一个路由来实现页面局部修改的效果，给用户造成一种多个页面的感觉，是不是很酷！！！</p>
<p>酷的同时也会给我们带来一些问题，因为使用路由参数时，从/user/xianyu导航到/user/mengxiang，原来的组件实例会被复用，两个路由都渲染同个组件，比起销毁再创建，显示复用显得效率更高，带来的的只管问题就是生命周期钩子函数不会再被调用，也就是不会再被触发；但是办法总比问题多，我们可以通过监听$route对象来实现;</p>
<p>修改user.vue的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;user&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;欢迎回来,&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                &#x2F;&#x2F; msg: &quot;我是page1组件&quot;</span><br><span class="line">                msg:&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123;</span><br><span class="line">		&#x2F;&#x2F;to表示即将要进入的那个组件，from表示从哪个组件过来的</span><br><span class="line">            $route(to,from)&#123;</span><br><span class="line">                this.msg&#x3D;to.params.name; </span><br><span class="line">                console.log(111);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>效果图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921141325741-575913091.png" alt="img"></p>
<p> 我们可以很明显的看到我们监听的$route对象被触发了，控制台也输出了；</p>
<p>下面我们来一起看一下嵌套路由：</p>
<p>#####　嵌套路由：</p>
<p>很多时候我们的页面结构决定了我们可能需要嵌套路由，比如当我们进入主页之后有分类，然后当选择其中一个分类之后进入对应的详情，这个时候我们就可以用到嵌套路由；官方文档中给我们提供了一个children属性，这个属性是一个数组类型，里面实际放着一组路由；这个时候父子关系结构就出来了，所以children属性里面的是路由相对来说是children属性外部路由的子路由；</p>
<p>好记性不如烂代码，让我们通过代码来看一看：</p>
<p>　　首先在我们的src目录下新建两个vue文件，分别是phone.vue和computer.vue</p>
<p>　　phone.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;嵌套手机组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>　　computer.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;嵌套电脑组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们再修改我们的App.vue文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page1&quot;&gt;Page1&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>通过上面的App.vue文件我们可以看到，我们此时页面只有一个page1的标签了；</p>
<p>我们再来修改router.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">import page1  from &#39;.&#x2F;page1.vue&#39;;</span><br><span class="line">import page2  from &#39;.&#x2F;page2.vue&#39;;</span><br><span class="line">import user   from &#39;.&#x2F;user.vue&#39;;</span><br><span class="line">import phone  from &#39;.&#x2F;phone.vue&#39;;</span><br><span class="line">import computer from &#39;.&#x2F;computer.vue&#39;</span><br><span class="line"></span><br><span class="line">const routes&#x3D;[</span><br><span class="line">    &#123;</span><br><span class="line">        path:&#39;&#x2F;page1&#39;,</span><br><span class="line">        component:page1,</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                path: &quot;phone&quot;,</span><br><span class="line">                component: phone</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: &quot;computer&quot;,</span><br><span class="line">                component: computer</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const router&#x3D;new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<p>为了大家看的直观点，其他路由全部注释了，页面只剩下/page1这一个路由了；</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921144040749-976651739.png" alt="img"></p>
<p>上面说到了，children属性其实就是一个子路由集合，数组结构里面放着子路由；</p>
<p>效果图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921144102502-80898094.png" alt="img"></p>
<h5 id="路由导航两种方式："><a href="#路由导航两种方式：" class="headerlink" title="路由导航两种方式："></a>路由导航两种方式：</h5><p>　　<strong>标签导航：</strong>标签导航<router-link><router-link>是通过转义为<a></a>标签进行跳转，其中router-link标签中的to属性会被转义为a标签中的href属性；</router-link></router-link></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;跳转到名为user路由，并传递参数userId</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>​    <strong>编程式导航：</strong>我们可以通过this.$router.push()这个方法来实现编程式导航，当然也可以实现参数传递，这种编程式导航一般是用于按钮点击之后跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>这两者都会把路由导航到user/123路径</p>
<h5 id="路由传参-params-与-query"><a href="#路由传参-params-与-query" class="headerlink" title="路由传参 params 与 query"></a>路由传参 params 与 query</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query要用path来引入，params要用name来引入</span><br><span class="line">tourlname()&#123;</span><br><span class="line">   this.$router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">tourlpath()&#123;</span><br><span class="line">   this.$router.push(&#123; path: &#39;&#x2F;user&#39;, query: &#123; userId: 123 &#125;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取参数的不同</span><br><span class="line">&#123;&#123;$route.params.userId&#125;&#125;</span><br><span class="line">&#123;&#123;$route.query.userId&#125;&#125;</span><br><span class="line"></span><br><span class="line">params类似于post，不显示参数名</span><br><span class="line">query类似于我们ajax中get传参，在浏览器地址栏中显示参数名，</span><br></pre></td></tr></table></figure>

<p>使用params传递参数，url上只会出现数据，不会出现具体字段<br><img src="https://img-blog.csdnimg.cn/20200718154856867.png" alt="在这里插入图片描述"><br>而使用查询参数query的方式，url上会出现具体的字段，比较不安全<br><img src="https://img-blog.csdnimg.cn/2020071815491147.png" alt="在这里插入图片描述"></p>
<p>多个参数<br>直接在路由路径上拼接多个参数<br><img src="https://img-blog.csdnimg.cn/20200718154421681.png" alt="在这里插入图片描述"><br>对应组件使用路由的方法如下：<br><img src="https://img-blog.csdnimg.cn/20200718154444639.png" alt="在这里插入图片描述"></p>
<p><strong>注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的</strong></p>
<h5 id="props传参"><a href="#props传参" class="headerlink" title="props传参"></a>props传参</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A跳到B页面</span><br><span class="line"></span><br><span class="line">布尔模式</span><br><span class="line">A页面</span><br><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;you&#x2F;18&quot;&gt;user&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">B页面</span><br><span class="line">props:[&quot;id&quot;,&quot;age&quot;],</span><br><span class="line"></span><br><span class="line">router.js</span><br><span class="line">&#123;</span><br><span class="line">    path: &quot;&#x2F;B&#x2F;:id&#x2F;:age&quot;,</span><br><span class="line">    component: user,</span><br><span class="line">    props: true</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">函数模式</span><br><span class="line">A页面</span><br><span class="line">&lt;p @click&#x3D;&quot;url&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  url() &#123;</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">      path: &quot;&#x2F;user&#x2F;test&quot;,</span><br><span class="line">      query: &#123;</span><br><span class="line">      	articleTitle: &quot;文章1&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line">B页面</span><br><span class="line">props:[&quot;id&quot;,&quot;age&quot;],</span><br><span class="line"></span><br><span class="line">router.js</span><br><span class="line">&#123;</span><br><span class="line">    path: &quot;&#x2F;B&#x2F;:id&quot;,</span><br><span class="line">    component: user,</span><br><span class="line">    props: (route) &#x3D;&gt; (&#123;</span><br><span class="line">      id: route.params.id,</span><br><span class="line">      age: route.query.age</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">对象模式</span><br><span class="line">router.js</span><br><span class="line">&#123;</span><br><span class="line">    path: &quot;&#x2F;user&#x2F;:id&quot;,</span><br><span class="line">    component: user,</span><br><span class="line">    props: &#123;  &#x2F;&#x2F; 写死</span><br><span class="line">      food: &#39;banana&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>





<h5 id="命名路由："><a href="#命名路由：" class="headerlink" title="命名路由："></a>命名路由：</h5><p>有的时候，通过一个名称来标识一个路由显得更方便一些，所以官方为了方便我们偷懒，又给我们在路由中添加了一个name属性，命名这个属性之后我们访问这个属性就等于直接访问到路由；</p>
<p>　　普通路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.push(&#123; path: &#39;&#x2F;user&#x2F;:userId&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>



<p>　　命名路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>其实两者并没有什么区别，只是提供了两种方式来访问路由，可以通过路径来匹配也可以通过别名来匹配；</p>
<h5 id="路由字段"><a href="#路由字段" class="headerlink" title="路由字段"></a>路由字段</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const routes &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;&#x2F;user&#x2F;:name&quot;, &#x2F;&#x2F;动态路由</span><br><span class="line">    name: &quot;user&quot;, &#x2F;&#x2F; 命名设置 name 值</span><br><span class="line">    alias: &#39;&#x2F;home_page&#39;, &#x2F;&#x2F; 别名</span><br><span class="line">    meta: &#123;  &#x2F;&#x2F; 路由元信息 &lt;h1&gt;&#123;&#123; $route.meta.title&#125;&#125;&lt;&#x2F;h1&gt;，可变 this.$route.meta.title &#x3D; &quot;首页&quot;;</span><br><span class="line">      title: &#39;主页&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: user, </span><br><span class="line">    components: &#123;  &#x2F;&#x2F; 加s 命名多个视图</span><br><span class="line">      default: () &#x3D;&gt; import(&#39;views&#x2F;child.vue&#39;),</span><br><span class="line">      email: () &#x3D;&gt; import(&#39;views&#x2F;email.vue&#39;),</span><br><span class="line">      tel: () &#x3D;&gt; import(&#39;views&#x2F;tel.vue&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;hash&#39;,  &#x2F;&#x2F; 默认 #&#x2F;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,  </span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h5><p>首先我们在router文件夹中创建一个index.js作为路由的入口文件，然后新建一个modules文件夹，里面存放各个模块的路由文件。例如这里储存了一个vote.js投票模块的路由文件和一个公共模块的路由文件。下面直接上index.js吧，而后在简单介绍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 公共页面的路由文件</span><br><span class="line">import PUBLIC from &#39;.&#x2F;modules&#x2F;public&#39; </span><br><span class="line">&#x2F;&#x2F; 投票模块的路由文件</span><br><span class="line">import VOTE from &#39;.&#x2F;modules&#x2F;vote&#39; </span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义路由</span><br><span class="line">const router &#x3D; new Router(&#123;  </span><br><span class="line">    mode: &#39;history&#39;,  </span><br><span class="line">    routes: [    </span><br><span class="line">        ...PUBLIC,    </span><br><span class="line">        ...VOTE,  </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路由变化时</span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;    </span><br><span class="line">    if (document.title !&#x3D;&#x3D; to.meta.title) &#123;        </span><br><span class="line">        document.title &#x3D; to.meta.title;    </span><br><span class="line">    &#125;    </span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导出</span><br><span class="line">export default router复制代码</span><br></pre></td></tr></table></figure>

<p>首先引入vue和router最后导出，这就不多说了，基本的操作。</p>
<p>这里把router.beforeEach的操作写了router的index.js文件中，有些人可能会写在main.js中，这也没有错，只不过，个人而言，既然是路由的操作，还是放在路由文件中管理更好些。这里就顺便演示了，如何在页面切换时，自动修改页面标题的操作。</p>
<p>而后引入你根据路由模块划分的各个js文件，然后在实例化路由的时候，在routes数组中，将导入的各个文件通过结构赋值的方法取出来。最终的结果和正常的写法是一样的。</p>
<p>然后看下我们导入的vote.js吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * 投票模块的router列表  </span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">export default [    </span><br><span class="line">    &#x2F;&#x2F; 投票模块首页    </span><br><span class="line">    &#123;        </span><br><span class="line">        path: &#39;&#x2F;vote&#x2F;index&#39;,        </span><br><span class="line">        name: &#39;VoteIndex&#39;,        </span><br><span class="line">        component: resolve &#x3D;&gt; require([&#39;@&#x2F;view&#x2F;vote&#x2F;index&#39;], resolve),        </span><br><span class="line">        meta: &#123;            </span><br><span class="line">            title: &#39;投票&#39;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    &#x2F;&#x2F; 详情页    </span><br><span class="line">    &#123;        </span><br><span class="line">        path: &#39;&#x2F;vote&#x2F;detail&#39;,        </span><br><span class="line">        name: &#39;VoteDetail&#39;,        </span><br><span class="line">        component: resolve &#x3D;&gt; require([&#39;@&#x2F;view&#x2F;vote&#x2F;detail&#39;], resolve),</span><br><span class="line">        meta: &#123;            </span><br><span class="line">            title: &#39;投票详情&#39;        </span><br><span class="line">        &#125;    </span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>



<h5 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a><strong>过渡动效</strong></h5><ul>
<li>单个路由过渡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition name&#x3D;&quot;router&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;transition&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .router-enter &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-enter-active &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-enter-to &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-leave &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-leave-active &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-leave-to &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态过渡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用动态的 transition name --&gt;</span><br><span class="line">&lt;transition :name&#x3D;&quot;transitionName&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;transition&gt;</span><br><span class="line"></span><br><span class="line">路由的meta中定义一个tree属性</span><br><span class="line">const routers&#x3D;[</span><br><span class="line">    	&#123;</span><br><span class="line">    		path: &#39;&#x2F;test&#39;,</span><br><span class="line">    		name: &#39;test&#39;,   &#x2F;&#x2F;财务查询页</span><br><span class="line">    		component: resolve &#x3D;&gt; require([&#39;@&#x2F;page&#x2F;test&#x2F;test&#39;], resolve),</span><br><span class="line">    		meta:&#123;</span><br><span class="line">    		   	title : &#39;测试页&#39;, &#x2F;&#x2F; 标题设置在这里</span><br><span class="line">    			tree: 4,</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: &#39;&#x2F;list1&#39;,</span><br><span class="line">		name: &#39;list1&#39;,   &#x2F;&#x2F;财务查询页</span><br><span class="line">		component: resolve &#x3D;&gt; require([&#39;@&#x2F;page&#x2F;test&#x2F;list1&#39;], resolve),</span><br><span class="line">		meta:&#123;</span><br><span class="line">		   	title : &#39;测试页&#39;, &#x2F;&#x2F; 标题设置在这里</span><br><span class="line">			tree: 1,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">导航守卫</span><br><span class="line">&#x2F;&#x2F;路由跳转前进后退动画,Vue原型上定义transition为动画效果</span><br><span class="line">router.beforeEach ( (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    Vue.prototype.transition &#x3D; &#39;slide-none&#39;;</span><br><span class="line">    if(from.meta.tree &gt; to.meta.tree) &#123;</span><br><span class="line">        &#x2F;&#x2F; 后退,想右滑动</span><br><span class="line">        Vue.prototype.transition &#x3D; &#39;slide-right&#39;;</span><br><span class="line">        from.meta.keepAlive &#x3D; false;</span><br><span class="line">        to.meta.keepAlive &#x3D; true;</span><br><span class="line">    &#125; else if(from.meta.tree &lt; to.meta.tree) &#123;</span><br><span class="line">        &#x2F;&#x2F; 前进,想左滑动</span><br><span class="line">        Vue.prototype.transition &#x3D; &#39;slide-left&#39;;</span><br><span class="line">        from.meta.keepAlive &#x3D; true;</span><br><span class="line">        to.meta.keepAlive &#x3D; false;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		&#x2F;&#x2F; 同一层级,无动画</span><br><span class="line">		Vue.prototype.transition &#x3D; &#39;slide-none&#39;;</span><br><span class="line">		from.meta.keepAlive &#x3D; true;</span><br><span class="line">		to.meta.keepAlive &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;使用title作为路由名称</span><br><span class="line">	if (to.meta.title) &#123;</span><br><span class="line">        document.title &#x3D; to.meta.title;</span><br><span class="line">    &#125;</span><br><span class="line">	next();</span><br><span class="line">&#125;)</span><br><span class="line">或者</span><br><span class="line">&#x2F;&#x2F; watch $route 决定使用哪种过渡 （弃用）</span><br><span class="line">watch: &#123;</span><br><span class="line">&#39;$route&#39; (to, from) &#123;</span><br><span class="line">    const toDepth &#x3D; to.meta.tree</span><br><span class="line">    const fromDepth &#x3D; from.meta.tree</span><br><span class="line">    this.transitionName &#x3D; toDepth &lt; fromDepth ? &#39;slide-right&#39; : &#39;slide-left&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">css</span><br><span class="line">@keyframes slideInLeft &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        transform: translate3d(100%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        transform: translate3d(0, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes slideInRight &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        transform: translate3d(0%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        transform: translate3d(-100%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.slide-left-enter-active&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0%;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    animation: slideInLeft 1s linear forwards;</span><br><span class="line">&#125;</span><br><span class="line">.slide-left-leave-active&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0%;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    animation: slideInRight 1s linear forwards;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*向右滑动*&#x2F;</span><br><span class="line">@keyframes slideOutLeft &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        transform: translate3d(-100%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        transform: translate3d(0%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes slideOutRight &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        transform: translate3d(0%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        transform: translate3d(100%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.slide-right-enter-active&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0%;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    animation: slideOutLeft 1s linear forwards;</span><br><span class="line">&#125;</span><br><span class="line">.slide-right-leave-active&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0%;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    animation: slideOutRight 1s linear forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h5 id="导航守卫-钩子函数-生命周期函数-、"><a href="#导航守卫-钩子函数-生命周期函数-、" class="headerlink" title="导航守卫(钩子函数/生命周期函数)、"></a><strong>导航守卫</strong>(钩子函数/生命周期函数)、</h5><ul>
<li>全局导航守卫</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;router&#x2F;index.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import routes from &#39;.&#x2F;router.js&#39;</span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">const router &#x3D;  new Router(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设登录判断</span><br><span class="line">const HAS_LOGIN &#x3D; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全局路由前置守卫</span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; to 即将跳转到的路由对象</span><br><span class="line">  &#x2F;&#x2F; from 将要离开的路由对象</span><br><span class="line">  &#x2F;&#x2F; next() 函数</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 开始是否进入登录</span><br><span class="line">  if (to.name !&#x3D;&#x3D; &#39;login&#39;) &#123;</span><br><span class="line">    if (HAS_LOGIN) next()  &#x2F;&#x2F; 如果登录了, 继续</span><br><span class="line">    else next(&#123;</span><br><span class="line">      name: &#39;login&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 如果跳转到登录页面</span><br><span class="line">    if (HAS_LOGIN) next(&#123;name: &#39;home&#39;&#125;) &#x2F;&#x2F; 登录了, 到主页</span><br><span class="line">    else next()  &#x2F;&#x2F; 没有登录 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全局路由后置守卫</span><br><span class="line">router.afterEach((to, from) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 可以设置 loading 的进度 为 false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<ul>
<li>路由独享守卫</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router.js</span><br><span class="line">import Home from &#39;.&#x2F;views&#x2F;Home.vue&#39;</span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,  &#x2F;&#x2F; url 路径</span><br><span class="line">    name: &#39;Home&#39;,</span><br><span class="line">    component: Home,  &#x2F;&#x2F; 路径对应渲染组件</span><br><span class="line">    beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>组件内的钩子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; home.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  home</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    beforeRouteEnter (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">      &#x2F;&#x2F; 不！能！获取组件实例 &#96;this&#96;</span><br><span class="line">      &#x2F;&#x2F; 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">      next(vm &#x3D;&gt; &#123;</span><br><span class="line">        console.log(vm)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 用户编辑未保存离开, 可以询问是否离开</span><br><span class="line">    beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">      &#x2F;&#x2F; 导航离开该组件的对应路由时调用</span><br><span class="line">      &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class="line">      const leave &#x3D; confirm(&#39;您确认要离开吗&#39;)</span><br><span class="line">      if (leave) next()</span><br><span class="line">      else next(false)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; argu.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  argu</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">      &#x2F;&#x2F; 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">      &#x2F;&#x2F; 举例来说，对于一个带有动态参数的路径 &#x2F;foo&#x2F;:id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，</span><br><span class="line">      &#x2F;&#x2F; 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">      &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整的导航解析流程</li>
</ul>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。<code>beforeRouteLeave</code></li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 <code>DOM</code> 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 next 的回调函数。</li>
</ol>
<h5 id="路由钩子在实际开发中的应用场景"><a href="#路由钩子在实际开发中的应用场景" class="headerlink" title="路由钩子在实际开发中的应用场景"></a>路由钩子在实际开发中的应用场景</h5><p>beforeRouteLeave, 使用场景分别为一下三类情况：<br>1、清除当前组件中的定时器,当一个组件中有一个定时器时, 在路由进行切换的时候, 可使用beforeRouteLeave将定时器进行清楚, 以免占用内存:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line"> window.clearInterval(this.timer) &#x2F;&#x2F;清除定时器</span><br><span class="line"> next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转如果页面内有重要的信息需要用户保存后才能进行跳转, 或者有弹出框的情况. 应该阻止用户跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line"> &#x2F;&#x2F;判断是否弹出框的状态和保存信息与否</span><br><span class="line"> if (this.dialogVisibility &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">  this.dialogVisibility &#x3D; false &#x2F;&#x2F;关闭弹出框</span><br><span class="line">  next(false) &#x2F;&#x2F;回到当前页面, 阻止页面跳转</span><br><span class="line"> &#125;else if(this.saveMessage &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">  &#x2F;&#x2F;弹出警告</span><br><span class="line">  next(false) &#x2F;&#x2F;回到当前页面, 阻止页面跳转</span><br><span class="line"> &#125;else &#123;</span><br><span class="line">  next() &#x2F;&#x2F;否则允许跳转</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、保存相关内容到Vuex中或Session中,当用户需要关闭页面时, 可以将公用的信息保存到session或Vuex中;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">  localStorage.setItem(name, content); &#x2F;&#x2F;保存到localStorage中</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>除了使用钩子函数外，我们也可以使用 watch 来监听 $route 对象，然后根据路由参数的变化来进行响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      &#39;$route&#39; (to, from) &#123;</span><br><span class="line">        &#x2F;&#x2F; 对路由变化作出响应...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-skeleton-webpack-plugin</title>
    <url>/2020/09/10/vue-skeleton-webpack-plugin/</url>
    <content><![CDATA[<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2020/09/10/vue-skeleton-webpack-plugin/image-20200910115921296.png" alt="image-20200910115921296"></p>
<a id="more"></a>

<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-skeleton-webpack-plugin</span><br></pre></td></tr></table></figure>



<h3 id="新建webpack-skeleton-conf-js"><a href="#新建webpack-skeleton-conf-js" class="headerlink" title="新建webpack.skeleton.conf.js"></a>新建webpack.skeleton.conf.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const merge &#x3D; require(&#39;webpack-merge&#39;)</span><br><span class="line">const baseWebpackConfig &#x3D; require(&#39;.&#x2F;webpack.base.conf&#39;)</span><br><span class="line">const nodeExternals &#x3D; require(&#39;webpack-node-externals&#39;)</span><br><span class="line">const utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">const config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">const isProduction &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">const sourceMapEnabled &#x3D; isProduction</span><br><span class="line">  ? config.build.productionSourceMap</span><br><span class="line">  : config.dev.cssSourceMap</span><br><span class="line"></span><br><span class="line">function resolve(dir) &#123;</span><br><span class="line">  return path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let skeletonWebpackConfig &#x3D; merge(baseWebpackConfig, &#123;</span><br><span class="line">  target: &#39;node&#39;,</span><br><span class="line">  devtool: false,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: resolve(&#39;..&#x2F;src&#x2F;entry-skeleton.js&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: Object.assign(&#123;&#125;, baseWebpackConfig.output, &#123;</span><br><span class="line">    libraryTarget: &#39;commonjs2&#39;</span><br><span class="line">  &#125;),</span><br><span class="line">  externals: nodeExternals(&#123;</span><br><span class="line">    whitelist: &#x2F;\.css$&#x2F;</span><br><span class="line">  &#125;),</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; important: enable extract-text-webpack-plugin</span><br><span class="line">skeletonWebpackConfig.module.rules[0].options.loaders &#x3D; utils.cssLoaders(&#123;</span><br><span class="line">  sourceMap: sourceMapEnabled,</span><br><span class="line">  extract: true</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; skeletonWebpackConfig</span><br></pre></td></tr></table></figure>



<h3 id="webpack-prod-conf-js-webpack-dev-conf-js"><a href="#webpack-prod-conf-js-webpack-dev-conf-js" class="headerlink" title="webpack.prod.conf.js/webpack.dev.conf.js"></a>webpack.prod.conf.js/webpack.dev.conf.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const SkeletonWebpackPlugin &#x3D; require(&#39;vue-skeleton-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">new SkeletonWebpackPlugin(&#123;</span><br><span class="line">      webpackConfig: require(&#39;.&#x2F;webpack.skeleton.conf&#39;),</span><br><span class="line">      quiet: true,</span><br><span class="line">      minimize: true,</span><br><span class="line">      router: &#123;</span><br><span class="line">        mode: &#39;hash&#39;,</span><br><span class="line">        routes: [</span><br><span class="line">            &#123;</span><br><span class="line">              path: &#39;&#x2F;page1&#39;,</span><br><span class="line">              skeletonId: &#39;skeleton1&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              path: &#39;&#x2F;Hello&#39;,</span><br><span class="line">              skeletonId: &#39;skeleton2&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              path: &#39;&#x2F;&#39;,</span><br><span class="line">              skeletonId: &#39;skeleton2&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数说明</span><br><span class="line">webpackConfig 必填，渲染 skeleton 的 webpack 配置对象</span><br><span class="line">insertAfter 选填，渲染 DOM 结果插入位置，默认值为字符串 &#39;&lt;div id&#x3D;&quot;app&quot;&gt;&#39;</span><br><span class="line">也可以传入 Function，方法签名为 insertAfter(entryKey: string): string，返回值为挂载点字符串</span><br><span class="line">quiet 选填，在服务端渲染时是否需要输出信息到控制台</span><br><span class="line">router 选填 SPA 下配置各个路由路径对应的 Skeleton</span><br><span class="line">mode 选填 路由模式，两个有效值 history|hash</span><br><span class="line">routes 选填 路由数组，其中每个路由对象包含两个属性：</span><br><span class="line">path 路由路径</span><br><span class="line">skeletonId Skeleton DOM 的 id</span><br><span class="line">minimize 选填 SPA 下是否需要压缩注入 HTML 的 JS 代码</span><br></pre></td></tr></table></figure>



<h3 id="src下新建entry-skeleton-js"><a href="#src下新建entry-skeleton-js" class="headerlink" title="src下新建entry-skeleton.js"></a>src下新建entry-skeleton.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import Skeleton1 from &#39;.&#x2F;Skeleton1&#39;;</span><br><span class="line">import Skeleton2 from &#39;.&#x2F;Skeleton2&#39;;</span><br><span class="line"></span><br><span class="line">export default new Vue(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        Skeleton1,</span><br><span class="line">        Skeleton2</span><br><span class="line">    &#125;,</span><br><span class="line">    template: &#96;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;skeleton1 id&#x3D;&quot;skeleton1&quot; style&#x3D;&quot;display:none&quot;&#x2F;&gt;</span><br><span class="line">            &lt;skeleton2 id&#x3D;&quot;skeleton2&quot; style&#x3D;&quot;display:none&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="src下新建Skeleton1-vue-Skeleton1-vue"><a href="#src下新建Skeleton1-vue-Skeleton1-vue" class="headerlink" title="src下新建Skeleton1.vue/Skeleton1.vue"></a>src下新建Skeleton1.vue/Skeleton1.vue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Skeleton1.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;</span><br><span class="line">    Skeleton For Home</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;Skeleton For Home&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;Skeleton For Home&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;Skeleton For Home&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;Skeleton For Home&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;skeleton2&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.skeleton-header &#123;</span><br><span class="line">  height: 152px;</span><br><span class="line">  background: grey;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">  width: 152px;</span><br><span class="line">  margin: 60px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.skeleton-block &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  padding-top: 8px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">Skeleton2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;</span><br><span class="line">        &lt;header class&#x3D;&quot;skeleton-header&quot;&gt;&lt;&#x2F;header&gt;</span><br><span class="line">        &lt;section class&#x3D;&quot;skeleton-block&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;data:image&#x2F;svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTA4MCAyNjEiPjxkZWZzPjxwYXRoIGlkPSJiIiBkPSJNMCAwaDEwODB2MjYwSDB6Ii8+PGZpbHRlciBpZD0iYSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgeD0iLTUwJSIgeT0iLTUwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij48ZmVPZmZzZXQgZHk9Ii0xIiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIi8+PGZlQ29sb3JNYXRyaXggaW49InNoYWRvd09mZnNldE91dGVyMSIgdmFsdWVzPSIwIDAgMCAwIDAuOTMzMzMzMzMzIDAgMCAwIDAgMC45MzMzMzMzMzMgMCAwIDAgMCAwLjkzMzMzMzMzMyAwIDAgMCAxIDAiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDEpIj48dXNlIGZpbGw9IiMwMDAiIGZpbHRlcj0idXJsKCNhKSIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNiIi8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCA0NGg1MzN2NDZIMjMweiIvPjxyZWN0IHdpZHRoPSIxNzIiIGhlaWdodD0iMTcyIiB4PSIzMCIgeT0iNDQiIGZpbGw9IiNGNkY2RjYiIHJ4PSI0Ii8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCAxMThoMzY5djMwSDIzMHpNMjMwIDE4MmgzMjN2MzBIMjMwek04MTIgMTE1aDIzOHYzOUg4MTJ6TTgwOCAxODRoMjQydjMwSDgwOHpNOTE3IDQ4aDEzM3YzN0g5MTd6Ii8+PC9nPjwvc3ZnPg&#x3D;&#x3D;&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;data:image&#x2F;svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTA4MCAyNjEiPjxkZWZzPjxwYXRoIGlkPSJiIiBkPSJNMCAwaDEwODB2MjYwSDB6Ii8+PGZpbHRlciBpZD0iYSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgeD0iLTUwJSIgeT0iLTUwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij48ZmVPZmZzZXQgZHk9Ii0xIiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIi8+PGZlQ29sb3JNYXRyaXggaW49InNoYWRvd09mZnNldE91dGVyMSIgdmFsdWVzPSIwIDAgMCAwIDAuOTMzMzMzMzMzIDAgMCAwIDAgMC45MzMzMzMzMzMgMCAwIDAgMCAwLjkzMzMzMzMzMyAwIDAgMCAxIDAiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDEpIj48dXNlIGZpbGw9IiMwMDAiIGZpbHRlcj0idXJsKCNhKSIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNiIi8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCA0NGg1MzN2NDZIMjMweiIvPjxyZWN0IHdpZHRoPSIxNzIiIGhlaWdodD0iMTcyIiB4PSIzMCIgeT0iNDQiIGZpbGw9IiNGNkY2RjYiIHJ4PSI0Ii8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCAxMThoMzY5djMwSDIzMHpNMjMwIDE4MmgzMjN2MzBIMjMwek04MTIgMTE1aDIzOHYzOUg4MTJ6TTgwOCAxODRoMjQydjMwSDgwOHpNOTE3IDQ4aDEzM3YzN0g5MTd6Ii8+PC9nPjwvc3ZnPg&#x3D;&#x3D;&quot;&gt;</span><br><span class="line">        &lt;&#x2F;section&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;skeleton&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">.skeleton-header &#123;</span><br><span class="line">    height: 152px;</span><br><span class="line">    background: grey;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    width: 152px;</span><br><span class="line">    margin: 60px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.skeleton-block &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    padding-top: 8px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>



<p>attentions：项目需要重新启动，npm run build 打包</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-skeleton-webpack-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-前进后退f动画</title>
    <url>/2020/07/30/vue-%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80f%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p><strong>一丶首先配置路由并且修改路由配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">路由配置就不讲了</span><br><span class="line">重点，给VueRoute添加一个goBack方法，用于记录路由的前进后退状态 this.isBack &#x3D; true </span><br><span class="line">VueRouter.prototype.goBack &#x3D; function () &#123; </span><br><span class="line">　　this.isBack &#x3D; true</span><br><span class="line">　　window.history.go(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="二丶监听路由变化（在路由变化时判断此时的路由状态是前进还是后退）"><a href="#二丶监听路由变化（在路由变化时判断此时的路由状态是前进还是后退）" class="headerlink" title="二丶监听路由变化（在路由变化时判断此时的路由状态是前进还是后退）**"></a>二丶监听路由变化（在路由变化时判断此时的路由状态是前进还是后退）**</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">　　&lt;div&gt;</span><br><span class="line"></span><br><span class="line">　　　　动态绑定路由动画，根据路由状态的不同绑定不同的路由动画分别为  ：‘slide-left’  和 &#39;slide-right&#39;</span><br><span class="line"></span><br><span class="line">　　　　&lt;transition :name&#x3D;&quot;transitionName&quot;&gt; </span><br><span class="line">　　　　　　&lt;router-view class&#x3D;&quot;Router&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">　　　　&lt;&#x2F;transition&gt;</span><br><span class="line">　　&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">　　data() &#123;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　transitionName: &#39;slide-right&#39;  &#x2F;&#x2F; 默认动态路由变化为slide-right</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;,</span><br><span class="line">　　watch: &#123;</span><br><span class="line">　　　&#39;$route&#39; (to, from) &#123;</span><br><span class="line">　　　　let isBack &#x3D; this.$router.isBack  &#x2F;&#x2F;  监听路由变化时的状态为前进还是后退**</span><br><span class="line">　　　　　　if(isBack) &#123;</span><br><span class="line">　　　　　　　　this.transitionName &#x3D; &#39;slide-right&#39;</span><br><span class="line">　　　　　　&#125; else &#123;</span><br><span class="line">　　　　　　       this.transitionName &#x3D; &#39;slide-left&#39;</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　this.$router.isBack &#x3D; false</span><br><span class="line">　　&#125;</span><br><span class="line">　  &#125; </span><br><span class="line">　&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="三丶给前进后退动画添加不同的动画效果，具体代码如下："><a href="#三丶给前进后退动画添加不同的动画效果，具体代码如下：" class="headerlink" title="三丶给前进后退动画添加不同的动画效果，具体代码如下："></a>三丶给前进后退动画添加不同的动画效果，具体代码如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.Router &#123;</span><br><span class="line">     position: absolute;</span><br><span class="line">     width: 100%;</span><br><span class="line">     transition: all .8s ease;</span><br><span class="line">     top: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.slide-left-enter,</span><br><span class="line"> .slide-right-leave-active &#123;</span><br><span class="line">     opacity: 0;</span><br><span class="line">    -webkit-transform: translate(100%, 0);</span><br><span class="line">    transform: translate(100%, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.slide-left-leave-active,</span><br><span class="line">.slide-right-enter &#123;</span><br><span class="line">     opacity: 0;</span><br><span class="line">    -webkit-transform: translate(-100%, 0);</span><br><span class="line">    transform: translate(-100% 0);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>



<h3 id="四丶路由前进的时候按正常方法走就行了；"><a href="#四丶路由前进的时候按正常方法走就行了；" class="headerlink" title="四丶路由前进的时候按正常方法走就行了；"></a>四丶路由前进的时候按正常方法走就行了；</h3><h3 id="五丶后退的时候调用goBack方法就OK；"><a href="#五丶后退的时候调用goBack方法就OK；" class="headerlink" title="五丶后退的时候调用goBack方法就OK；"></a>五丶后退的时候调用<strong>goBack</strong>方法就OK；</h3>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-vuex</title>
    <url>/2020/08/05/vue-vuex/</url>
    <content><![CDATA[<h1 id="最全Vue状态管理模式"><a href="#最全Vue状态管理模式" class="headerlink" title="最全Vue状态管理模式"></a>最全Vue状态管理模式</h1><h2 id="一、初识VueX"><a href="#一、初识VueX" class="headerlink" title="一、初识VueX"></a>一、初识VueX</h2><h3 id="1-1-关于VueX"><a href="#1-1-关于VueX" class="headerlink" title="1.1 关于VueX"></a>1.1 关于<code>VueX</code></h3><p><code>VueX</code>是适用于在<code>Vue</code>项目开发时使用的状态管理工具。</p>
<p>试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步<code>data</code>中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。</p>
<p>为此，<code>Vue</code>为这些被多个组件频繁使用的值提供了一个统一管理的工具——<code>VueX</code>。</p>
<p>在具有<code>VueX</code>的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</p>
<h3 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h3><p>由于<code>VueX</code>是在学习<code>VueCli</code>后进行的，所以在下文出现的项目的目录请参照<code>VueCli 2.x</code>构建的目录。</p>
<p>以下步骤的前提是你已经完成了Vue项目构建，并且已转至该项目的文件目录下。</p>
<ul>
<li><p>Npm安装Vuex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vuex -s</span><br></pre></td></tr></table></figure>
</li>
<li><p>在项目的根目录下新增一个<code>store</code>文件夹，在该文件夹内创建index.js</p>
<p>此时你的项目的<code>src</code>文件夹应当是这样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">│  App.vue</span><br><span class="line">│  main.js</span><br><span class="line">│</span><br><span class="line">├─assets</span><br><span class="line">│      logo.png</span><br><span class="line">│</span><br><span class="line">├─components</span><br><span class="line">│      HelloWorld.vue</span><br><span class="line">│</span><br><span class="line">├─router</span><br><span class="line">│      index.js</span><br><span class="line">│</span><br><span class="line">└─store</span><br><span class="line">       index.js</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h3><h4 id="1-3-1-初始化store下index-js中的内容"><a href="#1-3-1-初始化store下index-js中的内容" class="headerlink" title="1.3.1 初始化store下index.js中的内容"></a>1.3.1 初始化<code>store</code>下<code>index.js</code>中的内容</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建VueX对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        <span class="comment">//存放的键值对就是所要管理的状态</span></span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>



<h4 id="1-3-2-将store挂载到当前项目的Vue实例当中去（官方提供了一种机制将状态从根组件-“注入”-到每一个子组件中）"><a href="#1-3-2-将store挂载到当前项目的Vue实例当中去（官方提供了一种机制将状态从根组件-“注入”-到每一个子组件中）" class="headerlink" title="1.3.2 将store挂载到当前项目的Vue实例当中去（官方提供了一种机制将状态从根组件 “注入” 到每一个子组件中）"></a>1.3.2 将store挂载到当前项目的Vue实例当中去（官方提供了一种机制将状态从根组件 “注入” 到每一个子组件中）</h4><p>打开main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,  <span class="comment">//store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="1-3-3-在组件中使用Vuex"><a href="#1-3-3-在组件中使用Vuex" class="headerlink" title="1.3.3 在组件中使用Vuex"></a>1.3.3 在组件中使用Vuex</h4><ul>
<li>原生写法</li>
</ul>
<p>那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在<a href="https://cn.vuejs.org/guide/computed.html" target="_blank" rel="noopener">计算属性</a>中返回某个状态，每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性，并刷新界面。如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.js</span><br><span class="line"><span class="keyword">import</span> Vue from <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export store</span><br><span class="line"></span><br><span class="line">.vue</span><br><span class="line"><span class="keyword">import</span> &#123;store&#125; from ./js</span><br><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123; <span class="keyword">return</span> &#123;&#125; &#125;,</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果你把 <code>store.state.count</code> 放在 data 中， <code>store.state.count</code> 的变化是不会主动触发界面刷新的，当然，也不能直接这样：<code>&lt;div&gt;&lt;/div&gt;</code> ，因为在模板中是无法直接访问到 store 对象的，所以这样写无疑会报错。</strong></p>
<ul>
<li>挂载全局写法</li>
</ul>
<p>例如在App.vue中，我们要将state中定义的name拿来在h1标签中显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        name:</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; $store.state.name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者要在组件方法中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line">methods:&#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$store.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>注意，请不要在此处更改<code>state</code>中的状态的值，后文中将会说明</strong></p>
<h3 id="1-4-安装Vue开发工具VueDevtools"><a href="#1-4-安装Vue开发工具VueDevtools" class="headerlink" title="1.4 安装Vue开发工具VueDevtools"></a>1.4 安装Vue开发工具VueDevtools</h3><p>在Vue项目开发中，需要监控项目中得各种值，为了提高效率，Vue提供了一款浏览器扩展——VueDevtools。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/16550832-e1b684e312a9bd1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>在学习VueX时，更为需要使用该插件。关于该插件的使用可以移步官网，在此不再赘叙。</p>
<h2 id="二、VueX中的核心内容"><a href="#二、VueX中的核心内容" class="headerlink" title="二、VueX中的核心内容"></a>二、VueX中的核心内容</h2><p>在VueX对象中，其实不止有<code>state</code>,还有用来操作<code>state</code>中数据的方法集，以及当我们需要对<code>state</code>中的数据需要加工的方法集等等成员。</p>
<p>成员列表：</p>
<ul>
<li>state     存放状态</li>
<li>mutations   state成员操作</li>
<li>getters     加工state成员给外界</li>
<li>actions     异步操作</li>
<li>modules   模块化状态管理</li>
</ul>
<h3 id="2-1-VueX的工作流程"><a href="#2-1-VueX的工作流程" class="headerlink" title="2.1 VueX的工作流程"></a>2.1 VueX的工作流程</h3><p><img src="https:////upload-images.jianshu.io/upload_images/16550832-20d0ad3c60a99111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/701/format/webp" alt="img"></p>
<p>Vuex官网给出的流程图</p>
<p>首先，<code>Vue</code>组件如果调用某个<code>VueX</code>的方法过程中需要向后端请求时或者说出现异步操作时，需要<code>dispatch</code> VueX中<code>actions</code>的方法，以保证数据的同步。可以说，<code>action</code>的存在就是为了让<code>mutations</code>中的方法能在异步操作中起作用。</p>
<p>如果没有异步操作，那么我们就可以直接在组件内提交状态中的<code>Mutations</code>中自己编写的方法来达成对<code>state</code>成员的操作。注意，<code>1.3.3节</code>中有提到，不建议在组件中直接对<code>state</code>中的成员进行操作，这是因为直接修改(例如：<code>this.$store.state.name = &#39;hello&#39;</code>)的话不能被<code>VueDevtools</code>所监控到。</p>
<p>最后被修改后的state成员会被渲染到组件的原位置当中去。</p>
<h3 id="2-2-Mutations"><a href="#2-2-Mutations" class="headerlink" title="2.2 Mutations"></a>2.2 Mutations</h3><p><code>mutations</code>是操作<code>state</code>数据的方法的集合，比如对该数据的修改、增加、删除等等。</p>
<h4 id="2-2-1-Mutations使用方法"><a href="#2-2-1-Mutations使用方法" class="headerlink" title="2.2.1 Mutations使用方法"></a>2.2.1 Mutations使用方法</h4><p><code>mutations</code>方法都有默认的形参：</p>
<p>(<strong>[state]</strong> <strong>[,payload]</strong>)</p>
<ul>
<li><code>state</code>是当前<code>VueX</code>对象中的<code>state</code></li>
<li><code>payload</code>是该方法在被调用时传递参数使用的</li>
</ul>
<p>例如，我们编写一个方法，当被执行时，能把下例中的name值修改为<code>&quot;jack&quot;</code>,我们只需要这样做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.js</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        <span class="comment">//es6语法，等同edit:funcion()&#123;...&#125;</span></span><br><span class="line">        edit(state)&#123;</span><br><span class="line">            state.name = <span class="string">'jack'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>而在组件中，我们需要这样去调用这个<code>mutation</code>——例如在App.vue的某个<code>method</code>中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-Mutation传值"><a href="#2-2-2-Mutation传值" class="headerlink" title="2.2.2 Mutation传值"></a>2.2.2 Mutation传值</h4><p>在实际生产过程中，会遇到需要在提交某个<code>mutation</code>时需要携带一些参数给方法使用。</p>
<p>单个值提交时:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>当需要多参提交时，推荐把他们放在一个对象中来提交:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>,&#123;<span class="attr">age</span>:<span class="number">15</span>,<span class="attr">sex</span>:<span class="string">'男'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>接收挂载的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">edit(state,payload)&#123;</span><br><span class="line">    state.name = <span class="string">'jack'</span></span><br><span class="line">    <span class="built_in">console</span>.log(payload) <span class="comment">// 15或&#123;age:15,sex:'男'&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另一种提交方式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">    type:<span class="string">'edit'</span>,</span><br><span class="line">    payload:&#123;</span><br><span class="line">        age:<span class="number">15</span>,</span><br><span class="line">        sex:<span class="string">'男'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-3-增删state中的成员"><a href="#2-2-3-增删state中的成员" class="headerlink" title="2.2.3 增删state中的成员"></a>2.2.3 增删state中的成员</h4><p>为了配合Vue的响应式数据，我们在Mutations的方法中，应当使用Vue提供的方法来进行操作。如果使用<code>delete</code>或者<code>xx.xx = xx</code>的形式去删或增，则Vue不能对数据进行实时响应。</p>
<ul>
<li><p>Vue.set 为某个对象设置成员的值，若不存在则新增</p>
<p>例如对state对象中添加一个age成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.set(state,<span class="string">"age"</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.delete 删除成员</p>
<p>将刚刚添加的age成员删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.delete(state,<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2-2-4使用常量"><a href="#2-2-4使用常量" class="headerlink" title="2.2.4使用常量"></a>2.2.4使用常量</h4><p>就是使用常量来替代 mutation 事件的名字。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可能有人会有疑问啊，这样做到底有啥用，还得多创建个类型文件，用的时候还要导入进来，不嫌麻烦吗！</p>
<p>我们看看，mutation 是怎么调用的：<code>store.commit(&#39;increment&#39;)</code>，可以发现，这里 commit 提交的方法 <code>increment</code>，是以字符串的形式代入的。而定义成常量具有唯一性，不允许重复定义或覆盖。</p>
<h3 id="2-3-Getters"><a href="#2-3-Getters" class="headerlink" title="2.3 Getters"></a>2.3 Getters</h3><p>可以对state中的成员加工后传递给外界</p>
<p>Getters中的方法有两个默认参数</p>
<ul>
<li>state 当前VueX对象中的状态对象</li>
<li>getters 当前getters对象，用于将getters下的其他getter拿来用</li>
</ul>
<h4 id="粗说"><a href="#粗说" class="headerlink" title="粗说"></a>粗说</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">    nameInfo(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名:"</span>+state.name</span><br><span class="line">    &#125;,</span><br><span class="line">    fullInfo(state,getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> getters.nameInfo+<span class="string">'年龄:'</span>+state.age</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件中调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.getters.fullInfo</span><br></pre></td></tr></table></figure>



<h4 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h4><p>有时候，我们会发现 State 中的数据，并不是我们直接想要的，而是需要经过相应的处理后，才能满足我们的需求。</p>
<p>比如在一个组件中，我们需要把 state 中的日期 <code>date</code> 转换成星期几来展示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  weekDate () &#123;</span><br><span class="line">    <span class="keyword">return</span> moment(<span class="keyword">this</span>.$store.state.date).format(<span class="string">'dddd'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里的 <a href="http://momentjs.cn/" target="_blank" rel="noopener">moment</a> 是一个第三方日期处理类库，使用之前需要导入。</p>
<p>如果只有一个组件需要这样做还好，但如果在很多组件中，都需要这么转换的话，那就得在每一个组件中都需要把这个函数复制过去。而且，一旦产品经理心情不好，不想用星期几来显示，想直接用 <code>2018-10-30 11:12:23</code> 这种方式来显示日期，那你就得在所有用到它的组件中去更改日期格式化的方法，岂不难受至极。就算你把它单独抽取出来作为一个公共的函数，各种导入也麻烦，最重要的是不好统一管理。</p>
<p>所以，这个时候，Vuex 又引入了一个牛逼的玩意儿，<strong>Getter</strong>。我们可以把它当成 store 中的计算属性（computed）。</p>
<blockquote>
<p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
</blockquote>
<p>我们看看这两个例子，着重注意下里面的注释：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">// Getter 接受 state 作为其第一个参数</span></span><br><span class="line">    weekDate: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> moment(state.date).format(<span class="string">'dddd'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// Getter 还也可以接收 getters 作为第二个参数</span></span><br><span class="line">  dateLength: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.weekDate.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不但如此，Getter 还会将 store.getters 对象暴露出去，你可以以属性的形式访问这些值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">store</span><span class="selector-class">.getters</span><span class="selector-class">.weekDate</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以很容易地在任何组件中使用它：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  weekDate () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.weekDate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在需求又变了，每个模块要显示的 weekDate 的格式不一样，有的显示全部日期，有的需要显示星期几，怎么办？</p>
<p><strong>好办，那就给 Getter 传参呗，但是怎么传呢？</strong></p>
<p>因为 Getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的，所以是不能直接 <code>store.getters.weekDate(&#39;MM Do YY&#39;)</code>，因为 weekDate 并不是一个函数，它仅仅只是一个属性而已。</p>
<p>那么既然属性不能传参，怎么办呢？那我们就想办法把这个属性变成一个函数不就行了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// 返回一个函数，就可以传参了</span></span><br><span class="line">  weekDate: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">fm</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> moment(state.date).format(fm ? fm : <span class="string">'dddd'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">store.getters.weekDate(<span class="string">'MM Do YY'</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-4-Actions"><a href="#2-4-Actions" class="headerlink" title="2.4 Actions"></a>2.4 Actions</h3><h4 id="粗说-1"><a href="#粗说-1" class="headerlink" title="粗说"></a>粗说</h4><p>由于直接在<code>mutation</code>方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交<code>mutation</code>方法。</p>
<p><code>Actions</code>中的方法有两个默认参数</p>
<ul>
<li><code>context</code> 上下文(相当于箭头函数中的this)对象</li>
<li><code>payload</code> 挂载参数</li>
</ul>
<p>例如，我们在两秒中后执行<code>2.2.2</code>节中的<code>edit</code>方法</p>
<p>由于<code>setTimeout</code>是异步操作，所以需要使用<code>actions</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    aEdit(context,payload)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">'edit'</span>,payload)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中调用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'aEdit'</span>,&#123;<span class="attr">age</span>:<span class="number">15</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>改进:</strong></p>
<p>由于是异步操作，所以我们可以为我们的异步操作封装为一个<code>Promise</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">aEdit(context,payload)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">'edit'</span>,payload)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="细说-1"><a href="#细说-1" class="headerlink" title="细说"></a>细说</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Action 类似于 mutation，不同在于：</span><br><span class="line"></span><br><span class="line">1、Action 提交的是 mutation，而不是直接变更状态。</span><br><span class="line">2、Action 可以包含任意异步操作。</span><br></pre></td></tr></table></figure>

<p>看一个简单的 action 示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到，Action 函数接受一个 <code>context</code> 参数，注意，这个参数可不一般，它与 store 实例有着相同的方法和属性，但是他们并不是同一个实例，后面学习 Modules 的时候会介绍它们为什么不一样。</p>
<p>所以在这里可以使用 <code>context.commit</code> 来提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p>
<p>当然，为了代码简化，我们可以使用 ES2015 的 <a href="https://github.com/lukehoban/es6features#destructuring" target="_blank" rel="noopener">参数解构</a> 来直接展开，便于 <code>commit</code>、<code>state</code> 等多次调用。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Mutation 通过 <code>store.commit</code> 触发，那么 Action 则通过 <code>store.dispatch</code> 方法触发。</p>
<p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 Mutation 分发的方式异曲同工，这是注意这里是 <code>dispatch</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意示例中正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p>
</blockquote>
<h5 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h5><blockquote>
<p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>
</blockquote>
<p>不知道什么是 Promise 的，可以 <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="noopener">戳此了解下</a>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然，也可以这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以利用 <a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="noopener">async / await</a> 的方式组合 action ：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="keyword">async</span> <span class="title">actionA</span> (<span class="params">&#123; commit &#125;</span>)</span> &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">async</span> <span class="title">actionB</span> (<span class="params">&#123; dispatch, commit &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
</blockquote>
<p>我们在实际项目中经常的会遇到这种情况，比如说你现在想要处理 B 事件，但是 B 事件需要一种资源才能进行，而这种资源必须通过 A 事件来获得。这个时候，我们就需要组合 Action 来处理这些事件了。</p>
<h3 id="2-5mapState、mapGetters、mapActions、mapMutations的使用"><a href="#2-5mapState、mapGetters、mapActions、mapMutations的使用" class="headerlink" title="2.5mapState、mapGetters、mapActions、mapMutations的使用"></a>2.5mapState、mapGetters、mapActions、mapMutations的使用</h3><h4 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h4><p>通过前面的学习，我们知道，从 store 实例中读取状态最简单的方法就是在<a href="https://cn.vuejs.org/guide/computed.html" target="_blank" rel="noopener">计算属性</a>中返回某个状态。</p>
<p>那么，当一个组件需要获取多个状态的时候，怎么办？是不是这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">      a () &#123;</span><br><span class="line">        <span class="keyword">return</span> store.state.a</span><br><span class="line">      &#125;,</span><br><span class="line">      b () &#123;</span><br><span class="line">        <span class="keyword">return</span> store.state.b</span><br><span class="line">      &#125;,</span><br><span class="line">      c () &#123;</span><br><span class="line">        <span class="keyword">return</span> store.state.c</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这样是没问题的，但是总感觉写起来很难受，看起来更难受是吧！既然这么容易我们就感受到了，Vuex 能感受不到吗，能忍得了吗？</p>
<p>绝对不能忍，所以 <code>mapState</code> 辅助函数被创造了出来，用来搞定这个人人为之咬牙切齿的痛点。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.b,</span><br><span class="line">    c: <span class="function"><span class="params">state</span> =&gt;</span> state.c,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'b'</span></span><br><span class="line">    <span class="comment">// 等同于 `state =&gt; state.b`</span></span><br><span class="line">    bAlias: <span class="string">'b'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态</span></span><br><span class="line">    <span class="comment">// 必须使用常规函数</span></span><br><span class="line">    cInfo (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.c + <span class="keyword">this</span>.info</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的示例，可以了解到，我们可以直接把需要用到的状态全部存放在 <code>mapState</code> 里面进行统一管理，而且还可以取别名，做额外的操作等等。</p>
<p>如果所映射的计算属性名称与 state 的子节点名称相同时，我们还可以更加简化，给 <code>mapState</code> 传一个字符串数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.a 为 store.state.a</span></span><br><span class="line">  <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'b'</span>,</span><br><span class="line">  <span class="string">'c'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>因为 <code>computed</code> 这个计算属性接收的是一个对象，所以由上面的示例代码可以看出，<code>mapState</code> 函数返回的是一个对象，现在如果想要和局部的计算属性混合使用的话，可以使用 ES6 的语法这样写来大大简化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; </span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了 <code>mapState</code> 辅助函数后，接下来的几个辅助函数的用法也基本上都差不多了，我们继续往下看。</p>
<h4 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h4><p>这个和 <code>mapState</code> 基本上没啥区别，简单看下官方的例子，就懂了：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取个别名，那就用对象的形式，以下示例的意思就是把 <code>this.doneCount</code> 映射为 <code>this.$store.getters.doneTodosCount</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mapGetters</span>(&#123;</span><br><span class="line">  <span class="attribute">doneCount</span>: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h4><p>直接看示例代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="comment">// 将 `this.increment()` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store.commit('increment')`</span></span><br><span class="line">      <span class="string">'increment'</span>, </span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="comment">// 将 `this.incrementBy(amount)` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store.commit('incrementBy', amount)`</span></span><br><span class="line">      <span class="string">'incrementBy'</span> </span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      <span class="comment">// 将 `this.add()` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store.commit('increment')`</span></span><br><span class="line">      add: <span class="string">'increment'</span> </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简直不要太好用，连载荷也可以直接支持。</p>
<h4 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h4><p>和 <code>mapMutations</code> 用法一模一样，换个名字即可。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="comment">// 将 `this.increment()` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store. dispatch('increment')`</span></span><br><span class="line">      <span class="string">'increment'</span>, </span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="comment">// 将 `this.incrementBy(amount)` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store. dispatch('incrementBy', amount)`</span></span><br><span class="line">      <span class="string">'incrementBy'</span> </span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      <span class="comment">// 将 `this.add()` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store. dispatch('increment')`</span></span><br><span class="line">      add: <span class="string">'increment'</span> </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要在组件中调用，直接 <code>this.xxx</code> 就完了。</p>
<h3 id="2-6-Models"><a href="#2-6-Models" class="headerlink" title="2.6 Models"></a>2.6 Models</h3><h4 id="粗说-2"><a href="#粗说-2" class="headerlink" title="粗说"></a>粗说</h4><p>当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 <code>state、mutation、action、getter</code>、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">models:&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        state:&#123;&#125;,</span><br><span class="line">        getters:&#123;&#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件内调用模块a的状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.a</span><br></pre></td></tr></table></figure>

<p>而提交或者<code>dispatch</code>某个方法和以前一样,会自动执行所有模块内的对应<code>type</code>的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'editKey'</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'aEditKey'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="细说-2"><a href="#细说-2" class="headerlink" title="细说"></a>细说</h4><p>在前言里面，我们已经了 Module 的基本职责，那么具体如何使用呢？</p>
<p>Vuex 允许我们将 store 分割成大大小小的对象，每个对象也都拥有自己的 state、getter、mutation、action，这个对象我们把它叫做 module（模块），在模块中还可以继续嵌套子模块、子子模块 ……</p>
<p>现在在 <code>src</code> 里面建个文件夹，命名为 <code>module</code>，然后再里面新建一个 <code>moduleA.js</code> 文件，并编写如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> &#123;</span><br><span class="line">    <span class="attribute">state</span>: &#123;</span><br><span class="line">        text: <span class="string">'moduleA'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">getters</span>: &#123;&#125;,</span><br><span class="line">    <span class="selector-tag">mutations</span>: &#123;&#125;,</span><br><span class="line">    <span class="selector-tag">actions</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，再建一个 <code>moduleB.js</code> 文件，这里就不重复了。</p>
<p>然后打开 <code>store.js</code> 文件，导入这两个 module ：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">'./module/moduleA'</span>;</span><br><span class="line"><span class="keyword">import</span> moduleB <span class="keyword">from</span> <span class="string">'./module/moduleB'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        moduleA, moduleB,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，store 中已经注入了两个子模块 <code>moduleA moduleB</code>，我们可以在 <code>App.vue</code> 中通过 <code>this.$store.state.moduleA.text</code> 这种方式来直接访问模块中的 state 数据。如下修改：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        name: <span class="function"><span class="params">state</span> =&gt;</span> state.moduleA.text</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>由此可知，模块内部的 state 是局部的，只属于模块本身所有，所以外部必须通过对应的模块名进行访问。</p>
<p><strong>但是</strong>注意了：</p>
<p>模块内部的 action、mutation 和 getter 默认可是注册在<strong>全局命名空间</strong>的，这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>这里以 mutation 的响应为例，给 moduleA 和 moduleB 分别新增一个 mutations，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    setText(state) &#123;</span><br><span class="line">        state.text = <span class="string">'A'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>moduleB 和上面一样，把文本名称修改一下即可，这里就不重复了。然后回到 <code>App.vue</code> 中，修改如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;mapState, mapMutations&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line">            ...mapState(&#123;</span><br><span class="line"><span class="javascript">                name: <span class="function"><span class="params">state</span> =&gt;</span> (state.moduleA.text + <span class="string">'和'</span> + state.moduleB.text)</span></span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            ...mapMutations([<span class="string">'setText'</span>]),</span></span><br><span class="line">            modifyNameAction() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.setText();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行然后点击修改，我们会发现模块 A 和 B 中的 <code>text</code> 值都改变了。当然，action 的用法一模一样，大家也可以试试。</p>
<p>如果模块之间的数据有交集的话，那么我们其实就可以通过这种方式，来同步更新模块之间的数据，虽然看起来非常的方便，但是用的时候可一定要谨慎，这种处理方式一旦没用好，遇到错误，排查起来还是比较有难度的。</p>
<h5 id="访问根节点"><a href="#访问根节点" class="headerlink" title="访问根节点"></a>访问根节点</h5><p>我们已经知晓，模块内部的 state 是局部的，只属于模块本身所有。那么如果我们要想在模块中访问 store 根节点的数据 state，怎么办呢？</p>
<p>很简单，我们可以在模块内部的 getter 和 action 中，通过 rootState 这个参数来获取。接下来，我们给 <code>modelA.js</code> 文件添加一点代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    getters: &#123;</span><br><span class="line">        <span class="comment">// 注意:rootState必须是第三个参数</span></span><br><span class="line">        detail(state, getters, rootState) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.text + <span class="string">'-'</span> + rootState.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        callAction(&#123;state, rootState&#125;) &#123;</span><br><span class="line">            alert(state.text + <span class="string">'-'</span> + rootState.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>App.vue</code> ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;mapActions, mapGetters&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line">            ...mapGetters(&#123;</span><br><span class="line"><span class="actionscript">                name: <span class="string">'detail'</span></span></span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            ...mapActions([<span class="string">'callAction'</span>]),</span></span><br><span class="line">            modifyNameAction() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.callAction();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后运行你会发现，根节点的数据已经被我们获取到了。这里需要注意的是在 getters 中，rootState 是以第三个参数暴露出来的，另外，还有第四个参数 rootGetters，用来获得根节点的 getters 信息，这里就不演示了，感兴趣自己可以去尝试。唯一要强调的就是千万不要弄错参数的位置了。</p>
<p>当然，action 中也能接收到 rootGetters，但是在 action 中，由于它接收过来的数据都被包在 <code>context</code> 对象中的，所以解包出来没有什么顺序的限制。</p>
<h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>前面我们已经知道了，模块内部的 action、mutation 和 getter 默认是注册在全局命名空间的。如果我们只想让他们在当前的模块中生效，应该怎么办呢？</p>
<p><strong>通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。</strong>当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<p>我们在 <code>moduleA.js</code> 中添加 <code>namespaced: true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候再去运行代码，你会发现如下错误：</p>
<blockquote>
<p>[vuex] unknown getter: detail</p>
</blockquote>
<p>在全局 getter 中已经找不到 <code>detail</code> 的这个方法了，因为它的路劲已经改变了，不再属于全局，仅仅只属于 moduleA 了。所以，这个时候，如果我们想要访问它，必须带上路劲才行。修改 <code>App.vue</code> 如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;mapActions, mapGetters&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line">            ...mapGetters(&#123;</span><br><span class="line"><span class="actionscript">                name: <span class="string">'moduleA/detail'</span></span></span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...mapActions(&#123;</span><br><span class="line"><span class="actionscript">                call: <span class="string">'moduleA/callAction'</span></span></span><br><span class="line">            &#125;),</span><br><span class="line">            modifyNameAction() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.call();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，如果一个模块启用了命名空间，那么它里面的 getter 和 action 中收到的 getter，dispatch 和 commit 也都是局部化的，不需要在同一模块内额外添加空间名前缀。也就是说，更改 <code>namespaced</code> 属性后不需要修改模块内的任何代码。</p>
<p>那么我们如何<strong>在带命名空间的模块内访问全局内容</strong>呢？</p>
<p>通过前面的学习，我们已经了解到：</p>
<blockquote>
<p>如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p>
</blockquote>
<p>现在如果想要在全局命名空间内分发 action 或提交 mutation 的话，那么我们只需要将 将 <code>{ root: true }</code> 作为第三参数传给 dispatch 或 commit 即可。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    namespaced: <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    actions: &#123;</span><br><span class="line">        callAction(&#123;state, commit, rootState&#125;) &#123;</span><br><span class="line">            commit(<span class="string">'setName'</span>, <span class="string">'改变'</span>, &#123;root: <span class="keyword">true</span>&#125;);</span><br><span class="line">            alert(state.text + <span class="string">'-'</span> + rootState.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看如何<strong>在带命名空间的模块内注册全局 action</strong>。</p>
<blockquote>
<p>若需要在带命名空间的模块注册全局 action，你可添加 <code>root: true</code>，并将这个 action 的定义放在函数 handler 中。</p>
</blockquote>
<p>写法稍微有点变化，我们来看看，修改 <code>moduleA.js</code>，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    actions: &#123;</span><br><span class="line">        callAction: &#123;</span><br><span class="line">            root: <span class="literal">true</span>,</span><br><span class="line">            handler (namespacedContext, payload) &#123;</span><br><span class="line">                <span class="keyword">let</span> &#123;state, commit&#125; = namespacedContext;</span><br><span class="line">                commit(<span class="string">'setText'</span>);</span><br><span class="line">                alert(state.text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单解释下，这里的 <code>namespacedContext</code> 就相当于当前模块的上下文对象，<code>payload</code> 是调用的时候所传入的参数，当然也叫载荷。</p>
<p>示例就讲到这里，接下来看看<strong>带命名空间的绑定函数</strong>。</p>
<p>关于 <code>mapState, mapGetters, mapActions</code> 和 <code>mapMutations</code> 这些函数如何来绑定带命名空间的模块，上面示例代码中其实已经都写过了，这里再看看另外几种更简便的写法，先看看之前的写法。</p>
<p>这里就用官方的示例代码举例说明：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">computed:</span> &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        <span class="symbol">a:</span> state =&gt; state.some.nested<span class="class">.<span class="keyword">module</span>.<span class="title">a</span>,</span></span><br><span class="line">        <span class="symbol">b:</span> state =&gt; state.some.nested<span class="class">.<span class="keyword">module</span>.<span class="title">b</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="symbol">methods:</span> &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">        /<span class="regexp">/ -&gt; this['some/nested</span><span class="regexp">/module/foo</span><span class="string">']()</span></span><br><span class="line"><span class="string">        '</span>some/nested/<span class="class"><span class="keyword">module</span>/<span class="title">foo</span>', </span></span><br><span class="line">        /<span class="regexp">/ -&gt; this['some/nested</span><span class="regexp">/module/bar</span><span class="string">']()</span></span><br><span class="line"><span class="string">        '</span>some/nested/<span class="class"><span class="keyword">module</span>/<span class="title">bar</span>' </span></span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更优雅的写法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">        a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">        b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">'some/nested/module'</span>, [</span><br><span class="line">        <span class="string">'foo'</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">        <span class="string">'bar'</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。</p>
<p>我们还可以通过使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">'some/nested/module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">      b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'foo'</span>,</span><br><span class="line">      <span class="string">'bar'</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="模块的动态注册"><a href="#模块的动态注册" class="headerlink" title="模块的动态注册"></a>模块的动态注册</h5><p>这一章节，官网讲得比较清楚，所以直接搬过来了。</p>
<blockquote>
<p>在 store 创建之后，可以使用 <code>store.registerModule</code> 方法动态的注册模块：</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p>
<p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，<a href="https://github.com/vuejs/vuex-router-sync" target="_blank" rel="noopener"><code>vuex-router-sync</code></a> 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p>
<p>你也可以使用 <code>store.unregisterModule(moduleName)</code> 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</p>
<p>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 <code>preserveState</code> 选项将其归档：<code>store.registerModule(&#39;a&#39;, module, { preserveState: true })</code>。</p>
</blockquote>
<h5 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h5><p>就一点，重用会导致模块中的数据 state 被污染，所以和 Vue 中的 data 一样，也使用一个函数来申明 state 即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyReusableModule = &#123;</span><br><span class="line">  state () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、规范目录结构"><a href="#三、规范目录结构" class="headerlink" title="三、规范目录结构"></a>三、规范目录结构</h2><p>如果把整个<code>store</code>都放在<code>index.js</code>中是不合理的，所以需要拆分。比较合适的目录格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">store:.</span><br><span class="line">│  actions.js</span><br><span class="line">│  getters.js</span><br><span class="line">│  index.js</span><br><span class="line">│  mutations.js</span><br><span class="line">│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入</span><br><span class="line">│</span><br><span class="line">└─modules</span><br><span class="line">        Astore.js</span><br></pre></td></tr></table></figure>

<p>对应的内容存放在对应的文件中，和以前一样，在<code>index.js</code>中存放并导出<code>store</code>。<code>state</code>中的数据尽量放在<code>index.js</code>中。而<code>modules</code>中的<code>Astore</code>局部模块状态如果多的话也可以进行细分。</p>
<p>参考链接：<a href="https://www.jianshu.com/p/2e5973fe1223" target="_blank" rel="noopener">https://www.jianshu.com/p/2e5973fe1223</a></p>
<p>参考链接：<a href="https://www.jianshu.com/p/83d5677b0928" target="_blank" rel="noopener">https://www.jianshu.com/p/83d5677b0928</a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-slot</title>
    <url>/2020/08/04/vue-slot/</url>
    <content><![CDATA[<h2 id="什么是插槽？"><a href="#什么是插槽？" class="headerlink" title="什么是插槽？"></a>什么是插槽？</h2><ul>
<li>插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。</li>
<li>!!!插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</li>
</ul>
<a id="more"></a>

<h2 id="怎么用插槽？"><a href="#怎么用插槽？" class="headerlink" title="怎么用插槽？"></a>怎么用插槽？</h2><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slotOne1&gt;</span><br><span class="line">      &lt;p style&#x3D;&quot;color:red&quot;&gt;我是父组件插槽内容&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;slotOne1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在父组件引用的子组件中写入想要显示的内容（可以使用标签，也可以不用）</p>
</blockquote>
<p>子组件(slotOne1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;slotOne1&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是slotOne1组件&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在子组件中写入slot，slot所在的位置就是父组件要显示的内容</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144105784-1098819459.png" alt="img"></p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;slottwo&quot;&gt;</span><br><span class="line">    &lt;div&gt;slottwo&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在子组件中定义了三个slot标签，其中有两个分别添加了name属性header和footer</p>
</blockquote>
<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slot-two&gt;</span><br><span class="line">      &lt;p&gt;啦啦啦，啦啦啦，我是卖报的小行家&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;template slot&#x3D;&quot;header&quot;&gt;</span><br><span class="line">          &lt;p&gt;我是name为header的slot&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;p slot&#x3D;&quot;footer&quot;&gt;我是name为footer的slot&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;slot-two&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在父组件中使用template并写入对应的slot值来指定该内容在子组件中现实的位置（当然也不用必须写到template），没有对应值的其他内容会被放到子组件中没有添加name属性的slot中</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144415380-998676771.png" alt="img"></p>
<h3 id="插槽的默认内容"><a href="#插槽的默认内容" class="headerlink" title="插槽的默认内容"></a>插槽的默认内容</h3><p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slot-two&gt;&lt;&#x2F;slot-two&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;slottwo&quot;&gt;</span><br><span class="line">    &lt;slot&gt;我不是卖报的小行家&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在子组件的slot标签中写入内容，当父组件没有写入内容时会显示子组件的默认内容，当父组件写入内容时，会替换子组件的默认内容</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144645560-431732801.png" alt="img"></p>
<h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slot-two&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;slot-two&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name： &#39;Jack&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;slottwo&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112145001679-568383132.png" alt="img"></p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是作用域插槽的子组件</span><br><span class="line">    &lt;slot :data&#x3D;&quot;user&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;slotthree&#39;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: [</span><br><span class="line">        &#123;name: &#39;Jack&#39;, sex: &#39;boy&#39;&#125;,</span><br><span class="line">        &#123;name: &#39;Jone&#39;, sex: &#39;girl&#39;&#125;,</span><br><span class="line">        &#123;name: &#39;Tom&#39;, sex: &#39;boy&#39;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在子组件的slot标签上绑定需要的值</p>
</blockquote>
<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是作用域插槽</span><br><span class="line">    &lt;slot-three&gt;</span><br><span class="line">      &lt;template slot-scope&#x3D;&quot;user&quot;&gt;</span><br><span class="line">        &lt;div v-for&#x3D;&quot;(item, index) in user.data&quot; :key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;slot-three&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在父组件上使用slot-scope属性，user.data就是子组件传过来的值</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之上拉加载原理</title>
    <url>/2020/09/16/vue%E4%B9%8B%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>贴上效果展示：<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8DicribgBBbuvZ13dRfOBLsInRicV51f90TJDiblOfwq1LuN27vTaqssPfF5NeQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>样式方面不多赘述，滚动区域是给固定高度，设置 <code>overflow-y: auto</code> 来实现。</p>
<p>接下来看看js方面的实现，其实也很简单，触发的条件是：<code>可视高度</code> + <code>滚动距离</code> &gt;= <code>实际高度</code> 。例子我会使用<code>vue</code>来实现，和原生实现是一样的。</p>
<ul>
<li>可视高度(offsetHeight)：通过 <code>dom</code> 的 <code>offsetHeight</code> 获得，表示区域固定的高度。这里我推荐通过 <code>getBoundingClientRect()</code> 来获取高度，因为使用前者会引起浏览器回流，造成一些性能问题。</li>
<li>滚动高度(scrollTop)：滚动事件中通过 <code>e.target.scrollTop</code> 获取，表示滚动条距离顶部的px</li>
<li>实际高度(scrollHeight)：通过 <code>dom</code> 的 <code>scrollHeight</code> 获得，表示区域内所有内容的高度（包括滚动距离），也就是实际高度</li>
</ul>
<a id="more"></a>

<h1 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onScroll(e) &#123;</span><br><span class="line">    let scrollTop &#x3D; e.target.scrollTop &#x2F;&#x2F;滚动高度</span><br><span class="line">    let scrollHeight &#x3D; e.target.scrollHeight &#x2F;&#x2F;实际高度</span><br><span class="line">    let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)&#x2F;&#x2F;可视高度</span><br><span class="line">    let currentHeight &#x3D; scrollTop + offsetHeight</span><br><span class="line">    if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">        console.log(&#39;触底&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8Dicribp9bOZENlSxoMU2MQtaNovYQXIb65qUPxKwWtTibqm9icMicOxXsFSUlMQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>so easy~</p>
<h1 id="加点细节"><a href="#加点细节" class="headerlink" title="加点细节"></a>加点细节</h1><p>加点细节，现在我们希望是离底部一定距离就触发事件，而不是等到完全触底。如果你做过小程序，这和<code>onReachBottom</code>差不多的意思。</p>
<p>声明一个离底部的距离变量<code>reachBottomDistance</code></p>
<p>这时候触发条件：<code>可视高度</code> + <code>滚动距离</code> + <code>reachBottomDistance</code> &gt;= <code>实际高度</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">        let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">        let currentHeight &#x3D; scrollTop + offsetHeight + this.reachBottomDistance</span><br><span class="line">        if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">            console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8DicribkC2ZSbcwoQfvEQdXUGzpzibj2IK0xQawxOm2q1t6L5N0Sj21Mmb2fJw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>在距离底部100px时成功触发事件，但由于100px往下的区域是符合条件的，会导致一直触发，这不是我们想要的。</p>
<p>接下来做一些处理，让其进入后只触发一次:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isReachBottom: false,</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">        let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">        let currentHeight &#x3D; scrollTop + offsetHeight + this.reachBottomDistance</span><br><span class="line"></span><br><span class="line">        if(currentHeight &lt; scrollHeight &amp;&amp; this.isReachBottom)&#123;</span><br><span class="line">          this.isReachBottom &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.isReachBottom)&#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">          this.isReachBottom &#x3D; true</span><br><span class="line">          console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8Dicribqic9sKlSTeB0CianJYNJMViaUdChLxbic397ItI3Gb0O8VhpoadpCSzAQA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>实时去获取位置信息稍微会损耗性能，我们应该把不变的缓存起来，只实时获取可变的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isReachBottom: false,</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">      scrollHeight: 0,</span><br><span class="line">      offsetHeight: 0,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    &#x2F;&#x2F; 页面加载完成后  将高度存储起来</span><br><span class="line">    let dom &#x3D; document.querySelector(&#39;.comment-area .comment-list&#39;)</span><br><span class="line">    this.scrollHeight &#x3D; dom.scrollHeight</span><br><span class="line">    this.offsetHeight &#x3D; Math.ceil(dom.getBoundingClientRect().height)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let currentHeight &#x3D; scrollTop + this.offsetHeight + this.reachBottomDistance</span><br><span class="line"></span><br><span class="line">        if(currentHeight &lt; this.scrollHeight &amp;&amp; this.isReachBottom)&#123;</span><br><span class="line">          this.isReachBottom &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.isReachBottom)&#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentHeight &gt;&#x3D; this.scrollHeight) &#123;</span><br><span class="line">          this.isReachBottom &#x3D; true</span><br><span class="line">          console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现到这里就告一段落，如果你有更好的思路和值得改进的地方，欢迎交流~</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>上拉加载</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_template标签相关</title>
    <url>/2020/07/30/vue-template%E6%A0%87%E7%AD%BE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v-on:keyup.enter--@dblclick(双击)</span><br><span class="line">v-on:dblclick--@dblclick(双击)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><p><a href="https://cn.vuejs.org/v2/guide/forms.html#lazy" target="_blank" rel="noopener">.lazy</a></p>
<p>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了<a href="https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip" target="_blank" rel="noopener">上述</a>输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change事件进行同步：</p>
<!-- 在“change”时而非“input”时更新 --><input v-model.lazy="msg">

<p><a href="https://cn.vuejs.org/v2/guide/forms.html#number" target="_blank" rel="noopener">.number</a></p>
<p>如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p>
<input v-model.number="age" type="number">

<p>这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。</p>
<p><a href="https://cn.vuejs.org/v2/guide/forms.html#trim" target="_blank" rel="noopener">.trim</a></p>
<p>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p>
<input v-model.trim="msg">



<h3 id="is的作用"><a href="#is的作用" class="headerlink" title=":is的作用"></a>:is的作用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动态切换不同组件</span><br><span class="line">&lt;div v-bind:is&#x3D;&quot;currentView&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">return &#123;</span><br><span class="line">    currentView:&#39;component1&#39;</span><br><span class="line">     &#x2F;&#x2F;当前组件</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">解析DOM模板 : 解除限制元素</span><br><span class="line">&lt;table&gt;</span><br><span class="line">      &lt;my-component&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">&lt;!-- 这个自定义组件&lt;my-component&gt;会被作为无效的内容提升到外部，并导致最终渲染结果出错。 --&gt;</span><br><span class="line">&lt;table&gt; &lt;tr is&#x3D;&quot;my-component&quot;&gt;&lt;&#x2F;tr&gt; &lt;&#x2F;table&gt;</span><br><span class="line">&lt;!--增加is特性来扩展，从而达到可以在这些受限制的html元素中使用 --&gt;</span><br></pre></td></tr></table></figure>



<h3 id="vue中’-native’修饰符的使用"><a href="#vue中’-native’修饰符的使用" class="headerlink" title="vue中’. native’修饰符的使用"></a>vue中’. native’修饰符的使用</h3><p>该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，并且该修饰符对普通HTML标签是没有任何作用的。(子组件直接调用父组件中的方法)</p>
<p><img src="https://img-blog.csdnimg.cn/20200305115116484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F3cTE1MDM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="class类名"><a href="#class类名" class="headerlink" title="class类名"></a>class类名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class类名</span><br><span class="line">&lt;!-- 第一种方式:对象的形式 --&gt;</span><br><span class="line">&lt;!-- 第一个参数 类名， 第二个参数：boolean值 --&gt;</span><br><span class="line">&lt;!-- 对象的形式: 用花括号包裹起来，类名用引号， --&gt;</span><br><span class="line">&lt;!-- 优点: 以对象的形式可以写多个，用逗号分开 --&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;&#123;&#39;p1&#39; : true&#125;&quot;&gt;对象的形式(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;&#123;&#39;p1&#39; : false, &#39;p&#39;: true&#125;&quot;&gt;对象的形式(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种方式:三元表达式 注意点：放在数组中，类名要用引号--&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;[ 1 &lt; 2 ? &#39;p1&#39; : &#39;p&#39; ]&quot; &gt;三元表示式(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第三种方式: 数组的形式 --&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;[isTrue, isFalse]&quot;&gt;数组的形式(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组中用对象 --&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;[&#123;&#39;p1&#39;: false&#125;, isFalse]&quot;&gt;数组中使用对象(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!--补充:  class中还可以传方法，在方法中返回类名--&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;setClass&quot;&gt;通过方法设置class类名&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>



<h3 id="引入less注意点"><a href="#引入less注意点" class="headerlink" title="引入less注意点"></a>引入less注意点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单文件组件引用css文件的方式</span><br><span class="line">1.script中引入</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import &#39;bulma&#x2F;css&#x2F;bulma.css&#39;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">2.style中引入</span><br><span class="line">&lt;style lang&#x3D;&quot;stylus&quot;&gt;</span><br><span class="line">	@import &#39;~bulma&#x2F;css&#x2F;bulma.css&#39;;这个分号一定要写，要不会报错</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"> </span><br><span class="line">3.全局引入</span><br><span class="line">将外部的css文件放到style文件下，引入外部文件只需在main.js文件中</span><br><span class="line">import &#39;.&#x2F;style&#x2F;reset.css&#39;</span><br></pre></td></tr></table></figure>



<h3 id="v-once-保持插值表达式值不变，无法在console里改变app的值非响应式"><a href="#v-once-保持插值表达式值不变，无法在console里改变app的值非响应式" class="headerlink" title="v-once(保持插值表达式值不变，无法在console里改变app的值非响应式 )"></a>v-once(保持插值表达式值不变，无法在console里改变app的值非响应式 )</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v-once&#x3D;&quot;&#123;&#123;messenger&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="v-pre（不要解析变量-v-pre-原样输出）"><a href="#v-pre（不要解析变量-v-pre-原样输出）" class="headerlink" title="v-pre（不要解析变量 v-pre 原样输出）"></a>v-pre（不要解析变量 v-pre 原样输出）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v-pre&#x3D;&quot;&#123;&#123;messenger&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt; </span><br><span class="line"></span><br><span class="line">   &lt;loading&gt;&lt;&#x2F;loading&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;keep-laive&gt;</span><br></pre></td></tr></table></figure>

<p>当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行</p>
<p>被包裹在keep-alive中的组件的状态将会被保留，例如我们将某个列表类组件内容滑动到第100条位置，那么我们在切换到一个组件后再次切换回到该组件，该组件的位置状态依旧会保持在第100条列表处</p>
<ul>
<li><p>回到顶部</p>
<p>在keep-alive激活会触发activated钩子函数，那么在该函数内设置scrollTop为0</p>
</li>
<li><p>强制刷新某些组件</p>
<ul>
<li>利用include、exclude属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include&#x3D;&quot;bookLists,bookLists&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive exclude&#x3D;&quot;indexLists&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>include属性表示只有name属性为bookLists，bookLists的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存exclude属性表示除了name属性为indexLists的组件不会被缓存，其它组件都会被缓存</p>
<ul>
<li><ul>
<li>利用meta属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export</span><br><span class="line">default[&#123;</span><br><span class="line">        path:</span><br><span class="line">        &#39;&#x2F;&#39;,</span><br><span class="line">        name: &#39;home&#39;,</span><br><span class="line">        components: Home,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            keepAlive: true &#x2F;&#x2F;需要被缓存的组件 </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        path: &#39;&#x2F;book&#39;,</span><br><span class="line">        name: &#39;book&#39;,</span><br><span class="line">        components: Book,</span><br><span class="line">        meta: &#123;</span><br><span class="line">        keepAlive: false &#x2F;&#x2F;不需要被缓存的组件 </span><br><span class="line">        &#125;</span><br><span class="line">       ]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt; </span><br><span class="line"> 	&lt;router-view v-if&#x3D;&quot;this.$route.meat.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"> 	&lt;!--这里是会被缓存的组件--&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line"> 	 &lt;router-view v-if&#x3D;&quot;!this.$route.meat.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  	&lt;!--这里是不会被缓存的组件--&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>



<h3 id="data-v-23d425f8-属性"><a href="#data-v-23d425f8-属性" class="headerlink" title="[data-v-23d425f8]属性"></a>[data-v-23d425f8]属性</h3><p> 这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的’data-v-xxx’标记</p>
<p>使用深度选择器/deep/可以改变第三方的样式，并且会又data-v属性，不会污染全局，只在当前作用域生效，相当于scoped</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.van-tabs &#x2F;deep&#x2F; .van-ellipsis &#123; color: blue&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>编译后的结果就是：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/nyQjSftfElZ8QI3e1icLryxdaRFq0iaHdytHUuoDluRyGKZsr2MicRaRLHKqD7sYaYhYSHKpI0rgF6ERUbGyzN2kA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>这样就不会给van-ellipsis也添加[data-v-23d425f8]属性了。至此你可以愉快的修改第三方组件的样式了。</p>
<p>当然了这里的深度选择器<code>/deep/</code>是因为我用的<code>less</code>语言，如果你没有使用<code>less/sass</code>等，可以用<code>&gt;&gt;&gt;</code>符号。</p>
<style scoped>
    .parent >>> .child { /* ... */ }
</style>



<h3 id="清除定时器的-once方法"><a href="#清除定时器的-once方法" class="headerlink" title="清除定时器的$once方法"></a>清除定时器的$once方法</h3><p>该方法是通过$once这个事件侦听器器在定义完定时器之后的位置来清除定时器。以下是完整代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const timer &#x3D; setInterval(() &#x3D;&gt;&#123;                    </span><br><span class="line">    &#x2F;&#x2F; 某些定时器操作                </span><br><span class="line">&#125;, 500);            </span><br><span class="line">&#x2F;&#x2F; 通过$once来监听定时器，在beforeDestroy钩子可以被清除。</span><br><span class="line">this.$once(&#39;hook:beforeDestroy&#39;, () &#x3D;&gt; &#123;            </span><br><span class="line">    clearInterval(timer);                                    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="rem文件的导入问题："><a href="#rem文件的导入问题：" class="headerlink" title="rem文件的导入问题："></a>rem文件的导入问题：</h3><p>我们在做手机端时，适配是必须要处理的一个问题。例如，我们处理适配的方案就是通过写一个rem.js，原理很简单，就是根据网页尺寸计算html的font-size大小，基本上小伙伴们都知道，这里直接附上代码，不多做介绍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(c, d) &#123;</span><br><span class="line">    var e &#x3D; document.documentElement || document.body,</span><br><span class="line">    a &#x3D; &quot;orientationchange&quot; in window ? &quot;orientationchange&quot;: &quot;resize&quot;,</span><br><span class="line">    b &#x3D; function() &#123;</span><br><span class="line">        var f &#x3D; e.clientWidth;</span><br><span class="line">        e.style.fontSize &#x3D; (f &gt;&#x3D; 750) ? &quot;100px&quot;: 100 * (f &#x2F; 750) + &quot;px&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    b();</span><br><span class="line">    c.addEventListener(a, b, false)</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<p>这里说下怎么引入的问题，很简单。在main.js中，直接<code>import &#39;./config/rem&#39;</code>导入即可。import的路径根据你的文件路径去填写。</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p><strong>方式一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;empty v-model&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;empty&gt;复制代码</span><br></pre></td></tr></table></figure>

<p>子组件写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击该按钮触发父子组件的数据同步</span><br><span class="line">&lt;div class&#x3D;&quot;share-btn&quot; @click&#x3D;&quot;confirm&quot;&gt;确定&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收父组件传递的value值</span><br><span class="line">&#x2F;&#x2F; 注意，这种实现方法，这里只能使用value属性名</span><br><span class="line">props: &#123;            </span><br><span class="line">    value: &#123;                </span><br><span class="line">        type: Boolean,                </span><br><span class="line">        default: false            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;            </span><br><span class="line">    confirm () &#123;                </span><br><span class="line">        &#x2F;&#x2F; 双向数据绑定父组件:value对应的值 </span><br><span class="line">        &#x2F;&#x2F; 通过$emit触发父组件input事件，第二个参数为传递给父组件的值，这里传递了一个false值 </span><br><span class="line">        &#x2F;&#x2F; 可以理解为最上面展示的@input&#x3D;&quot;msg &#x3D; $event.target.value&quot;这个事件</span><br><span class="line">        &#x2F;&#x2F; 即触发父组件的input事件，并将传递的值‘false’赋值给msg             </span><br><span class="line">        this.$emit(&#39;input&#39;, false)            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;empty v-model&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;empty&gt;复制代码</span><br></pre></td></tr></table></figure>

<p>子组件写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;share-btn&quot; @click&#x3D;&quot;confirm&quot;&gt;确定&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; model选项用来避免冲突</span><br><span class="line">&#x2F;&#x2F; prop属性用来指定props属性中的哪个值用来接收父组件v-model传递的值</span><br><span class="line">&#x2F;&#x2F; 例如这里用props中的show来接收父组件传递的v-model值</span><br><span class="line">&#x2F;&#x2F; event：为了方便理解，可以简单理解为父组件@input的别名，从而避免冲突</span><br><span class="line">&#x2F;&#x2F; event的值对应了你emit时要提交的事件名，你可以叫aa，也可以叫bb，但是要命名要有意义哦！！！</span><br><span class="line">model: &#123;            </span><br><span class="line">    prop: &#39;show&#39;,            </span><br><span class="line">    event: &#39;changed&#39;        </span><br><span class="line">&#125;,</span><br><span class="line">props: &#123;</span><br><span class="line">    &#x2F;&#x2F; 由于model选项中的prop属性指定了，所以show接收的是父组件v-model传递的值            </span><br><span class="line">    show: &#123;                </span><br><span class="line">        type: Boolean,                </span><br><span class="line">        default: false            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;,        </span><br><span class="line">methods: &#123;            </span><br><span class="line">    confirm () &#123;                </span><br><span class="line">        &#x2F;&#x2F; 双向数据绑定父组件传递的值</span><br><span class="line">        &#x2F;&#x2F; 第一个参数，对应model选项的event的值，你可以叫aa，bbb，ccc，起名随你 </span><br><span class="line">        this.$emit(&#39;changed&#39;, false)            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式三：.sync</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;empty :oneprop.sync&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;empty&gt;</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        msg: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;share-btn&quot; @click&#x3D;&quot;changeMsg&quot;&gt;改变msg值&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">props: &#123;            </span><br><span class="line">    oneprop: &#123;                </span><br><span class="line">        type: String,                </span><br><span class="line">        default: &#39;hello world&#39;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;,        </span><br><span class="line">methods: &#123;            </span><br><span class="line">    changeMsg () &#123;                </span><br><span class="line">        &#x2F;&#x2F; 双向数据流</span><br><span class="line">        this.$emit(&#39;update:msg&#39;, &#39;helow world&#39;)           </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="事件们"><a href="#事件们" class="headerlink" title="事件们"></a>事件们</h3><ul>
<li><code>vm.$emit(event ,[...args])</code>这个api，其主要作用就是用来触发当前实例上的事件。附加参数都会传给监听器回调。子组件也属于当前实例。第一个参数：要触发的事件名称。后续的参数可选：即作为参数传递给要触发的事件。文档</li>
<li>监听当前实例上的自定义事件，事件可以有$emit触发，也能<strong>通过hook监听到钩子函数，</strong></li>
</ul>
<p>vm.$on( event, callback )：一直监听；文档</p>
<p>vm.$once( event, callback )：监听一次；文档</p>
<p>vm.$off( [event, callback] )：移除监听；文档</p>
<p>监听$emit触发的自定义事件，上面已经有过用法了，监听钩子函数，在上面的定时器那块也有演示到。监听钩子函数的场景使用的不多，但是还是要知道的。</p>
<ul>
<li>vm.$attrs：可以获取到父组件传递的除class和style外的所有自定义属性。</li>
<li>vm.$listeners：可以获取到父组件传递的所有自定义事件</li>
</ul>
<p>例如：父组件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;empty</span><br><span class="line">    :msg&#x3D;&quot;message&quot;</span><br><span class="line">    :title&#x3D;&quot;articleTitle&quot;</span><br><span class="line">    @confirm&#x3D;&quot;func1&quot;</span><br><span class="line">    @cancel&#x3D;&quot;func2&quot;</span><br><span class="line">&gt;&lt;&#x2F;empty&gt;复制代码</span><br></pre></td></tr></table></figure>

<p>就可以在子组件中获取父组件传递的属性和事件，而不用在props中定义。子组件简单演示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created() &#123;            </span><br><span class="line">    const msg &#x3D; this.$attrs.msg; &#x2F;&#x2F; 获取父组件传递的msg</span><br><span class="line">    this.$listeners.confirm &amp;&amp; this.$listeners.confirm(); &#x2F;&#x2F;若组件传递事件confirm则执行</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之上拉加载原理</title>
    <url>/2020/09/16/vue%E4%B9%8B%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%89/</url>
    <content><![CDATA[<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>贴上效果展示：<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8DicribgBBbuvZ13dRfOBLsInRicV51f90TJDiblOfwq1LuN27vTaqssPfF5NeQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>样式方面不多赘述，滚动区域是给固定高度，设置 <code>overflow-y: auto</code> 来实现。</p>
<p>接下来看看js方面的实现，其实也很简单，触发的条件是：<code>可视高度</code> + <code>滚动距离</code> &gt;= <code>实际高度</code> 。例子我会使用<code>vue</code>来实现，和原生实现是一样的。</p>
<ul>
<li>可视高度(offsetHeight)：通过 <code>dom</code> 的 <code>offsetHeight</code> 获得，表示区域固定的高度。这里我推荐通过 <code>getBoundingClientRect()</code> 来获取高度，因为使用前者会引起浏览器回流，造成一些性能问题。</li>
<li>滚动高度(scrollTop)：滚动事件中通过 <code>e.target.scrollTop</code> 获取，表示滚动条距离顶部的px</li>
<li>实际高度(scrollHeight)：通过 <code>dom</code> 的 <code>scrollHeight</code> 获得，表示区域内所有内容的高度（包括滚动距离），也就是实际高度</li>
</ul>
<h1 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onScroll(e) &#123;</span><br><span class="line">    let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">    let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">    let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">    let currentHeight &#x3D; scrollTop + offsetHeight</span><br><span class="line">    if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">        console.log(&#39;触底&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8Dicribp9bOZENlSxoMU2MQtaNovYQXIb65qUPxKwWtTibqm9icMicOxXsFSUlMQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>so easy~</p>
<h1 id="加点细节"><a href="#加点细节" class="headerlink" title="加点细节"></a>加点细节</h1><p>加点细节，现在我们希望是离底部一定距离就触发事件，而不是等到完全触底。如果你做过小程序，这和<code>onReachBottom</code>差不多的意思。</p>
<p>声明一个离底部的距离变量<code>reachBottomDistance</code></p>
<p>这时候触发条件：<code>可视高度</code> + <code>滚动距离</code> + <code>reachBottomDistance</code> &gt;= <code>实际高度</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">        let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">        let currentHeight &#x3D; scrollTop + offsetHeight + this.reachBottomDistance</span><br><span class="line">        if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">            console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8DicribkC2ZSbcwoQfvEQdXUGzpzibj2IK0xQawxOm2q1t6L5N0Sj21Mmb2fJw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>在距离底部100px时成功触发事件，但由于100px往下的区域是符合条件的，会导致一直触发，这不是我们想要的。</p>
<p>接下来做一些处理，让其进入后只触发一次:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isReachBottom: false,</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">        let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">        let currentHeight &#x3D; scrollTop + offsetHeight + this.reachBottomDistance</span><br><span class="line"></span><br><span class="line">        if(currentHeight &lt; scrollHeight &amp;&amp; this.isReachBottom)&#123;</span><br><span class="line">          this.isReachBottom &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.isReachBottom)&#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">          this.isReachBottom &#x3D; true</span><br><span class="line">          console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8Dicribqic9sKlSTeB0CianJYNJMViaUdChLxbic397ItI3Gb0O8VhpoadpCSzAQA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>实时去获取位置信息稍微会损耗性能，我们应该把不变的缓存起来，只实时获取可变的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isReachBottom: false,</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">      scrollHeight: 0,</span><br><span class="line">      offsetHeight: 0,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    &#x2F;&#x2F; 页面加载完成后  将高度存储起来</span><br><span class="line">    let dom &#x3D; document.querySelector(&#39;.comment-area .comment-list&#39;)</span><br><span class="line">    this.scrollHeight &#x3D; dom.scrollHeight</span><br><span class="line">    this.offsetHeight &#x3D; Math.ceil(dom.getBoundingClientRect().height)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let currentHeight &#x3D; scrollTop + this.offsetHeight + this.reachBottomDistance</span><br><span class="line"></span><br><span class="line">        if(currentHeight &lt; this.scrollHeight &amp;&amp; this.isReachBottom)&#123;</span><br><span class="line">          this.isReachBottom &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.isReachBottom)&#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentHeight &gt;&#x3D; this.scrollHeight) &#123;</span><br><span class="line">          this.isReachBottom &#x3D; true</span><br><span class="line">          console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现到这里就告一段落，如果你有更好的思路和值得改进的地方，欢迎交流~</p>
]]></content>
  </entry>
  <entry>
    <title>vue_方法相关</title>
    <url>/2020/07/30/vue-%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="匹配字体标红"><a href="#匹配字体标红" class="headerlink" title="匹配字体标红"></a>匹配字体标红</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brightenKeyword: function(val, keyword) &#123;</span><br><span class="line">    &#x2F;&#x2F;val &#x3D; val + &#39;&#39;;</span><br><span class="line">    &#x2F;&#x2F;if (val.indexOf(keyword) !&#x3D;&#x3D; -1 &amp;&amp; keyword !&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F;    return val.replace(keyword, &#39;&lt;font color&#x3D;&quot;#409EFF&quot;&gt;&#39; + keyword + &#39;&lt;&#x2F;font&gt;&#39;)</span><br><span class="line">    &#x2F;&#x2F;&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;    return val</span><br><span class="line">    &#x2F;&#x2F;&#125;</span><br><span class="line">    const Reg &#x3D; new RegExp(keyword, &#39;i&#39;);</span><br><span class="line">    if (val) &#123;</span><br><span class="line">        return val.replace(Reg, &#96; &lt; span class &#x3D; &quot;redColor zl-theme-price&quot; &gt; $ &#123;keyword&#125; &lt; &#x2F;span&gt;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&#x2F;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="图片的循环输出"><a href="#图片的循环输出" class="headerlink" title="图片的循环输出"></a>图片的循环输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;&lt;img :src&#x3D;&quot;imgIcon[index]&quot; width&#x3D;&quot;15px&quot; &gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line"> data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        imgIcon:[</span><br><span class="line">          require(&#39;@&#x2F;common&#x2F;img&#x2F;icon-search00.png&#39;),</span><br><span class="line">          require(&#39;@&#x2F;common&#x2F;img&#x2F;icon-search01.png&#39;),</span><br><span class="line">          require(&#39;@&#x2F;common&#x2F;img&#x2F;icon-search02.png&#39;),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="别名-需要重启vscode才能生效"><a href="#别名-需要重启vscode才能生效" class="headerlink" title="别名(需要重启vscode才能生效)"></a>别名(需要重启vscode才能生效)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;@&#39;: resolve(&#39;src&#39;),</span><br><span class="line">&#39;components&#39;: resolve(&#39;@&#x2F;components&#39;),</span><br><span class="line"></span><br><span class="line">在标签内必须使用~</span><br><span class="line">&lt;img src&#x3D;&quot;~asset&#x2F;image&#x2F;header.jpng&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app1&quot;,</span><br><span class="line">    data:&#123;that:this&#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        f:function()&#123;</span><br><span class="line">          console.log(this) &#x2F;&#x2F;vue实例</span><br><span class="line">        &#125;,</span><br><span class="line">        f1:()&#x3D;&gt;&#123;</span><br><span class="line">            console.log(this)&#x2F;&#x2F;window</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">建议使用es5的用法，用that定义</span><br></pre></td></tr></table></figure>



<h3 id="非父子组件通信–创建空实例"><a href="#非父子组件通信–创建空实例" class="headerlink" title="非父子组件通信–创建空实例"></a>非父子组件通信–创建空实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;foo&gt;&lt;&#x2F;foo&gt;</span><br><span class="line">    &lt;bar&gt;&lt;&#x2F;bar&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;使用一个空的实例来作为中央事件总线。</span><br><span class="line">    var eventBus&#x3D;new Vue(&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;foo组件</span><br><span class="line">    Vue.component(&#39;foo&#39;,&#123;</span><br><span class="line">        template:&#39;&lt;div&gt;&lt;p&gt;the count of foo is &#123;&#123;fooCount&#125;&#125;&lt;&#x2F;p&gt;&#39; +</span><br><span class="line">                &#39;&lt;button @click&#x3D;&quot;emitevent&quot;&gt;Add bar\&#39;s count&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">        data:function () &#123;</span><br><span class="line">            return &#123;fooCount:0&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            emitevent:function () &#123;</span><br><span class="line">			&#x2F;&#x2F;这里要使用中央事件发送信号。</span><br><span class="line">                eventBus.$emit(&#39;emitevent&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;bar组件</span><br><span class="line">    Vue.component(&#39;bar&#39;,&#123;</span><br><span class="line">        template:&#39;&lt;div&gt;&lt;p&gt;the count of bar is &#123;&#123;barCount&#125;&#125;&lt;&#x2F;p&gt;&#39; +</span><br><span class="line">                &#39;&lt;button &gt;B&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">        data:function () &#123;</span><br><span class="line">            return &#123;barCount:0&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted:function () &#123;</span><br><span class="line">		&#x2F;&#x2F;这里要使用中央事件接受信号。并且是在组件挂载完成后。</span><br><span class="line">            var _this&#x3D;this;</span><br><span class="line">            eventBus.$on(&#39;emitevent&#39;,function () &#123;</span><br><span class="line">                _this.barCount+&#x3D;1; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    var app&#x3D;new Vue(&#123;</span><br><span class="line">        el:&#39;#app&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="常用js库"><a href="#常用js库" class="headerlink" title="常用js库"></a>常用js库</h3><h4 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h4><p>一个著名的javascript原生库，不需要引入其他第三方依赖</p>
<h4 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h4><p>一个纯JavaScript图表库 –<a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener">echarts.apache.org</a></p>
<h3 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h3><p>vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<h3 id="static和assets"><a href="#static和assets" class="headerlink" title="static和assets"></a>static和assets</h3><p>1.static中的文件是不会经过webpack编译的，一般建议存放一些外部第三方（公用）的静态资源文件。</p>
<p>2.assets因为会经过webpack编译，建议是存放一些只有组件自己使用到的静态资源。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之惯性滚动动效</title>
    <url>/2020/09/23/vue%E4%B9%8B%E6%83%AF%E6%80%A7%E6%BB%9A%E5%8A%A8%E5%8A%A8%E6%95%88/</url>
    <content><![CDATA[<p>见下文</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ref</span>=<span class="string">"wrapper"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchstart.prevent</span>=<span class="string">"onStart"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchmove.prevent</span>=<span class="string">"onMove"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchend.prevent</span>=<span class="string">"onEnd"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchcancel.prevent</span>=<span class="string">"onEnd"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">transitionend</span>=<span class="string">"onTransitionEnd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">ref</span>=<span class="string">"scroller"</span> <span class="attr">:style</span>=<span class="string">"scrollerStyle"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">        template: <span class="string">'#tpl'</span>,</span></span><br><span class="line">        computed: &#123;</span><br><span class="line">          list() &#123;&#125;,</span><br><span class="line">          scrollerStyle() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="string">'transform'</span>: <span class="string">`translate3d(0, <span class="subst">$&#123;<span class="keyword">this</span>.offsetY&#125;</span>px, 0)`</span>,</span></span><br><span class="line"><span class="javascript">              <span class="string">'transition-duration'</span>: <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.duration&#125;</span>ms`</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'transition-timing-function'</span>: <span class="keyword">this</span>.bezier,</span></span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line">            minY: 0,</span><br><span class="line">            maxY: 0,</span><br><span class="line">            wrapperHeight: 0,</span><br><span class="line">            duration: 0,</span><br><span class="line"><span class="actionscript">            bezier: <span class="string">'linear'</span>,</span></span><br><span class="line"><span class="actionscript">            pointY: <span class="number">0</span>,                    <span class="comment">// touchStart 手势 y 坐标</span></span></span><br><span class="line"><span class="actionscript">            startY: <span class="number">0</span>,                    <span class="comment">// touchStart 元素 y 偏移值</span></span></span><br><span class="line"><span class="actionscript">            offsetY: <span class="number">0</span>,                   <span class="comment">// 元素实时 y 偏移值</span></span></span><br><span class="line"><span class="actionscript">            startTime: <span class="number">0</span>,                 <span class="comment">// 惯性滑动范围内的 startTime</span></span></span><br><span class="line"><span class="actionscript">            momentumStartY: <span class="number">0</span>,            <span class="comment">// 惯性滑动范围内的 startY</span></span></span><br><span class="line"><span class="actionscript">            momentumTimeThreshold: <span class="number">300</span>,   <span class="comment">// 惯性滑动的启动 时间阈值</span></span></span><br><span class="line"><span class="actionscript">            momentumYThreshold: <span class="number">15</span>,       <span class="comment">// 惯性滑动的启动 距离阈值</span></span></span><br><span class="line"><span class="actionscript">            isStarted: <span class="literal">false</span>,             <span class="comment">// start锁</span></span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.wrapperHeight = <span class="keyword">this</span>.$refs.wrapper.getBoundingClientRect().height;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.minY = <span class="keyword">this</span>.wrapperHeight - <span class="keyword">this</span>.$refs.scroller.getBoundingClientRect().height;</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          onStart(e) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> point = e.touches ? e.touches[<span class="number">0</span>] : e;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.isStarted = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.duration = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.stop();</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.pointY = point.pageY;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.momentumStartY = <span class="keyword">this</span>.startY = <span class="keyword">this</span>.offsetY;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line">          &#125;,</span><br><span class="line">          onMove(e) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isStarted) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> point = e.touches ? e.touches[<span class="number">0</span>] : e;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> deltaY = point.pageY - <span class="keyword">this</span>.pointY;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.offsetY = <span class="built_in">Math</span>.round(<span class="keyword">this</span>.startY + deltaY);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 记录在触发惯性滑动条件下的偏移值和时间</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (now - <span class="keyword">this</span>.startTime &gt; <span class="keyword">this</span>.momentumTimeThreshold) &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.momentumStartY = <span class="keyword">this</span>.offsetY;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.startTime = now;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onEnd(e) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isStarted) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.isStarted = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.isNeedReset()) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> absDeltaY = <span class="built_in">Math</span>.abs(<span class="keyword">this</span>.offsetY - <span class="keyword">this</span>.momentumStartY);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> duration = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - <span class="keyword">this</span>.startTime;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 启动惯性滑动</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (duration &lt; <span class="keyword">this</span>.momentumTimeThreshold &amp;&amp; absDeltaY &gt; <span class="keyword">this</span>.momentumYThreshold) &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">const</span> momentum = <span class="keyword">this</span>.momentum(<span class="keyword">this</span>.offsetY, <span class="keyword">this</span>.momentumStartY, duration);</span></span><br><span class="line"><span class="javascript">              <span class="keyword">this</span>.offsetY = <span class="built_in">Math</span>.round(momentum.destination);</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.duration = momentum.duration;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.bezier = momentum.bezier;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onTransitionEnd() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.isNeedReset();</span></span><br><span class="line">          &#125;,</span><br><span class="line">          momentum(current, start, duration) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> durationMap = &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="string">'noBounce'</span>: <span class="number">2500</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'weekBounce'</span>: <span class="number">800</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'strongBounce'</span>: <span class="number">400</span>,</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> bezierMap = &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="string">'noBounce'</span>: <span class="string">'cubic-bezier(.17, .89, .45, 1)'</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'weekBounce'</span>: <span class="string">'cubic-bezier(.25, .46, .45, .94)'</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'strongBounce'</span>: <span class="string">'cubic-bezier(.25, .46, .45, .94)'</span>,</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> type = <span class="string">'noBounce'</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 惯性滑动加速度</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> deceleration = <span class="number">0.003</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 回弹阻力</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> bounceRate = <span class="number">10</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 强弱回弹的分割值</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> bounceThreshold = <span class="number">300</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 回弹的最大限度</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> maxOverflowY = <span class="keyword">this</span>.wrapperHeight / <span class="number">6</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> overflowY;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> distance = current - start;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> speed = <span class="number">2</span> * <span class="built_in">Math</span>.abs(distance) / duration;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> destination = current + speed / deceleration * (distance &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (destination &lt; <span class="keyword">this</span>.minY) &#123;</span></span><br><span class="line"><span class="actionscript">              overflowY = <span class="keyword">this</span>.minY - destination;</span></span><br><span class="line"><span class="actionscript">              type = overflowY &gt; bounceThreshold ? <span class="string">'strongBounce'</span> : <span class="string">'weekBounce'</span>;</span></span><br><span class="line"><span class="javascript">              destination = <span class="built_in">Math</span>.max(<span class="keyword">this</span>.minY - maxOverflowY, <span class="keyword">this</span>.minY - overflowY / bounceRate);</span></span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (destination &gt; <span class="keyword">this</span>.maxY) &#123;</span></span><br><span class="line"><span class="actionscript">              overflowY = destination - <span class="keyword">this</span>.maxY;</span></span><br><span class="line"><span class="actionscript">              type = overflowY &gt; bounceThreshold ? <span class="string">'strongBounce'</span> : <span class="string">'weekBounce'</span>;</span></span><br><span class="line"><span class="javascript">              destination = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.maxY + maxOverflowY, <span class="keyword">this</span>.maxY + overflowY / bounceRate);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">              destination,</span><br><span class="line">              duration: durationMap[type],</span><br><span class="line">              bezier: bezierMap[type],</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          <span class="comment">// 超出边界时需要重置位置</span></span></span><br><span class="line">          isNeedReset() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> offsetY;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.offsetY &lt; <span class="keyword">this</span>.minY) &#123;</span></span><br><span class="line"><span class="actionscript">              offsetY = <span class="keyword">this</span>.minY;</span></span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.offsetY &gt; <span class="keyword">this</span>.maxY) &#123;</span></span><br><span class="line"><span class="actionscript">              offsetY = <span class="keyword">this</span>.maxY;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">typeof</span> offsetY !== <span class="string">'undefined'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.offsetY = offsetY;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.duration = <span class="number">500</span>;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.bezier = <span class="string">'cubic-bezier(.165, .84, .44, 1)'</span>;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          <span class="comment">// 停止滚动</span></span></span><br><span class="line">          stop() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> matrix = <span class="built_in">window</span>.getComputedStyle(<span class="keyword">this</span>.$refs.scroller).getPropertyValue(<span class="string">'transform'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.offsetY = <span class="built_in">Math</span>.round(+matrix.split(<span class="string">')'</span>)[<span class="number">0</span>].split(<span class="string">', '</span>)[<span class="number">5</span>]);</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>滚动</tag>
      </tags>
  </entry>
  <entry>
    <title>vue更改打包路径</title>
    <url>/2020/08/10/vue%E6%9B%B4%E6%94%B9%E6%89%93%E5%8C%85%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="根目录新建-env-local"><a href="#根目录新建-env-local" class="headerlink" title="根目录新建.env.local"></a>根目录新建.env.local</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VUE_APP_assetsRoot &#x3D; D:\zhenlvProject\webtouch\TC.itravel.WebFly\fly2.0\dist  （目标路径）</span><br><span class="line">VUE_APP_USER &#x3D; dali</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="build下新建readEnv-js"><a href="#build下新建readEnv-js" class="headerlink" title="build下新建readEnv.js"></a>build下新建readEnv.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读取环境变量的文件把它转化成对象</span><br><span class="line"></span><br><span class="line">const readEnv &#x3D; (file) &#x3D;&gt; &#123; &#x2F;&#x2F; flie为文件路径</span><br><span class="line">  let fileName &#x3D; path.join(__dirname, file);</span><br><span class="line">  let envParams &#x3D; &#123;&#125;</span><br><span class="line">  try&#123;</span><br><span class="line">    let fileData &#x3D; fs.readFileSync(fileName, &#123; encoding: &#39;utf8&#39; &#125;)</span><br><span class="line">    let deleteBlankData &#x3D; fileData.replace(&#x2F;\r&#x2F;g, &#39;,&#39;).replace(&#x2F;\s+&#x2F;g, &quot;&quot;) &#x2F;&#x2F; 把换行和回车替换并删除空格</span><br><span class="line">    let arr &#x3D; deleteBlankData.split(&#39;,&#39;).map(item &#x3D;&gt; &#123;</span><br><span class="line">      return item.split(&#39;&#x3D;&#39;)</span><br><span class="line">    &#125;) &#x2F;&#x2F; [ [ &#39;a&#39;, &#39;1&#39; ], [ &#39;b&#39;, &#39;2&#39; ] ]</span><br><span class="line">    arr.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">      if (item[1])&#123;</span><br><span class="line">        envParams[item[0]] &#x3D; &#96;&quot;$&#123;item[1]&#125;&quot;&#96;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;catch&#123;</span><br><span class="line">    fs.appendFileSync(fileName, &#39;&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  return envParams &#x2F;&#x2F;&#123; a: &#39;1&#39;, b: &#39;2&#39; &#125;</span><br><span class="line">  &#x2F;&#x2F; 可以接着处理</span><br><span class="line">  &#x2F;* 像vue-cli3 新版create-react-app 一样规定环境变量的Key必须以(VUE_APP_)  (REACT_APP_) 开头 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; readEnv</span><br></pre></td></tr></table></figure>



<h3 id="config下index-js"><a href="#config下index-js" class="headerlink" title="config下index.js"></a>config下index.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引入</span><br><span class="line">const readEnv &#x3D; require(&#39;..&#x2F;build&#x2F;readEnv&#39;)</span><br><span class="line">const localEnv &#x3D; readEnv(&#39;..&#x2F;.env.local&#39;)</span><br><span class="line">&#x2F;&#x2F; VUE_APP_assetsRoot 请设置成绝对路径</span><br><span class="line">const assetsRoot &#x3D;</span><br><span class="line">  localEnv.VUE_APP_assetsRoot ?</span><br><span class="line">    localEnv.VUE_APP_assetsRoot.replace(&#x2F;\&quot;&#x2F;g, &quot;&quot;) :</span><br><span class="line">    path.resolve(__dirname, &quot;..&#x2F;dist&quot;)</span><br><span class="line"></span><br><span class="line">应用</span><br><span class="line">改变前</span><br><span class="line">build: &#123;</span><br><span class="line">    &#x2F;&#x2F; Template for index.html</span><br><span class="line">    index: path.resolve(__dirname, &quot;..&#x2F;dist&#x2F;index.html&quot;),</span><br><span class="line">    &#x2F;&#x2F; index: path.resolve(__dirname, &#39;..&#x2F;..&#x2F;Views&#x2F;Home&#x2F;Hotel.cshtml&#39;),</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Paths</span><br><span class="line">    assetsRoot: path.resolve(__dirname, &quot;..&#x2F;dist&quot;),</span><br><span class="line">    assetsSubDirectory: &quot;static&quot;,</span><br><span class="line">    assetsPublicPath: &quot;&#x2F;vtravel&#x2F;fly2.0&#x2F;dist&#x2F;&quot;,</span><br><span class="line">&#125;</span><br><span class="line">改变后</span><br><span class="line">  build: &#123;</span><br><span class="line">    &#x2F;&#x2F; Template for index.html</span><br><span class="line">    index: &#96;$&#123;assetsRoot&#125;&#x2F;index.html&#96;,</span><br><span class="line">    &#x2F;&#x2F; index: path.resolve(__dirname, &#39;..&#x2F;..&#x2F;Views&#x2F;Home&#x2F;Hotel.cshtml&#39;),</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Paths</span><br><span class="line">    assetsRoot: assetsRoot,</span><br><span class="line">    assetsSubDirectory: &quot;static&quot;,</span><br><span class="line">    assetsPublicPath: &quot;&#x2F;vtravel&#x2F;fly2.0&#x2F;dist&#x2F;&quot;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>打包路径</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自动回复案例</title>
    <url>/2020/07/30/vue%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>用户提问题的自动回答案例（_.debounce、 _.capitalize、https:<span class="comment">//lodash.com/docs#debounce --特殊方法演示）</span></span><br><span class="line">&lt;div id=<span class="string">"watch-example"</span>&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            Ask a yes/no question:  </span><br><span class="line">            &lt;input v-model=<span class="string">"question"</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/axios@<span class="number">0.12</span><span class="number">.0</span>/dist/axios.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>https:<span class="comment">//cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">'#watch-example'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            question: <span class="string">''</span>,</span><br><span class="line">            answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">            question: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span><br><span class="line">                <span class="keyword">this</span>.debouncedGetAnswer()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="line">            <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="line">            <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="line">            <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="line">            <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="line">            <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            getAnswer: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span><br><span class="line">                <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">                axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">                    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">                        vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">                        vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自定义指令</title>
    <url>/2020/08/05/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-focus&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 注册一个全局自定义指令 v-focus</span><br><span class="line">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class="line">  &#x2F;&#x2F; 当绑定元素插入到 DOM 中。</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    &#x2F;&#x2F; 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="局部自定义指令"><a href="#局部自定义指令" class="headerlink" title="局部自定义指令"></a>局部自定义指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;input v-focus&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    &#x2F;&#x2F; 注册一个局部的自定义指令 v-focus</span><br><span class="line">    focus: &#123;</span><br><span class="line">      &#x2F;&#x2F; 指令的定义</span><br><span class="line">      inserted: function (el) &#123;</span><br><span class="line">        &#x2F;&#x2F; 聚焦元素</span><br><span class="line">        el.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><h5 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h5><p>指令定义函数提供了几个钩子函数（可选）：</p>
<ul>
<li><code>bind</code>: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li>
<li><code>inserted</code>: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li><code>update</code>: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li>
<li><code>componentUpdated</code>: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li><code>unbind</code>: 只调用一次， 指令与元素解绑时调用。</li>
</ul>
<h5 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h5><p>钩子函数的参数有：</p>
<ul>
<li><p><strong>el</strong>: 指令所绑定的元素，可以用来直接操作 DOM 。</p>
</li>
<li><p>binding</p>
<p>: 一个对象，包含以下属性：</p>
<ul>
<li><strong>name</strong>: 指令名，不包括 <code>v-</code> 前缀。</li>
<li><strong>value</strong>: 指令的绑定值， 例如： <code>v-my-directive=&quot;1 + 1&quot;</code>, value 的值是 <code>2</code>。</li>
<li><strong>oldValue</strong>: 指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><strong>expression</strong>: 绑定值的表达式或变量名。 例如 <code>v-my-directive=&quot;1 + 1&quot;</code> ， expression 的值是 <code>&quot;1 + 1&quot;</code>。</li>
<li><strong>arg</strong>: 传给指令的参数。例如 <code>v-my-directive:foo</code>， arg 的值是 <code>&quot;foo&quot;</code>。</li>
<li><strong>modifiers</strong>: 一个包含修饰符的对象。 例如： <code>v-my-directive.foo.bar</code>, 修饰符对象 modifiers 的值是 <code>{ foo: true, bar: true }</code>。</li>
</ul>
</li>
<li><p><strong>vnode</strong>: Vue 编译生成的虚拟节点。</p>
</li>
<li><p><strong>oldVnode</strong>: 上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p>
</li>
</ul>
<p>  以下实例演示了这些参数的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;  v-runoob:hello.a.b&#x3D;&quot;message&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.directive(&#39;runoob&#39;, &#123;</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    var s &#x3D; JSON.stringify</span><br><span class="line">    el.innerHTML &#x3D;</span><br><span class="line">      &#39;name: &#39;       + s(binding.name) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;value: &#39;      + s(binding.value) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;expression: &#39; + s(binding.expression) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;argument: &#39;   + s(binding.arg) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;modifiers: &#39;  + s(binding.modifiers) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;vnode keys: &#39; + Object.keys(vnode).join(&#39;, &#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;菜鸟教程!&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p>有时候我们不需要其他钩子函数，我们可以简写函数，如下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-runoob&#x3D;&quot;red&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.directive(&#39;runoob&#39;, function (el, binding) &#123;</span><br><span class="line">  &#x2F;&#x2F; 设置指令的背景颜色</span><br><span class="line">  el.style.backgroundColor &#x3D; binding.value.color</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p>指令函数可接受所有合法的 JavaScript 表达式，以下实例传入了 JavaScript 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-runoob&#x3D;&quot;&#123; color: &#39;green&#39;, text: &#39;菜鸟教程!&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.directive(&#39;runoob&#39;, function (el, binding) &#123;</span><br><span class="line">    &#x2F;&#x2F; 简写方式设置文本及背景颜色</span><br><span class="line">    el.innerHTML &#x3D; binding.value.text</span><br><span class="line">    el.style.backgroundColor &#x3D; binding.value.color</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4最全解析</title>
    <url>/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="命令合集"><a href="#命令合集" class="headerlink" title="命令合集"></a>命令合集</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-cli可以让我们在命令行里输入webpack相关命令</span><br><span class="line"></span><br><span class="line">本地安装webpack webpack-cli</span><br><span class="line">npm webpack webpack-cli -D </span><br><span class="line"></span><br><span class="line">生成默认的packpage.json</span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">查看旧的版本号</span><br><span class="line">npm info webpack</span><br><span class="line"></span><br><span class="line">全局安装翻译某个js</span><br><span class="line">webpack index.js</span><br><span class="line"></span><br><span class="line">本地安装翻译某个js</span><br><span class="line">npx webpack index.js</span><br><span class="line"></span><br><span class="line">查看本地安装的webpack</span><br><span class="line">npx webpack -v </span><br><span class="line"></span><br><span class="line">更改配置文件(由默认的webpack.config.js改成webpackconfig.js)</span><br><span class="line">npx webpack --config webpackconfig.js</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="配置解释"><a href="#配置解释" class="headerlink" title="配置解释"></a>配置解释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">	mode:&quot;production&quot;,&#x2F;&#x2F;默认模式，打包出的js是被压缩过的</span><br><span class="line">	&#x2F;&#x2F;mode:&quot;development&quot;,&#x2F;&#x2F;开发模式，打包出的js是原生</span><br><span class="line">	devtool:&quot;cheap-inline-module-source-map&quot;,</span><br><span class="line">	&#x2F;&#x2F;development devtool:&quot;cheap-module-eval-source-map&quot;</span><br><span class="line">	&#x2F;&#x2F;production devtool:&quot;cheap-module-source-map&quot;</span><br><span class="line">	&#x2F;&#x2F;source-map--会生成一个map的映射文件，inline-映射关系放进bundle.js去，cheap-只提示多少行错误，不提示列，提高打包速度，并且只检查自己的业务代码，module-也检查第三方的代码，eval使用eval函数生成映射关系</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="手写模拟webpack-dev-server-webpack-dev-middleware"><a href="#手写模拟webpack-dev-server-webpack-dev-middleware" class="headerlink" title="手写模拟webpack-dev-server(webpack-dev-middleware)"></a>手写模拟webpack-dev-server(webpack-dev-middleware)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-middleware express -D</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924160201890.png" alt="image-20200924160201890"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924160033781.png" alt="image-20200924160033781"></p>
<h4 id="babel-polyfill（注入es6的语法）"><a href="#babel-polyfill（注入es6的语法）" class="headerlink" title="@babel/polyfill（注入es6的语法）"></a>@babel/polyfill（注入es6的语法）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @babel&#x2F;pollyfill --save</span><br></pre></td></tr></table></figure>

<h5 id="main-js引入-babel-polyfill"><a href="#main-js引入-babel-polyfill" class="headerlink" title="main.js引入@babel/polyfill"></a>main.js引入@babel/polyfill</h5><p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924164534979.png" alt="image-20200924164534979"></p>
<h5 id="属性（targets：什么条件下需要引入，useBuiltIns：按需引入）"><a href="#属性（targets：什么条件下需要引入，useBuiltIns：按需引入）" class="headerlink" title="属性（targets：什么条件下需要引入，useBuiltIns：按需引入）"></a>属性（targets：什么条件下需要引入，useBuiltIns：按需引入）</h5><p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924164800345.png" alt="image-20200924164800345"></p>
<h5 id="书写第三方库的时候，上面的写法会污染全局，建议使用下面的方式"><a href="#书写第三方库的时候，上面的写法会污染全局，建议使用下面的方式" class="headerlink" title="书写第三方库的时候，上面的写法会污染全局，建议使用下面的方式"></a>书写第三方库的时候，上面的写法会污染全局，建议使用下面的方式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @babel&#x2F;plugin-transform-runtime --save-dev</span><br><span class="line">npm install @babel&#x2F;runtime --save</span><br><span class="line">&#x2F;&#x2F;corejs从false改成2需要下载corejs2</span><br><span class="line">npm install @babel&#x2F;runtime-corejs2 --save</span><br></pre></td></tr></table></figure>

<p><strong>注释引入</strong></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924165956498.png" alt="image-20200924165956498"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924171225161.png" alt="image-20200924171225161"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924165725570.png" alt="image-20200924165725570"></p>
<h4 id="使用webpack中的babel打包react"><a href="#使用webpack中的babel打包react" class="headerlink" title="使用webpack中的babel打包react"></a>使用webpack中的babel打包react</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @bable&#x2F;preset-react --save-dev</span><br><span class="line">npm install react react-dom --save</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924172440951.png" alt="image-20200924172440951"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924171913293.png" alt="image-20200924171913293"></p>
<h4 id="Tree-Shaking-只支持ES-module"><a href="#Tree-Shaking-只支持ES-module" class="headerlink" title="Tree Shaking(只支持ES module)"></a>Tree Shaking(只支持ES module)</h4><p>development模式下需要配置optimization</p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924174545413.png" alt="image-20200924174545413"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924174650855.png" alt="image-20200924174650855"></p>
<p>production模式下不需要配置optimization</p>
<p>sideEffects的值为false，意味着所有文件都需要使用tree shaking</p>
<p>sideEffects:[“*.css”,”@bable/polyfill”],意味着这两个文件不需要tree shaking</p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924174438221.png" alt="image-20200924174438221"></p>
<h4 id="区分development和production环境"><a href="#区分development和production环境" class="headerlink" title="区分development和production环境"></a>区分development和production环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev(dev)</span><br><span class="line">npm run build(prod)</span><br></pre></td></tr></table></figure>



<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924175922131.png" alt="image-20200924175922131"></p>
<h4 id="分离基础webpack的config"><a href="#分离基础webpack的config" class="headerlink" title="分离基础webpack的config"></a>分离基础webpack的config</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm intall webpack-merge -D</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924180246753.png" alt="image-20200924180246753"></p>
]]></content>
      <categories>
        <category>webpack4</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title>vue面试题记录</title>
    <url>/2020/09/14/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Vue 实例的 data 属性，可以在哪些生命周期中获取到？bcd</span><br><span class="line">A. beforeCreate</span><br><span class="line">B. created</span><br><span class="line">C. beforeMount</span><br><span class="line">D. mounted</span><br><span class="line"></span><br><span class="line">2. 下列对 Vue 原理的叙述，哪些是正确的？abcd</span><br><span class="line">A. Vue 中的数组变更通知，通过拦截数组操作方法而实现</span><br><span class="line">B. 编译器目标是创建渲染函数，渲染函数执行后将得到 VNode 树</span><br><span class="line">C. 组件内 data 发生变化时会通知其对应 watcher，执行异步更新</span><br><span class="line">D. patching 算法首先进行同层级比较，可能执行的操作是节点的增加、删除和更新</span><br><span class="line"></span><br><span class="line">3. 对于 Vue 中响应式数据原理的说法，下列哪项是不正确的？bd</span><br><span class="line">A. 采用数据劫持方式，即 Object.defineProperty() 劫持 data 中各属性，实现响应式数据</span><br><span class="line">B. 视图中的变化会通过 watcher 更新 data 中的数据</span><br><span class="line">C. 若 data 中某属性多次发生变化，watcher 仅会进入更新队列一次</span><br><span class="line">D. 通过编译过程进行依赖收集</span><br><span class="line"></span><br><span class="line">4. 下列说法不正确的是哪项？b</span><br><span class="line">A. key 的作用主要是为了高效地更新虚拟 DOM</span><br><span class="line">B. 若指定了组件的 template 选项，render 函数不会执行</span><br><span class="line">C. 使用 vm.$nextTick 可以确保获得 DOM 异步更新的结果</span><br><span class="line">D. 若没有 el 选项，vm.$mount(dom) 可将 Vue 实例挂载于指定元素上</span><br><span class="line"></span><br><span class="line">5. 下列关于 Vuex 的描述，不正确的是哪项？c</span><br><span class="line">A. Vuex 通过 Vue 实现响应式状态，因此只能用于 Vue</span><br><span class="line">B. Vuex 是一个状态管理模式</span><br><span class="line">C. Vuex 主要用于多视图间状态全局共享与管理</span><br><span class="line">D. 在 Vuex 中改变状态，可以通过 mutations 和 actions</span><br><span class="line"></span><br><span class="line">6. 关于 Vue 组件间的参数传递，下列哪项是不正确的？b</span><br><span class="line">A. 若子组件给父组件传值，可使用 $emit 方法</span><br><span class="line">B. 祖孙组件之间可以使用 provide 和 inject 方式跨层级相互传值</span><br><span class="line">C. 若子组件使用 $emit(&#39;say&#39;) 派发事件，父组件可使用 @say 监听</span><br><span class="line">D. 若父组件给子组件传值，子组件可通过 props 接受数据</span><br><span class="line"></span><br><span class="line">7. 下列关于 vue-router 的描述，不正确的是哪项？c</span><br><span class="line">A. vue-router 的常用模式有 hash 和 history 两种</span><br><span class="line">B. 可通过 addRoutes 方法动态添加路由</span><br><span class="line">C. 可通过 beforeEnter 对单个组件进行路由守卫</span><br><span class="line">D. vue-router 借助 Vue 实现响应式的路由，因此只能用于 Vue</span><br><span class="line"></span><br><span class="line">8. 下列说法不正确的是哪项？c</span><br><span class="line">A. 可通过 this.$parent 查找当前组件的父组件</span><br><span class="line">B. 可使用 this.$refs 查找命名子组件</span><br><span class="line">C. 可使用 this.$children 按顺序查找当前组件的直接子组件</span><br><span class="line">D. 可使用 $root 查找根组件，并可配合 children 遍历全部组件</span><br><span class="line"></span><br><span class="line">9. 下列关于 v-model 的说法，哪项是不正确的？c</span><br><span class="line">A. v-model 能实现双向绑定</span><br><span class="line">B. v-model 本质上是语法糖，它负责监听用户的输入事件以更新数据</span><br><span class="line">C. v-model 是内置指令，不能用在自定义组件上</span><br><span class="line">D. 对 input 使用 v-model，实际上是指定其 :value 和 :input</span><br><span class="line"></span><br><span class="line">10. 关于 Vue 的生命周期，下列哪项是不正确的？d</span><br><span class="line">A. DOM 渲染在 mounted 中就已经完成了</span><br><span class="line">B. Vue 实例从创建到销毁的过程，就是生命周期</span><br><span class="line">C. created 表示完成数据观测、属性和方法的运算和初始化事件，此时 $el 属性还未显示出来</span><br><span class="line">D. 页面首次加载过程中，会依次触发 beforeCreate，created，beforeMount，mounted，beforeUpdate，updated</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>好在拜天哥所赐，我们还是刷出了「权威的」参考答案，请查收：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. BCD</span><br><span class="line">2. ABCD</span><br><span class="line">3. BD</span><br><span class="line">4. B</span><br><span class="line">5. C</span><br><span class="line">6. B</span><br><span class="line">7. C</span><br><span class="line">8. C</span><br><span class="line">9. C</span><br><span class="line">10. D</span><br></pre></td></tr></table></figure>

<p>plus: <a href="https://mp.weixin.qq.com/s/a1mnUief7w9SqSRC8jlDEQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/a1mnUief7w9SqSRC8jlDEQ</a></p>
<h3 id="生命周期注意点："><a href="#生命周期注意点：" class="headerlink" title="生命周期注意点："></a>生命周期注意点：</h3><p>一些应用钩子函数的想法</p>
<ul>
<li><p>在created钩子中可以对data数据进行操作，这个时候可以进行ajax请求将返回的数据赋给data。</p>
</li>
<li><p>虽然updated函数会在数据变化时被触发，但却不能准确的判断是那个属性值被改变，所以在实际情况中用computed或match函数来监听属性的变化，并做一些其他的操作。</p>
</li>
<li><p>在mounted钩子对挂载的dom进行操作，此时，DOM已经被渲染到页面上。</p>
</li>
<li><p>在使用vue-router时有时需要使用<keep-alive></keep-alive>来缓存组件状态，这个时候created钩子就不会被重复调用了，如果我们的子组件需要在每次加载或切换状态的时候进行某些操作，可以使用activated钩子触发。</p>
</li>
<li><p>所有的生命周期钩子自动绑定 this 上下文到实例中，所以不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是导致this指向父级。</p>
<p>小结</p>
</li>
<li><p>加载渲染过程</p>
</li>
</ul>
<blockquote>
<p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p>
</blockquote>
<ul>
<li>子组件更新过程</li>
</ul>
<blockquote>
<p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p>
</blockquote>
<ul>
<li>父组件更新过程</li>
</ul>
<blockquote>
<p>父beforeUpdate-&gt;父updated</p>
</blockquote>
<ul>
<li>销毁过程</li>
</ul>
<blockquote>
<p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>
</blockquote>
<h3 id="路由篇"><a href="#路由篇" class="headerlink" title="路由篇"></a>路由篇</h3><h4 id="vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？"><a href="#vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？" class="headerlink" title="vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？"></a>vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？</h4><ul>
<li><p>hash 模式：</p>
</li>
<li><ul>
<li>#后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面</li>
<li>通过监听 <strong>hashchange</strong> 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。</li>
</ul>
</li>
<li><p>history 模式：</p>
</li>
<li><ul>
<li>history 模式的实现，主要是 HTML5 标准发布的两个 API，<strong>pushState</strong> 和 <strong>replaceState</strong>，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作</li>
</ul>
</li>
<li><p>区别</p>
</li>
<li><ul>
<li>url 展示上，hash 模式有“#”，history 模式没有</li>
<li>刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由</li>
<li>兼容性，hash 可以支持低版本浏览器和 IE。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目搭建</title>
    <url>/2020/08/05/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="从无到有搭建"><a href="#从无到有搭建" class="headerlink" title="从无到有搭建"></a>从无到有搭建</h3><ol>
<li><p>首先下载node.js要求版本在8.9以上        官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fzh-cn%2F" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p>
<p>下载完可检查在windows任务命令行里输入node -v</p>
</li>
</ol>
<ol start="2">
<li>使用淘宝NPM镜像源下载比较快    命令：npm install -g cnpm –registry=<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fregistry.npm.taobao.org%2F" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li>
</ol>
<ol start="3">
<li><p>安装vue-cli（全局安装vue-cli）    命令：cnpm install vue-cli -g</p>
<p>检查环境是否安装上：vue -V</p>
</li>
</ol>
<p>创建vue项目：</p>
<h5 id="vue-cli2-0安装"><a href="#vue-cli2-0安装" class="headerlink" title="vue-cli2.0安装"></a>vue-cli2.0安装</h5><p>vue init webpack vuecli_2.0(名称)</p>
<a id="more"></a>

<h5 id="vue-cli3-0创建项目"><a href="#vue-cli3-0创建项目" class="headerlink" title="vue-cli3.0创建项目"></a>vue-cli3.0创建项目</h5><p>1、vue create vuecli_3.0(名称)<br>2、默认选择default方式即可</p>
<h5 id="vue2-0和vue3-0的区别"><a href="#vue2-0和vue3-0的区别" class="headerlink" title="vue2.0和vue3.0的区别"></a>vue2.0和vue3.0的区别</h5><p>1.打包方式：<br>​    2.0是通过:npm run dev<br>​    3.0是：npm run serve<br>​    至于为什么会变，来看一下package.json</p>
<p>2.文件夹目录：<br>​    3.0取消掉了config目录、build目录、static目录 ,还有最重要的一点，3.0的安装项目时自动下载node-model<br>​    vue.config.js也没了，需要手动添加。</p>
<p>vue create 是vue-cli3.x的初始化方式，目前模板是固定的，模板选项可自由配置，创建出来的是vue-cli3的项目，与cue-cli2项目结构不同，配置方法不同，具体配置方法参考官方文档。vue init 是vue-cli2.x的初始化方式，可以使用github上面的一些模板来初始化项目，webpack是官方推荐的标准模板名。vue-cli2.x项目向3.x迁移只需要把static目录复制到public目录下，老项目的src目录覆盖3.x的src目录(如果修改了配置，可以查看文档，用cli3的方法进行配置)</p>
<h5 id="vue-cli2升级到vue-cli3"><a href="#vue-cli2升级到vue-cli3" class="headerlink" title="vue cli2升级到vue cli3"></a>vue cli2升级到vue cli3</h5><p>1.先升级npm的版本</p>
<p>​    npm install -g npm</p>
<p>2.再卸载之前的vue cli 2.9.6</p>
<p>​    npm uninstall -g @vue/cli</p>
<p>3.下载最新的vue cli版本</p>
<p>​    npm install -g @vue/cli</p>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p> 进入此文件夹：cd vuecli_2.0/vuecli_3.0</p>
<p>运行：npm install（’webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。）</p>
<p>运行：npm run dev        </p>
<p>运行之后会导出网址：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p>
<p>在网页上输入上面的网址即可</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack常见loader和plugins</title>
    <url>/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/</url>
    <content><![CDATA[<h3 id="常用webpack插件"><a href="#常用webpack插件" class="headerlink" title="常用webpack插件"></a>常用webpack插件</h3><p><strong>注意：插件的引入都在webpack.config.js中</strong></p>
<h4 id="live-server-必须全局安装，命令直接使用"><a href="#live-server-必须全局安装，命令直接使用" class="headerlink" title="live-server (必须全局安装，命令直接使用)"></a>live-server (必须全局安装，命令直接使用)</h4><p>一款npm工具，全局npm i -g live-server后，项目目录使用live-server命令行命令便可直接在浏览器中预览（默认找index.html，其他请自行带上文件名空格后跟在后面），并且自动全局监听实时更新</p>
<p>1.新建一个文件夹（最好英文），执行npm init命令；</p>
<p>2.生成package.json文件后，执行npm install -g live-server命令；</p>
<p>3.安装完成后，就可以执行live-server命令启动；</p>
<p>设置快捷方式如下：</p>
<p>1.找到package.json文件，然后找到”script”，写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;:&quot;live-server .&#x2F;port&#x3D;9090&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<a id="more"></a>



<p><img src="https:////upload-images.jianshu.io/upload_images/15484248-5c9d169a4fcb77da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488/format/webp" alt="img"></p>
<p>2.启动如下：npm run server。</p>
<h4 id="uglifyjs-webpack-plugin（js压缩插件）"><a href="#uglifyjs-webpack-plugin（js压缩插件）" class="headerlink" title="uglifyjs-webpack-plugin（js压缩插件）"></a>uglifyjs-webpack-plugin（js压缩插件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npmn  i -D uglifyjs-webpack-plugin</span><br><span class="line"></span><br><span class="line">const uglify &#x3D; &#96;require&#96;(&#39;uglifyjs-webpack-plugin&#39;);</span><br><span class="line">plugins:[</span><br><span class="line">        new uglify()</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>



<h4 id="html-webpack-plugin（打包HTML文件）"><a href="#html-webpack-plugin（打包HTML文件）" class="headerlink" title="html-webpack-plugin（打包HTML文件）"></a>html-webpack-plugin（<strong>打包HTML文件</strong>）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line"></span><br><span class="line">const htmlPlugin&#x3D; &#96;require&#96;(&#39;html-webpack-plugin&#39;);</span><br><span class="line">plugins:[</span><br><span class="line">         new htmlPlugin(&#123;</span><br><span class="line">            minify:&#123;</span><br><span class="line">                removeAttributeQuotes:true</span><br><span class="line">            &#125;,</span><br><span class="line">            hash:true,</span><br><span class="line">            template:&#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#x2F;&#x2F;打包结束后生成一个html文件，并且自动引入打包的js</span><br></pre></td></tr></table></figure>



<h4 id="clean-webpack-plugin（打包前删除dist文件）"><a href="#clean-webpack-plugin（打包前删除dist文件）" class="headerlink" title="clean-webpack-plugin（打包前删除dist文件）"></a>clean-webpack-plugin（打包前删除dist文件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br><span class="line"></span><br><span class="line">const CleanWebpackPlugin&#x3D; &#96;require&#96;(&#39;clean-webpack-plugin&#39;);</span><br><span class="line">plugins:[</span><br><span class="line">         new CleanWebpackPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure>



<h4 id="hot-module-replacement-热更新"><a href="#hot-module-replacement-热更新" class="headerlink" title="hot-module-replacement(热更新)"></a>hot-module-replacement(热更新)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br></pre></td></tr></table></figure>

<p>开启热更新</p>
<p><img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200924162419801.png" alt="image-20200924162419801"></p>
<p><img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200924162037602.png" alt="image-20200924162037602"></p>
<p>判断哪个文件做了修改，重新调用</p>
<p><img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200924162359826.png" alt="image-20200924162359826"></p>
<h4 id="extract-text-webpack-plugin（分离css插件）"><a href="#extract-text-webpack-plugin（分离css插件）" class="headerlink" title="extract-text-webpack-plugin（分离css插件）"></a>extract-text-webpack-plugin（分离css插件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br><span class="line"></span><br><span class="line">const extractTextPlugin &#x3D; &#96;require&#96;(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line">plugins:[</span><br><span class="line">        new extractTextPlugin(&quot;&#x2F;css&#x2F;index.css&quot;)</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>



<h4 id="PurifyCSS-webpack（消除未使用的css，必须配合extract-text-webpack-plugin插件）"><a href="#PurifyCSS-webpack（消除未使用的css，必须配合extract-text-webpack-plugin插件）" class="headerlink" title="PurifyCSS-webpack（消除未使用的css，必须配合extract-text-webpack-plugin插件）"></a>PurifyCSS-webpack（消除未使用的css，必须配合extract-text-webpack-plugin插件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npmn  i -D purifycss-webpack purify-css</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">onst PurifyCSSPlugin &#x3D; require(&quot;purifycss-webpack&quot;);</span><br><span class="line">new PurifyCSSPlugin(&#123;</span><br><span class="line">        &#x2F;&#x2F; Give paths to parse for rules. These should be absolute!</span><br><span class="line">        paths: glob.sync(path.join(__dirname, &#39;src&#x2F;*.html&#39;)),</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>



<p>骨架屏的插件见：vue-skeleton-webpack-plugin.md</p>
<h3 id="常见Loader"><a href="#常见Loader" class="headerlink" title="常见Loader"></a>常见Loader</h3><ul>
<li>可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。</li>
<li>可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。</li>
<li>可以把React中的JSX转换成JavaScript代码。</li>
</ul>
<p>注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。下面我们对Loaders的配置型简单梳理一下。</p>
<ul>
<li>test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；</li>
<li>use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；</li>
<li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li>
<li>query：为loaders提供额外的设置选项（可选）。</li>
</ul>
<h4 id="px2rem-loader-px单位转成rem"><a href="#px2rem-loader-px单位转成rem" class="headerlink" title="px2rem-loader(px单位转成rem)"></a>px2rem-loader(px单位转成rem)</h4><p>1.首先下载 lib-flexible</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install lib-flexible --save</span><br></pre></td></tr></table></figure>

<p>2.在main.js中引用 lib-flexible</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1544063/201912/1544063-20191203165101027-1706123685.png" alt="img"></p>
<p> 3.安装px2rem-loader(将px转换成rem)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install px2rem-loader</span><br></pre></td></tr></table></figure>

<p>4.配置px2rem</p>
<p>在build/utils.js中配置px2rem</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1544063/201912/1544063-20191203165921076-1993510106.png" alt="img"></p>
<p> <img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200927173555497.png" alt="image-20200927173555497"></p>
<p>我这边是根据 iphone6的设计图尺寸来的，所以用37.5能方便把设计图上的px直接写在代码里面。</p>
<p>最后重新 npm run dev 就可以使用了</p>
<p>　</p>
<h4 id="cssLoader（style-loader和css-loader）"><a href="#cssLoader（style-loader和css-loader）" class="headerlink" title="cssLoader（style-loader和css-loader）"></a>cssLoader（<strong>style-loader和</strong>css-loader）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install style-loader@0.13.1 css-loader@0.25.0 --save-dev</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: &#x2F;\.css$&#x2F;,</span><br><span class="line">              use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="图片Loader（file-loader和url-loader）"><a href="#图片Loader（file-loader和url-loader）" class="headerlink" title="图片Loader（file-loader和url-loader）"></a>图片Loader（<strong>file-loader</strong>和<strong>url-loader</strong>）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line"> module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">               test:&#x2F;\.(png|jpg|gif)&#x2F; ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:&#39;url-loader&#39;,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:500000,</span><br><span class="line">                       outputPath:&#39;images&#x2F;&#39;,&#x2F;&#x2F;打包后的路径</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br><span class="line">test:&#x2F;.(png|jpg|gif)&#x2F;是匹配图片文件后缀名称。</span><br><span class="line">use：是指定使用的loader和loader的配置参数。</span><br><span class="line">limit：是把小于500000B的文件打成Base64的格式，写入JS。</span><br><span class="line">url-loader和file-loader的区别在于url-loader有limit这个参数</span><br></pre></td></tr></table></figure>



<h4 id="hmtl文件中引入图片标签的Loader（html-withimg-loader）"><a href="#hmtl文件中引入图片标签的Loader（html-withimg-loader）" class="headerlink" title="hmtl文件中引入图片标签的Loader（html-withimg-loader）"></a>hmtl文件中引入图片标签的Loader（html-withimg-loader）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">    test: &#x2F;\.(htm|html)$&#x2F;i,</span><br><span class="line">     use:[ &#39;html-withimg-loader&#39;] </span><br><span class="line">&#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="less-Loader"><a href="#less-Loader" class="headerlink" title="less-Loader"></a>less-Loader</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev less</span><br><span class="line">npm n install --save-dev less-loader</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">       &#123;</span><br><span class="line">    test: &#x2F;\.less$&#x2F;,</span><br><span class="line">    use: [&#123;</span><br><span class="line">           loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">        , &#123;</span><br><span class="line">            loader: &quot;less-loader&quot; &#x2F;&#x2F; compiles Less to CSS</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">使用extract-text-webpack-plugin插件分离</span><br><span class="line">module:&#123;</span><br><span class="line">&#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;less-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">                &#x2F;&#x2F; use style-loader in development</span><br><span class="line">                fallback: &quot;style-loader&quot;</span><br><span class="line">            &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="SASS-Loader"><a href="#SASS-Loader" class="headerlink" title="SASS-Loader"></a>SASS-Loader</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm n install --save-dev node-sass</span><br><span class="line">cnpm install --save-dev sass-loader</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">       &#123;</span><br><span class="line">                test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;sass-loader&quot; &#x2F;&#x2F; compiles Sass to CSS</span><br><span class="line">                &#125;]</span><br><span class="line">&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    使用extract-text-webpack-plugin插件分离</span><br><span class="line">module:&#123;</span><br><span class="line">&#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;sass-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">                &#x2F;&#x2F; use style-loader in development</span><br><span class="line">                fallback: &quot;style-loader&quot;</span><br><span class="line">            &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="css3属性前缀postcss-loader"><a href="#css3属性前缀postcss-loader" class="headerlink" title="css3属性前缀postcss-loader"></a>css3属性前缀postcss-loader</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br><span class="line"></span><br><span class="line">和webpack.config.js同级，建立一个postcss.config.js文件。</span><br><span class="line">postcss.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: &#123;  </span><br><span class="line">        &#39;autoprefixer&#39;: &#123;browsers: &#39;last 5 version&#39;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对postcss.config.js配置完成后，我们还需要编写我们的loader配置。</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">      test: &#x2F;\.css$&#x2F;,</span><br><span class="line">      use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &quot;style-loader&quot;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: &quot;css-loader&quot;,</span><br><span class="line">              options: &#123;</span><br><span class="line">                 modules: true</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: &quot;postcss-loader&quot;</span><br><span class="line">            &#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br><span class="line">提取CSS</span><br><span class="line">配置提取CSS的loader配置.</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &#39;style-loader&#39;,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; </span><br><span class="line">            	loader: &#39;css-loader&#39;,</span><br><span class="line">            	options: &#123; </span><br><span class="line">            		importLoaders: 1 ,</span><br><span class="line">            		module:true</span><br><span class="line">            	&#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            &#x2F;&#x2F;importLoader：在使用css-loader之前必须先走下面的1个loader，importLoaders: 2使用css-loader之前必须先走下面的2个loader，以此类推</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            &#39;postcss-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="css-loader的模块化使用，只作用于当前文件"><a href="#css-loader的模块化使用，只作用于当前文件" class="headerlink" title="css-loader的模块化使用，只作用于当前文件"></a>css-loader的模块化使用，只作用于当前文件</h4><p><img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200924143827807.png" alt="image-20200924143827807"></p>
<h3 id="loader的三种写法："><a href="#loader的三种写法：" class="headerlink" title="loader的三种写法："></a><strong>loader的三种写法：</strong></h3><p>上节课学习了如何把CSS文件进行打包到JS当中去，有小伙伴就提问，我看到别人的CSS打包的写法和你的写法不太一样，是不是他们写错了，loader还有几种写法，这里我们就看两种另外的写法。</p>
<p><strong>第一种写法：直接用use。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.css$&#x2F;,</span><br><span class="line">                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p><strong>第二种写法：把use换成loader。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.css$&#x2F;,</span><br><span class="line">                loader:[&#39;style-loader&#39;,&#39;css-loader&#39;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>*<em>第三种写法：用use+loader的写法： *</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>由此看出，webpack的扩展和灵活性是非常强的，你习惯于那种写法都可以。最重要的是，你看见别人项目的其他写法也不要慌张，自己去试一试，有可能就可以Get到新知识。</p>
<h3 id="Babel的安装与配置"><a href="#Babel的安装与配置" class="headerlink" title="Babel的安装与配置"></a>Babel的安装与配置</h3><p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。</p>
<p>我们先一次性安装这些依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm c install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</span><br></pre></td></tr></table></figure>

<p>在webpack中配置Babel的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:&#39;babel-loader&#39;,</span><br><span class="line">        options:&#123;</span><br><span class="line">            presets:[</span><br><span class="line">                &quot;es2015&quot;,&quot;react&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你已经可以用webapck转换ES6的语法兼容各个浏览器了，我们可以修改一下entry.js的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import css from &#39;.&#x2F;css&#x2F;index.css&#39;;</span><br><span class="line">&#123;</span><br><span class="line">    let jspangString &#x3D; &#39;Hello Webpack&#39;</span><br><span class="line">    document.getElementById(&#39;title&#39;).innerHTML&#x3D;jspangString; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用了ES6的let声明方法。如果你不使用Babel来进行转换，你会发现打包出来的js代码没有作兼容处理，使用了Babel转换的代码是进行处理过的。</p>
<p><strong>.babelrc配置</strong></p>
<p>虽然Babel可以直接在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，如果卸载webapck.config.js中会非常的雍长不可阅读，所以我们经常把配置卸载.babelrc文件里。</p>
<p>在项目根目录新建.babelrc文件，并把配置写到文件里。</p>
<p>.babelrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;react&quot;,&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.webpack.config.js里的loader配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:&#39;babel-loader&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ENV：</strong></p>
<p>现在网络上已经不流行babel-preset-es2015，现在官方推荐使用的是babel-preset-env,那我们为了紧跟潮流，我们在讲一下env的配置方法。</p>
<p>首先需要下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install --save-dev babel-preset-env</span><br></pre></td></tr></table></figure>

<p>然后修改.babelrc里的配置文件。其实只要把之前的es2015换成env就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>plugins</tag>
        <tag>loader</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串方法</title>
    <url>/2020/07/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="charAt-方法"><a href="#charAt-方法" class="headerlink" title="charAt()方法"></a>charAt()方法</h3><p>charAt()返回字符串中x位置的字符，下标从 0 开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;charAt(x)返回字符串中x位置的字符，下标从 0 开始。</span><br><span class="line"></span><br><span class="line">    var myString &#x3D; &#39;wangxiaoting&#39;;</span><br><span class="line"></span><br><span class="line">    console.log(myString.charAt(7)); &#x2F;&#x2F; o</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat() 方法"></a>concat() 方法</h3><p>concat() 方法用于连接两个或多个字符串，此方法不改变现有的字符串，返回拼接后的新的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">     var name&#x3D;&quot;wnagxiaoting&quot;</span><br><span class="line"></span><br><span class="line">     var singel &#x3D; name.concat(&quot; is a&quot;,&quot;beautiful  girls&quot;)</span><br><span class="line"></span><br><span class="line">     console.log(singel) &#x2F;&#x2F; wnagxiaoting is abeautiful  girls</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>slice() 提取字符串的一部分片段，并返回一个新的字符串</p>
<p>接收起始位置但不接收末尾位置，俗称留头不留尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;slice() 方法可提取字符串的某个部分，返回一个新的字符串。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;包括字符串从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符。</span><br><span class="line">	&#x2F;&#x2F;start和end都可以是负数，如果是负数，就从字符串的尾部开始算起，例如-1就是最后一个字符，-2就是倒数第二个字符，一次类推</span><br><span class="line">    &#x2F;&#x2F;如果未指定end参数，则截取从 start 到原字符串结尾的字符串</span><br><span class="line">    </span><br><span class="line">    var myString&#x3D;&quot;wangxiaoting&quot;</span><br><span class="line"></span><br><span class="line">    console.log(myString.slice(0,5) ) &#x2F;&#x2F;打印结果 &quot;wangx&quot;</span><br><span class="line"></span><br><span class="line">    console.log( myString.slice(1,6)) &#x2F;&#x2F;打印结果 &quot;angxi&quot;</span><br><span class="line"></span><br><span class="line">	从后向前获取数组元素</span><br><span class="line">	var arr &#x3D; [1, 2, 3, 4]</span><br><span class="line">	console.log(arr.slice(-1)) &#x2F;&#x2F; [4]</span><br><span class="line">	console.log(arr.slice(-2)) &#x2F;&#x2F; [3, 4]</span><br><span class="line">	console.log(arr.slice(-3)) &#x2F;&#x2F; [2, 3, 4]</span><br><span class="line">	console.log(arr.slice(-4)) &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>





<h3 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h3><p>返回位于String对象中指定位置的子字符串，作用是提取字符串的子串，和slice一样也是留头不留尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;substring() 方法用于提取字符串中介于两个指定下标之间的字符，</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方返回的子串包括 start 处的字符，但不包括 stop 处的字符，to 可选，如果省略该参数，那么返回的子串会一直到字符串的结尾。</span><br><span class="line"></span><br><span class="line">    var myString &#x3D; &#39;wangxiaoting&#39;;</span><br><span class="line"></span><br><span class="line">    myString &#x3D; myString.substring(0,4);</span><br><span class="line"></span><br><span class="line">    console.log(myString)&#x2F;&#x2F;打印结果  wang</span><br><span class="line">    </span><br><span class="line">    截取字符串最后几位</span><br><span class="line">    var test&#x3D;&#39;123456789&#39;</span><br><span class="line">    console.log(test.substring(test.length-4))</span><br><span class="line">    </span><br><span class="line">    截取到字符倒数第二个</span><br><span class="line">	infoString &#x3D; infoString.substr(0, infoString.length - 1)</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="substr-方法"><a href="#substr-方法" class="headerlink" title="substr 方法"></a>substr 方法</h3><p>返回一个从指定位置开始到指定长度的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;substring() 方法用于提取字符串中介于两个指定下标之间的字符，</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方返回的子串包括 start 处的字符，但不包括 stop 处的字符，to 可选，如果省略该参数，那么返回的子串会一直到字符串的结尾。</span><br><span class="line"></span><br><span class="line">    var myString &#x3D; &#39;wangxiaoting&#39;;</span><br><span class="line"></span><br><span class="line">    myString &#x3D; myString.substr(0,4);</span><br><span class="line"></span><br><span class="line">    console.log(myString)&#x2F;&#x2F;打印结果  wang</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;从0位置开始搜索，返回第一个匹配的字符串的位置;搜索不到返回-1</span><br><span class="line"></span><br><span class="line">       var str&#x3D;&quot;ab cd efg&quot;;</span><br><span class="line"></span><br><span class="line">       console.log(str.indexOf(&quot;cd&quot;)); &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">       var str1&#x3D;&quot;my name is wangxiaoting &quot;;</span><br><span class="line"></span><br><span class="line">       console.log(str1.indexOf(&quot;is&quot;)); &#x2F;&#x2F;8</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;indexOf(&quot;要搜索的字符串&quot;,开始搜索的位置);</span><br><span class="line"></span><br><span class="line">       var str2&#x3D;&quot;abcedfghighdckkccccc&quot;;</span><br><span class="line"></span><br><span class="line">       console.log(str2.indexOf(&quot;c&quot;,13)); &#x2F;&#x2F;15</span><br><span class="line">		&#x2F;&#x2F;从下标是15的位置开始搜索，返回第一个匹配的字符串的位置;搜索不到返回-1</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>





<h3 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h3><p>split() 方法用于把一个字符串分割成字符串数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;把一个字符串分割成字符串数组。</span><br><span class="line"></span><br><span class="line">  var myString&#x3D;&quot;my name is wangxiaoting&quot;;</span><br><span class="line"></span><br><span class="line">  console.log(myString.split(&quot; &quot;));  &#x2F;&#x2F; [&quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;wangxiaoting&quot;]</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/2020/07/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/file" alt="img"></p>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>trim() 方法会从一个字符串的两端删除空白字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var myString &#x3D; &quot;     wang  xiao  ting     &quot;;</span><br><span class="line"></span><br><span class="line">    console.log(myString.trim());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;打印结果  wang  xiao  ting</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="lastIndexOf-string"><a href="#lastIndexOf-string" class="headerlink" title="lastIndexOf(string)"></a>lastIndexOf(string)</h3><p>返回String对象内最后一次出现子字符串位置。如果没有找到子字符串，则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">        var myString &#x3D; &quot;wangxiaoting&quot;</span><br><span class="line"></span><br><span class="line">        console.log(myString.lastIndexOf(&quot;a&quot;)) &#x2F;&#x2F;6</span><br><span class="line"></span><br><span class="line">        console.log(myString.lastIndexOf(&quot;g&quot;)) &#x2F;&#x2F;11</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="toUpperCase方法和toLowerCase方法"><a href="#toUpperCase方法和toLowerCase方法" class="headerlink" title="toUpperCase方法和toLowerCase方法"></a>toUpperCase方法和toLowerCase方法</h3><p>toUpperCase方法返回一个字符串，该字符串中的所有字母都被转换为大写字母。</p>
<p>toLowerCase:方法返回一个字符串，该字符串中的字母被转换成小写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">        var myString &#x3D; &quot;wangxiaoting&quot;</span><br><span class="line"></span><br><span class="line">        console.log(myString.toLowerCase());&#x2F;&#x2F;wangxiaoting</span><br><span class="line"></span><br><span class="line">        console.log(myString.toUpperCase());&#x2F;&#x2F;WANGXIAOTING</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="换行字符串-n"><a href="#换行字符串-n" class="headerlink" title="换行字符串\n"></a>换行字符串\n</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;\r&#39; 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖；</span><br><span class="line">&#39;\n&#39; 换行，换到当前位置的下一行，而不会回到行首；</span><br><span class="line"></span><br><span class="line">页面替换所有的‘&#x2F;’</span><br><span class="line">.replace(&#x2F;\|&#x2F;g,&#39; | &#39;)</span><br><span class="line">.replace(&#x2F;\n&#x2F;g,&#39;&lt;br&gt;&#39;)</span><br><span class="line"></span><br><span class="line">换行符号转义</span><br><span class="line">.split(&#39;\n&#39;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序wxParse解析html</title>
    <url>/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8FwxParse%E8%A7%A3%E6%9E%90html/</url>
    <content><![CDATA[<h3 id="wxParse解析html"><a href="#wxParse解析html" class="headerlink" title="wxParse解析html"></a>wxParse解析html</h3><p>最近项目上遇到在微信小程序里需要显示新闻内容，新闻内容是通过接口读取的服务器中的富文本内容，是html格式的，小程序默认是不支持html格式的内容显示的，那我们需要显示html内容的时候，就可以通过wxParse来实现。<br>首先我们在github上下载wxParse<br><a href="https://link.jianshu.com?t=https://github.com/icindy/wxParse" target="_blank" rel="noopener">https://github.com/icindy/wxParse</a></p>
<a id="more"></a>

<p><img src="http://upload-images.jianshu.io/upload_images/1749555-763e71fafa8b7d21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1006/format/webp" alt="img"></p>
<p>wxParse</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1749555-607f09905e3f1ffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt="img"></p>
<p>下面是具体的使用步骤</p>
<blockquote>
<p>1.在app.wxss全局样式文件中，需要引入wxParse的样式表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;&#x2F;page&#x2F;wxParse&#x2F;wxParse.wxss&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.在需要加载html内容的页面对应的js文件里引入wxParse</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var WxParse &#x3D; require(&#39;..&#x2F;..&#x2F;wxParse&#x2F;wxParse.js&#39;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.通过调用WxParse.wxParse方法来设置html内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* WxParse.wxParse(bindName , type, data, target,imagePadding)</span><br><span class="line">* 1.bindName绑定的数据名(必填)</span><br><span class="line">* 2.type可以为html或者md(必填)</span><br><span class="line">* 3.data为传入的具体数据(必填)</span><br><span class="line">* 4.target为Page对象,一般为this(必填)</span><br><span class="line">* 5.imagePadding为当图片自适应是左右的单一padding(默认为0,可选)</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    var that &#x3D; this;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">        url: &#39;&#39;, </span><br><span class="line">        method: &#39;POST&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            &#39;id&#39;:13</span><br><span class="line">        &#125;,</span><br><span class="line">        header: &#123;</span><br><span class="line">            &#39;content-type&#39;: &#39;application&#x2F;json&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        success: function(res) &#123;</span><br><span class="line">            var article &#x3D; res.data[0].post;</span><br><span class="line">            WxParse.wxParse(&#39;article&#39;, &#39;html&#39;, article, that,5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4.在页面中引用模板</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;import src&#x3D;&quot;..&#x2F;..&#x2F;wxParse&#x2F;wxParse.wxml&quot;&#x2F;&gt;</span><br><span class="line">&lt;template is&#x3D;&quot;wxParse&quot; data&#x3D;&quot;&#123;&#123;wxParseData:article.nodes&#125;&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以在微信小程序中嵌入html内容了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1749555-fc2cdae17f35c2e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/463/format/webp" alt="img"></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>wxParse</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试复习</title>
    <url>/2020/09/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>参考：<a href="https://mp.weixin.qq.com/s/QX0HL1tCAGU70zEb-HJQlQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QX0HL1tCAGU70zEb-HJQlQ</a></p>
<p>手写函数合集</p>
<p><a href="https://mp.weixin.qq.com/s/5mlf4yo6v4gRJnePAluqgg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5mlf4yo6v4gRJnePAluqgg</a></p>
<p>遍历A节点的父节点下的所有子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var b&#x3D;document.getElementById(&quot;a&quot;).parentNode.children;</span><br><span class="line">    console.log(b)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>target、currentTarget的区别？</p>
<p>currentTarget当前所绑定事件的元素（指向出发事件的函数，始终不变）</p>
<p>target当前被点击的元素</p>
<p>在浏览器地址栏中输入URL后发生了什么</p>
<h4 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h4><p>①查询ip地址</p>
<p>②建立tcp连接，接入服务器</p>
<p>③浏览器发起http请求</p>
<p>④服务器后台操作并做出http响应</p>
<p>⑤网页的解析与渲染</p>
<p>优化：</p>
<h5 id="从此可以得出网站的一些优化的方法"><a href="#从此可以得出网站的一些优化的方法" class="headerlink" title="从此可以得出网站的一些优化的方法:"></a>从此可以得出网站的一些优化的方法:</h5><p>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p>
<p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p>
<p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p>
<p>④提前渲染开始时间：将css链接放在html头部。</p>
<p>⑤减轻解析器的阻塞：将js链接放在body尾部。</p>
<p>参考：<a href="https://www.cnblogs.com/yanruizhe/p/11462462.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanruizhe/p/11462462.html</a></p>
<p>页面渲染html的过程？</p>
<blockquote>
<p>不需要死记硬背，理解整个过程即可</p>
</blockquote>
<p>浏览器渲染页面的一般过程：</p>
<p>1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。</p>
<p>2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</p>
<p>3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。</p>
<p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</p>
<p>4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p>
<p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。</p>
<p>说一下CORS？</p>
<p>CORS是一种新标准，支持同源通信，也支持跨域通信。fetch是实现CORS通信的</p>
<p>如何中断ajax请求？</p>
<p>一种是设置超时时间让ajax自动断开，另一种是手动停止ajax请求，其核心是调用XML对象的abort方法，ajax.abort()</p>
<p>用js递归的方式写1到100求和？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function num(n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1) return 1;</span><br><span class="line">    return num(n-1)+n;</span><br><span class="line">&#125;</span><br><span class="line">num(100);    </span><br><span class="line">延申：</span><br><span class="line">var sum &#x3D; 0;</span><br><span class="line">for(var i &#x3D; 1 ; i &lt;&#x3D; 100; i++)&#123;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">document.writeln(&quot;1~100以内的和为：&quot;+ sum);</span><br></pre></td></tr></table></figure>



<p>数组去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种：</span><br><span class="line">var arr&#x3D;[&#39;12&#39;,&#39;32&#39;,&#39;89&#39;,&#39;12&#39;,&#39;12&#39;,&#39;78&#39;,&#39;12&#39;,&#39;32&#39;];</span><br><span class="line">    &#x2F;&#x2F; 最简单数组去重法</span><br><span class="line">    function unique1(array)&#123;</span><br><span class="line">        var n &#x3D; []; &#x2F;&#x2F;一个新的临时数组</span><br><span class="line">        for(var i &#x3D; 0; i &lt; array.length; i++)&#123; &#x2F;&#x2F;遍历当前数组</span><br><span class="line">            if (n.indexOf(array[i]) &#x3D;&#x3D; -1)</span><br><span class="line">                n.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">arr&#x3D;unique1(arr);</span><br><span class="line"></span><br><span class="line">第二种</span><br><span class="line">es6方法数组去重</span><br><span class="line">arr&#x3D;[...new Set(arr)];</span><br><span class="line"></span><br><span class="line">第三种</span><br><span class="line">es6方法数组去重，第二种方法</span><br><span class="line">function dedupe(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));       &#x2F;&#x2F;Array.from()能把set结构转换为数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>变量提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a);  &#x2F;&#x2F;undefined</span><br><span class="line">var a &#x3D; 123;</span><br><span class="line"></span><br><span class="line">经典案例</span><br><span class="line">console.log(v1);</span><br><span class="line">var v1 &#x3D; 100;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(v1);</span><br><span class="line">    var v1 &#x3D; 200;</span><br><span class="line">    console.log(v1);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">console.log(v1);</span><br><span class="line">&#x2F;&#x2F; undefined  undefined 200  100</span><br></pre></td></tr></table></figure>

<p>函数提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数字面量式</span><br><span class="line">bar()</span><br><span class="line">var bar &#x3D; function() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 报错：TypeError: bar is not a function</span><br><span class="line"></span><br><span class="line">函数声明式</span><br><span class="line">bar()</span><br><span class="line">function bar() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果1</span><br></pre></td></tr></table></figure>



<p>虚拟dom的产生</p>
<p>改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树。</p>
<p>如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小</p>
<p>vue </p>
<p>采用的是虚拟 dom 通过重写 setter ， getter 实现观察者监听 data 属性的变化生成新的虚拟 dom 通过 h 函数创建真实 dom 替换掉dom树上对应的旧 dom。</p>
<p>react</p>
<p>react 也是通过虚拟 dom 和 setState 更改 data 生成新的虚拟 dom 以及 diff 算法来计算和生成需要替换的 dom 做到局部更新的。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序上传删除图片封装</title>
    <url>/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E4%BC%A0%E5%88%A0%E9%99%A4%E5%9B%BE%E7%89%87%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h3 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"img-model"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"img-item"</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;uploaderList&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"item"</span> <span class="attr">data-index</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">icon</span> <span class="attr">class</span>=<span class="string">'ui_uploader_item_icon'</span> <span class="attr">bindtap</span>=<span class="string">'clearImg'</span> <span class="attr">data-index</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">type</span>=<span class="string">"clear"</span> <span class="attr">size</span>=<span class="string">"20"</span> <span class="attr">color</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">image</span> <span class="attr">id</span>=<span class="string">"seal"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;item.path&#125;&#125;"</span>  <span class="attr">bindtap</span>=<span class="string">"showImg"</span> <span class="attr">data-item</span>=<span class="string">"&#123;&#123;item&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;item.upload_percent&gt;1&amp;&amp;item.upload_percent&lt;100&#125;&#125;"</span>&gt;</span>&#123;&#123;item.upload_percent&#125;&#125;%<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;item.upload_percent==100&#125;&#125;"</span>&gt;</span>上传成功<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:else</span>&gt;</span>上传失败<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"img-click"</span> <span class="attr">bindtap</span>=<span class="string">"goChooseImage"</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;showUpload&#125;&#125;"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">image</span> <span class="attr">id</span>=<span class="string">"seal"</span> <span class="attr">src</span>=<span class="string">"./img/seal.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    uploaderNum: <span class="number">0</span>,<span class="comment">//已经上传的数量</span></span><br><span class="line">    uploaderList:[],</span><br><span class="line">    showUpload: <span class="literal">true</span>,</span><br><span class="line">    maxLength: <span class="number">4</span> <span class="comment">//允许上传的最大数量</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">//选择图片 </span></span><br><span class="line">  goChooseImage(e) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> uploaderList = that.data.uploaderList;</span><br><span class="line">    <span class="keyword">let</span> maxSize = <span class="number">102</span> * <span class="number">1024</span>;</span><br><span class="line">    wx.chooseImage(&#123;</span><br><span class="line">      <span class="comment">//每次最多选择的个数，多余自动去除</span></span><br><span class="line">      count: that.data.maxLength - that.data.uploaderList.length,</span><br><span class="line">      sizeType: [<span class="string">'original'</span>, <span class="string">'compressed'</span>],</span><br><span class="line">      sourceType: [<span class="string">'album'</span>, <span class="string">'camera'</span>],</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          title: <span class="string">'正在上传...'</span>,</span><br><span class="line">          icon: <span class="string">'loading'</span>,</span><br><span class="line">          mask: <span class="literal">true</span>,</span><br><span class="line">          duration: <span class="number">500</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//上传个数限制</span></span><br><span class="line">        <span class="keyword">if</span> ((res.tempFiles.length + that.data.uploaderList.length) &gt; that.data.maxLength) &#123;</span><br><span class="line">          wx.showModal(&#123;</span><br><span class="line">            content: <span class="string">'最多能上传'</span> + that.data.maxLength + <span class="string">'张图片'</span>,</span><br><span class="line">            showCancel: <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断图片大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.tempFiles.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.tempFiles[i].size &gt; maxSize) &#123;</span><br><span class="line">            wx.showModal(&#123;</span><br><span class="line">              content: <span class="string">'图片太大，不允许上传'</span>,</span><br><span class="line">              showCancel: <span class="literal">false</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            uploaderList = that.data.uploaderList.concat(res.tempFiles[i])</span><br><span class="line">            that.setData(&#123;</span><br><span class="line">              uploaderList,</span><br><span class="line">              uploaderNum: that.data.uploaderList.length</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//隐藏点击上传图片</span></span><br><span class="line">        <span class="keyword">if</span> (uploaderList.length == that.data.maxLength) &#123;</span><br><span class="line">          that.setData(&#123;</span><br><span class="line">            showUpload: <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上传图片</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; uploaderList.length; i++) &#123;</span><br><span class="line">          <span class="comment">//that.upLoadImg(uploaderList[i],i)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 图片上传</span></span><br><span class="line">  upLoadImg(upImg,idx) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> uploadTask = wx.uploadFile(&#123;</span><br><span class="line">      url: config.itravel_api + <span class="string">'TravelCard/tcUploadPicture.mini'</span>,</span><br><span class="line">      filePath: upImg.path,</span><br><span class="line">      header: &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">      &#125;, <span class="comment">// 设置请求的 header</span></span><br><span class="line">      name: <span class="string">'idCard'</span>,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx === that.data.uploaderList.length<span class="number">-1</span>)&#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title: <span class="string">"上传成功"</span>,</span><br><span class="line">            icon: <span class="string">'none'</span>,</span><br><span class="line">            mask: <span class="literal">true</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(res) &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          title: <span class="string">"上传失败"</span>,</span><br><span class="line">          icon: <span class="string">'none'</span>,</span><br><span class="line">          mask: <span class="literal">true</span>,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//进度条属性置为0显示上传失败</span></span><br><span class="line">        upImg[<span class="string">'upload_percent'</span>] = <span class="number">0</span></span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          uploaderList: that.data.uploaderList</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 上传进度条</span></span><br><span class="line">    uploadTask &amp;&amp; uploadTask.onProgressUpdate(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//增加进度条属性</span></span><br><span class="line">      upImg[<span class="string">'upload_percent'</span>] = res.progress</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        uploaderList: that.data.uploaderList</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//展示图片</span></span><br><span class="line">  showImg: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> path = e.currentTarget.dataset.item.path</span><br><span class="line">    <span class="keyword">let</span> images = <span class="keyword">this</span>.data.uploaderList</span><br><span class="line">    <span class="keyword">let</span> allImages = [];</span><br><span class="line">    images.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      allImages.push(item.path)</span><br><span class="line">    &#125;)</span><br><span class="line">    wx.previewImage(&#123;</span><br><span class="line">      urls: allImages,</span><br><span class="line">      current: path</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 删除图片</span></span><br><span class="line">  clearImg: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    wx.showModal(&#123;</span><br><span class="line">      title: <span class="string">'提示'</span>,</span><br><span class="line">      content: <span class="string">'确定删除图片吗？'</span>,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.confirm) &#123;</span><br><span class="line">          <span class="comment">//删除start</span></span><br><span class="line">          <span class="keyword">let</span> uploaderList = that.data.uploaderList;<span class="comment">//原数据</span></span><br><span class="line">          <span class="keyword">let</span> index = e.currentTarget.dataset.index;</span><br><span class="line">          uploaderList.splice(index, <span class="number">1</span>);</span><br><span class="line">          that.setData(&#123;</span><br><span class="line">            uploaderNum: that.data.uploaderNum - <span class="number">1</span>,</span><br><span class="line">            showUpload: <span class="literal">true</span>,</span><br><span class="line">            uploaderList: uploaderList,</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">//删除end</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序之wx-request封装</title>
    <url>/2020/09/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bwx-request%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h2 id="微信请求-Promise-化"><a href="#微信请求-Promise-化" class="headerlink" title="微信请求 Promise 化"></a>微信请求 Promise 化</h2><h3 id="2-1-使用现成的库"><a href="#2-1-使用现成的库" class="headerlink" title="2.1 使用现成的库"></a>2.1 使用现成的库</h3><a id="more"></a>

<p>安装 Promise 库 wx-promise-pro，记得一定要带 <code>-s</code> 或 <code>--production</code>，要不然无法构建成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -S wx-promise-pro</span><br></pre></td></tr></table></figure>

<p>然后在 <code>app.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; promisifyAll &#125; from &#39;wx-promise-pro&#39;</span><br><span class="line"></span><br><span class="line">promisifyAll()  &#x2F;&#x2F; promisify all wx api</span><br><span class="line"></span><br><span class="line">App(&#123; ... &#125;)</span><br></pre></td></tr></table></figure>

<p>之后就可以正常使用了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.pro.showLoading(&#123;</span><br><span class="line">    title: &#39;加载中&#39;,</span><br><span class="line">    mask: true</span><br><span class="line">&#125;)</span><br><span class="line">  .then(() &#x3D;&gt; console.log(&#39;in promise ~&#39;))</span><br></pre></td></tr></table></figure>

<h3 id="2-2-自己实现"><a href="#2-2-自己实现" class="headerlink" title="2.2 自己实现"></a>2.2 自己实现</h3><p>其实我们可以自己来实现一个这样的库，原理很简单，以原生 API 的 wx.request 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 原生 API 使用方式</span><br><span class="line">wx.request(&#123;</span><br><span class="line">    url: &#39;&#39;,     &#x2F;&#x2F; 请求的 url</span><br><span class="line">    data: &#123;&#125;,    &#x2F;&#x2F; 参数</span><br><span class="line">    method: &#39;&#39;,  &#x2F;&#x2F; post、get</span><br><span class="line">    success: res &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 请求成功回调函数，res为回调参数</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: res &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 请求失败回调函数，res为回调参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们将其 Promise 化，应该的调用方式希望是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise 化后的期望使用方式</span><br><span class="line">wx.pro.request(&#123;</span><br><span class="line">    url: &#39;&#39;,     &#x2F;&#x2F; 请求的 url</span><br><span class="line">    data: &#123;&#125;,    &#x2F;&#x2F; 参数</span><br><span class="line">    method: &#39;&#39;   &#x2F;&#x2F; post、get</span><br><span class="line">&#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 请求成功回调函数，res为回调参数</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(res &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 请求失败回调函数，res为回调参数</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>并且 <code>then</code> 函数返回的是一个 Promise 对象，让这个函数可以不断链式调用下去，所以首先需要 <code>new</code> 出来一个 Promise 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function request(opt) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">            ...opt,</span><br><span class="line">            success: res &#x3D;&gt; &#123; resolve(res)&#125;,</span><br><span class="line">            fail: res &#x3D;&gt; &#123;reject(res)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码我们可以进一步改进，由于 <code>success</code>、<code>fail</code> 这里传入的参数只是由<code>resolve</code>、<code>reject</code> 方法执行了下，所以可以直接传入 <code>resolve</code>、<code>reject</code> 方法即可。</p>
<p>另外，由于其他小程序原生 API 格式一致，所以我们可以使用柯里化方法，来将其他需要进行 Promise 化的 API 进行处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function promisify(api) &#123;</span><br><span class="line">    return (opt &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            api(&#123;</span><br><span class="line">                ...opt,</span><br><span class="line">                fail: reject,</span><br><span class="line">                success: resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将柯里化方法执行的结果作为新的 Promise 化的 API 挂载到 <code>wx.pro</code> 对象上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将指定 API 进行 Promise 化</span><br><span class="line">wx.pro.request &#x3D; promisify(wx.request)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">wx.pro.request(&#123;...&#125;)</span><br><span class="line">    .then(...)</span><br></pre></td></tr></table></figure>

<p>然后为了方便我们使用其他方法，可以循环将 <code>wx</code> 对象上可以被 Promise 化的方法比如 <code>request</code>、<code>scanCode</code>、<code>showToast</code>、<code>getUserInfo</code> 等一一挂载到 <code>wx.pro</code> 对象上，使用时可以直接<code>wx.pro.xx</code>，由于这个方法执行返回的是一个 Promise 对象，因此可以像其它 Promise 化的对象那样使用。</p>
<p>事实上，不知不觉，我们就自己实现了 <code>wx-promise-pro</code> 的源码，这个库的核心代码也就是上面那这几行 🥳</p>
<h3 id="2-3-在项目中使用"><a href="#2-3-在项目中使用" class="headerlink" title="2.3 在项目中使用"></a>2.3 在项目中使用</h3><p>有了上面的工具后，我们可以将其使用在项目中，为了不在项目中遍布 <code>wx.request</code> 或 <code>wx.pro.request</code> 这里可以简单进行封装，新建两个文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; utils&#x2F;api&#x2F;fetch.js 封装请求方法、请求拦截器</span><br><span class="line"></span><br><span class="line">const app &#x3D; getApp()</span><br><span class="line"></span><br><span class="line">const BaseUrl &#x3D; &#39;http:&#x2F;&#x2F;172.0.0.1:7300&#x2F;mock&#39;</span><br><span class="line"></span><br><span class="line">const TokenWhiteList &#x3D; [</span><br><span class="line">    &#39;&#x2F;app&#x2F;user&#x2F;get-by-code&#39;     &#x2F;&#x2F; 不需要鉴权的api手动添加到这里</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 设置请求拦截器</span><br><span class="line"> * @param params 请求参数</span><br><span class="line"> *&#x2F;</span><br><span class="line">const fetch &#x3D; (params &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 拦截器逻辑</span><br><span class="line">    if (!TokenWhiteList.includes(params.url)) &#123;</span><br><span class="line">        params.header &#x3D; &#123;</span><br><span class="line">            &#39;content-type&#39;: &#39;application&#x2F;json&#39;,             &#x2F;&#x2F; 默认值</span><br><span class="line">            &#39;token&#39;: app.globalData.token || &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (params.url.startsWith(&#39;&#x2F;&#39;)) &#123;    &#x2F;&#x2F; 拼接完整URL</span><br><span class="line">        params.url &#x3D; BaseUrl + params.url</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回promise</span><br><span class="line">    return wx.pro.request(&#123; ...params &#125;)</span><br><span class="line">      .then((&#123; data: &#123; code, message, data &#125; &#125;) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; ... 各种异常情况的逻辑处理</span><br><span class="line">          &#x2F;&#x2F; 与后端约定 code 20000 时正常返回</span><br><span class="line">          if (code &#x3D;&#x3D;&#x3D; 20000) return Promise.resolve(data)</span><br><span class="line">          return Promise.reject(message)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; fetch &#125;</span><br></pre></td></tr></table></figure>

<p>然后再将所有 API 封装到单独的文件中集中管理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; utils&#x2F;api&#x2F;apis.js 封装所有请求 API</span><br><span class="line"></span><br><span class="line">import &#123; fetch &#125; from &#39;.&#x2F;fetch&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;* 根据微信code获取用户信息 *&#x2F;</span><br><span class="line">const appUserGetByCode &#x3D; (&#123; code &#125; &#x3D; &#123;&#125;) &#x3D;&gt; fetch(&#123;</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;user&#x2F;get-by-code&#39;,</span><br><span class="line">    data: &#123; code &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;* 扫码登录 *&#x2F;</span><br><span class="line">const appUserQrLogin &#x3D; (&#123; qrCode &#125; &#x3D; &#123;&#125;) &#x3D;&gt; fetch(&#123;</span><br><span class="line">    method: &#39;POST&#39;,</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;user&#x2F;qr-login&#39;,</span><br><span class="line">    data: &#123; qrCode &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;* 个人信息 *&#x2F;</span><br><span class="line">const appUserInfo &#x3D; () &#x3D;&gt; fetch(&#123;</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;user&#x2F;info&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;* 系统参数获取，数据字典 *&#x2F;</span><br><span class="line">const appSysParamListByParam &#x3D; () &#x3D;&gt; fetch(&#123;</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;sys-param&#x2F;list-by-param&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;* 数据字典所有 *&#x2F;</span><br><span class="line">const appSysParamListAll &#x3D; () &#x3D;&gt; fetch(&#123;</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;sys-param&#x2F;list-all&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    appSysParamListAll,   &#x2F;&#x2F; 数据字典所有</span><br><span class="line">    appSysParamListByParam,   &#x2F;&#x2F; 系统参数获取，数据字典</span><br><span class="line">    appUserGetByCode,   &#x2F;&#x2F; 根据微信code获取用户信息</span><br><span class="line">    appUserQrLogin,   &#x2F;&#x2F; 扫码登录</span><br><span class="line">    appUserInfo   &#x2F;&#x2F; 个人信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在要使用 API 的地方就可以这样引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Api from &#39;..&#x2F;..&#x2F;utils&#x2F;api&#x2F;apis.js&#39;   &#x2F;&#x2F; 相对路径</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方式</span><br><span class="line">Api.appSysParamListAll()</span><br><span class="line">  .then((&#123; dataList &#125;) &#x3D;&gt; this.upData(&#123; sysParamList: dataList &#125;))</span><br><span class="line">  .then(() &#x3D;&gt; &#123;</span><br><span class="line">      const keyList &#x3D; this.data.sysParamList.map(T &#x3D;&gt; T.key)</span><br><span class="line">      this.upData(&#123;</span><br><span class="line">          keyList,</span><br><span class="line">          formData: &#123; keys: keyList &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://mp.weixin.qq.com/s/PqSlKWOaWXLdEJ7SvrIy0Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PqSlKWOaWXLdEJ7SvrIy0Q</a></p>
]]></content>
  </entry>
  <entry>
    <title>小程序开发之下载保存图片</title>
    <url>/2020/10/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E4%B8%8B%E8%BD%BD%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="下载pdf"><a href="#下载pdf" class="headerlink" title="下载pdf"></a>下载pdf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">downloadFile: function(e) &#123;</span><br><span class="line">    let url &#x3D; e.currentTarget.dataset.url;</span><br><span class="line">    wx.downloadFile(&#123;</span><br><span class="line">        url: url,</span><br><span class="line">        success: function(res) &#123;</span><br><span class="line">            var filePath &#x3D; res.tempFilePath;</span><br><span class="line">            wx.openDocument(&#123;</span><br><span class="line">                filePath: filePath,</span><br><span class="line">                fileType:&quot;pdf&quot;,&#x2F;&#x2F;必填</span><br><span class="line">                success: function(res) &#123;</span><br><span class="line">                    console.log(&#39;打开文档成功&#39;)</span><br><span class="line">                &#125;,</span><br><span class="line">                fail: function(res) &#123;</span><br><span class="line">                    console.log(res);</span><br><span class="line">                &#125;,</span><br><span class="line">                complete: function(res) &#123;</span><br><span class="line">                    console.log(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: function(res) &#123;</span><br><span class="line">            console.log(&#39;文件下载失败&#39;);</span><br><span class="line">        &#125;,</span><br><span class="line">        complete: function(res) &#123;&#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="长按保存图片"><a href="#长按保存图片" class="headerlink" title="长按保存图片"></a>长按保存图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;image src&#x3D;&quot;&#123;&#123;url&#125;&#125;&quot; data-url&#x3D;&quot;&#123;&#123;url&#125;&#125;&quot; bindlongpress&#x3D;&quot;saveImage&quot;&gt;&lt;&#x2F;image&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"> data: &#123;</span><br><span class="line">   			     url:&quot;https:&#x2F;&#x2F;wechat.weixinzjit.com&#x2F;costa&#x2F;public&#x2F;uploads&#x2F;images&#x2F;20190109&#x2F;67b16149693920598435315fd0d5ab3e.jpg&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#x2F;&#x2F; 长按保存图片</span><br><span class="line"> saveImg(e)&#123;</span><br><span class="line">  let url &#x3D; e.currentTarget.dataset.url;</span><br><span class="line">  &#x2F;&#x2F;用户需要授权</span><br><span class="line">  wx.getSetting(&#123;</span><br><span class="line">   success: (res) &#x3D;&gt; &#123;</span><br><span class="line">    if (!res.authSetting[&#39;scope.writePhotosAlbum&#39;]) &#123;</span><br><span class="line">     wx.authorize(&#123;</span><br><span class="line">      scope: &#39;scope.writePhotosAlbum&#39;,</span><br><span class="line">      success:()&#x3D;&gt; &#123;</span><br><span class="line">       &#x2F;&#x2F; 同意授权</span><br><span class="line">       this.saveImg1(url);</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: (res) &#x3D;&gt;&#123;</span><br><span class="line">       console.log(res);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">     &#x2F;&#x2F; 已经授权了</span><br><span class="line">     this.saveImg1(url);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   fail: (res) &#x3D;&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)  </span><br><span class="line"> &#125;,</span><br><span class="line"> saveImg1(url)&#123;</span><br><span class="line">  wx.getImageInfo(&#123;</span><br><span class="line">   src: url,</span><br><span class="line">   success:(res)&#x3D;&gt; &#123;</span><br><span class="line">    let path &#x3D; res.path;</span><br><span class="line">    wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">     filePath:path,</span><br><span class="line">     success:(res)&#x3D;&gt; &#123; </span><br><span class="line">      console.log(res);</span><br><span class="line">     &#125;,</span><br><span class="line">     fail:(res)&#x3D;&gt;&#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;,</span><br><span class="line">   fail:(res)&#x3D;&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序之wx-upData</title>
    <url>/2020/09/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bwx-upData/</url>
    <content><![CDATA[<p>鉴于在下使用微信小程序开发时使用 <code>setData</code> 的蹩脚体验，开发了个库函数 <code>wx-updata</code>，项目上线之后，我把这个自用的库函数整理放到 Github 上开源出来 wx-updata，这个库函数在开发的时候对我很有帮助，希望也可以帮到大家 ????</p>
<p>如果大家在使用中遇到了问题，可以给我提 pr，提 issue，一起来改善小程序开发体验加油～</p>
<ol>
<li><code>wx-updata</code> 版本 0.0.10</li>
<li>Github 地址：<a href="https://github.com/SHERlocked93/wx-updata" target="_blank" rel="noopener">https://github.com/SHERlocked93/wx-updata</a></li>
<li>小程序代码片段预览地址：<a href="https://developers.weixin.qq.com/s/CcXdO1mc73jD" target="_blank" rel="noopener">https://developers.weixin.qq.com/s/CcXdO1mc73jD</a></li>
<li>小程序代码片段代码地址：<a href="https://github.com/SHERlocked93/wx-updata-demo" target="_blank" rel="noopener">https://github.com/SHERlocked93/wx-updata-demo</a></li>
</ol>
<h2 id="1-setData-不方便的地方"><a href="#1-setData-不方便的地方" class="headerlink" title="1. setData 不方便的地方"></a><strong>1. setData 不方便的地方</strong></h2><p>你在使用 <code>setData</code> 的时候，是不是有时候觉得很难受，举个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你的 data</span></span><br><span class="line">data: &#123;</span><br><span class="line">    name: <span class="string">'蜡笔小新'</span>,</span><br><span class="line">    info: &#123; height: <span class="number">140</span>, color: <span class="string">'黄色'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果要修改 <code>info.height</code> 为 155，使用 <code>setData</code> 要怎么做呢：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样会把 info 里其他属性整不见了</span></span><br><span class="line">this.setData(&#123; info: &#123; height: <span class="number">155</span> &#125; &#125;)</span><br><span class="line"><span class="comment">// 你需要取出 info 对象，修改后整个 setData</span></span><br><span class="line"><span class="keyword">const</span> &#123; info &#125; = this.data</span><br><span class="line">info.height = <span class="number">155</span></span><br><span class="line">this.setData(&#123; info &#125;)</span><br></pre></td></tr></table></figure>

<p>似乎并不太复杂，但如果 <code>data</code> 是个很大的对象，要把比较深且不同的对象、数组项挨个改变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    name: <span class="string">'蜡笔小新'</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">        height: <span class="number">140</span>, color: <span class="string">'黄色'</span>,</span><br><span class="line">        desc: [&#123; age: <span class="number">8</span> &#125;, <span class="string">'最喜欢大象之歌'</span>, <span class="string">'靓仔'</span>, &#123; dog: <span class="string">'小白'</span>, color: <span class="string">'白色'</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如某个需求，需要把 <code>info.height</code> 改为 155，同时改变 <code>info.desc</code> 数组的第 0 项的 <code>age</code> 为 12，第 3 项的 <code>color</code> 为灰色呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先取出要改变的对象，改变数字后 setData 回去</span></span><br><span class="line"><span class="keyword">const</span> &#123; info &#125; = this.data</span><br><span class="line">info.height = <span class="number">155</span></span><br><span class="line">info.desc[<span class="number">0</span>].age = <span class="number">12</span></span><br><span class="line">info.desc[<span class="number">3</span>].color = <span class="string">'灰色'</span></span><br><span class="line">this.setData(&#123; info &#125;)</span><br><span class="line"><span class="comment">// 或者像某些文章里介绍的，这样可读性差，也不太实用</span></span><br><span class="line">this.setData(&#123;</span><br><span class="line">    <span class="string">'info.height'</span>: <span class="number">155</span>,</span><br><span class="line">    <span class="string">'info.desc[0].age'</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">'info.desc[3].color'</span>: <span class="string">'灰色'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面这两种方法，是我们平常小程序里经常用的，和其他 Web 端的框架相比，就很蹩脚，一种浓浓的半成品感扑面而来，有没有这样一个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">this.upData(&#123;</span><br><span class="line">    info: &#123;</span><br><span class="line">        height: <span class="number">155</span>,</span><br><span class="line">        desc: [&#123; age: <span class="number">12</span> &#125;, , , &#123; color: <span class="string">'灰色'</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个方法会帮我们深度改变嵌套对象里对应的属性值，跳过数组项里不想改变的，只设置我们提供了的属性值、数组项，岂不是省略了一大堆蹩脚的代码，而且可读性也极佳呢。</p>
<p>这就是为什么我在上线的项目中使用 wx-updata，而不是 <code>setData</code></p>
<h2 id="2-wx-updata-的优点"><a href="#2-wx-updata-的优点" class="headerlink" title="2. wx-updata 的优点"></a><strong>2. wx-updata 的优点</strong></h2><ol>
<li>支持 <code>setData</code> 对象自动合并，不用写蹩脚的对象路径了 ????</li>
<li>支持对象中嵌套数组，数组中嵌套对象；</li>
<li>如果数组的某个值你不希望覆盖，请使用数组空位来跳过这个数组项，比如 <code>[1,,3]</code> 这个数组中间就是数组空位；</li>
<li>如果数组空位你的 <code>Eslint</code> 报错，可以使用 <code>wx-updata</code> 提供的 Empty 来代替：<code>[1, Empty, 3]</code></li>
</ol>
<h2 id="3-wx-updata-安装"><a href="#3-wx-updata-安装" class="headerlink" title="3. wx-updata 安装"></a><strong>3. wx-updata 安装</strong></h2><blockquote>
<p>你也可以直接把 <code>dist</code> 目录下的 <code>wx-updata.js</code> 拷贝到项目里使用</p>
</blockquote>
<p>使用 <code>npm</code>、<code>yarn</code> 安装方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ npm i -S wx-updata</span><br><span class="line"># or</span><br><span class="line">$ yarn add wx-updata</span><br></pre></td></tr></table></figure>

<p>然后：</p>
<ol>
<li>把微信开发者工具面板右侧的 <code>详情 - 本地设置 - 使用npm模块</code> 按钮打开；</li>
<li>点击微信开发者工具面板工具栏的 <code>工具 - 构建npm</code>；</li>
</ol>
<p>构建后成功生成 <code>miniprogram_npm</code> 文件夹就可以正常使用了</p>
<h2 id="4-wx-updata-使用方法"><a href="#4-wx-updata-使用方法" class="headerlink" title="4. wx-updata 使用方法"></a><strong>4. wx-updata 使用方法</strong></h2><h3 id="使用方式一"><a href="#使用方式一" class="headerlink" title="使用方式一"></a><strong>使用方式一</strong></h3><p>可以使用直接挂载到 <code>Page</code> 上的方式，这样就可以在 <code>Page</code> 实例中像使用 <code>setData</code> 一样使用 <code>upData</code> 了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; updataInit &#125; from <span class="string">'./miniprogram_npm/wx-updata/index'</span>  <span class="comment">// 你的库文件路径</span></span><br><span class="line">App(&#123;</span><br><span class="line">    onLaunch() &#123;</span><br><span class="line">        Page = updataInit(Page, &#123; debug: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 页面代码中</span></span><br><span class="line">this.upData(&#123;</span><br><span class="line">    info: &#123; height: <span class="number">155</span> &#125;,</span><br><span class="line">    desc: [&#123; age: <span class="number">13</span> &#125;, <span class="string">'帅哥'</span>],</span><br><span class="line">    family: [, , [, , , &#123; color: <span class="string">'灰色'</span> &#125;]]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用方式二"><a href="#使用方式二" class="headerlink" title="使用方式二"></a><strong>使用方式二</strong></h3><p>有的框架可能在 <code>Page</code> 对象上进行了进一步修改，直接替换 <code>Page</code> 的方式可能就不太好了，<code>wx-updata</code> 同样暴露了工具方法，用户可以在页面代码中直接使用工具方法进行处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面代码中</span></span><br><span class="line"><span class="keyword">import</span> &#123; objToPath &#125; from <span class="string">'./miniprogram_npm/wx-updata/index'</span>  <span class="comment">// 你的库文件路径</span></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123; a: &#123; b: <span class="number">2</span>&#125;, c: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;,</span><br><span class="line">    <span class="comment">// 自己封装一下</span></span><br><span class="line">    upData(data) &#123;</span><br><span class="line">        <span class="keyword">return</span> this.setData(objToPath(data))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 你的方法中或生命周期函数</span></span><br><span class="line">    yourMethod() &#123;</span><br><span class="line">        this.upData(&#123; a: &#123; b: <span class="number">7</span>&#125;, c: [<span class="number">8</span>,,<span class="number">9</span>]&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用-Empty-代替数组空位"><a href="#使用-Empty-代替数组空位" class="headerlink" title="使用 Empty 代替数组空位"></a><strong>使用 Empty 代替数组空位</strong></h3><p>可以使用 <code>wx-updata</code> 提供的 Empty 来代替数组空位，由于 Empty 本质上是一个 Symbol，所以只能使用 <code>wx-updata</code> 导出的，而不能自己新建。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面代码中</span></span><br><span class="line"><span class="keyword">import</span> &#123; Empty &#125; from <span class="string">'./miniprogram_npm/wx-updata/index'</span></span><br><span class="line">this.upData(&#123;</span><br><span class="line">    info: &#123; height: <span class="number">155</span> &#125;,</span><br><span class="line">    desc: [&#123; age: <span class="number">13</span> &#125;, <span class="string">'帅哥'</span>],</span><br><span class="line">    family: [Empty, Empty, [Empty, Empty, Empty, &#123; color: <span class="string">'灰色'</span> &#125;]]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-wx-updata-相关-API"><a href="#5-wx-updata-相关-API" class="headerlink" title="5. wx-updata 相关 API"></a><strong>5. wx-updata 相关 API</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page.prototype.upData(Object data, Function callback)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>data</code>：你希望设置的 data</li>
<li><code>callback</code>：跟 setData 第二个参数一样，引起界面更新渲染完毕后的回调函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updataInit(Page, config)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Page</code>：页面对象，需要在 <code>app.js</code> 中调用；</li>
<li><code>config</code>：若提供配置参数 <code>{ debug: true }</code>，会将路径化后的 data 打印出来，帮助用户进行调试；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objToPath(Object data)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>data</code>：你希望设置的 data 对象</li>
</ol>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>wx-updata</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack3最全解析</title>
    <url>/2020/09/21/webpack3%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="开始（以3-X版本为例，内容有过时的还没更新）"><a href="#开始（以3-X版本为例，内容有过时的还没更新）" class="headerlink" title="开始（以3.X版本为例，内容有过时的还没更新）"></a>开始（以3.X版本为例，内容有过时的还没更新）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;新建文件夹</span><br><span class="line">mkdir webpack_demo</span><br><span class="line">cd webpack_demo</span><br><span class="line">&#x2F;&#x2F;全局安装webpack</span><br><span class="line">npm install -g webpack@3.6.0</span><br><span class="line">&#x2F;&#x2F;初始化生成package.json</span><br><span class="line">npm init </span><br><span class="line">&#x2F;&#x2F;开发时依赖</span><br><span class="line">npm install --save-dev webpack@3.6.0</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>首先进入上节课我们建立的webpack_demo目录。进入后在根目录建立两个文件夹，分别是src文件夹和dist文件夹：</p>
<ul>
<li>src文件夹：用来存放我们编写的javascript代码，可以简单的理解为用JavaScript编写的模块。</li>
<li>dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包成的文件。</li>
</ul>
<p>你可以理解成src是源码文件，dist是我们编译打包好的文件；一个用于开发环境，一个用于生产环境。</p>
<h4 id="新建文件目录-编写程序文件"><a href="#新建文件目录-编写程序文件" class="headerlink" title="新建文件目录-编写程序文件"></a>新建文件目录-编写程序文件</h4><p>/dist/index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;jspang webpack&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;title&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;.&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>这里引入了一个JavaScript的bundle.js文件。这个文件现在还没有，这是用webpack执行打包命令后生产的文件。我们的index.html写好后，接下来在src文件夹下建立entry.js的文件，用于编写我们的JavaScript代码，也是我们的入口文件。</p>
<p>src/entry.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&#39;title&#39;).innerHTML&#x3D;&#39;Hello Webpack&#39;;</span><br></pre></td></tr></table></figure>

<p>这个文件的代码很简单，就是在</p>
<p>标签里写入Hello Webpack这句话。</p>
<h4 id="第一次Webpack打包"><a href="#第一次Webpack打包" class="headerlink" title="第一次Webpack打包"></a><strong>第一次Webpack打包</strong></h4><p>Webpack其实是可以在终端（命令行）中使用的，基本使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack &#123;entry file&#125; &#123;destination for bundled file&#125;</span><br><span class="line">&#x2F;&#x2F;本例中</span><br><span class="line">webpack src&#x2F;entry.js dist&#x2F;bundle.js</span><br></pre></td></tr></table></figure>

<ul>
<li>{entery file}:入口文件的路径，本文中就是src/entery.js的路径；</li>
<li>{destination for bundled file}:填写打包后存放的路径。</li>
<li>注意：在命令行中是不需要写{ }的。</li>
</ul>
<p>命令执行成功后，会在dist目录下出现bundle.js文件，这时我们就可以在浏览器中预览结果了，网页中显示出了Hello Webpack的信息。</p>
<h4 id="配置文件：入口和出口-配置文件webpack-config-js"><a href="#配置文件：入口和出口-配置文件webpack-config-js" class="headerlink" title="配置文件：入口和出口-配置文件webpack.config.js"></a>配置文件：入口和出口-配置文件webpack.config.js</h4><p>上节课通过一个小Demo我们对Webpack有了初步了解，但是上节课的终端打包方案，在实际开发中并不使用，而是使用Webpack的配置文件的方式进行设置。这节课我们就学一下配置文件的大体结构和入口出口文件的配置。</p>
<p>webpack.config.js就是Webpack的配置文件，这个文件需要自己在项目根目录下手动建立。建立好后我们对其进行配置，先看下面的代码（webpack.config.js的基本结构），这是一个没有内容的标准webpack配置模版。</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>entry：配置入口文件的地址，可以是单一入口，也可以是多入口。</li>
<li>output：配置出口文件的地址，在webpack2.X版本后，支持多出口配置。</li>
<li>module：配置模块，主要是解析CSS和图片转换压缩等功能。</li>
<li>plugins：配置插件，根据你的需要配置不同功能的插件。</li>
<li>devServer：配置开发服务功能，后期我们会详细讲解。</li>
</ul>
<p>entry选项（入口配置）</p>
<p>这个选项就是配置我们要压缩的文件一般是JavaScript文件（当然也可以是CSS…..）。按照上节课的代码(如果你上节课的代码还没作，那你可以返回去重新作一下)，这里要填写的是src目录下的entery.js文件。</p>
<p>wepback.config.js中的entry选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;入口文件的配置项</span><br><span class="line">entry:&#123;</span><br><span class="line">    &#x2F;&#x2F;里面的entery是可以随便写的</span><br><span class="line">    entry:&#39;.&#x2F;src&#x2F;entry.js&#39;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>output选项（出口配置）</strong></p>
<p>出口配置是用来告诉webpack最后打包文件的地址和文件名称的。按照上节课的操作，应该打包到dist目录下。在编写出口文件时，我们需要用到一点Node的知识，如果你还不会Node也没有 关系，就简单的两句代码，你记住就可以了（在视频中我还有详细的讲解）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;出口文件的配置项</span><br><span class="line">output:&#123;</span><br><span class="line">    &#x2F;&#x2F;打包的路径文职</span><br><span class="line">    path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">    &#x2F;&#x2F;打包的文件名称</span><br><span class="line">    filename:&#39;bundle.js&#39;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如果你只这样写，是会报错的：找不到path这个东西。所以我们要在webpack.config.js的头部引入path，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  path  &#x3D;  require(&#39;path&#39;);</span><br></pre></td></tr></table></figure>

<p>其实path.resolve(__dirname,’dist’)就是获取了项目的绝对路径。</p>
<p>filename:是打包后的文件名称，这里我们起名为bundle.js。</p>
<p>现在webpack.config.js的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;</span><br><span class="line">        entry:&#39;.&#x2F;src&#x2F;entry.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;</span><br><span class="line">        &#x2F;&#x2F;输出的路径，用了Node语法</span><br><span class="line">        path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F;输出的文件名称</span><br><span class="line">        filename:&#39;bundle.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码写完后，可以在终端中直接输入webpack就会进行打包。</p>
<p>在实际开发中我们都是通过配置文件进行打包的，所以必须要掌握好。</p>
<p><strong>多入口、多出口配置</strong></p>
<p>Webpack在版本1的时候很难设置多出口文件，但是在2版本开始就变的很方便了。直接看多入口和多出口的文件配置，然后可以和单一出口对比一下，你会发现这种设置非常简单（只需改动两点配置就可以）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; &#96;require&#96;(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;</span><br><span class="line">        entry:&#39;.&#x2F;src&#x2F;entry.js&#39;,</span><br><span class="line">        &#x2F;&#x2F;这里我们又引入了一个入口文件</span><br><span class="line">        entry2:&#39;.&#x2F;src&#x2F;entry2.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;</span><br><span class="line">        &#x2F;&#x2F;输出的路径，用了Node语法</span><br><span class="line">        path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F;输出的文件名称</span><br><span class="line">        &#x2F;&#x2F;filename:&#39;[name].js&#39;打包到dist文件夹下</span><br><span class="line">        filename:&#39;js&#x2F;[name].js&#39;&#x2F;&#x2F;打包到dist&#x2F;js文件夹下</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到代码的第7和14行进行了增加和修改，在入口文件配置中，增加了一个entry2.js的入口文件（这个文件你需要自己手动建立），这时候要打包的就有了两个入口文件。在代码14行我们把原来的bundle.js修改成了<code>[name].js</code>。</p>
<p><code>[name]</code>的意思是根据入口文件的名称，打包成相同的名称，有几个入口文件，就可以打包出几个文件。</p>
<h4 id="配置文件：-服务和热更新-webpack-dev-server"><a href="#配置文件：-服务和热更新-webpack-dev-server" class="headerlink" title="配置文件： 服务和热更新-webpack-dev-server"></a>配置文件： 服务和热更新-webpack-dev-server</h4><p>作为一个前端工程师，最大的编程需求之一就是所见即所得的工具，也就是常说的热更新。这节课就学习用webpack3.6版本实现热更新效果。</p>
<p><strong>设置webpack-dev-server</strong></p>
<p>要执行<code>webpack-dev-server</code>是要先用<code>npm install webpack-dev-server –save-dev</code>来进行下载的。下载好后，需要配置一下devServer。最简单的devServer配置项只有四个。先看一下代码，然后我再作解释。</p>
<p>/webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">        &#x2F;&#x2F;设置基本目录结构</span><br><span class="line">        contentBase:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F;服务器的IP地址，可以使用IP也可以使用localhost</span><br><span class="line">        host:&#39;localhost&#39;,</span><br><span class="line">        &#x2F;&#x2F;服务端压缩是否开启</span><br><span class="line">        compress:true,</span><br><span class="line">        &#x2F;&#x2F;配置服务端口号</span><br><span class="line">        port:1717</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>contentBase:配置服务器基本运行路径，用于找到程序打包地址。</li>
<li>host：服务运行地址，建议使用本机IP，这里为了讲解方便，所以用localhost。</li>
<li>compress：服务器端压缩选型，一般设置为开启，如果你对服务器压缩感兴趣，可以自行学习。</li>
<li>port：服务运行端口，建议不使用80，很容易被占用，这里使用了1717.</li>
</ul>
<p><strong>注意：</strong>这里需要使用npm 来进行安装<code>webpack-dev-server</code>了， 命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server@2.9.1 --save-dev</span><br></pre></td></tr></table></figure>

<p>这是本地安装，所以使用了–save-dev。</p>
<p>配置好后，你可以试着在终端中输入webpack-dev-server,如果可以执行成功，但是往往提示下面的错误（或者是无法找到内部或外部命令）。</p>
<p>出现下面的错误不用慌张，我们只要在package.json里配置一下scripts选项就可以执行了。</p>
<p>/package.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;:&quot;webpack-dev-server&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>配置好保存后，在终端里输入 <code>npm run server</code> 打开服务器。然后在浏览器地址栏输入<a href="http://localhost:1717就可以看到结果了。/">http://localhost:1717就可以看到结果了。</a></p>
<p><strong>支持热更新</strong></p>
<p>在npm run server 启动后，它是有一种监控机制的（也叫watch）。它可以监控到我们修改源码，并立即在浏览器里给我们更新。</p>
<p>注意：这里只是我们的webpack3.6版本支持，在3.5版本时要支持热更新还需要一些其他的操作。因为已经有了成熟的3.6版本，我就不再介绍低版本的操作方法。还有一种情况。如果你都设置好了，但是不进行热更新，可能是你系统的问题，在Linux和Ma上支持良好，在Windows上有时会出现问题。</p>
<h4 id="模块：CSS文件打包"><a href="#模块：CSS文件打包" class="headerlink" title="模块：CSS文件打包"></a>模块：CSS文件打包</h4><p>Webpack在生产环境中有一个重要的作用就是减少http的请求数，就是把多个文件打包到一个js里，这样请求数就可以减少好多。这节课我们就学习一个重要的知识，把我们的CSS文件打包。在学习CSS打包之前，需要先对webpack.config.js里的Loaders配置项进行了解。</p>
<p><strong>Loaders</strong></p>
<p>Loaders是Webpack最重要的功能之一，他也是Webpack如此盛行的原因。通过使用不同的Loader，Webpack可以的脚本和工具，从而对不同的文件格式进行特定处理。</p>
<p>简单的举几个Loaders使用例子：</p>
<ul>
<li>可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。</li>
<li>可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。</li>
<li>可以把React中的JSX转换成JavaScript代码。</li>
</ul>
<p>注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。下面我们对Loaders的配置型简单梳理一下。</p>
<ul>
<li>test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；</li>
<li>use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；</li>
<li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li>
<li>query：为loaders提供额外的设置选项（可选）。</li>
</ul>
<p>明白了Loader是什么后，就开始这节课的正题，如何打包CSS文件。</p>
<p><strong>打包CSS文件：</strong></p>
<p>建立index.css文件</p>
<p>要打包CSS你必须先要有个CSS文件，在/src目录下，我们建立一个css文件夹，在文件夹里建立index.css文件。代码内容如下。</p>
<p>./src/css/index.css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">    color: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSS文件建立好后，需要引入到入口文件中，才可以打包到，这里我们引入到entry.js中。</p>
<p><code>/src/entery.js</code>中在首行加入代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;.&#x2F;css&#x2F;index.css&quot;;</span><br><span class="line">或者 require(&quot;.&#x2F;css&#x2F;index.css&quot;)</span><br></pre></td></tr></table></figure>

<p>CSS和引入做好后，我们就需要使用loader来解析CSS文件了，这里我们需要两个解析用的loader，分别是style-loader和css-loader。</p>
<p><strong>style-loader:</strong></p>
<p>它是用来处理css文件中的url()等，npm中的网址：<code>https://www.npmjs.com/package/style-loader</code></p>
<p>用npm install 进行项目安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install style-loader@0.13.1 --save-dev</span><br></pre></td></tr></table></figure>

<p><strong>css-loader：</strong></p>
<p>它是用来将css插入到页面的style标签。npm中的网址：<a href="https://www.npmjs.com/package/css-loader" target="_blank" rel="noopener">https://www.npmjs.com/package/css-loader</a></p>
<p>用npm install 进行项目安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install css-loader@0.25.0 --save-dev</span><br></pre></td></tr></table></figure>

<p>一起下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install style-loader@0.13.1 css-loader@0.25.0 --save-dev</span><br></pre></td></tr></table></figure>

<p>两个loader都下载安装好后，我们就可以配置我们loaders了。</p>
<p><strong>loaders配置：</strong></p>
<p>修改webpack.config.js中module属性中的配置代码如下：</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: &#x2F;\.css$&#x2F;,</span><br><span class="line">              use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>webpack的loader的配置是从右往左的，从上面代码看的话，就是先使用css-loader之后使用style-loader。</p>
<p>同理，如果你使用less来写样式的话，则需要先用less-loader来编译样式文件为css文件，再继续使用css-loader与style-loader。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123; test: &#x2F;\.$&#x2F;, loader: &quot;style-loader!css-loader!less-loader&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JS压缩插件"><a href="#JS压缩插件" class="headerlink" title="JS压缩插件"></a>JS压缩插件</h4><p><strong>压缩JS代码：</strong></p>
<p>在Webpack中可以很轻松的实现JS代码的压缩，它是通过插件的方式实现的，这里我们就先来引入一个uglifyjs-webpack-plugin(JS压缩插件，简称uglify)。</p>
<p><strong>注意：</strong>虽然uglifyjs是插件，但是webpack版本里默认已经集成，不需要再次安装。</p>
<p><strong>引入：</strong></p>
<p>我们需要在webpack.config.js中引入uglifyjs-webpack-glugin插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const uglify &#x3D; &#96;require&#96;(&#39;uglifyjs-webpack-plugin&#39;);</span><br></pre></td></tr></table></figure>

<p>引入后在plugins配置里new一个 uglify对象就可以了，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">       new uglify()</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>

<p>这时候在终端中使用webpack进行打包，你会发现JS代码已经被压缩了。如果你用的VSCode的话，可以按Alt+Z让他文件自动换行，查看效果。</p>
<p>贴出通过6节课学习，现在webpack.config.js文件中的所有代码，这样大家可以对照学习。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path&#x3D;&#96;require&#96;(&#39;path&#39;);</span><br><span class="line">const uglify &#x3D; &#96;require&#96;(&#39;uglifyjs-webpack-plugin&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        entry:&#39;.&#x2F;src&#x2F;entry.js&#39;,</span><br><span class="line">        entry2:&#39;.&#x2F;src&#x2F;entry2.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        filename:&#39;[name].js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [&quot;style-loader&quot;, &quot;css-loader&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new uglify()</span><br><span class="line">    ],</span><br><span class="line">    devServer:&#123;</span><br><span class="line">       contentBase:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">       host:&#39;192.168.0.104&#39;,</span><br><span class="line">       compress:true,</span><br><span class="line">       port:1717</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="HTML文件的发布"><a href="#HTML文件的发布" class="headerlink" title="HTML文件的发布"></a>HTML文件的发布</h4><p>有经验的小伙伴其实一眼就可以看出，现在我们的项目结构是有问题的，我们把index.html直接放到了dist文件夹下，这肯定是不正确的，应该放到我们src目录下。但是前期我们为了循序渐进的学习，所以把index.html放到了dist目录下。这节课我们就学习如何把html文件打包到我们的生产路径下。</p>
<p><strong>devServer和JS压缩的冲突</strong></p>
<p>上节课学习了JS压缩，在视频中我使用了webpack进行打包，而没有使用npm run server 进行预览，也就是说没有启用devServer里的配置。那有些小伙伴在学习完视频后，在终端中输入了npm run server进行了预览，发现终端中报错了。</p>
<p>要弄明白这个问题，我们先要弄清楚什么是开发环境，什么是生产环境。开发环境中是基本不会对js进行压缩的，在开发预览时我们需要明确的报错行数和错误信息，所以完全没有必要压缩JavasScript代码。而生产环境中才会压缩JS代码，用于加快程序的工作效率。devServer用于开发环境，而压缩JS用于生产环境，在开发环境中作生产环境的事情所以Webpack设置了冲突报错。</p>
<p>在实际开发中，webpack配置文件是分开的，开发环境一个文件，生产环境一个文件。</p>
<p><strong>打包HTML文件</strong></p>
<p>我们先把dist中的html文件剪切到src目录中，并去掉我们的JS引入代码（webpack会自动为我们引入JS），因为这才是我们真实工作的目录文件结构。</p>
<p>然后我们配置webpack.config.js文件，先引入我们的html-webpack-plugin插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const htmlPlugin&#x3D; &#96;require&#96;(&#39;html-webpack-plugin&#39;);</span><br></pre></td></tr></table></figure>

<p>引入后使用npm进行安装包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>最后在webpack.config.js里的plugins里进行插件配置，配置代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new htmlPlugin(&#123;</span><br><span class="line">           minify:&#123;</span><br><span class="line">               removeAttributeQuotes:true</span><br><span class="line">           &#125;,</span><br><span class="line">           hash:true,</span><br><span class="line">           template:&#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line"></span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。</li>
<li>hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。</li>
<li>template：是要打包的html模版路径和文件名称。</li>
</ul>
<p>上边的都配置完成后，我们就可以在终端中使用webpack，进行打包。你会看到index.html文件已经被打包到我们的dist目录下了，并且自动为我们引入了路口的JS文件。</p>
<p><strong>总结：</strong></p>
<p>html文件的打包可以有效的区分开发目录和生产目录，在webpack的配置中也要搞清楚哪些配置用于生产环境，哪些配置用于开发环境，避免两种环境的配置冲突。</p>
<h4 id="图片迈坑：CSS中的图片处理（采用file-loader、url-loader）"><a href="#图片迈坑：CSS中的图片处理（采用file-loader、url-loader）" class="headerlink" title="图片迈坑：CSS中的图片处理（采用file-loader、url-loader）"></a>图片迈坑：CSS中的图片处理（采用file-loader、url-loader）</h4><p>在学习Webapck过程中你可能遇到的第一个坑就是CSS中的图片处理。很多webpack新手都在图片的坑中无法自拔（有的小伙伴在开发环境中是可以找到图片的，但是一打包后就找不到图片了，有的小伙伴是不知道如何正确引入html或者css中的图片，导致程序出错），我们将用三节课时间搞彻底走出webpack图片的坑。</p>
<p><strong>图片写入CSS</strong></p>
<p>你可以先在网上找一个图片，我这里就自恋的使用了我的头像，如果你需要下载，也可以下载（当然你可以完全自己找一个自己喜欢的）。</p>
<p>找到图片后在src目录下新建一个images文件夹，把图片放入images文件夹。</p>
<p>在index.html文件中增加一个放置div的标签（需要注意的是这里修改的是src下的index.html文件，不是dist下的，这点新手很容易弄混，要格外注意），代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;tupian&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>编写css文件，把你用的图片作为背景显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#tupian&#123;</span><br><span class="line">   background-image: url(..&#x2F;images&#x2F;manhua.png);</span><br><span class="line">   width:466px;</span><br><span class="line">   height:453px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写完成后，我们可以试着用webpack去打包一下。你会发现终端中是报错的，具体错误可以看下图。 <img src="http://7xjyw1.com1.z0.glb.clouddn.com/webpack_aadd.png" alt="alt"></p>
<p><strong>file-loader、url-loader</strong></p>
<p>上面的错误是由于缺少loader的解析，对loader其实我们并不陌生，因为前边已经学习了CSS打包的loader。我们先安装两个解析图片用的loader。</p>
<p>安装file-loader和url-loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure>

<p>安装好后我们需要对两个loader进行基本的了解，学习尽量做到知其然知其所以然。</p>
<p><strong>file-loader：</strong>解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。</p>
<p><strong>url-loader：</strong>如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。</p>
<p>配置url-loader</p>
<p>我们安装好后，就可以使用这个loader了，记得在loader使用时不需要用require引入，在plugins才需要使用require引入。</p>
<p>webpack.config.js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">   module:&#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">             test: &#x2F;\.css$&#x2F;,</span><br><span class="line">             use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">              test:&#x2F;\.(png|jpg|gif)&#x2F; ,</span><br><span class="line">              use:[&#123;</span><br><span class="line">                  loader:&#39;url-loader&#39;,</span><br><span class="line">                  options:&#123;</span><br><span class="line">                      limit:5000</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;]</span><br><span class="line">           &#125;</span><br><span class="line">         ]</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>test:/.(png|jpg|gif)/是匹配图片文件后缀名称。</li>
<li>use：是指定使用的loader和loader的配置参数。</li>
<li>limit：是把小于5000的图片打成Base64的格式，写入JS，大于5000的图片使用原来的格式</li>
</ul>
<p>写好后就可以使用webpack进行打包了，这回你会发现打包很顺利的完成了。具体的Base64的格式，你可以查看视频中的样子。</p>
<p><strong>为什么只使用了url-loader</strong></p>
<p>有的小伙伴会发现我们并没有在webpack.config.js中使用file-loader，但是依然打包成功了。我们需要了解file-loader和url-loader的关系。url-loader和file-loader是什么关系呢？简答地说，url-loader封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。通过上面的介绍，我们可以看到，url-loader工作分两种情况：</p>
<p>1.文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）；</p>
<p>2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。</p>
<p>也就是说，其实我们只安装一个url-loader就可以了。但是为了以后的操作方便，我们这里就顺便安装上file-loader。</p>
<h4 id="CSS分离与图片路径处理（extract-text-webpack-plugin插件-）"><a href="#CSS分离与图片路径处理（extract-text-webpack-plugin插件-）" class="headerlink" title="CSS分离与图片路径处理（extract-text-webpack-plugin插件/）"></a>CSS<strong>分离与图片路径处理</strong>（extract-text-webpack-plugin插件/）</h4><p>通过上节课的学习已经能把小图片打包成Base64格式，也对webpack对图片的打包有个基本了解。这节课主要学习两个知识：第一个是把CSS从JavasScript代码中分离出来，第二个是如何处理分离出来后CSS中的图片路径不对问题。</p>
<p><strong>CSS分离:extract-text-webpack-plugin</strong></p>
<p>有些简单的交互页面中，你的JavasScript页面代码会非常少，而大部分代码都在CSS中，这时候项目组长会要求把CSS单独提取出来，方便以后更改。遇到这个需求你不要惊慌，已经有大神为我们准备好了对象的插件（plugin）。</p>
<p>extract-text-webpack-plugin</p>
<p>这个插件就可以完美的解决我们提取CSS的需求，但是webpack官方其实并不建议这样作，他们认为CSS就应该打包到JavasScript当中以减少http的请求数。但现实中的需求往往不是我们前端能控制的，有些需求是我们不能控制的，分离CSS就是这样一个既合理由不合理的需求。</p>
<p><strong>安装：</strong>录制课程时的版本是3.0.0版本，直接使用npm install 就可以安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure>

<p><strong>引入：</strong>安装完成后，需要先用require引入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const extractTextPlugin &#x3D; &#96;require&#96;(&quot;extract-text-webpack-plugin&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>设置Plugins：</strong>引入成功后需要在plugins属性中进行配置。这里只要new一下这个对象就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new extractTextPlugin(&quot;&#x2F;css&#x2F;index.css&quot;)</span><br></pre></td></tr></table></figure>

<p>这里的/css/index.css是分离后的路径位置。这部配置完成后，包装代码：还要修改原来我们的style-loader和css-loader。</p>
<p>修改代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: &#x2F;\.css$&#x2F;,</span><br><span class="line">              use: extractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: &quot;style-loader&quot;,</span><br><span class="line">                use: &quot;css-loader&quot;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">               test:&#x2F;\.(png|jpg|gif)&#x2F; ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:&#39;url-loader&#39;,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:500000</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>作完上边这四部后，就可以使用webpack进行打包了。</p>
<p><strong>图片路径问题：</strong></p>
<p>利用extract-text-webpack-plugin插件很轻松的就把CSS文件分离了出来，但是CSS路径并不正确，很多小伙伴就在这里搞个几天还是没有头绪，网上也给出了很多的解决方案，我觉的最好的解决方案是使用publicPath解决，我也一直在用。</p>
<p>publicPath：是在webpack.config.js文件的output选项中，主要作用就是处理静态文件路径的。</p>
<p>在处理前，我们在webpack.config.js 上方声明一个对象，叫website。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var website &#x3D;&#123;</span><br><span class="line">    publicPath:&quot;http:&#x2F;&#x2F;192.168.1.108:1717&#x2F;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。</p>
<p>然后在output选项中引用这个对象的publicPath属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;</span><br><span class="line">        &#x2F;&#x2F;输出的路径，用了Node语法</span><br><span class="line">        path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F;输出的文件名称</span><br><span class="line">        filename:&#39;[name].js&#39;,</span><br><span class="line">        publicPath:website.publicPath</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>配置完成后，你再使用webpack命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。</p>
<p><strong>总结：</strong>这节课我们实现了CSS的分离，并在分离后处理了图片路径不对的问题。处理路径的方法一定要充分理解，因为这在工作中经常用到。</p>
<h4 id="图片迈坑：处理HTML中的图片-html-withimg-loader"><a href="#图片迈坑：处理HTML中的图片-html-withimg-loader" class="headerlink" title="图片迈坑：处理HTML中的图片(html-withimg-loader)"></a>图片迈坑：处理HTML中的图片(html-withimg-loader)</h4><p>有的小伙伴在学习视频时，并没有全局安装webpack，而是使用了项目安装。首先我要说的是，这种做法是webpack推崇的，webpack并不鼓励全局安装webpack。但是小伙伴看我视频中直接在终端用webpack进行打包项目，他使用时会出现不是内部命令或者外部命令。</p>
<p>这时候需要配置package.json里的scripts选项，我们以前的课程已经学习了配置 webpack-dev-server命令，在这个命令下面我们再加一个build命令进行打包项目使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">    &quot;build&quot;:&quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>配置完成后，可以在控制台输入npm run build 进行打包。</p>
<p><strong>如何把图片放到指定的文件夹下</strong></p>
<p>前边两节课程，打包后的图片并没有放到images文件夹下，要放到images文件夹下，其实只需要配置我们的url-loader选项就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: &#x2F;\.css$&#x2F;,</span><br><span class="line">              use: extractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: &quot;style-loader&quot;,</span><br><span class="line">                use: &quot;css-loader&quot;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">               test:&#x2F;\.(png|jpg|gif)&#x2F; ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:&#39;url-loader&#39;,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:5000,</span><br><span class="line">                       name:[name]_[hash:7].[ext]&#x2F;&#x2F;占位符，name引用原来图片的名字，hash打包的时候的hash值，ext引用原来图片的后缀</span><br><span class="line">                       outputPath:&#39;images&#x2F;&#39;,&#x2F;&#x2F;输入文件夹</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这回你再执行打包就可以把图片打包到images文件夹里了。</p>
<p><strong>html-withimg-loader</strong></p>
<p>html-withimg-loader就是我们今天的重点了，这个插件并不是很火，也是我个人喜欢的一个小loader。解决的问题就是在hmtl文件中引入图片标签的问题。</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure>

<p><strong>配置loader</strong></p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.(htm|html)$&#x2F;i,</span><br><span class="line">     use:[ &#39;html-withimg-loader&#39;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在终端中可以进行打包了。你会发现images被很好的打包了。并且路径也完全正确。</p>
<p>总结：我们通过三节课的时间讲了webpack图片中的坑，这些坑在我初学webpack初期给我带来了不少的麻烦，我也算是倾囊相教了，希望小伙伴们有所收获。在你工作中遇到图片的问题，也可以返回文章里进行对比查找问题。</p>
<h4 id="CSS进阶：Less文件的打包和分离"><a href="#CSS进阶：Less文件的打包和分离" class="headerlink" title="CSS进阶：Less文件的打包和分离"></a>CSS进阶：Less文件的打包和分离</h4><p>第05节中已经讲过CSS文件的打包，后来又讲了CSS分离。这节我们讲解一下Less文件如何打包和分离。Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。也就是说Less给我们枯燥单一的样式文件加入了编程机制，这让我们这些前端程序员很受用，所以在工作中大部分程序员都使用了Leess开发。</p>
<p><strong>打包Less文件</strong></p>
<p>安装:</p>
<p>要使用Less，我们要首先安装Less的服务，当然也是用npm来进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev less</span><br></pre></td></tr></table></figure>

<p>还需要安装Less-loader用来打包使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install --save-dev less-loader</span><br></pre></td></tr></table></figure>

<p>写loader配置：</p>
<p>安装好后，需要在webpack.config.js里编写loader配置，当然要想正确解析成CSS，还是需要style-loader和css-loader的帮助，但是这两个loader前边已经讲过了，所以在这里就不重复了，如果你还对这两个loader不熟悉，那自行回去补前边的第五节吧。</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.less$&#x2F;,</span><br><span class="line">    use: [&#123;</span><br><span class="line">           loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">        , &#123;</span><br><span class="line">            loader: &quot;less-loader&quot; &#x2F;&#x2F; compiles Less to CSS</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写一个less文件</strong></p>
<p>现在webpack的配置好了，我们还需要编写一个less文件，这里明文为black.less.里边只做一件是就是把一个层的背景设置成黑色。</p>
<p>black.less</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@base :#000;</span><br><span class="line">#gogo&#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:300px;</span><br><span class="line">    background-color:@base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里#gogo是层的ID名称。@base是我们设置的变量名称。</p>
<p><strong>引入到我们entery.js文件中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import less from &#39;.&#x2F;css&#x2F;black.less&#39;;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以把less文件进行打包了。我们可以使用webpack命令打包试一试。</p>
<p><strong>把Lees文件分离。</strong></p>
<p>我们之前讲了extract-text-webpack-plugin这个插件，想把Less文件分离出来的方法跟这个几乎一样，之前的我们在第09节中讲过，这里我们就只讲less的loader配置方法。（此处建议收看视频）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;less-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">                &#x2F;&#x2F; use style-loader in development</span><br><span class="line">                fallback: &quot;style-loader&quot;</span><br><span class="line">            &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>配置好后，你会发现less被分离到了index.css文件里。</p>
<p>总结：Less是非常好的CSS扩展，但是Less得转换稍显麻烦，好的是webpack为我们提供了简单轻松的转换方法。希望小伙伴可以学好这一课，在你们的工作中都开始使用Less编写你们css代码。</p>
<h4 id="CSS进阶：SASS文件的打包和分离"><a href="#CSS进阶：SASS文件的打包和分离" class="headerlink" title="CSS进阶：SASS文件的打包和分离"></a>CSS进阶：SASS文件的打包和分离</h4><p>上节课学习了Less的打包和分离，群里使用SASS的小伙伴马上就不干了，要求讲一下SASS的配置，其实你会了Less得配置，SASS的配置可以很轻松的学会，为了公平公正，那我们就用一节课的时间学一下SASS的配置的。</p>
<p><strong>安装SASS打包的loader</strong></p>
<p>这里需要 在项目目录下用npm安装两个包。node-sass和sass-loader</p>
<p>node-sass：因为sass-loader依赖于node-sass，所以需要先安装node-sass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install --save-dev node-sass</span><br></pre></td></tr></table></figure>

<p>sass-loader:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev sass-loader</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在用npm安装时，这个loader很容易安装失败，最好使用cnpm来进行安装。如果你安装一直报错，最好是把node_modules文件夹删除后，再重新安装。</p>
<p>编写loader配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">                test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;sass-loader&quot; &#x2F;&#x2F; compiles Sass to CSS</span><br><span class="line">                &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Sass文件的编写</strong></p>
<p>写好loader配置后，就可以愉快的编写sass文件拉，但是不要忘记把sass文件引入到entery.js中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$nav-color: #FFF;</span><br><span class="line">#nav &#123;</span><br><span class="line">  $width: 100%;</span><br><span class="line">  width: $width;</span><br><span class="line">  height:30px;</span><br><span class="line">  background-color: $nav-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都完成后，你就可以启动我们npm run server 来查看效果了。</p>
<p><strong>把SASS文件分离。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;sass-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">                &#x2F;&#x2F; use style-loader in development</span><br><span class="line">                fallback: &quot;style-loader&quot;</span><br><span class="line">            &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这节课算是专门为sass使用者录制的吧，其实整体过程和less的使用差不多，希望你能在工作中开始使用sass，并写出漂亮的css代码。</p>
<h4 id="CSS进阶：自动处理css前缀，兼容浏览器"><a href="#CSS进阶：自动处理css前缀，兼容浏览器" class="headerlink" title="CSS进阶：自动处理css前缀，兼容浏览器"></a>CSS进阶：自动处理css前缀，兼容浏览器</h4><p>这节课我们就学习一下如何通过postcss-loader给css3属性自动添加前缀。</p>
<p><strong>什么是属性前缀</strong></p>
<p>我们先来看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-webkit-transform: rotate(45deg);</span><br><span class="line">        transform: rotate(45deg);</span><br></pre></td></tr></table></figure>

<p>为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz这些前缀。目的就是让我们写的页面在每个浏览器中都可以顺利运行。</p>
<p><strong>PostCSS</strong></p>
<p>PostCSS是一个CSS的处理平台，它可以帮助你的CSS实现更多的功能，但是今天我们就通过其中的一个加前缀的功能，初步了解一下PostCSS。</p>
<p><strong>安装</strong></p>
<p>需要安装两个包postcss-loader 和autoprefixer（自动添加前缀的插件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br></pre></td></tr></table></figure>

<p>postcss.config.js</p>
<p>postCSS推荐在项目根目录（和webpack.config.js同级），建立一个postcss.config.js文件。</p>
<p>postcss.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: &#123;  </span><br><span class="line">        &#39;autoprefixer&#39;: &#123;browsers: &#39;last 5 version&#39;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        require(&#39;autoprefixer&#39;)</span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是对postCSS一个简单的配置，引入了autoprefixer插件。让postCSS拥有添加前缀的能力，它会根据 can i use 来增加相应的css3属性前缀。</p>
<p><strong>编写loader</strong></p>
<p>对postcss.config.js配置完成后，我们还需要编写我们的loader配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      test: &#x2F;\.css$&#x2F;,</span><br><span class="line">      use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &quot;style-loader&quot;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: &quot;css-loader&quot;,</span><br><span class="line">              options: &#123;</span><br><span class="line">                 modules: true</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: &quot;postcss-loader&quot;</span><br><span class="line">            &#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提取CSS</strong></p>
<p>配置提取CSS的loader配置.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &#39;style-loader&#39;,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; loader: &#39;css-loader&#39;, options: &#123; importLoaders: 1 &#125; &#125;,</span><br><span class="line">            &#39;postcss-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:postcss还有很多功能，我希望小伙伴学会自学。这里给出postcss-loader的github地址：<a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">https://github.com/postcss/postcss-loader</a></p>
<h4 id="CSS进阶：消除未使用的CSS"><a href="#CSS进阶：消除未使用的CSS" class="headerlink" title="CSS进阶：消除未使用的CSS"></a>CSS进阶：消除未使用的CSS</h4><p>像Bootstrap这样的框架往往会带有很多CSS。在项目中通常我们只使用它的一小部分。就算我们自己写CSS，随着项目的进展，CSS也会越来越多，有时候需求更改，带来了DOM结构的更改，这时候我们可能无暇关注CSS样式，造成很多CSS的冗余。这节课就学习用webpack消除未使用的CSS。</p>
<p><strong>PurifyCSS</strong></p>
<p>使用PurifyCSS可以大大减少CSS冗余，比如我们经常使用的BootStrap(140KB)就可以减少到只有35KB大小。这在实际开发当中是非常有用的。</p>
<p><strong>安装PurifyCSS-webpack</strong></p>
<p>从名字你就可以看出这是一个插件，而不是loader。所以这个需要安装还需要引入。 PurifyCSS-webpack要以来于purify-css这个包，所以这两个都需要安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npmn  i -D purifycss-webpack purify-css</span><br></pre></td></tr></table></figure>

<p>这里的-D代表的是–save-dev ,只是一个简写。</p>
<p><strong>引入glob</strong></p>
<p>因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。在webpack.config.js文件头部引入glob。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const glob &#x3D; &#96;require&#96;(&#39;glob&#39;);</span><br></pre></td></tr></table></figure>

<p>引入purifycss-webpack</p>
<p>同样在webpack.config.js文件头部引入purifycss-webpack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PurifyCSSPlugin &#x3D; &#96;require&#96;(&quot;purifycss-webpack&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>配置plugins</strong></p>
<p>引入完成后我们需要在webpack.config.js里配置plugins。代码如下，重点看标黄部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    &#x2F;&#x2F;new uglify() </span><br><span class="line">    new htmlPlugin(&#123;</span><br><span class="line">        minify:&#123;</span><br><span class="line">            removeAttrubuteQuotes:true</span><br><span class="line">        &#125;,</span><br><span class="line">        hash:true,</span><br><span class="line">        template:&#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line"></span><br><span class="line">    &#125;),</span><br><span class="line">    new extractTextPlugin(&quot;css&#x2F;index.css&quot;),</span><br><span class="line">    new PurifyCSSPlugin(&#123;</span><br><span class="line">        &#x2F;&#x2F; Give paths to parse for rules. These should be absolute!</span><br><span class="line">        paths: glob.sync(path.join(__dirname, &#39;src&#x2F;*.html&#39;)),</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这里配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了。</p>
<p><strong>注意：</strong>使用这个插件必须配合extract-text-webpack-plugin这个插件，这个插件在前边的课程已经讲解过了。如果你还不会请自学一下。</p>
<p>配置好上边的代码，我们可以故意在css文件里写一些用不到的属性，然后用webpack打包，你会发现没用的CSS已经自动给你删除掉了。在工作中记得一定要配置这个plugins，因为这决定你代码的质量，非常有用。</p>
<h4 id="打包iconfont字体文件"><a href="#打包iconfont字体文件" class="headerlink" title="打包iconfont字体文件"></a>打包iconfont字体文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: &#x2F;\.(woff2?|eot|ttf|otf)(\?.*)?$&#x2F;,</span><br><span class="line">        loader: &quot;url-loader&quot;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&quot;fonts&#x2F;[name].[hash:7].[ext]&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="给webpack增加bable支持（es6转es5）"><a href="#给webpack增加bable支持（es6转es5）" class="headerlink" title="给webpack增加bable支持（es6转es5）"></a>给webpack增加bable支持（es6转es5）</h4><p>在前端开发中都开始使用ES6的语法了，虽然说webpack3增加了一些ES6的转换支持，但是实际效果不是很好，也可能是本人技术有限，没发挥出真正的功能。所以我在开发中还是喜欢添加Babel-loader的，我也查看了一些别人的webpack配置也都增加了babel-loader，所以这节课我们学习一下如何增加Babel支持。（此节文章部分内容引用了zhangwang大神的文章内容）</p>
<p>Babel是什么？ Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过便宜帮你达到以下目的：</p>
<p>使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。</p>
<p>使用基于JavaScript进行了扩展的语言，比如React的JSX。</p>
<p><strong>Babel的安装与配置</strong></p>
<p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。</p>
<p>我们先一次性安装这些依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm c install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</span><br></pre></td></tr></table></figure>

<p>在webpack中配置Babel的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:&#39;babel-loader&#39;,</span><br><span class="line">        options:&#123;</span><br><span class="line">            presets:[</span><br><span class="line">                &quot;es2015&quot;,&quot;react&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你已经可以用webapck转换ES6的语法兼容各个浏览器了，我们可以修改一下entry.js的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import css from &#39;.&#x2F;css&#x2F;index.css&#39;;</span><br><span class="line">&#123;</span><br><span class="line">    let jspangString &#x3D; &#39;Hello Webpack&#39;</span><br><span class="line">    document.getElementById(&#39;title&#39;).innerHTML&#x3D;jspangString; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用了ES6的let声明方法。如果你不使用Babel来进行转换，你会发现打包出来的js代码没有作兼容处理，使用了Babel转换的代码是进行处理过的。</p>
<p><strong>.babelrc配置</strong></p>
<p>虽然Babel可以直接在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，如果卸载webapck.config.js中会非常的雍长不可阅读，所以我们经常把配置卸载.babelrc文件里。</p>
<p>在项目根目录新建.babelrc文件，并把配置写到文件里。</p>
<p>.babelrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;react&quot;,&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.webpack.config.js里的loader配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:&#39;babel-loader&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ENV：</strong></p>
<p>现在网络上已经不流行babel-preset-es2015，现在官方推荐使用的是babel-preset-env,那我们为了紧跟潮流，我们在讲一下env的配置方法。</p>
<p>首先需要下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install --save-dev babel-preset-env</span><br></pre></td></tr></table></figure>

<p>然后修改.babelrc里的配置文件。其实只要把之前的es2015换成env就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：对于在React中Babel的使用，如何解析JSX，我会在后边的课程作详细了解，大家不要着急。在实际工作中还是要安装Babel的，这样能更好的兼容每种浏览器，而把Babel的配置文件分解出来是最好的选择。</p>
<h4 id="打包后如何调试"><a href="#打包后如何调试" class="headerlink" title="打包后如何调试"></a>打包后如何调试</h4><p>作为一个程序员每天的大部分工作就是调试自己写的程序，那我们使用了webpack后，所以代码都打包到了一起，给调试带来了麻烦，但是webpack已经为我们充分考虑好了这点，它支持生产Source Maps来方便我们的调试。（敲黑板，这节可能偏理论一点。）</p>
<p>在使用webpack时只要通过简单的devtool配置，webapck就会自动给我们生产source maps 文件，map文件是一种对应编译文件和源文件的方法，让我们调试起来更简单。</p>
<p>四种选项</p>
<p>在配置devtool时，webpack给我们提供了四种选项。</p>
<ul>
<li>source-map:在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的source map,但是它会减慢打包速度；</li>
<li>cheap-module-source-map:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。</li>
<li>eval-source-map:使用eval打包源文件模块，在同一个文件中生产干净的完整版的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</li>
<li>cheap-module-eval-source-map:这是在打包文件时最快的生产source map的方法，生产的 Source map 会和打包后的JavaScript文件同行显示，没有影射列，和eval-source-map选项具有相似的缺点。</li>
</ul>
<p>四种打包模式，有上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对执行和调试有一定的影响。</p>
<p>个人意见是，如果大型项目可以使用source-map，如果是中小型项目使用eval-source-map就完全可以应对，需要强调说明的是，source map只适用于开发阶段，上线前记得修改这些调试设置。</p>
<p>简单的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  devtool: &#39;eval-source-map&#39;,</span><br><span class="line">  entry:  __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;&#x2F;public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：调试在开发中也是必不可少的，但是一定要记得在上线前一定要修改webpack配置，在打出上线包。</p>
<h4 id="实战技巧：开发和生产并行设置"><a href="#实战技巧：开发和生产并行设置" class="headerlink" title="实战技巧：开发和生产并行设置"></a>实战技巧：开发和生产并行设置</h4><p><strong>依赖不同</strong></p>
<p>一个项目中是有开发环境和生产环境的，这两个环境的依赖也是不同的。</p>
<ul>
<li>开发依赖：只在开发中用来帮助你进行开发，简化代码或者生成兼容设置的以来包。你可以打开package.json来查看，devDependencies的下面的这些包为开发使用的包。这些包在生产环境中并没有用处。</li>
<li>生产依赖：就是比如我们的js使用了jquery，jquery的程序要在浏览器端起作用，也就是说我们最终的程序也需要这个包，这就是生产依赖。这些包在dependencies中。</li>
</ul>
<p>npm安装</p>
<p>假如我们要在项目中使用jquery库，这时候我们一般有三种安装方法，每种我都详细讲解一下。</p>
<p><strong>第一种：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install jquery</span><br></pre></td></tr></table></figure>

<p>安装完成后，你会发现在package.json中并不存在这个包的依赖。如果你项目拷贝给别人继续开发，或者别人和你git合作，再次下载项目npm install时就会缺少这个jquery包。项目就会无法正常运行，所以这也是我们最不赞成的安装方法。</p>
<p><strong>第二种：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install jquery --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，它存在于package.json的dependencies中，也就是说它是生产环境需要依赖的包（上线时需要的以来包）。</p>
<p><strong>第三种：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install jquery --save-dev</span><br></pre></td></tr></table></figure>

<p>安装完成后，它存在于package.json的devDependencies中，也就是说它是开发环境中需要的，上线并不需要这个包的依赖。</p>
<p><strong>安装全部项目依赖包：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>安装生产环境依赖包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --production</span><br></pre></td></tr></table></figure>

<p><strong>配置生产和开发并行</strong></p>
<p>我们在以前的配置中设置了一个变量website，用于静态资源正确找到路径。那如果生产环境和开发环境不一样，而且我们需要来回切换，这时候我们需要更好的设置方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var website&#x3D;&#123;</span><br><span class="line">    publicPath:&quot;http:&#x2F;&#x2F;192.168.0.104:1717&#x2F;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>采用插件的形式设置环境变量的值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">       new webpack.DefinePlugin(&#123;</span><br><span class="line">           &#39;process.env&#39;: &#123;</span><br><span class="line">               NODE_ENV: &#39;&quot;production&quot;&#39;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>

<p><strong>修改package.json命令</strong></p>
<p>其实就是添加一个dev设置，并通过环境变量来进行区分，下面是package.json里的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">    &quot;dev&quot;:&quot;set NODE_ENV&#x3D;dev&amp;webapck&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;set NODE_ENV&#x3D;build&amp;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><strong>修改webpack.config.js文件</strong></p>
<p>可以利用node的语法来读取NODE_ENV的值，然后根据NODE_ENV的值用if–else判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(process.env.NODE_ENV&#x3D;&#x3D; &quot;build&quot;)&#123;</span><br><span class="line">    var website&#x3D;&#123;</span><br><span class="line">        publicPath:&quot;http:&#x2F;&#x2F;192.168.0.104:1717&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    var website&#x3D;&#123;</span><br><span class="line">        publicPath:&quot;http:&#x2F;&#x2F;cdn.jspang.com&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你说我想看一下传过来的值到底是什么？可以用下面的输出语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log( encodeURIComponent(process.env.NODE_ENV) );</span><br></pre></td></tr></table></figure>

<p><strong>Mac下的package.json设置</strong></p>
<p>MAC电脑下需要把set换成export，并且要多加一个&amp;符，具体代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">    &quot;dev&quot;:&quot;export NODE_ENV&#x3D;dev&amp;&amp;webpack&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;export NODE_ENV&#x3D;build&amp;&amp;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="实战技巧：webpack模块化配置"><a href="#实战技巧：webpack模块化配置" class="headerlink" title="实战技巧：webpack模块化配置"></a>实战技巧：webpack模块化配置</h4><p>现在的前端开发随着ES6的普及已经大面积使用模块化进行开发了，那在webpack.config.js配置文件中，如何进行模块化开发那？例如把开发环境的写到一个模块中，把生产环境的写到一个模块中。这节课我们就用一节课的时间学习一下webpack模块化配置的技巧。</p>
<p><strong>JS中的模块化实现</strong></p>
<p>先来看一下JavaScript如何实现模块话开发。其实很多小伙伴都会这种操作，那我们就当复习了，再预习一遍知识。看下面ES6中的模块化代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function jspang()&#123;</span><br><span class="line">    alert(&#39;jspang.com:&#39;+&#39;webpack&#39;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports&#x3D;jspang;</span><br></pre></td></tr></table></figure>

<p>上面的代码是一个最简单的es6模块化写法，我们声明了一个jspang方法，并且把这个方法用module.exports进行暴露出去。然后我们在入口文件中用import进行引入，并进行使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import jspang from &#39;.&#x2F;jspang.js&#39;;</span><br><span class="line">jspang();</span><br></pre></td></tr></table></figure>

<p>我们了解如何作Javascript的模块化后，其实webpack的模块化和上边的过程很类似。</p>
<p><strong>webpack模块</strong></p>
<p>为了让大家容易看懂，我把webpack.config.js中的entry入口文件进行模块化设置，单独拿出来制作成一个模块。</p>
<p>首先在根目录，新建一个webpack_config文件夹，然后新建entry_webpack.js文件，代码如下：</p>
<p>entry_webpack.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明entry变量</span><br><span class="line">const entry &#x3D;&#123;&#125;;  </span><br><span class="line">&#x2F;&#x2F;声明路径属性</span><br><span class="line">entry.path&#x3D;&#123;</span><br><span class="line">    entry:&#39;.&#x2F;src&#x2F;entry.js&#39;  </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;进行模块化</span><br><span class="line">module.exports &#x3D;entry;</span><br></pre></td></tr></table></figure>

<p>配置的模块化代码编写好以后，需要在webpack.config.js中引入，注意这里的引入只能使用require的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const entry &#x3D; require(&quot;.&#x2F;webpack_config&#x2F;entry_webpack.js&quot;)</span><br></pre></td></tr></table></figure>

<p>然后在入口文件部分，修改成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry:entry.path,</span><br></pre></td></tr></table></figure>

<p>这时候你可以再次使用npm run dev 进行测试，你会发现模块化成功了。</p>
<p><strong>总结：</strong>模块化在实际工作中是必不可少的操作，但是现在的webpack教程还很少讲到，大家一定要重视这节，因为如果你搞不清这节的内容，可能你看别人的配置也会看不明白。记得一定要动手练习操作，否则你下面的课程也没办法学习。</p>
<h4 id="实战技巧：优雅打包第三方类库（JQuery）"><a href="#实战技巧：优雅打包第三方类库（JQuery）" class="headerlink" title="实战技巧：优雅打包第三方类库（JQuery）"></a>实战技巧：优雅打包第三方类库（JQuery）</h4><p>在工作中引用第三方的框架是必不可少的，比如引入JQuery或者Vue，但是很多小伙伴一遇到引入第三方的类库时就不知道如何操作了。这节课就学习一下如何优雅并正确的用webpack引入第三方库。（本节建议收看视频学习）我们讲两种打包的方法，小伙伴们可以根据自己的喜好选择，个人认为两种都是比较不错的。</p>
<p><strong>引入JQuery</strong></p>
<p>其实引用第三方库的方法有很多种，但是有些并不是很优雅，还有些方法会出现打包问题，技术胖在这里介绍一下自己工作中引入第三方模块的方法，我们就拿JQuery为例。小伙伴们要举一反三，学会后试着自己引入Vue试试。</p>
<p>安装JQuery</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save jquery</span><br></pre></td></tr></table></figure>

<p>安装时需要注意的时Jquery最终要在生产环境中使用，所以我们这里要使用–save进行安装。</p>
<p><strong>修改entry.js文件</strong></p>
<p>安装好后，还需要引入到我们的entry.js中，这里直接使用import进行引入就可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &#39;jquery&#39;;</span><br></pre></td></tr></table></figure>

<p>这里引入是不需要我们写相对路径的，因为jquery的包是在node_modules里的，只要写一个包名jquery，系统会自动为我们查找的。</p>
<p>引入好后我们就可以在entry.js里使用jquery，我们可以加入下面的代码，然后进行测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;#title&#39;).html(&#39;Hello JSpang&#39;);</span><br></pre></td></tr></table></figure>

<p>可以看到上面是标准的jquery代码，你可以使用npm run server 进行测试，现在代码顺利运行了，这说明我们引用的JQuery库成功了。需要说的是你不仅可以在入口中进行引入，你还可以在任何你需要的js中引入，webpack并不会重复打包，它只给我们打包一次。</p>
<p><strong>用plugin引入</strong></p>
<p>如果你觉的上面的方法和webpack没什么关系，只是普通的引入，webpack只是负责了一下打包，这样并没有全局感。那再学习一种在webapck.config.js中配置的方法，这种不需要你在入口文件中引入，而是webpack给你作了全局引入。这个插件就是ProvidePlugin。</p>
<p>ProvidePlugin是一个webpack自带的插件，Provide的意思就是装备、提供。因为ProvidePlugin是webpack自带的插件，所以要先再webpack.config.js中引入webpack。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constc  webpack &#x3D; require(&#39;webpack&#39;);</span><br></pre></td></tr></table></figure>

<p>在webpack.config.js里引入必须使用require，否则会报错的，这点小伙伴们一定要注意。</p>
<p>引入成功后配置我们的plugins模块，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    new webpack.ProvidePlugin(&#123;</span><br><span class="line">        $:&quot;jquery&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>配置好后，就可以在你的入口文件中使用了，而不用再次引入了。这是一种全局的引入，在实际工作中也可以很好的规范项目所使用的第三方库。</p>
<p><strong>总结：</strong>每一个项目都可能引入第三方类库，而像Vue和Angular这样的成熟框架都推出了自己的webpack框架，比如vue-cli。但是很多情况还是需要我们手动更改这些配置好的webpack来适用于我们的公司项目，所以这节课的知识也是在工作中经常使用的，希望小伙伴们一定要重视并进行练习。</p>
<h3 id="打包多个文件"><a href="#打包多个文件" class="headerlink" title="打包多个文件"></a>打包多个文件</h3><p><strong>1.多个js文件不合并打包(分别打包)</strong></p>
<p>配置文件./conf/webpack.dev.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>, <span class="comment">//打包为开发模式</span></span><br><span class="line">    <span class="comment">// 入口配置的对象中，属性为输出的js文件名，属性值为入口文件</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">    	main1:<span class="string">"./src/main1"</span>,</span><br><span class="line">    	main2:<span class="string">"./src/main2"</span></span><br><span class="line">    &#125;, <span class="comment">//入口文件,从项目根目录指定</span></span><br><span class="line">    output: &#123; <span class="comment">//输出路径和文件名，使用path模块resolve方法将输出路径解析为绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"../dist/js"</span>), <span class="comment">//将js文件打包到dist/js的目录</span></span><br><span class="line">        filename: <span class="string">"[name].js"</span> <span class="comment">//使用[name]打包出来的js文件会分别按照入口文件配置的属性来命名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包过程：</p>
<p><img src="https://img-blog.csdn.net/20180719162034769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjE4NTAyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>打包结果：</p>
<p><img src="https://img-blog.csdn.net/20180719162218590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjE4NTAyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>2.多个js中部分合并打包成一个js文件</strong></p>
<p>配置文件./conf/webpack.dev.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>, <span class="comment">//打包为开发模式</span></span><br><span class="line">    <span class="comment">// 出口对象中，属性为输出的js文件名，属性值为入口文件</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">    	main1:<span class="string">"./src/main1"</span>,</span><br><span class="line">    	main:[<span class="string">"./src/main2"</span>,<span class="string">"./src/main3"</span>]</span><br><span class="line">    &#125;, <span class="comment">//入口文件,从项目根目录指定</span></span><br><span class="line">    output: &#123; <span class="comment">//输出路径和文件名，使用path模块resolve方法将输出路径解析为绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"../dist/js"</span>), <span class="comment">//将js文件打包到dist/js的目录</span></span><br><span class="line">        filename: <span class="string">"[name].js"</span> <span class="comment">//使用[name]打包出来的js文件会分别按照入口文件配置的属性来命名</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.多个js全部打包成一个js文件</strong></p>
<p>配置文件./conf/webpack.dev.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>, <span class="comment">//打包为开发模式</span></span><br><span class="line">    <span class="comment">// 出口对象中，属性为输出的js文件名，属性值为入口文件</span></span><br><span class="line">    entry: [<span class="string">"./src/main1"</span>,<span class="string">"./src/main2"</span>,<span class="string">"./src/main3"</span>], <span class="comment">//入口文件,从项目根目录指定</span></span><br><span class="line">    output: &#123; <span class="comment">//输出路径和文件名，使用path模块resolve方法将输出路径解析为绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"../dist/js"</span>), <span class="comment">//将js文件打包到dist/js的目录</span></span><br><span class="line">        filename: <span class="string">"main.js"</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>webpack3</category>
      </categories>
      <tags>
        <tag>webpack3</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序如何生成海报分享朋友圈</title>
    <url>/2020/09/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E6%B5%B7%E6%8A%A5%E5%88%86%E4%BA%AB%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>利用微信强大的社交能力通过小程序达到裂变的目的，拉取新用户。<br>生成的海报如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvu1YtvSoiajLEyawsNz1JTxLpJb1T6GDwktsib3UBrOEz9KYatzRbhE9fIxjYGteosUh33C4Ysq2icw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<a id="more"></a>

<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>1、利用小程序官方提供的api可以直接分享转发到微信群打开小程序<br>2、利用小程序生成海报保存图片到相册分享到朋友圈，用户长按识别二维码关注公众号或者打开小程序来达到裂变的目的</p>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><h4 id="一、分析如何实现"><a href="#一、分析如何实现" class="headerlink" title="一、分析如何实现"></a>一、分析如何实现</h4><p>相信大家应该都会有类似的迷惑，就是如何按照产品设计的那样绘制成海报，其实当时我也是不知道如何下手，认真想了下得通过canvas绘制成图片，这样用户保存这个图片到相册，就可以分享到朋友圈了。但是要绘制的图片上面不仅有文字还有数字、图片、二维码等且都是活的，这个要怎么动态生成呢。认真想了下，需要一点一点的将文字和数字，背景图绘制到画布上去，这样通过api最终合成一个图片导出到手机相册中。</p>
<h4 id="二、需要解决的问题"><a href="#二、需要解决的问题" class="headerlink" title="二、需要解决的问题"></a>二、需要解决的问题</h4><p>1、二维码的动态获取和绘制（包括如何生成小程序二维码、公众号二维码、打开网页二维码）<br>2、背景图如何绘制，获取图片信息<br>3、将绘制完成的图片保存到本地相册<br>4、处理用户是否取消授权保存到相册</p>
<h4 id="三、实现步骤"><a href="#三、实现步骤" class="headerlink" title="三、实现步骤"></a>三、实现步骤</h4><p><strong>这里我具体写下围绕上面所提出的问题，描述大概实现的过程</strong></p>
<p>①首先创建canvas画布,我把画布定位设成负的,是为了不让它显示在页面上,是因为我尝试把canvas通过判断条件动态的显示和隐藏,在绘制的时候会出现问题,所以采用了这种方法，这里还有一定要设置画布的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas canvas-id&#x3D;&quot;myCanvas&quot; style&#x3D;&quot;width: 690px;height:1085px;position: fixed;top: -10000px;&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure>

<p>②创建好画布之后，先绘制背景图，因为背景图我是放在本地，所以获取 <canvas> 组件 canvas-id 属性，通过createCanvasContext创建canvas的绘图上下文 CanvasContext 对象。使用drawImage绘制图像到画布，第一个参数是图片的本地地址，后面两个参数是图像相对画布左上角位置的x轴和y轴，最后两个参数是设置图像的宽高。</canvas></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ctx &#x3D; wx.createCanvasContext(&#39;myCanvas&#39;)</span><br><span class="line"></span><br><span class="line">ctx.drawImage(&#39;&#x2F;img&#x2F;study&#x2F;shareimg.png&#39;, 0, 0, 690, 1085)</span><br></pre></td></tr></table></figure>

<p>③创建好背景图后，在背景图上绘制头像，文字和数字。通过getImageInfo获取头像的信息，这里需要注意下在获取的网络图片要先配置download域名才能生效，具体在小程序后台设置里配置。</p>
<p>获取头像地址，首先量取头像在画布中的大小，和x轴Y轴的坐标，这里的result[0]是我用promise封装返回的一个图片地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> headImg = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        wx.getImageInfo(&#123;</span><br><span class="line">          src: <span class="string">`<span class="subst">$&#123;app.globalData.baseUrl2&#125;</span><span class="subst">$&#123;that.data.currentChildren.headImg&#125;</span>`</span>,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            resolve(res.path)</span><br><span class="line">          &#125;,</span><br><span class="line">          fail: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">              title: <span class="string">'网络错误请重试'</span>,</span><br><span class="line">              icon: <span class="string">'loading'</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">let</span> avatarurl_width = <span class="number">60</span>, <span class="comment">//绘制的头像宽度</span></span><br><span class="line">    avatarurl_heigth = <span class="number">60</span>, <span class="comment">//绘制的头像高度</span></span><br><span class="line">    avatarurl_x = <span class="number">28</span>, <span class="comment">//绘制的头像在画布上的位置</span></span><br><span class="line">    avatarurl_y = <span class="number">36</span>; <span class="comment">//绘制的头像在画布上的位置</span></span><br><span class="line">    </span><br><span class="line">    ctx.save(); <span class="comment">// 先保存状态 已便于画完圆再用</span></span><br><span class="line">    ctx.beginPath(); <span class="comment">//开始绘制</span></span><br><span class="line">    <span class="comment">//先画个圆   前两个参数确定了圆心 （x,y） 坐标  第三个参数是圆的半径  四参数是绘图方向  默认是false，即顺时针</span></span><br><span class="line">    ctx.arc(avatarurl_width / <span class="number">2</span> + avatarurl_x, avatarurl_heigth / <span class="number">2</span> + avatarurl_y, avatarurl_width / <span class="number">2</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">    ctx.clip(); <span class="comment">//画了圆 再剪切  原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内</span></span><br><span class="line">    ctx.drawImage(result[<span class="number">0</span>], avatarurl_x, avatarurl_y, avatarurl_width, avatarurl_heigth); <span class="comment">// 推进去图片</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里举个例子说下如何绘制文字，比如我要绘制如下这个“字”，需要动态获取前面字数的总宽度，这样才能设置“字”的x轴坐标，这里我本来是想通过measureText来测量字体的宽度，但是在iOS端第一次获取的宽度值不对，关于这个问题，我还在微信开发者社区提了bug，所以我想用另一个方法来实现，就是先获取正常情况下一个字的宽度值，然后乘以总字数就获得了总宽度，亲试是可以的。</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvu1YtvSoiajLEyawsNz1JTxgNlzticcibNAObP0F6iaFVPAjbziauHKauUX5yQJFTXGO5HkMa2cIDOpqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let allReading &#x3D; 97 &#x2F; 6 &#x2F; app.globalData.ratio * wordNumber.toString().length + 325;</span><br><span class="line">ctx.font &#x3D; &#39;normal normal 30px sans-serif&#39;;</span><br><span class="line">ctx.setFillStyle(&#39;#ffffff&#39;)</span><br><span class="line">ctx.fillText(&#39;字&#39;, allReading, 150);</span><br></pre></td></tr></table></figure>

<p>④绘制公众号二维码，和获取头像是一样的，也是先通过接口返回图片网络地址，然后再通过getImageInfo获取公众号二维码图片信息</p>
<p>⑤如何绘制小程序码，具体官网文档也给出生成无限小程序码接口，通过生成的小程序可以打开任意一个小程序页面，并且二维码永久有效，具体调用哪个小程序二维码接口有不同的应用场景，具体可以看下官方文档怎么说的，也就是说前端通过传递参数调取后端接口返回的小程序码，然后绘制在画布上（和上面写的绘制头像和公众号二维码一样的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.drawImage(&#39;小程序码的本地地址&#39;, x轴, Y轴, 宽, 高)</span><br></pre></td></tr></table></figure>

<p>⑥最终绘制完把canvas画布转成图片并返回图片地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.canvasToTempFilePath(&#123;</span><br><span class="line">    canvasId: &#39;myCanvas&#39;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">      canvasToTempFilePath &#x3D; res.tempFilePath &#x2F;&#x2F; 返回的图片地址保存到一个全局变量里</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        showShareImg: true</span><br><span class="line">      &#125;)</span><br><span class="line">      wx.showToast(&#123;</span><br><span class="line">        title: &#39;绘制成功&#39;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function () &#123;</span><br><span class="line">      wx.showToast(&#123;</span><br><span class="line">        title: &#39;绘制失败&#39;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: function () &#123;</span><br><span class="line">      wx.hideLoading()</span><br><span class="line">      wx.hideToast()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>⑦保存到系统相册；先判断用户是否开启用户授权相册，处理不同情况下的结果。比如用户如果按照正常逻辑授权是没问题的，但是有的用户如果点击了取消授权该如何处理，如果不处理会出现一定的问题。所以当用户点击取消授权之后，来个弹框提示，当它再次点击的时候，主动跳到设置引导用户去开启授权，从而达到保存到相册分享朋友圈的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取用户是否开启用户授权相册</span><br><span class="line">    if (!openStatus) &#123;</span><br><span class="line">      wx.openSetting(&#123;</span><br><span class="line">        success: (result) &#x3D;&gt; &#123;</span><br><span class="line">          if (result) &#123;</span><br><span class="line">            if (result.authSetting[&quot;scope.writePhotosAlbum&quot;] &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">              openStatus &#x3D; true;</span><br><span class="line">              wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">                filePath: canvasToTempFilePath,</span><br><span class="line">                success() &#123;</span><br><span class="line">                  that.setData(&#123;</span><br><span class="line">                    showShareImg: false</span><br><span class="line">                  &#125;)</span><br><span class="line">                  wx.showToast(&#123;</span><br><span class="line">                    title: &#39;图片保存成功，快去分享到朋友圈吧~&#39;,</span><br><span class="line">                    icon: &#39;none&#39;,</span><br><span class="line">                    duration: 2000</span><br><span class="line">                  &#125;)</span><br><span class="line">                &#125;,</span><br><span class="line">                fail() &#123;</span><br><span class="line">                  wx.showToast(&#123;</span><br><span class="line">                    title: &#39;保存失败&#39;,</span><br><span class="line">                    icon: &#39;none&#39;</span><br><span class="line">                  &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: () &#x3D;&gt; &#123; &#125;,</span><br><span class="line">        complete: () &#x3D;&gt; &#123; &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      wx.getSetting(&#123;</span><br><span class="line">        success(res) &#123;</span><br><span class="line">          &#x2F;&#x2F; 如果没有则获取授权</span><br><span class="line">          if (!res.authSetting[&#39;scope.writePhotosAlbum&#39;]) &#123;</span><br><span class="line">            wx.authorize(&#123;</span><br><span class="line">              scope: &#39;scope.writePhotosAlbum&#39;,</span><br><span class="line">              success() &#123;</span><br><span class="line">                openStatus &#x3D; true</span><br><span class="line">                wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">                  filePath: canvasToTempFilePath,</span><br><span class="line">                  success() &#123;</span><br><span class="line">                    that.setData(&#123;</span><br><span class="line">                      showShareImg: false</span><br><span class="line">                    &#125;)</span><br><span class="line">                    wx.showToast(&#123;</span><br><span class="line">                      title: &#39;图片保存成功，快去分享到朋友圈吧~&#39;,</span><br><span class="line">                      icon: &#39;none&#39;,</span><br><span class="line">                      duration: 2000</span><br><span class="line">                    &#125;)</span><br><span class="line">                  &#125;,</span><br><span class="line">                  fail() &#123;</span><br><span class="line">                    wx.showToast(&#123;</span><br><span class="line">                      title: &#39;保存失败&#39;,</span><br><span class="line">                      icon: &#39;none&#39;</span><br><span class="line">                    &#125;)</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;,</span><br><span class="line">              fail() &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果用户拒绝过或没有授权，则再次打开授权窗口</span><br><span class="line">                openStatus &#x3D; false</span><br><span class="line">                console.log(&#39;请设置允许访问相册&#39;)</span><br><span class="line">                wx.showToast(&#123;</span><br><span class="line">                  title: &#39;请设置允许访问相册&#39;,</span><br><span class="line">                  icon: &#39;none&#39;</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 有则直接保存</span><br><span class="line">            openStatus &#x3D; true</span><br><span class="line">            wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">              filePath: canvasToTempFilePath,</span><br><span class="line">              success() &#123;</span><br><span class="line">                that.setData(&#123;</span><br><span class="line">                  showShareImg: false</span><br><span class="line">                &#125;)</span><br><span class="line">                wx.showToast(&#123;</span><br><span class="line">                  title: &#39;图片保存成功，快去分享到朋友圈吧~&#39;,</span><br><span class="line">                  icon: &#39;none&#39;,</span><br><span class="line">                  duration: 2000</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;,</span><br><span class="line">              fail() &#123;</span><br><span class="line">                wx.showToast(&#123;</span><br><span class="line">                  title: &#39;保存失败&#39;,</span><br><span class="line">                  icon: &#39;none&#39;</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        fail(err) &#123;</span><br><span class="line">          console.log(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此所有的步骤都已实现，在绘制的时候会遇到一些异步请求后台返回的数据，所以我用promise和async和await进行了封装，确保导出的图片信息是完整的。在绘制的过程确实遇到一些坑的地方。比如初开始导出的图片比例大小不对，还有用measureText测量文字宽度不对，多次绘制（可能受网络原因）有时导出的图片上的文字颜色会有误差等。如果你也遇到一些比较坑的地方可以一起探讨下做个记录</p>
<p>参考链接：<a href="https://mp.weixin.qq.com/s/Dsc81YRD5WrI6V105ci4hg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Dsc81YRD5WrI6V105ci4hg</a></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>海报</tag>
        <tag>分享朋友圈</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序之骨架屏的使用</title>
    <url>/2020/09/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%AA%A8%E6%9E%B6%E5%B1%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="自定义骨架屏"><a href="#自定义骨架屏" class="headerlink" title="自定义骨架屏"></a>自定义骨架屏</h3><p>index.wxml:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作为组件在页面中使用 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">skeleton</span> <span class="attr">selector</span>=<span class="string">"skeleton"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">loading</span>=<span class="string">"spin"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">bgcolor</span>=<span class="string">"#FFF"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">wx:if</span>=<span class="string">"&#123;&#123;showSkeleton&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">skeleton</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--index.wxml--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染的根节点，加上 .skeleton --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container skeleton"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"userinfo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">block</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 要渲染的圆形节点，加上 .skeleton-radius --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">"userinfo-avatar skeleton-radius"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;userInfo.avatarUrl&#125;&#125;"</span> <span class="attr">mode</span>=<span class="string">"cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 要渲染的矩形节点，加上 .skeleton-rect --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"userinfo-nickname skeleton-rect"</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"margin: 20px 0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;lists&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"lists"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"success"</span> <span class="attr">size</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"list skeleton-radius"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"skeleton-rect"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"usermotto"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"user-motto skeleton-rect"</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"margin-top: 200px;"</span>&gt;</span>aaaaaaaaaaa<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>index.json:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 引入骨架屏组件</span></span><br><span class="line">  <span class="string">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="string">"skeleton"</span>: <span class="string">"/component/skeleton/skeleton"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后来探索一下骨架屏组件的实现</strong></p>
<p>skeleton.wxml:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 最外层的view绑定了js中定义的宽、高以及背景颜色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"width: &#123;&#123;systemInfo.width&#125;&#125;px; height: &#123;&#123;systemInfo.height&#125;&#125;px; background-color: &#123;&#123;bgcolor&#125;&#125;; position: absolute; left:0; top:0; z-index:9998; overflow: hidden;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 循环，遍历绘制矩形节点，宽高参照js获取到的节点宽高，以绝对定位的方式定位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;skeletonRectLists&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"&#123;&#123;loading == 'chiaroscuro' ? 'chiaroscuro' : ''&#125;&#125;"</span> <span class="attr">style</span>=<span class="string">"width: &#123;&#123;item.width&#125;&#125;px; height: &#123;&#123;item.height&#125;&#125;px; background-color: rgb(194, 207, 214); position: absolute; left: &#123;&#123;item.left&#125;&#125;px; top: &#123;&#123;item.top&#125;&#125;px"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 循环，遍历绘制矩形节点，宽高参照js获取到的节点宽高，以绝对定位的方式定位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;skeletonCircleLists&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"&#123;&#123;loading == 'chiaroscuro' ? 'chiaroscuro' : ''&#125;&#125;"</span> <span class="attr">style</span>=<span class="string">"width: &#123;&#123;item.width&#125;&#125;px; height: &#123;&#123;item.height&#125;&#125;px; background-color: rgb(194, 207, 214); border-radius: &#123;&#123;item.width&#125;&#125;px; position: absolute; left: &#123;&#123;item.left&#125;&#125;px; top: &#123;&#123;item.top&#125;&#125;px"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"spinbox"</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;loading == 'spin'&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"spin"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>skeleton.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    bgcolor: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">'#fff'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    selector: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">'skeleton'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">'spin'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    loadingAni: [<span class="string">'spin'</span>, <span class="string">'chiaroscuro'</span>],</span><br><span class="line">    systemInfo: &#123;&#125;,</span><br><span class="line">    skeletonRectLists: [],</span><br><span class="line">    skeletonCircleLists: []</span><br><span class="line">  &#125;,</span><br><span class="line">  attached: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//默认的首屏宽高，防止内容闪现</span></span><br><span class="line">    <span class="keyword">const</span> systemInfo = wx.getSystemInfoSync();</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      systemInfo: &#123;</span><br><span class="line">        width: systemInfo.windowWidth,</span><br><span class="line">        height: systemInfo.windowHeight</span><br><span class="line">      &#125;,</span><br><span class="line">      loading: <span class="keyword">this</span>.data.loadingAni.includes(<span class="keyword">this</span>.data.loading) ? <span class="keyword">this</span>.data.loading : <span class="string">'spin'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  ready: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//绘制背景</span></span><br><span class="line">    wx.createSelectorQuery().selectAll(<span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span>`</span>).boundingClientRect().exec(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        <span class="string">'systemInfo.height'</span>: res[<span class="number">0</span>][<span class="number">0</span>].height + res[<span class="number">0</span>][<span class="number">0</span>].top</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="keyword">this</span>.rectHandle();</span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="keyword">this</span>.radiusHandle();</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    rectHandle: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">//绘制不带样式的节点</span></span><br><span class="line">      wx.createSelectorQuery().selectAll(<span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span> &gt;&gt;&gt; .<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span>-rect`</span>).boundingClientRect().exec(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          skeletonRectLists: res[<span class="number">0</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    radiusHandle: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">      wx.createSelectorQuery().selectAll(<span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span> &gt;&gt;&gt; .<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span>-radius`</span>).boundingClientRect().exec(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          skeletonCircleLists: res[<span class="number">0</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">备注：也可以使用下面这种方式来选择节点</span><br><span class="line">wx.createSelectorQuery().selectAll(<span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span>-rect`</span>).boundingClientRect().exec...</span><br></pre></td></tr></table></figure>



<h3 id="使用npm包"><a href="#使用npm包" class="headerlink" title="使用npm包"></a>使用npm包</h3><p><a href="https://github.com/jayZOU/skeleton" target="_blank" rel="noopener">https://github.com/jayZOU/skeleton</a></p>
<h3 id="一、安装和引入"><a href="#一、安装和引入" class="headerlink" title="一、安装和引入"></a>一、安装和引入</h3><h4 id="1-安装组件："><a href="#1-安装组件：" class="headerlink" title="1.安装组件："></a>1.安装组件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save miniprogram-skeleton</span><br></pre></td></tr></table></figure>

<h4 id="2-引入skeleton自定义组件"><a href="#2-引入skeleton自定义组件" class="headerlink" title="2.引入skeleton自定义组件"></a>2.引入skeleton自定义组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;skeleton&quot;: &quot;..&#x2F;miniprogram_npm&#x2F;miniprogram-skeleton&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小程序中npm的配置及使用：</strong></p>
<ul>
<li>在微信开发者工具中，设置 —&gt; 项目设置—&gt; 勾选使用npm模块。</li>
<li>在微信开发者工具中，工具 —&gt; 构建npm，构建完成会生成 <code>miniprogram_npm</code> 文件夹，项目用到的npm包都在这里。</li>
<li>按照页面的使用路径，从 <code>miniprogram_npm</code> 引入需要的包。</li>
</ul>
<h4 id="二、使用方式与自定义使用方式一样"><a href="#二、使用方式与自定义使用方式一样" class="headerlink" title="二、使用方式与自定义使用方式一样"></a>二、使用方式与自定义使用方式一样</h4><p>。。。</p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>骨架屏</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之定位</title>
    <url>/2020/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h4 id="结合腾讯地图sdk"><a href="#结合腾讯地图sdk" class="headerlink" title="结合腾讯地图sdk"></a>结合腾讯地图sdk</h4><p>腾讯地图提供了供小程序使用的SDK，可结合地图组件和api进行快速调用。首次使用需要申请秘钥，下载sdk文件qqmap-wx-jssdk.js。需要设置安全域名<a href="https://apis.map.qq.com" target="_blank" rel="noopener">https://apis.map.qq.com</a></p>
<p>sdk使用方法及js链接：</p>
<p><a href="https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview" target="_blank" rel="noopener">https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview</a></p>
<p>核心方法：</p>
<p><a href="https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/qqMapwx" target="_blank" rel="noopener">https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/qqMapwx</a></p>
<a id="more"></a>

<p>具体实现参考：</p>
<h4 id="app-json-不知道具体位置可以看这里-这里有整个app-json的配置"><a href="#app-json-不知道具体位置可以看这里-这里有整个app-json的配置" class="headerlink" title="app.json:  (不知道具体位置可以看这里,这里有整个app.json的配置)"></a>app.json:  (<a href="https://blog.csdn.net/guochanof/article/details/89669839" target="_blank" rel="noopener">不知道具体位置可以看这里,这里有整个app.json的配置</a>)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;permission&quot;: &#123;</span><br><span class="line">   &quot;scope.userLocation&quot;: &#123;</span><br><span class="line">     &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="wxml"><a href="#wxml" class="headerlink" title="wxml:"></a>wxml:</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pages/map/map.wxml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是地图部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"map_container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">map</span> <span class="attr">class</span>=<span class="string">'map'</span> <span class="attr">longitude</span>=<span class="string">'&#123;&#123;longitude&#125;&#125;'</span> <span class="attr">latitude</span>=<span class="string">'&#123;&#123;latitude&#125;&#125;'</span> <span class="attr">scale</span>=<span class="string">'&#123;&#123;scale&#125;&#125;'</span> <span class="attr">markers</span>=<span class="string">'&#123;&#123;markers&#125;&#125;'</span> <span class="attr">controls</span>=<span class="string">"&#123;&#123;controls&#125;&#125;"</span> <span class="attr">bindcontroltap</span>=<span class="string">"bindcontroltap"</span> <span class="attr">polyline</span>=<span class="string">'&#123;&#123;polyline&#125;&#125;'</span> <span class="attr">circles</span>=<span class="string">"&#123;&#123;circles&#125;&#125;"</span> <span class="attr">bindmarkertap</span>=<span class="string">'bindmarkertap'</span> <span class="attr">bindcontroltap</span>=<span class="string">'bindcontroltap'</span></span></span><br><span class="line"><span class="tag">    <span class="attr">show-location</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下是导航部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'list-guide'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里的坐标本应该是从服务器获取数据的,这时丈先写死在页面上了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">"onGuideTap"</span> <span class="attr">data-latitude</span>=<span class="string">'39.92392'</span> <span class="attr">data-longitude</span>=<span class="string">'116.411885'</span> <span class="attr">data-bankName</span>=<span class="string">'最高人民检察院'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">'/images/banklist/daohang.png'</span> <span class="attr">class</span>=<span class="string">'list-guide-imgae'</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">'list-guide-text'</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">'onbankTap'</span> <span class="attr">data-bankId</span>=<span class="string">"&#123;&#123;item.BANK_ID&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">'/images/banklist/xiangqing.png'</span> <span class="attr">class</span>=<span class="string">'list-guide-imgae'</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">'list-guide-text'</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>宽度不是满屏,所以加个样式</p>
<h4 id="wxss"><a href="#wxss" class="headerlink" title="wxss:"></a>wxss:</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* pages/map/map.wxss */</span></span><br><span class="line"><span class="selector-class">.map_container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">260px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.map</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.list-guide</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;  </span><br><span class="line">  <span class="attribute">flex-direction</span>: row; </span><br><span class="line">  <span class="attribute">justify-content</span>:space-around;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#ededed</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-guide-imgae</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">70</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70</span>rpx;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-guide-text</span>&#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">90</span>rpx;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">35</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是最重要的JS部分了()</p>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS:"></a>JS:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/map/map.js</span></span><br><span class="line">varQQMapWX= <span class="built_in">require</span>(<span class="string">'../libs/qqmap-wx-jssdk.js'</span>);</span><br><span class="line"><span class="keyword">var</span> qqmapsdk;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    addmissage: <span class="string">'选的位置'</span>,</span><br><span class="line">    <span class="comment">// markers	 Array	标记点</span></span><br><span class="line">    stitle:<span class="string">'故宫'</span>,</span><br><span class="line">    latitude: <span class="string">""</span>,</span><br><span class="line">    longitude: <span class="string">""</span>,</span><br><span class="line">    scale: <span class="number">14</span>,</span><br><span class="line">    markers: [],</span><br><span class="line">    <span class="comment">//controls控件 是左下角圆圈小图标,用户无论放大多少,点这里可以立刻回到当前定位(控件（更新一下,即将废弃，建议使用 cover-view 代替）)</span></span><br><span class="line">    controls: [&#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      iconPath: <span class="string">'../../images/img/controls.png'</span>,</span><br><span class="line">      position: &#123;</span><br><span class="line">        left: <span class="number">15</span>,</span><br><span class="line">        top: <span class="number">260</span> - <span class="number">50</span>,</span><br><span class="line">        width: <span class="number">40</span>,</span><br><span class="line">        height: <span class="number">40</span></span><br><span class="line">      &#125;,</span><br><span class="line">      clickable: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    distanceArr: []</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">//new 地图对象</span></span><br><span class="line">    qqmapsdk =<span class="keyword">new</span> QQMapWX(&#123;</span><br><span class="line">     key:<span class="string">'22VBZ-REEK5-WVSI7-QKCOP-QPM6E-W7BPO'</span></span><br><span class="line">   &#125;);</span><br><span class="line">    <span class="comment">//小程序api获取当前的地理位置、速度</span></span><br><span class="line">    wx.getLocation(&#123;</span><br><span class="line">      type: <span class="string">'wgs84'</span>, <span class="comment">// 默认为 wgs84 返回 gps 坐标，gcj02 返回可用于 wx.openLocation 的坐标</span></span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//赋值经纬度</span></span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          latitude: res.latitude,</span><br><span class="line">          longitude: res.longitude,</span><br><span class="line"> </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//在这里调用了逆地理解析reverseGeocoder，对地理解析结果读取获取当前位置。</span></span><br><span class="line">        qqmapsdk.reverseGeocoder(&#123;</span><br><span class="line">           location:&#123;</span><br><span class="line">             latitude: res.latitude1,</span><br><span class="line">             longitude: res.longitude1</span><br><span class="line">           &#125;,</span><br><span class="line">           success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(res);</span><br><span class="line">             <span class="keyword">var</span> add= res.result.address</span><br><span class="line">             that.setData(&#123;</span><br><span class="line">               wd: latitude1,</span><br><span class="line">               jd: longitude1,</span><br><span class="line">               address: add</span><br><span class="line">             &#125;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//controls控件的点击事件</span></span><br><span class="line">  bindcontroltap(e) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (e.controlId == <span class="number">1</span>) &#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        latitude: <span class="keyword">this</span>.data.latitude,</span><br><span class="line">        longitude: <span class="keyword">this</span>.data.longitude,</span><br><span class="line">        scale: <span class="number">14</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//导航</span></span><br><span class="line">  onGuideTap: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lat = <span class="built_in">Number</span>(event.currentTarget.dataset.latitude);</span><br><span class="line">    <span class="keyword">var</span> lon = <span class="built_in">Number</span>(event.currentTarget.dataset.longitude);</span><br><span class="line">    <span class="keyword">var</span> bankName = event.currentTarget.dataset.bankname;</span><br><span class="line">    <span class="built_in">console</span>.log(lat);</span><br><span class="line">    <span class="built_in">console</span>.log(lon);</span><br><span class="line">    wx.openLocation(&#123;</span><br><span class="line">      type: <span class="string">'gcj02'</span>,</span><br><span class="line">      latitude: lat,</span><br><span class="line">      longitude: lon,</span><br><span class="line">      name: bankName,</span><br><span class="line">      scale: <span class="number">28</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="type参数"><a href="#type参数" class="headerlink" title="type参数"></a>type参数</h4><h5 id="WGS84，GCJ02之间的区别"><a href="#WGS84，GCJ02之间的区别" class="headerlink" title="WGS84，GCJ02之间的区别"></a>WGS84，GCJ02之间的区别</h5><p>84坐标系可以理解为是真实坐标系，是一个地点的实际坐标值。02坐标系是加密后的坐标系，是为了国家安全考虑。对应的不是实际的坐标值，但是在加密的坐标下，进行导航、定位等操作是完全不受影响的，只不过坐标不是真实的坐标而已。我国的各个地图软件，均使用02坐标系进行街景地图测绘和卫星地图测绘，因此可以看到我国的地图应用上均不会标注经纬坐标信息。</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>wgs84：GPS坐标系<br>gcj02：火星坐标系，国测局02年发布的坐标体系，高德，腾讯等使用（<em>火星坐标指的就是实际坐标经过GCJ02算法得到的坐标</em>）。<br>BD-09：百度坐标系，百度自研，百度地图使用（<em>百度坐标指的就是实际坐标经过BD-09算法得到的坐标</em>）。</p>
<h4 id="sdk和api"><a href="#sdk和api" class="headerlink" title="sdk和api"></a>sdk和api</h4><h6 id="1-SDK是什么？"><a href="#1-SDK是什么？" class="headerlink" title="1.SDK是什么？"></a>1.SDK是什么？</h6><p>SDK：<br>概念：软件开发工具包（SDK，全称：Software Development Kit）<br>一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。</p>
<p>通俗点是指由第三方服务商提供的实现软件产品某项功能的工具包。</p>
<p>就相当于很多API和其他文件的集合体，你可以用这个完成某一个事情。</p>
<p>举例子：<br>整个计算器产品可以看做是一个SDK，它里面有API集合（计算器），说明文档（说明书），以及一些其他文件。<br>这个SDK的功能就是计算，可能要算什么不确定，但是你可以通过这个SDK中的某个方法完成，实现你的目的。</p>
<h6 id="2-API是什么？"><a href="#2-API是什么？" class="headerlink" title="2.API是什么？"></a>2.API是什么？</h6><p>API：<br>概念：API（Application Programming Interface,应用程序编程接口）<br>一般是指一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p>
<p>其实就是别人已经写好的可以实现特定功能的函数，而你只需要根据他提供好的接口，也就是调用他的方法，传入他规定的参数，然后这个函数就会帮你实现这些功能。</p>
<p>举例子：</p>
<p>比如别人写好了一个数字求和的方法sum(int a, int b)。<br>提供给你一个API接口——你只需要调用它这个sum()函数，然后传入这个a，b的值，然后就可以得到计算的结果，你不需要知道这个方法是怎么实现的，知道该怎么调用即可。</p>
<p>如果别人又写了一个两数相乘的方法Mul(int a, int b)，那这又称为另一个API。</p>
<h6 id="3-SDK和API的区别"><a href="#3-SDK和API的区别" class="headerlink" title="3.SDK和API的区别"></a>3.SDK和API的区别</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.API是一个具体的函数，一个确定的功能，已经明确了它的作用（比如做加法）。</span><br><span class="line"> </span><br><span class="line">2.SDK就像是很多方法的集合体，是一个工具包。</span><br><span class="line"></span><br><span class="line">3.SDK相当于开发集成工具环境，API就是数据接口。在SDK环境下调用API数据。（而这个SDK你可以自己配置或者下载第三方提供的）</span><br><span class="line"> </span><br><span class="line">4.SDK除了他提供的完善的接口，他还会给你提供相关的开发环境，而API需要的环境你得自己提供（比如传参）</span><br></pre></td></tr></table></figure>



<p>参考链接：<a href="https://blog.csdn.net/guochanof/article/details/90130871" target="_blank" rel="noopener">https://blog.csdn.net/guochanof/article/details/90130871</a></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之互相跳转</title>
    <url>/2020/10/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BA%92%E7%9B%B8%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/wangmaoling/p/11764651.html" target="_blank" rel="noopener">微信小程序与内嵌webview之间来回跳转的几点总结，以及二维码的使用</a></p>
<p>截止到发稿小程序支持的功能，后续如果小程序更新在完善文稿。</p>
<h3 id="小程序可以内嵌组件跳转到h5页面"><a href="#小程序可以内嵌组件跳转到h5页面" class="headerlink" title="小程序可以内嵌组件跳转到h5页面"></a>小程序可以内嵌组件跳转到h5页面</h3><p>\1. 小程序可以内嵌组件跳转到h5页面，前提是在小程序后台配置相应的业务域名。新打开的h5页面会替代小程序组件内的其它组件，即为h5不能与小程序组件共存显示在屏幕上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;web-view src&#x3D;&quot;&#123;&#123;content&#125;&#125;&quot;&gt;&lt;&#x2F;web-view&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="打开的h5页面可以通过触发某事件可以跳转到本小程序"><a href="#打开的h5页面可以通过触发某事件可以跳转到本小程序" class="headerlink" title="打开的h5页面可以通过触发某事件可以跳转到本小程序"></a>打开的h5页面可以通过触发某事件可以跳转到本小程序</h3><p>\2. 打开的h5页面可以通过触发某事件可以跳转到<strong>本小程序(不能是其它小程序)</strong>的任意页面，并且可以携带参数。前提是在h5页面引入相应jssdk。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;user-scalable&#x3D;no, width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;res.wx.qq.com&#x2F;open&#x2F;js&#x2F;jweixin-1.3.0.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p id&#x3D;&quot;app&quot;&gt;点我跳转此小程序&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var app &#x3D; document.getElementById(&#39;app&#39;);</span><br><span class="line">        app.onclick &#x3D; function () &#123;</span><br><span class="line">            wx.miniProgram.redirectTo(&#123;url:&#39;&#x2F;pages&#x2F;index&#x2F;index?id&#x3D;111&#39;&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="本小程序可以跳转到其它小程序"><a href="#本小程序可以跳转到其它小程序" class="headerlink" title="本小程序可以跳转到其它小程序"></a>本小程序可以跳转到其它小程序</h3><p>\3. 本小程序可以跳转到其它小程序，前提要知道对方APPID。并且要在app.json文件配置下，这里也可以通过path跳转到其它子页面,不填默认主页。</p>
<p><img src="https://img2018.cnblogs.com/blog/1105103/201910/1105103-20191030135932605-1838988117.png" alt="img"></p>
<p>详情参考小程序文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html</a></p>
<p><strong>跳转方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.navigateToMiniProgram(&#123;</span><br><span class="line">  appId: &#39;&#39;,&#x2F;&#x2F;要打开的小程序 appId</span><br><span class="line">  path: &#39;page&#x2F;index&#x2F;index?id&#x3D;123&#39;,&#x2F;&#x2F;打开的页面路径，如果为空则打开首页</span><br><span class="line">  extraData: &#123;</span><br><span class="line">    foo: &#39;bar&#39;&#x2F;&#x2F;需要传递给目标小程序的数据，目标小程序可在 App.onLaunch，App.onShow 中获取到这份数据</span><br><span class="line">  &#125;,</span><br><span class="line">  envVersion: &#39;develop&#39;,&#x2F;&#x2F;要打开的小程序版本。仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    &#x2F;&#x2F; 打开成功</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>跳转方法二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;小程序代码</span><br><span class="line">&lt;navigator target&#x3D;&quot;miniProgram&quot; open-type&#x3D;&quot;navigate&quot; app-id&#x3D;&quot;对方APPID必填&quot; path&#x3D;&quot;&quot; extra-data&#x3D;&quot;&quot; version&#x3D;&quot;release&quot; hover-class&#x3D;&quot;none&quot;&gt;&lt;&#x2F;navigator&gt;</span><br></pre></td></tr></table></figure>

<p><strong>返回本小程序</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.navigateBackMiniProgram(&#123;</span><br><span class="line">    extraData: &#123;&#125;,</span><br><span class="line">    success(res) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回成功</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="两个小程序间的相互跳转传参"><a href="#两个小程序间的相互跳转传参" class="headerlink" title="两个小程序间的相互跳转传参"></a>两个小程序间的相互跳转传参</h3><p>小程序a代码： 跳转到小程序b并传id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.navigateToMiniProgram(&#123;</span><br><span class="line">appId: &#39;&#39;,</span><br><span class="line">path: &#39;pages&#x2F;index&#x2F;index?id&#x3D;123&#39;,</span><br><span class="line">extraData: &#123;&#125;,</span><br><span class="line">envVersion: &#39;develop&#39;,</span><br><span class="line">success(res) &#123;</span><br><span class="line">&#x2F;&#x2F; 打开成功</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>小程序b代码：</p>
<p>//index.js 接收并打印小程序a传递过来的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">onLoad: function (options) &#123;</span><br><span class="line">console.log(options)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="webview内嵌的h5页面，跳转到其它小程序"><a href="#webview内嵌的h5页面，跳转到其它小程序" class="headerlink" title="webview内嵌的h5页面，跳转到其它小程序"></a>webview内嵌的h5页面，跳转到其它小程序</h3><p>\4. 如果想要在webview内嵌的h5页面，跳转到其它小程序的实现途径。</p>
<p>　　a. 内嵌h5是不支持跳转到其它外部小程序，即便用上面2里面的触发事件也不能。</p>
<p>　　b. 实现方法只能是在内嵌的h5页面里面插入要跳转的小程序的二维码，可以通过长按识别的方法跳转过去。（</p>
<p>　　  <strong>小程序只识别嵌入h5里面的其它的小程序的二维码，不会识别其它二维码，这个二维吗还必须是菊花码</strong>）</p>
<p>　　c. 菊花二维码可以通过微信小程序后台生成，可以生成子页面的菊花二维码，也可以用外部工具来实现这个菊花二维码的生成。</p>
<p>　　  草料二维码可以实现实现菊花二维码，并且可以有参数：<a href="https://cli.im/mina/home" target="_blank" rel="noopener">https://cli.im/mina/home</a></p>
<p>　　d. 小程序二维码只能有一个参数，如果设置了多个参数就会被拼接。如果想要传多个参数，需要自定义分割符，以及获取。</p>
<h3 id="app和小程序互相跳转"><a href="#app和小程序互相跳转" class="headerlink" title="app和小程序互相跳转"></a>app和小程序互相跳转</h3><p>app和小程序互相跳转：</p>
<p>1、App主动发起小程序卡片分享到微信，微信点击打开小程序，这时的小程序可以打开App</p>
<p>2、App主动发起打开小程序，这时的小程序可以打开App</p>
<p>目前主要就这两种方式吧，说是互相跳转好像不太妥当，毕竟App才是主动一方，小程序只能被动返回，类似于分享，App如果不发起分享到微信，微信是不能返回你的App的。说到这里大家应该都有一个印象了吧。</p>
<p>至于上面两种方式的实现方法也简单，只要把微信官网的代码复制过来就能用了。</p>
<p>App主动分享小程序卡片（<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317340&token=ae4e632e7dcc175a183ce11346e0dfcd98399d82&lang=zh_CN" target="_blank" rel="noopener">微信官网</a>）：小程序测试版不能分享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WXMiniProgramObject miniProgramObj = <span class="keyword">new</span> WXMiniProgramObject();</span><br><span class="line">miniProgramObj.webpageUrl = <span class="string">"http://www.qq.com"</span>; <span class="comment">// 兼容低版本的网页链接</span></span><br><span class="line">miniProgramObj.miniprogramType = WXMiniProgramObject.MINIPTOGRAM_TYPE_RELEASE;<span class="comment">// 正式版:0，测试版:1，体验版:2</span></span><br><span class="line">miniProgramObj.userName = <span class="string">"gh_d43f693ca31f"</span>;     <span class="comment">// 小程序原始id</span></span><br><span class="line">miniProgramObj.path = <span class="string">"/pages/media"</span>;            <span class="comment">//小程序页面路径</span></span><br><span class="line">WXMediaMessage msg = <span class="keyword">new</span> WXMediaMessage(miniProgramObj);</span><br><span class="line">msg.title = <span class="string">"小程序消息Title"</span>;                    <span class="comment">// 小程序消息title</span></span><br><span class="line">msg.description = <span class="string">"小程序消息Desc"</span>;               <span class="comment">// 小程序消息desc</span></span><br><span class="line">msg.thumbData = getThumb();                      <span class="comment">// 小程序消息封面图片，小于128k</span></span><br><span class="line"> </span><br><span class="line">SendMessageToWX.Req req = <span class="keyword">new</span> SendMessageToWX.Req();</span><br><span class="line">req.transaction = buildTransaction(<span class="string">"webpage"</span>);</span><br><span class="line">req.message = msg;</span><br><span class="line">req.scene = SendMessageToWX.Req.WXSceneSession;  <span class="comment">// 目前支持会话</span></span><br><span class="line">api.sendReq(req);</span><br></pre></td></tr></table></figure>

<p>App主动打开小程序（<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=21526646437Y6nEC&token=ae4e632e7dcc175a183ce11346e0dfcd98399d82&lang=zh_CN" target="_blank" rel="noopener">微信官网</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String appId = <span class="string">"wxd930ea5d5a258f4f"</span>; <span class="comment">// 填应用AppId</span></span><br><span class="line">IWXAPI api = WXAPIFactory.createWXAPI(context, appId);</span><br><span class="line">WXLaunchMiniProgram.Req req = <span class="keyword">new</span> WXLaunchMiniProgram.Req();</span><br><span class="line">req.userName = <span class="string">"gh_d43f693ca31f"</span>; <span class="comment">// 填小程序原始id</span></span><br><span class="line">req.path = path;                  <span class="comment">//拉起小程序页面的可带参路径，不填默认拉起小程序首页</span></span><br><span class="line">req.miniprogramType = WXLaunchMiniProgram.Req.MINIPTOGRAM_TYPE_RELEASE;<span class="comment">// 可选打开 开发版，体验版和正式版</span></span><br><span class="line">api.sendReq(req);</span><br><span class="line"></span><br><span class="line">WXEntryActivity中</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResp</span><span class="params">(BaseResp resp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resp.getType() == ConstantsAPI.COMMAND_LAUNCH_WX_MINIPROGRAM) &#123;</span><br><span class="line">        WXLaunchMiniProgram.Resp launchMiniProResp = (WXLaunchMiniProgram.Resp) resp;</span><br><span class="line">        String extraData =launchMiniProResp.extMsg; <span class="comment">// 对应JsApi navigateBackApplication中的extraData字段数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小程序返回App就更简单了（<a href="https://developers.weixin.qq.com/miniprogram/dev/api/launchApp.html" target="_blank" rel="noopener">微信官网</a>）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">"launchApp"</span> <span class="attr">app-parameter</span>=<span class="string">"wechat"</span> <span class="attr">binderror</span>=<span class="string">"launchAppError"</span>&gt;</span>打开APP<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另附：微信分享打开App：使用魔窗SDK实现，实际是网页打开App，苹果倒是可以直接打开App，安卓只能用网页打开分享再打开App。具体实现可以查看<a href="http://www.magicwindow.cn/doc/" target="_blank" rel="noopener">官网文档</a>。</p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>webview</tag>
        <tag>跳转</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之分享</title>
    <url>/2020/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>在小程序开发API中，发送给好友/群，可以有两种实现方式：</p>
<p>1）入口</p>
<p>a.小程序右上角自带的分享功能（…）：</p>
<p>如果在当前页面调用wx.hideShareMenu()方法，那么右上角的分享功能将被隐藏，当然，隐藏方法与现实方法是成对出现的，调用wx.showShareMenu()方法，可以显示该功能。</p>
<p>b.自定义分享按钮：<butto n open-type="share">分享&lt;/butto n&gt;</butto></p>
<p>以上两种方式均可实现分享功能</p>
<a id="more"></a>

<p>2）分享数据类型</p>
<p>不管采用以上何种方法，转发给好友的数据总归有它的数据模型，该数据模型是通过onShareAppMessage(options)返回的，也就是return一个object即可。其中，options.from可以用来判断是从自定义button打开的转发页面，还是从右上角的打开的转发页面。</p>
<p>以下是该object的数据模型：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6901201-5e4dd35c86bc518a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/873/format/webp" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 用户点击右上角分享</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onShareAppMessage: function () &#123;</span><br><span class="line">    let url &#x3D; encodeURIComponent(&#39;&#x2F;pages&#x2F;navMain&#39;); </span><br><span class="line">    return &#123;</span><br><span class="line">      title: &quot;热点详情&quot;, &#x2F;&#x2F;转发标题</span><br><span class="line">      path:&#96;&#x2F;pages&#x2F;test&#x2F;index&#96; , &#x2F;&#x2F;转发路径</span><br><span class="line">      imageUrl:&#39;&#x2F;pages&#x2F;img&#x2F;header.jpg&#39; &#x2F;&#x2F;自定义分享图片路径</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>如上所示，如果开发人员在onShareAppMessage(options)不进行任何处理，那么微信将会有一个默认的数据转发出去，title为当前小程序名称，path为当前页面的路径，imageUrl为当前页面的截图。根据imageUrl的定义，开发人员可以上传自定义图片。</p>
<h3 id="封装一个分享的组件"><a href="#封装一个分享的组件" class="headerlink" title="封装一个分享的组件"></a>封装一个分享的组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&#39;share&#39;&gt;</span><br><span class="line">   &lt;view class&#x3D;&#39;like&#39;&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;iconfont icon-aixin&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">   &lt;&#x2F;view&gt;</span><br><span class="line">   &lt;view class&#x3D;&#39;weixin&#39;&gt;</span><br><span class="line">       &lt;button open-type&#x3D;&quot;share&quot; class&#x3D;&#39;iconfont icon-weixin&#39;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">   &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>页面效果如下:</p>
<p>​                      <img src="https://img-blog.csdnimg.cn/20190725150933355.png" alt="img"></p>
<p>说明:</p>
<p>  如果想在页面上实现点击按钮分享,那么这个点击的按钮必须使用button标签,并且open-type置为share</p>
<p>2.在想要分享的页面中引入上面组件,并在页面的js中Page所包含的对象里增加一个方法onShareAppMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 用户点击右上角分享</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  onShareAppMessage: function () &#123;</span><br><span class="line">    let url &#x3D; encodeURIComponent(&#39;&#x2F;packageNews&#x2F;pages&#x2F;news_detail&#x2F;news_detail?news_id&#x3D;&#39; + this.data.news_id);</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &quot;热点详情&quot;,</span><br><span class="line">      path:&#96;&#x2F;pages&#x2F;index&#x2F;index?url&#x3D;$&#123;url&#125;&#96; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 说明:</p>
<p> 将当前页面的路径包括参数使用encodeURIComponent进行编码并作为url的参数,path设置为小程序的首页.当我们将该页面</p>
<p>分享给其他人时,他们打开的首先是首页,然后跳转到我们分享的这个页面.</p>
<p>3.要想分享后的页面打开先进入首页再跳转到分享的页面,首页的js要做如下设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;index.js</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line">    if(options.url)&#123;</span><br><span class="line">      let url &#x3D; decodeURIComponent(options.url);</span><br><span class="line">      wx.navigateTo(&#123;</span><br><span class="line">        url</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之自定义导航栏</title>
    <url>/2020/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
    <content><![CDATA[<h1 id="微信小程序-自定义头部导航栏-navigationStyle"><a href="#微信小程序-自定义头部导航栏-navigationStyle" class="headerlink" title="微信小程序 自定义头部导航栏 navigationStyle"></a>微信小程序 自定义头部导航栏 navigationStyle</h1><p><img src="https://upload-images.jianshu.io/upload_images/8198580-8401274f1a9f6607.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/389/format/webp" alt="img"></p>
<a id="more"></a>

<p>navigationStyle</p>
<p>要用自定义的导航栏只需要在app.json中配置</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8198580-11a5485516f3abc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/422/format/webp" alt="img"></p>
<p>app.json</p>
<blockquote>
<p>目前微信小程序不支持单个页面设置(现在支持了，本文章仅供参考)，一旦在要决定使用自定义导航栏，那么每个页面都需要设置，为了方便我就将其写成了一个组件：</p>
</blockquote>
<p>组件目录：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8198580-1e0091fc766021d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/269/format/webp" alt="img"></p>
<p>组件目录</p>
<p>index.wxml文件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">'nav-wrap'</span> style=<span class="string">'height: &#123;&#123;height*2 + 20&#125;&#125;px;'</span>&gt;</span><br><span class="line">    <span class="comment">// 导航栏 中间的标题</span></span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">'nav-title'</span> style=<span class="string">'line-height: &#123;&#123;height*2 + 44&#125;&#125;px;'</span>&gt;&#123;&#123;navbarData.title&#125;&#125;&lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">  &lt;view style='display: flex; justify-content: space-around;flex-direction: column'&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 导航栏  左上角的返回按钮 和home按钮</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/  其中wx:if='&#123;&#123;navbarData.showCapsule&#125;&#125;' 是控制左上角按钮的显示隐藏，首页不显示</span></span><br><span class="line"><span class="regexp">    &lt;view class='nav-capsule' style='height: &#123;&#123;height*2 + 44&#125;&#125;px;' wx:if='&#123;&#123;navbarData.showCapsule&#125;&#125;'&gt;</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/左上角的返回按钮，wx:if='&#123;&#123;!share&#125;&#125;'空制返回按钮显示</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/从分享进入小程序时 返回上一级按钮不应该存在</span></span><br><span class="line"><span class="regexp">      &lt;view bindtap='_navback' wx:if='&#123;&#123;!share&#125;&#125;'&gt;</span></span><br><span class="line"><span class="regexp">        &lt;image src='/img</span>s/back-pre.png<span class="string">' mode='</span>aspectFill<span class="string">' class='</span>back-pre<span class="string">'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="string">      &lt;/view&gt;</span></span><br><span class="line"><span class="string">      &lt;view class='</span>navbar-v-line<span class="string">' wx:if='</span>&#123;&#123;!share&#125;&#125;<span class="string">'&gt;&lt;/view&gt;</span></span><br><span class="line"><span class="string">      &lt;view bindtap='</span>_backhome<span class="string">'&gt;</span></span><br><span class="line"><span class="string">        &lt;image src='</span>/imgs/back-home.png<span class="string">' mode='</span>aspectFill<span class="string">' class='</span>back-home<span class="string">'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="string">      &lt;/view&gt;</span></span><br><span class="line"><span class="string">    &lt;/view&gt;</span></span><br><span class="line"><span class="string">  &lt;/view&gt;</span></span><br><span class="line"><span class="string">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure>

<p>index.wxss文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 顶部要固定定位   标题要居中   自定义按钮和标题要和右边微信原生的胶囊上下对齐 */</span></span><br><span class="line"><span class="selector-class">.nav-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">9999999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 标题要居中 */</span></span><br><span class="line"><span class="selector-class">.nav-title</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">400</span>rpx;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">36</span>rpx;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2c2b2b</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav-capsule</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">30</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">140</span>rpx;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar-v-line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">32</span>rpx;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e5e5e5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.back-pre</span>, <span class="selector-class">.back-home</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">32</span>rpx;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">36</span>rpx;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">4</span>rpx;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nav-capsule</span> <span class="selector-class">.back-home</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">36</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40</span>rpx;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">3</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.json文件（自定义组件必须）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"component"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js文件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    navbarData: &#123;   <span class="comment">//navbarData   由父页面传递的数据，变量名字自命名</span></span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      value: &#123;&#125;,</span><br><span class="line">      observer: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    height: <span class="string">''</span>,</span><br><span class="line">    <span class="comment">//默认值  默认显示左上角</span></span><br><span class="line">    navbarData: &#123;</span><br><span class="line">      showCapsule: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  attached: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取是否是通过分享进入的小程序</span></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      share: app.globalData.share</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 定义导航栏的高度   方便对齐</span></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      height: app.globalData.height</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">  <span class="comment">// 返回上一页面</span></span><br><span class="line">    _navback() &#123;</span><br><span class="line">      wx.navigateBack()</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="comment">//返回到首页</span></span><br><span class="line">    _backhome() &#123;</span><br><span class="line">      wx.switchTab(&#123;</span><br><span class="line">        url: <span class="string">'/pages/index/index'</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app.js 文件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否由分享进入小程序</span></span><br><span class="line">    <span class="keyword">if</span> (options.scene == <span class="number">1007</span> || options.scene == <span class="number">1008</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.globalData.share = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.globalData.share = <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//获取设备顶部窗口的高度（不同设备窗口高度不一样，根据这个来设置自定义导航栏的高度）</span></span><br><span class="line">    <span class="comment">//这个最初我是在组件中获取，但是出现了一个问题，当第一次进入小程序时导航栏会把</span></span><br><span class="line">    <span class="comment">//页面内容盖住一部分,当打开调试重新进入时就没有问题，这个问题弄得我是莫名其妙</span></span><br><span class="line">    <span class="comment">//虽然最后解决了，但是花费了不少时间</span></span><br><span class="line">    wx.getSystemInfo(&#123;</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.globalData.height = res.statusBarHeight</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  globalData: &#123;</span><br><span class="line">    share: <span class="literal">false</span>,  <span class="comment">// 分享默认为false</span></span><br><span class="line">    height: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app.wxss文件:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**app.wxss**/</span></span><br><span class="line"><span class="selector-tag">pages</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">9999998</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用自定义导航栏：<br>文件目录图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8198580-e0ae0f716b3677e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300/format/webp" alt="img"></p>
<p>文件目录图</p>
<p>在微信小程序页面中：<br>pages文件夹index.wxml文件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入自定义组价。'navbar-data'中navbar是自定义名字，决定了组件中'navbarData'的名字</span></span><br><span class="line">&lt;nav-bar navbar-data=<span class="string">'&#123;&#123;nvabarData&#125;&#125;'</span>&gt;&lt;<span class="regexp">/nav-bar&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;view class='home-page' style='margin-top: &#123;&#123;height&#125;&#125;px'&gt;</span></span><br><span class="line"><span class="regexp">  home page</span></span><br><span class="line"><span class="regexp">&lt;/</span>view&gt;</span><br></pre></td></tr></table></figure>

<p>pages文件夹index.json文件中(声明使用的组件，和组件的地址)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"nav-bar"</span>: <span class="string">"/commpents/navbar/index"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pages文件夹index.js文件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="keyword">data</span>: &#123;</span><br><span class="line">  <span class="comment">// 组件所需的参数</span></span><br><span class="line">    nvabarData: &#123;</span><br><span class="line">      showCapsule: <span class="number">1</span>, <span class="comment">//是否显示左上角图标   1表示显示    0表示不显示</span></span><br><span class="line">      title: <span class="string">'我的主页'</span>, <span class="comment">//导航栏 中间的标题</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此页面 页面内容距最顶部的距离</span></span><br><span class="line">    height: app.globalData.height * <span class="number">2</span> + <span class="number">20</span> ,   </span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.<span class="keyword">data</span>.height)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>pages文件夹index.wxss文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**index.wxss**/</span></span><br><span class="line"><span class="selector-class">.home-page</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1</span>rpx solid red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">60</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由自定义组件引发的一些问题，1.下拉刷新：当页面内容高度不够屏幕高度时，ios的下拉刷新将会出现—-拉下来，上不去了，也是偶尔出现。解决方法就是页面设置个最小高度，精准一点就是页面的高度 + 下拉刷新时顶部内容距离顶部的高度。</p>
<p>参考链接：<a href="https://www.jianshu.com/p/7393c800ba09" target="_blank" rel="noopener">https://www.jianshu.com/p/7393c800ba09</a></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序文字展开收起</title>
    <url>/2020/08/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%87%E5%AD%97%E5%B1%95%E5%BC%80%E6%94%B6%E8%B5%B7/</url>
    <content><![CDATA[<p>微信小程序开发中想要如h5一样获取元素的宽高值进行业务的功能实现，一开始不知道怎么实现，翻看文档发现，微信官方提供了一个非常好的东西</p>
<h1 id="SelectorQuery"><a href="#SelectorQuery" class="headerlink" title="SelectorQuery"></a><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fwxml%2FSelectorQuery.html" target="_blank" rel="noopener">SelectorQuery</a></h1><h3 id="wx-createSelectorQuery"><a href="#wx-createSelectorQuery" class="headerlink" title="wx.createSelectorQuery()"></a>wx.createSelectorQuery()</h3><p>示例代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = wx.createSelectorQuery()</span><br><span class="line">query.select(<span class="string">'#the-id'</span>).boundingClientRect()</span><br><span class="line">query.selectViewport().scrollOffset()</span><br><span class="line">query.exec(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  res[<span class="number">0</span>].top       <span class="comment">// #the-id节点的上边界坐标</span></span><br><span class="line">  res[<span class="number">1</span>].scrollTop <span class="comment">// 显示区域的竖直滚动位置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>1.如果高度要px单位的话：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> query = wx.createSelectorQuery();</span><br><span class="line">query.select(<span class="string">'.content'</span>).boundingClientRect(<span class="function"><span class="params">rect</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> height = rect.height;</span><br><span class="line">  <span class="built_in">console</span>.log(height);</span><br><span class="line">&#125;).exec();</span><br></pre></td></tr></table></figure>

<p>2.如果高度要rpx单位的话，那么可以用宽高比换算获得：（以下的750是该元素的宽度，单位是rpx的）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> query = wx.createSelectorQuery();</span><br><span class="line">query.select(<span class="string">'.content'</span>).boundingClientRect(<span class="function"><span class="params">rect</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clientHeight = rect.height;</span><br><span class="line">  <span class="keyword">let</span> clientWidth = rect.width;</span><br><span class="line">  <span class="keyword">let</span> ratio = <span class="number">750</span> / clientWidth;</span><br><span class="line">  <span class="keyword">let</span> height = clientHeight * ratio;</span><br><span class="line">  <span class="built_in">console</span>.log(height);</span><br><span class="line">&#125;).exec();</span><br></pre></td></tr></table></figure>



<p>3.在页面渲染完成OnReady回调 获取元素高度时，如果不加定时器，获取的元素的高度还是没渲染完异步数据前的高度。故需要加定时器</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">onReady () &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> query = wx.createSelectorQuery();</span><br><span class="line">    query.select(<span class="string">'.content'</span>).boundingClientRect(<span class="function"><span class="params">rect</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> height = rect.height;</span><br><span class="line">        <span class="built_in">console</span>.log(height);</span><br><span class="line">        &#125;).exec();</span><br><span class="line">    &#125;, <span class="number">300</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实例记录</p>
<p>1.WXML</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;view <span class="keyword">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">  &lt;view <span class="keyword">class</span>=<span class="string">'list-box'</span>&gt;</span><br><span class="line">    &lt;view <span class="keyword">class</span>=<span class="string">'list'</span> wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;list&#125;&#125;"</span> wx:key=<span class="string">"index"</span>&gt;</span><br><span class="line">        &lt;text <span class="keyword">class</span>=<span class="string">"text &#123;&#123;item.collapse?'text-collapse':''&#125;&#125;"</span>&gt;&#123;&#123;item.text&#125;&#125;&lt;/text&gt;</span><br><span class="line">        &lt;text bindtap=<span class="string">"changeCollapse"</span> data-index=<span class="string">"&#123;&#123;index&#125;&#125;"</span> wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;item.showCollapse&#125;&#125;"</span> <span class="keyword">class</span>=<span class="string">'coll-p'</span>&gt;&#123;&#123;item.collapse?<span class="string">'全文'</span>:<span class="string">'收起'</span>&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>



<p>2.JS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: [&#123;</span><br><span class="line">                text: &#39;文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                text: &#39;文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                text: &#39;文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    onShow: function()&#123;</span><br><span class="line">        this.setCollapse()</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;判断全文收起是否展示</span><br><span class="line">    setCollapse: function() &#123;</span><br><span class="line">        var query &#x3D; wx.createSelectorQuery();</span><br><span class="line">        var that &#x3D; this;</span><br><span class="line">        query.selectAll(&#39;.text&#39;).boundingClientRect(function (rect) &#123;</span><br><span class="line">            rect.forEach((v, i) &#x3D;&gt; &#123;</span><br><span class="line">                if (v.height &gt; 45) &#123;  &#x2F;&#x2F;判断高度,根据各种高度取折中</span><br><span class="line">                    var set &#x3D; &quot;list[&quot; + i + &quot;].collapse&quot;;</span><br><span class="line">                    var set1 &#x3D; &quot;list[&quot; + i + &quot;].showCollapse&quot;;</span><br><span class="line">                    that.setData(&#123;</span><br><span class="line">                        [set]: true,</span><br><span class="line">                        [set1]: true,</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).exec();</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;点击全文收起</span><br><span class="line">    changeCollapse: function(e)&#123;</span><br><span class="line">        var index &#x3D; e.currentTarget.dataset.index;</span><br><span class="line">        var set &#x3D; &quot;list[&quot; + index + &quot;].collapse&quot;;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">            [set]: !this.data.list[index].collapse</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>3.WXSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-box</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">30</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-box</span> <span class="selector-class">.list</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1</span>rpx solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30</span>rpx <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-box</span> <span class="selector-class">.list</span> <span class="selector-tag">text</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">28</span>rpx;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40</span>rpx;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-box</span> <span class="selector-class">.list</span> <span class="selector-tag">text</span><span class="selector-class">.text-collapse</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:-webkit-box;</span><br><span class="line">    <span class="attribute">-webkit-box-orient</span>:vertical; </span><br><span class="line">    <span class="attribute">-webkit-line-clamp</span>:<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-box</span> <span class="selector-class">.coll-p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30</span>rpx;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#5064A3</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之阿拉丁统计平台</title>
    <url>/2020/10/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E9%98%BF%E6%8B%89%E4%B8%81%E7%BB%9F%E8%AE%A1%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h3 id="关键步骤："><a href="#关键步骤：" class="headerlink" title="关键步骤："></a><strong>关键步骤：</strong></h3><ul>
<li>注册/登录统计平台</li>
<li>创建小程序</li>
<li>接入SDK</li>
<li>检测SDK</li>
<li>集成成功</li>
</ul>
<a id="more"></a>

<h2 id="第一步：注册-登录-阿拉丁统计平台"><a href="#第一步：注册-登录-阿拉丁统计平台" class="headerlink" title="第一步：注册/登录 阿拉丁统计平台"></a><strong>第一步：注册/登录 阿拉丁统计平台</strong></h2><p>阿拉丁统计平台注册可以通过 PC 访问：<a href="http://link.zhihu.com/?target=http%3A//tj.aldwx.com">tj.aldwx.com</a>，通过「微信扫码+手机号」的方式即可完成注册。注册流程大约只需要 19s。</p>
<p><img src="https://pic2.zhimg.com/v2-9668fef89e4cd797290ec2c4c6c28898_b.jpg" alt="img">)<img src="https://pic2.zhimg.com/80/v2-9668fef89e4cd797290ec2c4c6c28898_720w.jpg" alt="img"></p>
<p>如果您已经注册过阿拉丁统计平台，可以直接通过微信扫码的方式登录，方便快捷。</p>
<h2 id="第二步：-创建阿拉丁小程序"><a href="#第二步：-创建阿拉丁小程序" class="headerlink" title="第二步： 创建阿拉丁小程序"></a><strong>第二步： 创建阿拉丁小程序</strong></h2><p>登录阿拉丁统计平台后，会默认跳转到阿拉丁统计后台的主页。方便您了解所有小程序的数据变化。</p>
<p><img src="https://pic2.zhimg.com/v2-3b07e92e7e9d502f8e794542369aeb97_b.jpg" alt="img">)<img src="https://pic2.zhimg.com/80/v2-3b07e92e7e9d502f8e794542369aeb97_720w.jpg" alt="img"></p>
<p>我们通过右上角「创建应用」可以进入小程序的创建页面，开始我们小程序的创建工作。</p>
<p><img src="https://pic3.zhimg.com/v2-0b62994983a194e435507e94d3ad2600_b.jpg" alt="img">)<img src="https://pic3.zhimg.com/80/v2-0b62994983a194e435507e94d3ad2600_720w.jpg" alt="img"></p>
<p>创建小程序需要填写：<strong>小程序名称</strong>，选择<strong>小程序的类型</strong>（小程序、小游戏），选择<strong>小程序的分类</strong>（小程序对应的是小程序类型，小游戏对应的是小游戏类型）。</p>
<p>填写信息后，提交就可以获取AppKey，然后就开始SDK接入了。</p>
<h2 id="第三步：接入阿拉丁统计SDK（重点）"><a href="#第三步：接入阿拉丁统计SDK（重点）" class="headerlink" title="第三步：接入阿拉丁统计SDK（重点）"></a><strong>第三步：接入阿拉丁统计SDK（重点）</strong></h2><p>接入SDK一直以来都是大家最关心的部分，也是接入阿拉丁统计最重要的一个步骤。所以这部分要认真看哦。提交信息后可以看到下面的截图：</p>
<p><img src="https://pic1.zhimg.com/v2-ed664367f737309b65ae3f58afbc4269_b.jpg" alt="img">)<img src="https://pic1.zhimg.com/80/v2-ed664367f737309b65ae3f58afbc4269_720w.jpg" alt="img"></p>
<blockquote>
<p>注：阅读此部分的内容需要和开发人员一起，欢迎分享给自己本公司的小程序开发人员。</p>
</blockquote>
<p>首先，这个部分的流程需要小程序的技术人员（一般是前端）来协助完成。在此过程中需要了解 阿拉丁Key、统计平台SDK、帮助文档以及数据检测。</p>
<p>阿拉丁Key（又称“AppKey”）是我们为大家创建小程序后生成的唯一凭证，开发者在集成SDK的时候需要将其填写到代码中（具体的操作见后文）。</p>
<p>其次，我们在接入的时候需要充分了解自己的小程序是否采用了框架（wepy、mpvue、Taro）或者插件（最好是和小程序的开发人员沟通确认），如果都没有的话就是标准的小程序类型。</p>
<p>不同的框架、插件接入流程会有细微的变化，但是阿拉丁Key和阿拉丁SDK是一样的。</p>
<p><a href="http://doc.aldwx.com/mini-program/join/wx-sdk/plugin" target="_blank" rel="noopener">阿拉丁帮助文档</a></p>
<p><img src="https://pic4.zhimg.com/v2-346337e2cb6a71de0c5757415b3a38d8_b.jpg" alt="img">)<img src="https://pic4.zhimg.com/80/v2-346337e2cb6a71de0c5757415b3a38d8_720w.jpg" alt="img"></p>
<p>接着，我们了解了阿拉丁Key和小程序类型后，我们可以下载SDK进行代码集成工作了。由于本文篇幅问题，本文的集成案例以「<strong>标准版小程序</strong>」演示。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>1、设置域名</p>
<p>登录<a href="http://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/">微信公众平台</a>(mp.weixin.qq.com)，在 <strong>开发→开发设置-&gt;服务器域名</strong> 找到「 <strong>request 合法域名</strong>」，点击「修改」，将<strong><code>log.aldwx.com</code></strong> 添加 <strong>request 合法域名</strong>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log.aldwx.com</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/v2-cd5e478a31d7facc7b7763dd524581d8_b.jpg" alt="img">)<img src="https://pic4.zhimg.com/80/v2-cd5e478a31d7facc7b7763dd524581d8_720w.jpg" alt="img"></p>
<p>2、配置SDK</p>
<p><strong><a href="http://link.zhihu.com/?target=http%3A//tongji.aldwx.com/tool/ald-stat.zip">点击下载</a></strong> 微信小程序SDK，并将下载的文件解压，将解压后的文件 <strong>ald-stat.js</strong> 和 <strong>ald-stat-conf.js</strong> 复制到小程序根目录的 <strong>utils 文件夹</strong>中。</p>
<blockquote>
<p>如果没有 <strong>utils</strong> 文件夹请在小程序项目的根目录下创建；</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/v2-d4cb4a63766df8d586e96509af489c14_b.jpg" alt="img">)<img src="https://pic1.zhimg.com/80/v2-d4cb4a63766df8d586e96509af489c14_720w.jpg" alt="img"></p>
<p>使用微信开发者工具打开小程序根目录 <strong>utils 文件夹</strong>下的 <strong>ald-stat-conf.js</strong> 文件，在浏览器<strong>登录<a href="http://link.zhihu.com/?target=http%3A//tongji.aldwx.com/">阿拉丁小程序平台</a>-管理-小程序列表-找到需要集成的小程序</strong>，复制对应小程序的 AppKey 到  <code>exports.app_key = &quot;&quot;</code>的双引号中间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引号前后不能有空格；其他配置项请勿随意更改。</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/v2-422b54fb7647447b1dac1da247c310a2_b.jpg" alt="img">)<img src="https://pic3.zhimg.com/80/v2-422b54fb7647447b1dac1da247c310a2_720w.jpg" alt="img"></p>
<p>使用微信开发者工具打开小程序根目录下的 <strong>app.js</strong> 文件，复制下段代码到 <strong>app.js</strong> 文件的第一行粘贴，完成后通过 <strong>菜单栏-文件-保存</strong>（快捷键 Ctrl+S ）修改的代码；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; app.js </span><br><span class="line">const ald &#x3D; require(&#39;.&#x2F;utils&#x2F;ald-stat.js&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/v2-84098f5dea9e38ef386963dfc4f68563_b.jpg" alt="img">)<img src="https://pic3.zhimg.com/80/v2-84098f5dea9e38ef386963dfc4f68563_720w.jpg" alt="img"></p>
<p>3、检测上报状态</p>
<p>在微信开发者工具中，查看控制台中的 Network 是否存在 <strong>d.html</strong> 开头的请求，点击后可看到 <strong><a href="http://link.zhihu.com/?target=http%3A//log.aldwx.com">http://log.aldwx.com</a></strong> 的域名信息，且 <strong>status</strong> 状态为 <strong>200</strong>。</p>
<p><img src="https://pic2.zhimg.com/v2-61ca010cd343e84a71c2ed0c55d76884_b.jpg" alt="img">)<img src="https://pic2.zhimg.com/80/v2-61ca010cd343e84a71c2ed0c55d76884_720w.jpg" alt="img"></p>
<p>验证成功后，将所有代码提交至微信审核，审核通过后需<strong>发布版本</strong>。</p>
<p>以上流程全部配置完成后了，表示小程序已经成功接入了阿拉丁统计平台。</p>
<p>如果遇到问题可以咨询您的同事（前端技术人员）或者咨询阿拉丁统计平台客服（微信ID：alddandan)。</p>
<h2 id="增加统计埋点"><a href="#增加统计埋点" class="headerlink" title="增加统计埋点"></a>增加统计埋点</h2><h3 id="一、自定义事件上报方法"><a href="#一、自定义事件上报方法" class="headerlink" title="一、自定义事件上报方法"></a>一、自定义事件上报方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.aldstat.sendEvent( key, value )</span><br></pre></td></tr></table></figure>

<p>定义：该方法接收两个参数，第一个参数key为事件名称。第二个参数vaule为事件本身的参数，该参数可以为一个字符串( String )或者一个JavaScript对象 ( Object )。</p>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key ： string</span><br><span class="line">value： &#123;  string | object &#125;</span><br></pre></td></tr></table></figure>

<p>规则：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>事件名称</td>
<td>string</td>
<td>描述用户的动作名称，不超过255个字符，支持特殊字符</td>
</tr>
<tr>
<td>参数</td>
<td>string</td>
<td>动作的参数，不超过255个字符，支持特殊字符但不包括（英文逗号 , 英文冒号 : 点 .）</td>
</tr>
<tr>
<td>参数值</td>
<td>string</td>
<td>动作的参数值，不超过255个字符，支持特殊字符但不包括（英文逗号 , 英文冒号 : 点 .）</td>
</tr>
</tbody></table>
<p>满足上述规则时，SDK才会上报事件及其参数。否则SDK 不会上报。</p>
<h3 id="二、自定义事件成功检测"><a href="#二、自定义事件成功检测" class="headerlink" title="二、自定义事件成功检测"></a>二、自定义事件成功检测</h3><p>例如，以<strong>获取用户昵称</strong>为例，进行事件上报，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.aldstat.sendEvent(&#39;获取用户昵称&#39;, &#123;</span><br><span class="line">        &quot;用户昵称&quot;: &quot;DemoChen&quot;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>上报成功后如下图所示：</p>
<p><img src="https://aldpicsh-1252823355.cossh.myqcloud.com/ueditor/1578224507.jpg" alt="img"></p>
<p>埋点验证成功后，将所有代码提交至微信审核，审核通过后需<strong>发布版本</strong></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>阿拉丁</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序登陆</title>
    <url>/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h3 id="小程序获取授权，得到用户的昵称头像"><a href="#小程序获取授权，得到用户的昵称头像" class="headerlink" title="小程序获取授权，得到用户的昵称头像"></a>小程序获取授权，得到用户的昵称头像</h3><h5 id="使用button标签的open-type-”getUserInfo”引导用户去授权"><a href="#使用button标签的open-type-”getUserInfo”引导用户去授权" class="headerlink" title="使用button标签的open-type=”getUserInfo”引导用户去授权"></a>使用button标签的open-type=”getUserInfo”引导用户去授权</h5><h4 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"userinfo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;"</span> <span class="attr">open-type</span>=<span class="string">"getUserInfo"</span> <span class="attr">bindgetuserinfo</span>=<span class="string">"getUserInfo"</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">bindtap</span>=<span class="string">"bindViewTap"</span> <span class="attr">class</span>=<span class="string">"userinfo-avatar"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;userInfo.avatarUrl&#125;&#125;"</span> <span class="attr">mode</span>=<span class="string">"cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"userinfo-nickname"</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: <span class="string">'Hello World'</span>,</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//判断小程序的API，回调，参数，组件等是否在当前版本可用。</span></span><br><span class="line">    canIUse: wx.canIUse(<span class="string">'button.open-type.getUserInfo'</span>),</span><br><span class="line">    value: <span class="number">3.6</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: <span class="string">'../logs/logs'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line">      <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">      <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">      app.userInfoReadyCallback = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>本地文件夹上传github</title>
    <url>/2020/09/22/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0github/</url>
    <content><![CDATA[<p>首先你需要一个github账号，所有还没有的话先去注册吧！</p>
<p><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
<p>我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可：</p>
<p><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">https://git-for-windows.github.io/</a></p>
<p>1.进入Github首页，点击New repository新建一个项目</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823164154526-418441991.png" alt="img"></p>
<a id="more"></a>

<p> 2.填写相应信息后点击create即可 </p>
<p>Repository name: 仓库名称</p>
<p>Description(可选): 仓库描述介绍</p>
<p>Public, Private : 仓库权限（公开共享，私有或指定合作者）</p>
<p>Initialize this repository with a README: 添加一个README.md</p>
<p>gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore</p>
<p>license: 证书类型，对应生成文件LICENSE</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823165025370-49444506.png" alt="img"></p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823165107308-439926006.png" alt="img"></p>
<p>4.点击Clone or dowload会出现一个地址，copy这个地址备用。</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823165450636-1167722003.png" alt="img"></p>
<p>5.接下来就到本地操作了，首先右键你的项目，如果你之前安装git成功的话，右键会出现两个新选项，分别为Git Gui Here,Git Bash Here,这里我们选择Git Bash Here，进入如下界面，Test_Bluetooth即为我的项目名。</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171048308-194895299.png" alt="img"></p>
<p>6.接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地</p>
<p>git clone <a href="https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址）" target="_blank" rel="noopener">https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址）</a></p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171143980-741152042.png" alt="img"></p>
<p> 7.这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个Test文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下，</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171209730-2089496483.png" alt="img"></p>
<p>8.接着继续输入命令 cd Test，进入Test文件夹</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171454261-10363777.png" alt="img"></p>
<p>9.接下来依次输入以下代码即可完成其他剩余操作：</p>
<p>git add .     （注：别忘记后面的.，空格之后再输入.  此操作是把Test文件夹下面的文件都添加进来）</p>
<p>git commit  -m  “提交信息”  （注：“提交信息”里面换成你需要，如“first commit”）</p>
<p>git push -u origin master  （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）</p>
<p> <img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171557823-3863512.png" alt="img"></p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171651808-1225335136.png" alt="img"></p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171818933-1506815566.png" alt="img"></p>
<p>输入你Github的用户名 和密码：</p>
<p><img src="https://img-blog.csdn.net/20160118172619673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20160118172535690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>上传文件夹</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发随笔（一）</title>
    <url>/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“..&#x2F;”代表当前文件所在目录的上一级目录。</span><br><span class="line"></span><br><span class="line">“..&#x2F;..&#x2F;”代表当前文件所在目录的上上级目录。</span><br><span class="line"></span><br><span class="line">“..&#x2F;..&#x2F;..&#x2F;”可以依次类推。</span><br><span class="line"></span><br><span class="line">“&#x2F;”代表根目录。</span><br><span class="line"></span><br><span class="line">“.&#x2F;”表示当前目录，HTML中，可以省略。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="给对象属性赋值，增加属性"><a href="#给对象属性赋值，增加属性" class="headerlink" title="给对象属性赋值，增加属性"></a>给对象属性赋值，增加属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  tel: &#39;15184138787&#39;,</span><br><span class="line">  list: &#123;</span><br><span class="line">   title: &#39;我是标题哦&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">需求：更改list里title的值</span><br><span class="line"> let  value &#x3D; &#39;list.title&#39;; &#x2F;&#x2F; 注意这里哈</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    [value]: &#39;我是新标题&#39;</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line">需求：list新增动态属性值</span><br><span class="line"> let  value &#x3D; &#96;list.$&#123;name&#125;&#96; &#x2F;&#x2F; 这里的name是动态的哈，可以是1，2，3，4.... 任意值</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    [value]: &#39;我是新属性&#39;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>



<h3 id="页面栈（带参数返回上一个页面）"><a href="#页面栈（带参数返回上一个页面）" class="headerlink" title="页面栈（带参数返回上一个页面）"></a>页面栈（带参数返回上一个页面）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组中第一个元素为首页，最后一个元素为当前页面。</span><br><span class="line"></span><br><span class="line">***注意：</span><br><span class="line">不要尝试修改页面栈，会导致路由以及页面状态错误。</span><br><span class="line">不要在 App.onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。</span><br><span class="line"></span><br><span class="line">按照这个逻辑 pages[pages.length - 1] 我们拿到的就是当前页</span><br><span class="line">pages[pages.length - 2] 我们拿到的是上一页</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取上一个页面的this</span><br><span class="line">let pages &#x3D; getCurrentPages()</span><br><span class="line">var prevPage &#x3D; pages[pages.length - 2]</span><br><span class="line">&#x2F;&#x2F;给上一个的data设置一个想要传递的参数</span><br><span class="line">prevPage.setData(&#123;</span><br><span class="line">xxxx: 1,</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;然后我们在上一个页面的onshow 里面就可以拿到这个值</span><br></pre></td></tr></table></figure>





<h3 id="通过id直接调用组件内部方法"><a href="#通过id直接调用组件内部方法" class="headerlink" title="通过id直接调用组件内部方法"></a>通过id直接调用组件内部方法</h3><blockquote>
<p><img src="/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/4ac158cdc9c648f2951aba06d0452f20/816184259208.png" alt="img"></p>
<p>followUs-component组件里的方法</p>
<p><img src="/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/251ac7f7360748fe8f80002cfe80af9e/816184028689.png" alt="img"></p>
<p>页面调用组件方法</p>
<p><img src="/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/6c63b95b03214999a9f7a0bd92a2f6b9/081618435245.png" alt="img"></p>
</blockquote>
<h3 id="禁止下拉-ios下拉空白"><a href="#禁止下拉-ios下拉空白" class="headerlink" title="禁止下拉(ios下拉空白)"></a>禁止下拉(ios下拉空白)</h3><blockquote>
<p>在微信小程序中，用力往下拉动，页面顶部会出现一段空白的地方。 产品的需求不太允许这么做，会影响用户体验，查看文档发现可以使用enablePullDownRefresh这属性来实现，在page.json里面添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;enablePullDownRefresh&quot;:false</span><br></pre></td></tr></table></figure>

<p>这样可以禁用页面下拉滚动，需要注意的是不可在全局配置 app.json中配置。经测试发现：虽然禁止了下拉刷新，但是在部分ios端仍然可以下拉出现空白。那么该如何解决呢？方法：当页面滚动的时候判断与顶部的距离，当这个距离小于0的时候，强制性拉回顶部即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onPageScroll:function(e)&#123;</span><br><span class="line">  if(e.scrollTop&lt;0)&#123;</span><br><span class="line">    wx.pageScrollTo(&#123;</span><br><span class="line">   	 scrollTop: 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="自带水平和垂直滚动事件"><a href="#自带水平和垂直滚动事件" class="headerlink" title="自带水平和垂直滚动事件"></a>自带水平和垂直滚动事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">scroll-y</span>&gt;</span>111<span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">scroll-x</span>&gt;</span>222<span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="text套text，内部text绑定点击事件失效"><a href="#text套text，内部text绑定点击事件失效" class="headerlink" title="text套text，内部text绑定点击事件失效"></a>text套text，内部text绑定点击事件失效</h3><h3 id="hover添加class事件"><a href="#hover添加class事件" class="headerlink" title="hover添加class事件"></a>hover添加class事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hover-class</span>=<span class="string">"none"</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hover-class</span>=<span class="string">"bg_red"</span>  <span class="attr">hover-stop-propagation</span>=<span class="string">"false"</span> <span class="attr">hover-start-time</span>=<span class="string">"50"</span> <span class="attr">hover-stay-time</span>=<span class="string">"400"</span> &gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">hover-stop-propagation属性并不是说完全阻止了祖先节点的被点击能力，它只是代表点击当前view的时候，它的祖先节点不会产生点击效果</span><br><span class="line">hover-start-time按住多久出现点击态</span><br><span class="line">hover-stay-time手指松开后保持点击的状态</span><br><span class="line">通常，当一个 view 组件中包含 image 等不支持 hover-class 的组件，但又需要在该组件上使用 hover-stop-propagation 属性的作用时，需要将不支持 hover-class 的组件用view、button 或 navigator 包裹起来。</span><br></pre></td></tr></table></figure>



<h3 id="使用button标签的open-type-”getUserInfo”引导用户去授权"><a href="#使用button标签的open-type-”getUserInfo”引导用户去授权" class="headerlink" title="使用button标签的open-type=”getUserInfo”引导用户去授权]"></a>使用button标签的open-type=”getUserInfo”引导用户去授权]</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">index.wxml</span><br><span class="line">&lt;button</span><br><span class="line">    wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;canIUse&#125;&#125;"</span></span><br><span class="line">    open-type=<span class="string">"getUserInfo"</span></span><br><span class="line">    bindgetuserinfo=<span class="string">"bindGetUserInfo"</span></span><br><span class="line">&gt;授权登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;view wx:else&gt;请升级微信版本&lt;/</span>view&gt;</span><br><span class="line">index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">     <span class="comment">//判断小程序的API，回调，参数，组件等是否在当前版本可用。</span></span><br><span class="line">    canIUse: wx.canIUse(<span class="string">'button.open-type.getUserInfo'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查看是否授权</span></span><br><span class="line">    wx.getSetting(&#123;</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.authSetting[<span class="string">'scope.userInfo'</span>]) &#123;</span><br><span class="line">          wx.getUserInfo(&#123;</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(res.userInfo)</span><br><span class="line">              <span class="comment">//用户已经授权过</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  bindGetUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.detail.userInfo)</span><br><span class="line">    <span class="keyword">if</span> (e.detail.userInfo)&#123;</span><br><span class="line">      <span class="comment">//用户按了允许授权按钮</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//用户按了拒绝按钮</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="页面跳转方法总结"><a href="#页面跳转方法总结" class="headerlink" title="页面跳转方法总结"></a>页面跳转方法总结</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wx.navigateBack返回上上个页面。</span></span><br><span class="line">wx.navigateBack(&#123;</span><br><span class="line">  delta: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//携带参数</span></span><br><span class="line"><span class="keyword">const</span> pages = getCurrentPages()</span><br><span class="line"><span class="keyword">const</span> prevPage = pages[pages.length<span class="number">-2</span>] <span class="comment">// 上一页</span></span><br><span class="line"><span class="comment">// 调用上一个页面的setData 方法，将数据存储</span></span><br><span class="line">prevPage.setData(&#123;</span><br><span class="line">    testdata: <span class="number">12456</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。</span></span><br><span class="line"><span class="comment">// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈</span></span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">'page/detail/detail?product_id=222'</span>　　<span class="comment">// 页面 </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭当前页面，跳转到应用内的某个页面。</span></span><br><span class="line">wx.redirectTo(&#123;</span><br><span class="line">  url: <span class="string">'page/home/home?user_id=111'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到tabBar页面（在app.json中注册过的tabBar页面），同时关闭其他非tabBar页面。</span></span><br><span class="line">wx.switchTab(&#123;</span><br><span class="line">  url: <span class="string">'page/index/index'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭所有页面，打开到应用内的某个页面。</span></span><br><span class="line">wx.reLanch(&#123;</span><br><span class="line">  url: <span class="string">'page/home/home?user_id=111'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="wxml-页面组件跳转（可以通过设置open-type属性指明页面跳转方式）："><a href="#wxml-页面组件跳转（可以通过设置open-type属性指明页面跳转方式）：" class="headerlink" title="wxml 页面组件跳转（可以通过设置open-type属性指明页面跳转方式）："></a>wxml 页面组件跳转（可以通过设置open-type属性指明页面跳转方式）：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// navigator 组件默认的 open-type 为 navigate </span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"/page/navigate/navigate?title=navigate"</span> <span class="attr">hover-class</span>=<span class="string">"navigator-hover"</span>&gt;</span>跳转到新页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// redirect 对应 API 中的 wx.redirect 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"../../redirect/redirect/redirect?title=redirect"</span> <span class="attr">open-type</span>=<span class="string">"redirect"</span> <span class="attr">hover-class</span>=<span class="string">"other-navigator-hover"</span>&gt;</span>在当前页打开<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// switchTab 对应 API 中的 wx.switchTab 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"/page/index/index"</span> <span class="attr">open-type</span>=<span class="string">"switchTab"</span> <span class="attr">hover-class</span>=<span class="string">"other-navigator-hover"</span>&gt;</span>切换 Tab<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// reLanch 对应 API 中的 wx.reLanch 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"../../redirect/redirect/redirect?title=redirect"</span> <span class="attr">open-type</span>=<span class="string">"redirect"</span> <span class="attr">hover-class</span>=<span class="string">"other-navigator-hover"</span>&gt;</span>关闭所有页面，打开到应用内的某个页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// navigateBack 对应 API 中的 wx.navigateBack 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"/page/index/index"</span> <span class="attr">open-type</span>=<span class="string">"navigateBack"</span> <span class="attr">hover-class</span>=<span class="string">"other-navigator-hover"</span>&gt;</span>关闭当前页面，返回上一级页面或多级页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="离开页面清除定时器"><a href="#离开页面清除定时器" class="headerlink" title="离开页面清除定时器"></a>离开页面清除定时器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//离开页面清除</span></span><br><span class="line">onUnload: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.data.start_timer);</span><br><span class="line">&#125;,</span><br><span class="line">onHide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.data.start_timer);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒计时</span></span><br><span class="line">setCountDown: <span class="function"><span class="keyword">function</span> (<span class="params">Time = <span class="string">'2020-07-28 16:25:00'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Time = <span class="keyword">this</span>.data.paytime;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.paytime,<span class="string">'paytime'</span>);</span><br><span class="line">  <span class="keyword">var</span> setTime = <span class="number">0.5</span> * <span class="number">3600</span> * <span class="number">1000</span>;<span class="comment">//半个小时的毫秒数</span></span><br><span class="line">  <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();<span class="comment">//现在时间（时间戳）</span></span><br><span class="line">  <span class="keyword">var</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>().setTime(<span class="keyword">new</span> <span class="built_in">Date</span>(Time).getTime() + setTime);<span class="comment">//距离参数半个小时后的时间</span></span><br><span class="line">  <span class="keyword">var</span> intDiff = (endTime - nowTime) / <span class="number">1000</span>;<span class="comment">//毫秒数差</span></span><br><span class="line">  <span class="keyword">var</span> day = <span class="number">0</span>,</span><br><span class="line">    hour = <span class="number">24</span>,</span><br><span class="line">    minute = <span class="number">60</span>,</span><br><span class="line">    second = <span class="number">60</span>;<span class="comment">//时间默认值</span></span><br><span class="line">  <span class="keyword">if</span> (intDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    day = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line">    hour = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span>)) - (day * <span class="number">24</span>);</span><br><span class="line">    minute = <span class="built_in">Math</span>.floor(intDiff / <span class="number">60</span>) - (day * <span class="number">24</span> * <span class="number">60</span>) - (hour * <span class="number">60</span>);</span><br><span class="line">    second = <span class="built_in">Math</span>.floor(intDiff) - (day * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) - (hour * <span class="number">60</span> * <span class="number">60</span>) - (minute * <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (hour &lt;= <span class="number">9</span>) hour = <span class="string">'0'</span> + hour;</span><br><span class="line">    <span class="keyword">if</span> (minute &lt;= <span class="number">9</span>) minute = <span class="string">'0'</span> + minute;</span><br><span class="line">    <span class="keyword">if</span> (second &lt;= <span class="number">9</span>) second = <span class="string">'0'</span> + second;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      showTime: hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      showTime: <span class="string">'00:00:00'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    start_timer: setTimeout(<span class="keyword">this</span>.setCountDown, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="ios页面回弹"><a href="#ios页面回弹" class="headerlink" title="ios页面回弹"></a>ios页面回弹</h3><p>给page加一个border-bottom就可，也要给一定的padding-bottom</p>
<h3 id="wx-if和hidden"><a href="#wx-if和hidden" class="headerlink" title="wx:if和hidden"></a>wx:if和hidden</h3><p>wx:if条件为true显示，hidden条件为false显示</p>
<h3 id="微信小程序“对应的服务器证书无效”"><a href="#微信小程序“对应的服务器证书无效”" class="headerlink" title="微信小程序“对应的服务器证书无效”"></a>微信小程序“对应的服务器证书无效”</h3><p><img src="/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/image-20200927102756626.png" alt="image-20200927102756626"></p>
<p>到腾讯云上，SSL证书管理，可以申请一个免费的证书，申请好了放到nginx配置中，验证可以通过。</p>
<h3 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h3><p>对于用户来说，小程序加载流程变成了：</p>
<p>1.首次启动时，先下载小程序主包，显示主包内的页面；</p>
<p>2.如果用户进入了某个分包的页面，再下载这个对应分包，下载完毕后，显示分包的页面。</p>
<p>采用分包加载，对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务；而对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能</p>
<p><strong>attention：</strong></p>
<p>1.无法在首页面或tabbar页面打开分包中的页面，必须先链接到非首页面或tabbar页面，再进行跳转到分包中的页面。</p>
<p>2.每个页面的js文件必须初始化page({})。</p>
<p>3.避免分包与分包之间引用上的耦合。因为分包的加载是由用户操作触发的，并不能确保某分包加载时，另外一个分包就一定存在，这个时候可能会导致 JS 逻辑异常的情况，例如报「”xxx.js” is not defined」这样的错误；</p>
<p>4.一些公共用到的自定义组件，需要放在主包内。</p>
<p>5.整个小程序所有分包大小不超过 4M</p>
<p>6.单个分包/主包大小不能超过 2M</p>
<p>7.微信 6.6.0 版本开始支持分包加载，而对于低于这个版本的客户端，我们做了兼容处理，开发者不需要对老版本微信客户端做兼容。</p>
<p>对于老版本的客户端，编译后台会将所有的分包打包成一个整包，老版本的客户端依然按照整包的方式进行加载。</p>
<p><strong>how:</strong></p>
<p>当理清了分包的划分后，就可以进行分包的配置了，这一步并不复杂。</p>
<p>假设支持分包的小程序目录结构如下：</p>
<p><img src="https://img-blog.csdn.net/20180422115731135" alt="img"></p>
<p>开发者通过在 app.json<code>subPackages</code>字段声明项目分包结构：</p>
<p><img src="https://img-blog.csdn.net/20180422115740142" alt="img"></p>
<h3 id="添加到我的小程序"><a href="#添加到我的小程序" class="headerlink" title="添加到我的小程序"></a>添加到我的小程序</h3><p>当用户进入小程序后，</p>
<p>能否判断用户是否将当前小程序添加到我的小程序中-否</p>
<p>能否通过js操作将当前小程序添加到我的小程序中-否</p>
<h3 id="AppID、AppKey、AppSecret"><a href="#AppID、AppKey、AppSecret" class="headerlink" title="AppID、AppKey、AppSecret"></a>AppID、AppKey、AppSecret</h3><p>AppID：应用的唯一标识（是用来标记你的开发者账号的）<br>AppKey：公匙（相当于账号）<br>AppSecret：私匙（相当于密码）</p>
<p>token：令牌（过期失效）</p>
<p>使用方法</p>
<p>\1. 向第三方服务器请求授权时，带上AppKey和AppSecret（需存在服务器端）</p>
<p>\2. 第三方服务器验证AppKey和AppSecret在DB中有无记录</p>
<p>\3. 如果有，生成一串唯一的字符串（token令牌），返回给服务器，服务器再返回给客户端</p>
<p>\4. 客户端下次请求敏感数据时带上令牌</p>
<p>关于第一点，可以采用签名的方式发送，当应用服务端向第三方服务端发请求时，带上AppKey、时间戳、随机数、签名，签名可以使用 AppSecret + 时间戳 + 随机数使用sha1生成，第三方服务端收到后，生成本地签名和收到的签名比对，如果一致，校验成功</p>
<h3 id="常见open-type"><a href="#常见open-type" class="headerlink" title="常见open-type"></a>常见open-type</h3><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">contact</td>
<td align="left">打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/customer-message/customer-message.html" target="_blank" rel="noopener">具体说明</a></td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.1.0</a></td>
</tr>
<tr>
<td align="left">share</td>
<td align="left">触发用户转发，使用前建议先阅读<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html#使用指引" target="_blank" rel="noopener">使用指引</a></td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.2.0</a></td>
</tr>
<tr>
<td align="left">getPhoneNumber</td>
<td align="left">获取用户手机号，可以从bindgetphonenumber回调中获取到用户信息，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html" target="_blank" rel="noopener">具体说明</a></td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.2.0</a></td>
</tr>
<tr>
<td align="left">getUserInfo</td>
<td align="left">获取用户信息，可以从bindgetuserinfo回调中获取到用户信息</td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.3.0</a></td>
</tr>
<tr>
<td align="left">launchApp</td>
<td align="left">打开APP，可以通过app-parameter属性设定向APP传的参数<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html" target="_blank" rel="noopener">具体说明</a></td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.9.5</a></td>
</tr>
<tr>
<td align="left">openSetting</td>
<td align="left">打开授权设置页</td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">2.0.7</a></td>
</tr>
<tr>
<td align="left">feedback</td>
<td align="left">打开“意见反馈”页面，用户可提交反馈内容并上传<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getLogManager.html" target="_blank" rel="noopener">日志</a>，开发者可以登录<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">小程序管理后台</a>后进入左侧菜单“客服反馈”页面获取到反馈内容</td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">2.1.0</a></td>
</tr>
</tbody></table>
<h3 id="公众号组件official-account"><a href="#公众号组件official-account" class="headerlink" title="公众号组件official-account"></a>公众号组件official-account</h3><p>tips:</p>
<ol>
<li>使用组件前，需前往小程序后台，在“设置”-&gt;“关注公众号”中设置要展示的公众号。<strong>注：设置的公众号需与小程序主体一致。</strong></li>
<li>在一个小程序的生命周期内，只有从以下场景进入小程序，才具有展示引导关注公众号组件的能力:<ul>
<li>当小程序从扫小程序码场景（场景值1047，场景值1124）打开时</li>
<li>当小程序从聊天顶部场景（场景值1089）中的「最近使用」内打开时，若小程序之前未被销毁，则该组件保持上一次打开小程序时的状态</li>
<li>当从其他小程序返回小程序（场景值1038）时，若小程序之前未被销毁，则该组件保持上一次打开小程序时的状态</li>
</ul>
</li>
<li>为便于开发者调试，基础库 <code>2.7.3</code> 版本起开发版小程序增加以下场景展示公众号组件：<ul>
<li>开发版小程序从扫二维码（场景值 1011）打开 — 体验版小程序打开</li>
</ul>
</li>
<li>组件限定最小宽度为300px，高度为定值84px。</li>
<li>每个页面只能配置一个该组件。</li>
<li>可改变宽度</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">official-account</span> <span class="attr">stlye</span>=<span class="string">"width:200px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">official-account</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="获取unionId"><a href="#获取unionId" class="headerlink" title="获取unionId"></a>获取unionId</h3><p>一个微信开放平台下的相同主体的App、公众号、小程序的unionid是相同的，这样就可以锁定是不是同一个用户</p>
<p>微信针对不同的用户在不同的应用下都有唯一的一个openId, 但是要想确定用户是不是同一个用户，就需要靠unionid来区分</p>
<p>同一个微信开放平台下的相同主体的 App、公众号、小程序，如果用户已经关注公众号，或者曾经登录过App或公众号，则用户打开小程序时，开发者可以直接通过 wx.login 获取到该用户UnionID，无须用户再次授权<br> （解读：用户如果没有登录过app，也没有登录过公众号，也没有关注过公众号的情况下，小程序中通过 wx.login 是获取不到 unionid的）</p>
<p>UnionID获取途径</p>
<ul>
<li>调用接口wx.getUserInfo，从解密数据中获取UnionID。注意本接口需要用户授权，请开发者妥善处理用户拒绝授权后的情况。</li>
<li>如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过wx.login获取到该用户UnionID，无须用户再次授权</li>
</ul>
<p><strong>重点</strong></p>
<p>所有就有两种情况:</p>
<ol>
<li><p>一般情况，用户登录过关联的其他公众号</p>
<p>使用 wx.login 获取code，传到后端，code换openid，unionId</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.login</span></span><br><span class="line">wx.login(&#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: openIdUrl,<span class="comment">//后端接口</span></span><br><span class="line">      data: &#123;</span><br><span class="line">        code: data.code</span><br><span class="line">      &#125;,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        self.globalData.openid = res.data.openid</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'拉取用户openid失败，将无法正常使用开放接口等服务'</span>, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br><span class="line">  &#125;,</span><br><span class="line">  fail: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wx.login 接口调用失败，将无法正常使用开放接口等服务'</span>, err)</span><br><span class="line">    callback(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户没有用过关联的公众号等</p>
<p>这时候 wx.login 就获取不到 unionId 了。需要使用 wx.getUserInfo</p>
<p>解决思路：通过带登录态的 wx.getUserInfo 获取到用户的加密数据 encryptedData 和加密算法的初始向量iv，然后将 encryptdata、iv 以及 code传给后端，后端再去通过接收到的encryptedData、iv以、code 以及之前的 session_key 解密出用户的 openid、unionid 等</p>
</li>
</ol>
   <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">wx.getUserInfo(&#123;</span><br><span class="line">  withCredentials:<span class="literal">false</span>,</span><br><span class="line">  success:<span class="function">(<span class="params">obj</span>)=&gt;</span>&#123;</span><br><span class="line">   </span><br><span class="line">      wx.request(&#123;</span><br><span class="line">          url: openIdUrl,<span class="comment">//后端接口</span></span><br><span class="line">          data: &#123;</span><br><span class="line">              code: data.code,</span><br><span class="line">              encryptedData : obj.encryptedData,</span><br><span class="line">              iv : obj.iv,</span><br><span class="line">          &#125;,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">              self.globalData.openid = res.data.openid</span><br><span class="line">          &#125;,</span><br><span class="line">          fail: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'拉取用户openid失败，将无法正常使用开放接口等服务'</span>, res)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>实际项目中，需要将两种情况整合使用</p>
<p>两种方案：</p>
<p>第一种：（ 前端判断是否有 unionid ）wx.login 向后端上传 code 并且后端返回数据以后，前端判断返回值中是否有 unionid 或者 unionid 是否为 null，null 的情况下去调用带有用户登录态的wx.getUserInfo()，然后再将微信返回的  encryptedData 和 iv 返回给后端，后端解密出相应的信息后再返回给前端；</p>
<p>第二种：（ 后端判断是否有 unionid ）前端调用 wx.login(), wx.getUserInfo() ,把 code,encryptedData 和 iv 返回给后端，后端在拿到前端 code 之后去请求微信的接口拿 unionid，如果返回的 unionid 为空，再用的 encryptedData、iv以及之前的 session_key 解密出 unionid，后端解密出相应的信息后再返回给前端</p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染基本原理</title>
    <url>/2020/07/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/k9N4R779RPrE_zB8xmna4A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/k9N4R779RPrE_zB8xmna4A</a></p>
<p><a href="https://wenku.baidu.com/view/43f6de6f846a561252d380eb6294dd88d1d23d06.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/43f6de6f846a561252d380eb6294dd88d1d23d06.html</a></p>
<p><img src="http://note.youdao.com/yws/res/4277/AB6FE614A7284DA09E42D70C34CB2779" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4276/0895E95CD6B94F388805B4003B303ECF" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4255/EE222C21922A4A99AEF1FAEABBB44B30" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4282/995D42C84F7A44ECB44BAE0D6D70B660" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4268/C1BED60D28E5444EA00850BB2ED7E4B3" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4275/AFCEE7C8A8CE4379AFC0A90500F5D7EC" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4261/75DA24369E3C47EB9BB435A28C00BD4A" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4270/960E57F755BE41D980B26965553FBE05" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4271/7A5A0D1E6D514F90903FC2FC8B4889CF" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4274/90F32D72F8154097A71448DB627058AE" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4252/8CDAF1667E844A03943CCCDB8A8383D4" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4281/1E90E3AE969641F998B15E076DEBAD81" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4260/22EB87EF0AFA45A5AA9D792F6C918C68" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4279/5BAAE640B2D845969886053DB2D7F44C" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4283/D9F09BD217474E1A9F2D41FD70CBDDC2" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4269/C2F8519F8FC041409A5DE68752133C42" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4278/BF3A766456E04571815F922E763FA8C7" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4284/234DB30344EF41AFA054D705F2836BD3" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4280/A3BD42A40E534E36A96A733A5D9DFB77" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4264/EB73BB8AE59948C88C564B6FFA89C2F8" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4263/2D6AABD6340148AF93879F5CD66194F4" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4265/04C3B07C45E1484B8D011C23E3C853BE" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4257/F520A8FD508D431DA0863483527347B0" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4258/B6A63060475542D2A12FE924DBCDB047" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4272/8929B48A70304679A1476FA0A36FF402" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4253/B0BCF84D012748B891CB75EF92917157" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4273/A530722F60924E02AB99E64C65EFF057" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4254/635131C32ED9491C896179DEC9038CD1" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4262/7C8B2221AE1B4B1693B079614BBBDE29" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4256/D1EBFEBA4F334306A7A7659743837626" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4266/51CA35C897744305AEDEBBDEFDE5B0DB" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4267/2522117618C54535A56381480FB2A4B6" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4259/DDAC63C11C574212A0C600F2120CED6B" alt="img"></p>
<p>更多 <a href="https://mp.weixin.qq.com/s/k9N4R779RPrE_zB8xmna4A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/k9N4R779RPrE_zB8xmna4A</a></p>
<p>参考链接 <a href="https://wenku.baidu.com/view/43f6de6f846a561252d380eb6294dd88d1d23d06.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/43f6de6f846a561252d380eb6294dd88d1d23d06.html</a></p>
]]></content>
      <categories>
        <category>浏览器渲染</category>
      </categories>
      <tags>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式方法记录</title>
    <url>/2020/07/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><a id="more"></a>

<blockquote>
<ol>
<li><p>年月日</p>
<p>/^((?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)$/</p>
</li>
<li><p>时分秒</p>
<p>/[0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]/</p>
<p>/^([01]\d|2[0123]):([0-5]\d|59)$/</p>
</li>
<li><p>密码6-20位，只允许字母、数字、特殊字符的其中两项及以上</p>
<ul>
<li><p>能匹配的组合为：数字+字母，数字+特殊字符，字母+特殊字符，数字+字母+特殊字符组合，而且不能是纯数字，纯字母，纯特殊字符</p>
<p>^(?![\d]+$)(?![a-zA-Z]+$)(?![^\da-zA-Z]+$).{6,20}$</p>
</li>
<li><p>上面的正则里所说的特殊字符是除了数字，字母之外的所有字符 如果要限定特殊字符，例如，特殊字符的范围为 !#$%^&amp;* ，那么可以这么改</p>
<p>^(?![\d]+$)(?![a-zA-Z]+$)(?![!#$%^&amp;<em>]+$)[\da-zA-Z!#$%^&amp;</em>]{6,20}$</p>
</li>
<li><p>下面的是只包含下划线的特殊字符</p>
<p>^(?![\d]+$)(?![a-zA-Z]+$)(?![!_]+$)[\da-zA-Z!_]{6,20}$ </p>
</li>
</ul>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量process.env</title>
    <url>/2020/07/30/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fprocess-env/</url>
    <content><![CDATA[<p>最近系统接入了公司的单点登录，为了登陆成功后再跳回系统的主页面，又申请了测试和沙箱的域名（之前都是直接用IP登的），本地开发是配置的host。接入之后发现了一个非常麻烦的点就是给单点登录传的跳转地址每次都要修改，开发的时候要写成开发的域名，测试的时候要改成测试的域名，进沙箱的时候要改成跳转沙箱的域名，上线的时候又要改成线上的域名。特别是在测试阶段，开发测试来回切换，不胜其烦。<br>于是就想把它写成配置文件，根据不同环境加载不同的配置，这样就不用来回改了。这个时候，process.env就跳入了脑海，叫嚣着，终于该我出场啦！！</p>
<h4 id="扒一扒process-env"><a href="#扒一扒process-env" class="headerlink" title="扒一扒process.env"></a>扒一扒process.env</h4><p>process对象是全局变量，它提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()。<br>既然process都是一个对象了，env自然是它的一个属性，这个属性返回包含用户环境信息的对象。在终端输入node后，在输入process.env可以看到打印出来的信息。</p>
<a id="more"></a>

<h4 id="主角出场-process-env-NODE-ENV"><a href="#主角出场-process-env-NODE-ENV" class="headerlink" title="主角出场 process.env.NODE_ENV"></a>主角出场 process.env.NODE_ENV</h4><p>NODE_ENV不是process.env对象上原有的属性，它是我们自己添加上去的一个环境变量，用来确定当前所处的开发阶段。一般生产阶段设为production，开发阶段设为develop，然后在脚本中读取process.env.NODE_ENV。<br>运行脚本时，可以这样改变环境变量, 在package.json文件的scripts里面添加命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_ENV&#x3D;production node build.js</span><br></pre></td></tr></table></figure>

<p>但是这个命令使用Windows的同学拉下代码后就报错了，因为Windows上面设置的方式不一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set NODE_ENV&#x3D;production node build.js</span><br></pre></td></tr></table></figure>

<p>但是不同电脑上不同的设置肯定是不行的呀，这个时候cross-env赶来救场了。<br>cross-env可以跨平台的设置和使用环境变量<br>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev cross-env</span><br></pre></td></tr></table></figure>

<p>接下来我们就可以通过cross-env来设置了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cross-env NODE_ENV&#x3D;production node build.js</span><br></pre></td></tr></table></figure>

<p>这样设置之后，我们可以在脚本中使用process.env.NODE_ENV了，但是不能在模块中使用，要想在模块当中直接使用，我们还需要一些配置</p>
<h5 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h5><p>DefinePlugin可以定义一些全局变量，让我们在模块当中直接使用，不用做任何声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &#39;.&#x2F;src&#x2F;app&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &#39;dist&#39;,</span><br><span class="line">        filename: &#39;bundle.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DefinePlugin(&#123;</span><br><span class="line">           &#39;process.env.NODE_ENV&#39;:  &#39;production&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们直接这样定义的时候，编译后是这个样子的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5262488-8d77f226c73186e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/862/format/webp" alt="img"></p>
<p>bundle.png</p>
<p>DefinePlugin直接将内容替换了，而不是一个字符串，所以我们经常这样定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.DefinePlugin(&#123;</span><br><span class="line">      &#39;process.env.NODE_ENV&#39;: JSON.stringify(process.env.NODE_ENV)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样就可以直接使用啦_<br>现在我们要在模块中根据环境变量来配置不同的url了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let url &#x3D; &#39;&#39;;</span><br><span class="line"> if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;testing&#39;) &#123;</span><br><span class="line">   url &#x3D; &#39;http:&#x2F;&#x2F;my.test.cn&#39;;</span><br><span class="line"> &#125; else if (process.env.alpord &#x3D;&#x3D;&#x3D; &#39;alpord&#39;) &#123;</span><br><span class="line">   url &#x3D; &#39;http:&#x2F;&#x2F;my.alpord.cn&#39;;</span><br><span class="line"> &#125; else if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">   url &#x3D; &#39;http:&#x2F;&#x2F;my.product.cn&#39;;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   url &#x3D; &#39;http:&#x2F;&#x2F;my.develop.cn&#39;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这只是简单列了一下process.env.NODE_ENV的用法，大家知道怎么用就好啦</p>
<p>参考链接 <a href="https://www.jianshu.com/p/c8f9c61c2f20" target="_blank" rel="noopener">https://www.jianshu.com/p/c8f9c61c2f20</a></p>
]]></content>
      <categories>
        <category>环境变量</category>
      </categories>
      <tags>
        <tag>环境变量</tag>
        <tag>process-env</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点链接</title>
    <url>/2020/09/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>vue生命周期从源码看</p>
<p><a href="https://mp.weixin.qq.com/s/6-WDKTyyDnkbw224WOEpjw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6-WDKTyyDnkbw224WOEpjw</a></p>
<p>作为一位Vue工程师，这些开发技巧你都会吗？</p>
<p><a href="https://mp.weixin.qq.com/s/QqMfogiIPLrsSBRUkN_WlQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QqMfogiIPLrsSBRUkN_WlQ</a></p>
<a id="more"></a>

<p>Vue项目从2.5M优化到200kb的全过程</p>
<p><a href="https://mp.weixin.qq.com/s/FRay4O1VAJ9c1RDyvjkzpg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FRay4O1VAJ9c1RDyvjkzpg</a></p>
<p>很多人不知道可以使用这种 key 的方式来对 Vue 组件进行重新渲染！</p>
<p><a href="https://mp.weixin.qq.com/s/DA2X_aIqBolHSKlYt9aH5Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DA2X_aIqBolHSKlYt9aH5Q</a></p>
<p>Vue.use中都发生了什么？</p>
<p><a href="https://mp.weixin.qq.com/s/LBaQiq4CVGYXSDC9GgGp4Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LBaQiq4CVGYXSDC9GgGp4Q</a></p>
<p>Vue keep-alive深入理解及实践总结</p>
<p><a href="https://mp.weixin.qq.com/s/NgrrK_HC_ci_mOd2PiiWxA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NgrrK_HC_ci_mOd2PiiWxA</a></p>
<p>Vue中mixin怎么理解？</p>
<p><a href="https://mp.weixin.qq.com/s/0tRYs-tlf8NaWoqu5qvYcw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0tRYs-tlf8NaWoqu5qvYcw</a></p>
<p>从Vue源码角度深挖Watch、Computed</p>
<p><a href="https://mp.weixin.qq.com/s/ApYLgnuQ9cxvQrFekAU75w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ApYLgnuQ9cxvQrFekAU75w</a></p>
<p>从源码解读 Vuex 注入 Vue 生命周期的过程</p>
<p><a href="https://mp.weixin.qq.com/s/15YA0baY5MGIjG3CkamDyA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/15YA0baY5MGIjG3CkamDyA</a></p>
<p>一文看懂Vue3周边配套现状</p>
<p><a href="https://mp.weixin.qq.com/s/Em_fOGXBzEtQ8UEA2_Bdew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Em_fOGXBzEtQ8UEA2_Bdew</a></p>
<p> 为你的 Vue.js 单页应用提速</p>
<p><a href="https://mp.weixin.qq.com/s/5DAm7WvU9htzkdYGM5Tmkw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5DAm7WvU9htzkdYGM5Tmkw</a></p>
<p>Vue超好玩的新特性：在CSS中使用JS变量</p>
<p><a href="https://mp.weixin.qq.com/s/DW_G5W3tz1CzbFz4aYDXcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DW_G5W3tz1CzbFz4aYDXcA</a></p>
<p>彻底理解 Cookie、Session、Token、JWT</p>
<p><a href="https://mp.weixin.qq.com/s/Du9GIaV87BU3disvC2gtGQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Du9GIaV87BU3disvC2gtGQ</a></p>
<p>10个Vue开发技巧助力成为更好的工程师</p>
<p><a href="https://mp.weixin.qq.com/s/_W-0JoGtaJPXDjF6Mx6u4Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_W-0JoGtaJPXDjF6Mx6u4Q</a></p>
<p>Vue 开发必须知道的 36 个技巧</p>
<p><a href="https://mp.weixin.qq.com/s/dr4c0HWmHsGrrw91l_mk-Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dr4c0HWmHsGrrw91l_mk-Q</a></p>
<p>Vue最全知识点（基础到进阶，覆盖vue3.0，持续更新整理，欢迎补充讨论）</p>
<p><a href="https://mp.weixin.qq.com/s/uat5Tt21ZU7-q4S3xMqTdg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uat5Tt21ZU7-q4S3xMqTdg</a></p>
<p>前端一键换肤的N种方案，请收下</p>
<p><a href="https://mp.weixin.qq.com/s/5rejEt5xvRYTNPFvhLyEoQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5rejEt5xvRYTNPFvhLyEoQ</a></p>
<p>一份值得收藏的 Git 异常处理清单</p>
<p><a href="https://mp.weixin.qq.com/s/GKdhcb0ekirjg4jEwERizA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GKdhcb0ekirjg4jEwERizA</a></p>
<p>前端工程师如何处理10万条数据</p>
<p><a href="https://mp.weixin.qq.com/s/0duasKMCrIYjwWZvoZikrQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0duasKMCrIYjwWZvoZikrQ</a></p>
<p>那些不常见，但却非常实用的css属性(整理不易)</p>
<p><a href="https://mp.weixin.qq.com/s/yt6dNfSxJZwtMTSrbprquQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yt6dNfSxJZwtMTSrbprquQ</a></p>
<p>你可能不知道的15个有用的Github功能</p>
<p><a href="https://mp.weixin.qq.com/s/abeqBYe__mzZ3CVNxbaw5Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/abeqBYe__mzZ3CVNxbaw5Q</a></p>
<p>7个快速发现 bug 神仙调试工具</p>
<p><a href="https://mp.weixin.qq.com/s/BOJv26_ul3RidiKSECQ_uA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BOJv26_ul3RidiKSECQ_uA</a></p>
<p>9个很棒的CSS边框技巧</p>
<p><a href="https://mp.weixin.qq.com/s/dbG4LzlRYNAxXzmvjEBtkw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dbG4LzlRYNAxXzmvjEBtkw</a></p>
<p>通过事例讲解如果在 Vue 创建及使用过滤器</p>
<p><a href="https://mp.weixin.qq.com/s/Zyzb5f0cNVmcCp2dxcxP-w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Zyzb5f0cNVmcCp2dxcxP-w</a></p>
<p>分分钟教会你搭建企业级的 npm 私有仓库</p>
<p><a href="https://mp.weixin.qq.com/s/otSFSAmedqihFRMUvVHL0Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/otSFSAmedqihFRMUvVHL0Q</a></p>
<p>npx， 你了解吗？</p>
<p><a href="https://mp.weixin.qq.com/s/2FkK_hANiCDhTpikAT7UxA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2FkK_hANiCDhTpikAT7UxA</a></p>
<p>5个JavaScript的字符串处理库</p>
<p><a href="https://mp.weixin.qq.com/s/1R3jRyH-y8hSVmCIVevKzw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1R3jRyH-y8hSVmCIVevKzw</a></p>
<p>JavaScript闭包的深入理解</p>
<p><a href="https://mp.weixin.qq.com/s/5FbV4U4AyJAYdCtzgHM9bg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5FbV4U4AyJAYdCtzgHM9bg</a></p>
<p><a href="https://mp.weixin.qq.com/s/A9pLVDAIn-DGLbkkBgKmFA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/A9pLVDAIn-DGLbkkBgKmFA</a></p>
<p>CSS中的背景用法大全</p>
<p><a href="https://mp.weixin.qq.com/s/P5BmWbWGjpVKQnttQXi5zQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/P5BmWbWGjpVKQnttQXi5zQ</a></p>
<p>107条Javascript的常用语句</p>
<p><a href="https://mp.weixin.qq.com/s/eB6plUyXqGc1rwX9K9ZGKg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eB6plUyXqGc1rwX9K9ZGKg</a></p>
<p>display的32种写法</p>
<p><a href="https://mp.weixin.qq.com/s/Wk_1prutXU6bvt9gYxKQ2g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Wk_1prutXU6bvt9gYxKQ2g</a></p>
<p>60个非常实用的CSS代码片段，千万要收藏好了！</p>
<p><a href="https://mp.weixin.qq.com/s/uOlu39yKWe8B076vEXVPZA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uOlu39yKWe8B076vEXVPZA</a></p>
<p>浏览器缓存机制</p>
<p><a href="https://mp.weixin.qq.com/s/o0B38SgXj-2tcpPIr-x7Bw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/o0B38SgXj-2tcpPIr-x7Bw</a></p>
<p>ES6中常用的数组方法总结</p>
<p><a href="https://mp.weixin.qq.com/s/oEwhydO00rx7YtBV1Vz0yA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oEwhydO00rx7YtBV1Vz0yA</a></p>
<p>ES6中常用的对象方法总结</p>
<p><a href="https://mp.weixin.qq.com/s/GbIDW9PnUVi6MGJWL3Y4UQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GbIDW9PnUVi6MGJWL3Y4UQ</a></p>
<p>ES6中Promise方法总结</p>
<p><a href="https://mp.weixin.qq.com/s/1cbG6D1mWbLtUmwu2OIjQA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1cbG6D1mWbLtUmwu2OIjQA</a></p>
<p>一文搞懂ES6中的模块化</p>
<p><a href="https://mp.weixin.qq.com/s/p24ZtSV8vGmdUm2lKu5ksg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/p24ZtSV8vGmdUm2lKu5ksg</a></p>
<p>写给初中级前端的高级进阶指南（万字长文，建议收藏）</p>
<p><a href="https://mp.weixin.qq.com/s/vaVd_laecfCVth0s6SCOfQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vaVd_laecfCVth0s6SCOfQ</a></p>
<p>7种你应该知道的JavaScript常见的错误</p>
<p><a href="https://mp.weixin.qq.com/s/FbMv8YH6AVHxCeBYE1NzRw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FbMv8YH6AVHxCeBYE1NzRw</a></p>
<p>JavaScript的6种继承方式及其优缺点汇总</p>
<p><a href="https://mp.weixin.qq.com/s/CaT3-IeBuLx_ELo2BKMUcg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CaT3-IeBuLx_ELo2BKMUcg</a></p>
<p>能解决 80% 需求的 10个 CSS动画库</p>
<p><a href="https://mp.weixin.qq.com/s/s4A-KI1FepWcJjmevhJOsA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/s4A-KI1FepWcJjmevhJOsA</a></p>
<p>CSS calc()函数的用法</p>
<p><a href="https://mp.weixin.qq.com/s/YgRjhS7JX_pIf0oO2mb0zg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YgRjhS7JX_pIf0oO2mb0zg</a></p>
<p>10个非常实用的JS工具函数</p>
<p><a href="https://mp.weixin.qq.com/s/FF_-Mi2ntESUCWsEo4BB1Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FF_-Mi2ntESUCWsEo4BB1Q</a></p>
<p>我和大佬之间差一个JS工具函数大全…</p>
<p><a href="https://mp.weixin.qq.com/s/AdVQxNgj5gB5Z4CmfZX9-g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AdVQxNgj5gB5Z4CmfZX9-g</a></p>
<p>通过删除“ if-else”语句来清理代码</p>
<p><a href="https://mp.weixin.qq.com/s/LOOU0LPFPQH_jv93mR9KMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LOOU0LPFPQH_jv93mR9KMw</a></p>
<p>15条值得收藏的高效JS技巧</p>
<p><a href="https://mp.weixin.qq.com/s/EXAh91-qM4TmVm6D9Wxxig" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EXAh91-qM4TmVm6D9Wxxig</a></p>
<p>JSON.stringify() 的 5 个秘密特性</p>
<p><a href="https://mp.weixin.qq.com/s/wVF2VX5BZWLP2TbDWhqVVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wVF2VX5BZWLP2TbDWhqVVA</a></p>
<p>处理 JS中 undefined 的 7 个技巧</p>
<p><a href="https://mp.weixin.qq.com/s/KZYfxG54WcPnAQhNhBvYsQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KZYfxG54WcPnAQhNhBvYsQ</a></p>
<p>JavaScript 里的奇葩知识</p>
<p><a href="https://mp.weixin.qq.com/s/rQ3bFYxQYDNes1eJWl6zwg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rQ3bFYxQYDNes1eJWl6zwg</a></p>
<p>如何优雅的实现一个九宫格抽奖</p>
<p><a href="https://mp.weixin.qq.com/s/z58BmufL_vwCvy4C6NNAjg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/z58BmufL_vwCvy4C6NNAjg</a></p>
<p>JavaScript原型与继承的秘密</p>
<p><a href="https://mp.weixin.qq.com/s/Jvu48weJiAS1IejVd-QWYQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Jvu48weJiAS1IejVd-QWYQ</a></p>
<p><a href="https://www.cnblogs.com/ayseeing/p/3990815.html" target="_blank" rel="noopener">window的cmd窗口运行git</a></p>
<p><a href="https://www.cnblogs.com/ayseeing/p/3990815.html" target="_blank" rel="noopener">https://www.cnblogs.com/ayseeing/p/3990815.html</a></p>
<p>js判断苹果机型</p>
<p><a href="https://www.cnblogs.com/heroine/p/6710848.html" target="_blank" rel="noopener">https://www.cnblogs.com/heroine/p/6710848.html</a></p>
<p>「前端编程实战 57」HTML+CSS3实现效响应盒模型特效</p>
<p><a href="https://mp.weixin.qq.com/s/8jDmr5wehAeWg1o1XJaXfQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8jDmr5wehAeWg1o1XJaXfQ</a></p>
<p>手把手教你如何实现大量图片的自适应图片页面的排列</p>
<p><a href="https://mp.weixin.qq.com/s/G95WTM2pNkjkA7Qn8BmArg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/G95WTM2pNkjkA7Qn8BmArg</a></p>
<p>13 个 npm 快速开发技巧</p>
<p><a href="https://mp.weixin.qq.com/s/tK5X23Osg197gWvE_q_AhA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tK5X23Osg197gWvE_q_AhA</a></p>
<p>15个前端必须懂的linux命令</p>
<p><a href="https://mp.weixin.qq.com/s/-b9WxWtWwQMhXZkBMySjkA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-b9WxWtWwQMhXZkBMySjkA</a></p>
<p>js函数式编程术语总结</p>
<p><a href="https://mp.weixin.qq.com/s/WA00OYXKv73s7HWrVMOV1Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WA00OYXKv73s7HWrVMOV1Q</a></p>
<p>node 写爬虫，原来这么简单</p>
<p><a href="https://mp.weixin.qq.com/s/qfcfW4JXLrRjagTlIZl6mQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qfcfW4JXLrRjagTlIZl6mQ</a></p>
<p>重磅：小程序开放“分享朋友圈”功能</p>
<p><a href="https://mp.weixin.qq.com/s/EMULfoSjCf21MVJVhFK2Eg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EMULfoSjCf21MVJVhFK2Eg</a></p>
<p>强烈推介的几个微信小程序开发小技巧，简单又实用</p>
<p><a href="https://mp.weixin.qq.com/s/CuX3p0hKRHlxDYXyJlJo3g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CuX3p0hKRHlxDYXyJlJo3g</a></p>
<p>微信支持H5跳转App、跳转小程序</p>
<p><a href="https://mp.weixin.qq.com/s/KewfM91K5To1Jj_xMWqqPw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KewfM91K5To1Jj_xMWqqPw</a></p>
<p><strong>hookEvent</strong>,原来可以这样监听组件生命周期</p>
<p><a href="https://mp.weixin.qq.com/s/KL1jB5UYXNXOOF8gau0sFA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KL1jB5UYXNXOOF8gau0sFA</a></p>
<p>18款Webpack插件，总会有你想要的！</p>
<p><a href="https://mp.weixin.qq.com/s/GGEmCQVr7ShMcP6_KsmaMQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GGEmCQVr7ShMcP6_KsmaMQ</a></p>
<p>webpack原理</p>
<p><a href="https://mp.weixin.qq.com/s/Arx6XIzPhlUaEPpH_wLMjg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Arx6XIzPhlUaEPpH_wLMjg</a></p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式原理分析</title>
    <url>/2020/07/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>*在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#39;00\d&#39;可以匹配&#39;007&#39;，但无法匹配&#39;00A&#39;；</span><br><span class="line"></span><br><span class="line">- &#39;\d\d\d&#39;可以匹配&#39;010&#39;；</span><br><span class="line"></span><br><span class="line">- &#39;\w\w&#39;可以匹配&#39;js&#39;；</span><br><span class="line"></span><br><span class="line">.可以匹配任意字符，所以：</span><br><span class="line"></span><br><span class="line">- &#39;js.&#39;可以匹配&#39;jsp&#39;、&#39;jss&#39;、&#39;js!&#39;等等。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来看一个复杂的例子：\d&#123;3&#125;\s+\d&#123;3,8&#125;。</span><br><span class="line">我们来从左到右解读一下：</span><br><span class="line">1. \d&#123;3&#125;表示匹配3个数字，例如&#39;010&#39;；</span><br><span class="line"></span><br><span class="line">2. \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配&#39; &#39;，&#39;\t\t&#39;等；</span><br><span class="line"></span><br><span class="line">3. \d&#123;3,8&#125;表示3-8个数字，例如&#39;1234567&#39;。</span><br><span class="line"></span><br><span class="line">4. \d&#123;3&#125;\-\d&#123;3,8&#125; 例如&#39;010-12345&#39; 由于&#39;-&#39;是特殊字符，在正则表达式中，要用&#39;\&#39;转义</span><br></pre></td></tr></table></figure>



<p>但是，仍然无法匹配’010 - 12345’，因为带有空格。所以我们需要更复杂的匹配方式。</p>
<p>进阶</p>
<p>要做更精确地匹配，可以用[]表示范围，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；</span><br><span class="line"></span><br><span class="line">- [0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如&#39;a100&#39;，&#39;0_Z&#39;，&#39;js2015&#39;等等；</span><br><span class="line"></span><br><span class="line">- [a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；</span><br><span class="line"></span><br><span class="line">- [a-zA-Z\_\$][0-9a-zA-Z\_\$]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</span><br><span class="line"></span><br><span class="line">A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配&#39;JavaScript&#39;、&#39;Javascript&#39;、&#39;javaScript&#39;或者&#39;javascript&#39;。</span><br><span class="line"></span><br><span class="line">^表示行的开头，^\d表示必须以数字开头。</span><br><span class="line"></span><br><span class="line">$表示行的结束，\d$表示必须以数字结束。</span><br><span class="line"></span><br><span class="line">你可能注意到了，js也可以匹配&#39;jsp&#39;，但是加上^js$就变成了整行匹配，就只能匹配&#39;js&#39;了。</span><br></pre></td></tr></table></figure>



<p>RegExp</p>
<p>JavaScript有两种方式创建一个正则表达式：</p>
<p>第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp(‘正则表达式’)创建一个RegExp对象。</p>
<p>两种写法是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re1 &#x3D; &#x2F;ABC\-001&#x2F;;</span><br><span class="line"></span><br><span class="line">var re2 &#x3D; new RegExp(&#39;ABC\\-001&#39;);</span><br><span class="line"></span><br><span class="line">re1; &#x2F;&#x2F; &#x2F;ABC\-001&#x2F;</span><br><span class="line"></span><br><span class="line">re2; &#x2F;&#x2F; &#x2F;ABC\-001&#x2F;</span><br></pre></td></tr></table></figure>



<p>注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\实际上是一个\。</p>
<p>先看看如何判断正则表达式是否匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.test(&#39;010-12345&#39;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">re.test(&#39;010-1234x&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">re.test(&#39;010 12345&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>



<p>RegExp对象的test()方法用于测试给定的字符串是否符合条件。</p>
<p>切分字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</span><br><span class="line"></span><br><span class="line">&#39;a b   c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">嗯，无法识别连续的空格，用正则表达式试试：</span><br><span class="line"></span><br><span class="line">&#39;a b   c&#39;.split(&#x2F;\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">无论多少个空格都可以正常分割。加入,试试：</span><br><span class="line"></span><br><span class="line">&#39;a,b, c  d&#39;.split(&#x2F;[\s\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br><span class="line"></span><br><span class="line">再加入;试试：</span><br><span class="line"></span><br><span class="line">&#39;a,b;; c  d&#39;.split(&#x2F;[\s\,\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure>



<p>分组</p>
<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：</p>
<p>^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.exec(&#39;010-12345&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]</span><br><span class="line"></span><br><span class="line">re.exec(&#39;010 12345&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>



<p>如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。</p>
<p>exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p>
<p>exec()方法在匹配失败时返回null。</p>
<p>提取子串非常有用。来看一个更凶残的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.exec(&#39;19:05:30&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;19:05:30&#39;, &#39;19&#39;, &#39;05&#39;, &#39;30&#39;]</span><br></pre></td></tr></table></figure>



<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$&#x2F;;</span><br></pre></td></tr></table></figure>



<p>对于’2-30’，’4-31’这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<p>贪婪匹配</p>
<p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d+)(0*)$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.exec(&#39;102300&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;102300&#39;, &#39;102300&#39;, &#39;&#39;]</span><br></pre></td></tr></table></figure>



<p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。</p>
<p>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d+?)(0*)$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.exec(&#39;102300&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;102300&#39;, &#39;1023&#39;, &#39;00&#39;]</span><br></pre></td></tr></table></figure>



<p>全局搜索</p>
<p>JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var r1 &#x3D; &#x2F;test&#x2F;g;</span><br><span class="line"></span><br><span class="line">&#x2F;等价于:var r2 &#x3D; new RegExp(&#39;test&#39;, &#39;g&#39;);</span><br></pre></td></tr></table></figure>



<p>全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;JavaScript, VBScript, JScript and ECMAScript&#39;;</span><br><span class="line"></span><br><span class="line">var re&#x3D;&#x2F;[a-zA-Z]+Script&#x2F;g;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用全局匹配:re.exec(s); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;JavaScript&#39;]</span><br><span class="line"></span><br><span class="line">re.lastIndex; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">re.exec(s);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; [&#39;VBScript&#39;]</span><br><span class="line"></span><br><span class="line">re.lastIndex; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 20</span><br><span class="line"></span><br><span class="line">re.exec(s); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;JScript&#39;]</span><br><span class="line"></span><br><span class="line">re.lastIndex; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 29</span><br><span class="line"></span><br><span class="line">re.exec(s); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;ECMAScript&#39;]</span><br><span class="line"></span><br><span class="line">re.lastIndex;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 44</span><br><span class="line"></span><br><span class="line">re.exec(s); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null，直到结束仍没有匹配到</span><br><span class="line"></span><br><span class="line">全局匹配类似搜索，因此不能使用&#x2F;^...$&#x2F;，那样只会最多匹配一次。</span><br><span class="line"></span><br><span class="line">正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。</span><br></pre></td></tr></table></figure>



<p>小结</p>
<p>正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>环境搭建从无到有</title>
    <url>/2020/08/18/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/</url>
    <content><![CDATA[<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="nodeJs"><a href="#nodeJs" class="headerlink" title="nodeJs"></a>nodeJs</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p><a href="https://git-scm.com/" target="_blank" rel="noopener">官网地址</a></p>
<a id="more"></a>

<h3 id="GitExtensions"><a href="#GitExtensions" class="headerlink" title="GitExtensions"></a>GitExtensions</h3><p><a href="https://sourceforge.net/projects/gitextensions/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="Tortoisegit-小乌龟"><a href="#Tortoisegit-小乌龟" class="headerlink" title="Tortoisegit(小乌龟)"></a>Tortoisegit(小乌龟)</h3><p><a href="https://tortoisegit.org/download/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="KDiff3（比较工具一）"><a href="#KDiff3（比较工具一）" class="headerlink" title="KDiff3（比较工具一）"></a>KDiff3（比较工具一）</h3><p><a href="https://sourceforge.net/projects/kdiff3/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="beyond-compare（比较工具二）"><a href="#beyond-compare（比较工具二）" class="headerlink" title="beyond compare（比较工具二）"></a>beyond compare（比较工具二）</h3><p><a href="http://www.scootersoftware.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="vs和插件"><a href="#vs和插件" class="headerlink" title="vs和插件"></a>vs和插件</h3><p><a href="https://marketplace.visualstudio.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="vsCode"><a href="#vsCode" class="headerlink" title="vsCode"></a>vsCode</h3><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="微信开发者工具"><a href="#微信开发者工具" class="headerlink" title="微信开发者工具"></a>微信开发者工具</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h3><p><a href="https://www.google.cn/chrome/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="Snipaste截图工具"><a href="#Snipaste截图工具" class="headerlink" title="Snipaste截图工具"></a>Snipaste截图工具</h3><p><a href="https://www.snipaste.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="向日葵远程连接工具"><a href="#向日葵远程连接工具" class="headerlink" title="向日葵远程连接工具"></a>向日葵远程连接工具</h3><p><a href="https://sunlogin.oray.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="同程电脑管家"><a href="#同程电脑管家" class="headerlink" title="同程电脑管家"></a>同程电脑管家</h3><p><a href="http://guanjia.tcent.cn/" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="前端测试工具"><a href="#前端测试工具" class="headerlink" title="前端测试工具"></a>前端测试工具</h2><h3 id="charles-抓包"><a href="#charles-抓包" class="headerlink" title="charles(抓包)"></a>charles(抓包)</h3><p><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="totalcontrol（控制手机）"><a href="#totalcontrol（控制手机）" class="headerlink" title="totalcontrol（控制手机）"></a>totalcontrol（控制手机）</h3><p><a href="http://tc.sigma-rt.com.cn/index.php" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="书写工具"><a href="#书写工具" class="headerlink" title="书写工具"></a>书写工具</h2><h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h3><p><a href="https://www.typora.io/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="notepad"><a href="#notepad" class="headerlink" title="notepad"></a>notepad</h3><p><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="聊天工具"><a href="#聊天工具" class="headerlink" title="聊天工具"></a>聊天工具</h2><h3 id="WeChat"><a href="#WeChat" class="headerlink" title="WeChat"></a>WeChat</h3><p><a href="https://pc.weixin.qq.com/?t=win_weixin" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="DingTalk"><a href="#DingTalk" class="headerlink" title="DingTalk"></a>DingTalk</h3><p><a href="https://www.dingtalk.com/" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="录屏工具"><a href="#录屏工具" class="headerlink" title="录屏工具"></a>录屏工具</h2><h3 id="GifCam"><a href="#GifCam" class="headerlink" title="GifCam"></a>GifCam</h3><p><a href="http://blog.bahraniapps.com/gifcam/#download" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="ScreenToGif"><a href="#ScreenToGif" class="headerlink" title="ScreenToGif"></a>ScreenToGif</h3><p><a href="http://www.screentogif.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="快压"><a href="#快压" class="headerlink" title="快压"></a>快压</h3><p><a href="http://www.kuaizip.com/" target="_blank" rel="noopener">官网地址</a></p>
]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>软件官网</tag>
      </tags>
  </entry>
  <entry>
    <title>配置本地iis</title>
    <url>/2020/08/18/%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0iis/</url>
    <content><![CDATA[<h3 id="开启iis"><a href="#开启iis" class="headerlink" title="开启iis"></a>开启iis</h3><p>控制面板-程序-启用或者关闭windows功能</p>
<a id="more"></a>

<p><img src="https://i.loli.net/2020/08/18/ubYlvzxaKsMFrNn.png" alt="iis.png"></p>
<p>新建应用程序</p>
<p><img src="https://i.loli.net/2020/08/18/nT59tOQ8RxPYlC4.png" alt="应用程序.png"></p>
<p>生成解决方案时，需要新增Nuget包才能成功</p>
<p>工具-Nuget包管理器-程序包管理器设置-程序包源-新增-更新-确定-生成解决方案-编译成功</p>
]]></content>
      <categories>
        <category>iis</category>
      </categories>
      <tags>
        <tag>iis</tag>
        <tag>localhost</tag>
      </tags>
  </entry>
  <entry>
    <title>算法排序</title>
    <url>/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>简单递归</p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/01.png" alt="01"></p>
<a id="more"></a>

<p>冒泡排序</p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/02.png" alt="02"></p>
<p>插入排序</p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/03.png" alt="03"></p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/04.png" alt="04"></p>
<p>快速排序（<a href="https://www.bilibili.com/video/BV1b441117Rn/?spm_id_from=trigger_reload" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1b441117Rn/?spm_id_from=trigger_reload</a>）</p>
<p>简单版</p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/05.png" alt="05"></p>
<p>精简版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const quickSort &#x3D; function (arr) &#123;</span><br><span class="line">    if(arr.length &lt; 2) return arr;</span><br><span class="line">    &#x2F;&#x2F; 随机选择0～arr.length之间选一个基准值</span><br><span class="line">    const pivot &#x3D; Math.floor(Math.random() * arr.length)</span><br><span class="line">    &#x2F;&#x2F; 声明两个数组，分别用于存放比基准值小的数据和比基准值大的数据</span><br><span class="line">    let minArr &#x3D; [];</span><br><span class="line">    let maxArr &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 根据基准值填充数组</span><br><span class="line">    for(let i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 大于基准值就放maxArr里</span><br><span class="line">        if(arr[i] &gt;&#x3D; arr[pivot] &amp;&amp; i !&#x3D;&#x3D; pivot)&#123;</span><br><span class="line">            maxArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 小于基准值就放minArr里</span><br><span class="line">        if(arr[i] &lt; arr[pivot] &amp;&amp; i !&#x3D;&#x3D; pivot)&#123;</span><br><span class="line">            minArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 分别对基准值划分出来的数组递归调用快速排序，然后合并数组</span><br><span class="line">    return [...quickSort(minArr), arr[pivot], ...quickSort(maxArr)];</span><br><span class="line">&#125;</span><br><span class="line">测试</span><br><span class="line">const dataArr &#x3D; [3,5,8,1,2,9,4,7,6];</span><br><span class="line">console.log(quickSort(dataArr))</span><br></pre></td></tr></table></figure>

<p>快速排序优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @param arr 需要进行三路快排的数组</span><br><span class="line"> * @param L 数组的起始位置</span><br><span class="line"> * @param R 数组的末尾位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">function partition(arr, L, R) &#123;</span><br><span class="line">  if(L&gt;&#x3D;R)return;</span><br><span class="line">  let left&#x3D;L,right&#x3D;R;</span><br><span class="line">  let pivot&#x3D;arr[left]</span><br><span class="line">  while(left&lt;right)&#123;</span><br><span class="line">    while(left&lt;right&amp;&amp;arr[right]&gt;&#x3D;pivot)&#123;</span><br><span class="line">      right--</span><br><span class="line">    &#125;</span><br><span class="line">    if(left&lt;right)&#123;</span><br><span class="line">      arr[left]&#x3D;arr[right]</span><br><span class="line">    &#125;</span><br><span class="line">    while (left &lt; right &amp;&amp; arr[left] &lt;&#x3D; pivot) &#123;</span><br><span class="line">      left++</span><br><span class="line">    &#125;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">      arr[right] &#x3D; arr[left]</span><br><span class="line">    &#125;</span><br><span class="line">    if(left&gt;&#x3D;right)&#123;</span><br><span class="line">      arr[left]&#x3D;pivot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  partition(arr, L, right-1)</span><br><span class="line">  partition(arr, right+1, R)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">const dataArr &#x3D; [3, 5, 8, 1, 2, 9, 4, 7, 610, 0, -1];</span><br><span class="line">console.log(partition(dataArr, 0, dataArr.length - 1));</span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line">const dataArr &#x3D; [3,5,8,1,2,9,4,7,6];</span><br><span class="line">console.log(partition(dataArr,0,dataArr.length - 1));</span><br></pre></td></tr></table></figure>



<p>给对象按照某一个属性从小到大排序（对象排序）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var compare &#x3D; function (prop) &#123;</span><br><span class="line">  return function (obj1, obj2) &#123;</span><br><span class="line">      var val1 &#x3D; obj1[prop];</span><br><span class="line">      var val2 &#x3D; obj2[prop];</span><br><span class="line">      if (!isNaN(Number(val1)) &amp;&amp; !isNaN(Number(val2))) &#123;</span><br><span class="line">          val1 &#x3D; Number(val1);</span><br><span class="line">          val2 &#x3D; Number(val2);</span><br><span class="line">      &#125;</span><br><span class="line">      if (val1 &lt; val2) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">      &#125; else if (val1 &gt; val2) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [&#123; name: &quot;zlw&quot;, age: 25 &#125;, &#123; name: &quot;wlz&quot;, age: 30 &#125;, &#123; name: &quot;wlz&quot;, age: 27 &#125;, &#123; name: &quot;wlz&quot;, age: 29 &#125;];</span><br><span class="line">console.log(arr.sort(compare(&quot;age&quot;)));</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
