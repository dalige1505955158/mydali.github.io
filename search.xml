<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Androidchrome远程调试</title>
    <url>/2020/09/04/Androidchrome%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><strong>一：背景</strong><br>通常情况我们调试移动端页面最常用的方法就是：切换pc端浏览器的userAgent来模拟手机或其他移动设备调试页面 然后用手机打开要调试的页面 刷新页面查看调试结果</p>
<p>但是这就存在两个问题 在pc浏览器模拟手机可能造成调试不准 用手机直接调试 又多一步刷新 那怎么能达到在pc端修改代码 在手机上直接看到修改结果这样的所见即所得的效果呢 chrome做到了</p>
<a id="more"></a>

<p><strong>二.功能</strong></p>
<p>我们先看下最终想要达到的效果</p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130923544443367.jpg" alt="img"></p>
<p>上图的左边是pc端的chrome浏览器，右边是手机上的chrome 然后可以看到当鼠标移动到某个div上时 手机上的这个区域高亮显示 跟pc上调试某段代码效果一样 你可以修改代码 并直接在手机上反馈修改结果</p>
<p><strong>三，准备</strong></p>
<p>为了完成这一亮骚的移动调试功能我们需要以下准备工作</p>
<p>1.pc端安装最新的chrome<br>2.手机端安装最新的chrome (Android机)<br>3.USB连接线</p>
<p>（感觉是不是too simple）</p>
<p>Tip:之前的的chrome如果要实现这种调试需要安装一个<a href="https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage/related" target="_blank" rel="noopener">ADB插件</a>（需要FQ） 但是最新的chrome已经直接支持对Android的识别 所以也不用再在chrome上安装ADB插件了 但需要下载最新的chrome</p>
<p><strong>四：步骤</strong><br>下来我们逐步完成<br>1.假设你已经在电脑上下载了最新的chrome 也在手机上下载了最新的chrome</p>
<p>2.USB设置 在你的手机里打开”设置”-&gt;”开发人员工具”-&gt;”USB调试” 打开USB调试。 因为Android手机型号众多 很多人找不到”USB调试这个选项在哪” 而且大多数手机”开发者选项”默认是影藏的，你需要看下自己的手机说明然后将手机调到”开发者模式” 就可以找到 “USB调试了” </p>
<p><img src="https://img-blog.csdnimg.cn/2019052811513234.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppb2hvX2NoZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>3.假设你已经将手机设置为”USB调试”打开的状态 将手机连接到电脑 手机会弹出是否链接 点击确定</p>
<p>4.打开电脑的chrome 在地址栏输入 chrome://inspect 选中 Discover USB devices 可以检测到你的设备 可以看到监测到我的设备是M351 魅族X3 </p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130927258353280.png" alt="img"></p>
<p>5.打开手机上的chrome</p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130927507564327.png" alt="img"></p>
<p>上图可以看到手机上chrome打开的页面 此时我手机上的chrome没打开任何网页 历史记录也么有 如果我们在手机 chrome浏览器输入<a href="http://www.cnblogs.com" target="_blank" rel="noopener">www.cnblogs.com</a> 可以看到下图 ，也可以通过 inspect里chrome后面那个输入框直接打开某个链接</p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130928474446813.jpg" alt="img"></p>
<p>6.点击inspect 如下图 就看到了文章开始一样的效果 此时就是可以审查手机页面上的元素了</p>
<p><img src="https://images0.cnblogs.com/blog/494920/201411/130929083038684.jpg" alt="img"></p>
<p>7.可以点击弹出的审查元素框右上角的方形小图标切换到视图模式 这时会把你手机打开的页面拉到pc上显示<br><img src="https://images0.cnblogs.com/blog/494920/201411/130929414447110.png" alt="img"></p>
<p><strong>五：总结</strong></p>
<p>基本上已经愉快的完成了 总结下整个流程 ：pc端和Android手机端都下载最新的chrome ，在手机设置里将”USB调试”打开 链接到电脑 打开电脑chrome 输入chrome://inspect 打开手机chrome输入你想调试的页面 点击inspect 开始调试 ,整个调试的过程都是要FQ的哦 。</p>
<p>PS:如果inspect出空白窗口，有可能是长城防火城的原因，试下用VPN</p>
<p><img src="https://images0.cnblogs.com/blog/692371/201411/131813137254471.jpg" alt="img"></p>
<p>转载于：<a href="https://www.cnblogs.com/alantao/p/5220392.html" target="_blank" rel="noopener">https://www.cnblogs.com/alantao/p/5220392.html</a></p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>34条我能告诉你的Vue之实操篇</title>
    <url>/2021/01/21/34%E6%9D%A1%E6%88%91%E8%83%BD%E5%91%8A%E8%AF%89%E4%BD%A0%E7%9A%84Vue%E4%B9%8B%E5%AE%9E%E6%93%8D%E7%AF%87/</url>
    <content><![CDATA[<p>参考链接 <a href="https://mp.weixin.qq.com/s/MchD5YiXvuIjhvkj86hTlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MchD5YiXvuIjhvkj86hTlg</a></p>
<h2 id="组件通信方式"><a href="#组件通信方式" class="headerlink" title="组件通信方式"></a>组件通信方式</h2><h3 id="props-on-emit"><a href="#props-on-emit" class="headerlink" title="props/@on+$emit"></a>props/@on+$emit</h3><p>通过 <code>props</code> 可以把父组件的消息传递给子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; parent.vue    </span><br><span class="line">&lt;child :title&#x3D;&quot;title&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#39;&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而通过 <code>@on+$emit</code> 组合可以实现子组件给父组件传递信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;child @changeTitle&#x3D;&quot;changeTitle&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">this.$emit(&#39;changeTitle&#39;, &#39;bubuzou.com&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="attrs和listeners"><a href="#attrs和listeners" class="headerlink" title="attrs和listeners"></a>attrs和listeners</h3><p><code>Vue_2.4</code> 中新增的 <code>$attrs/$listeners</code> 可以进行跨级的组件通信。<code>$attrs</code> 包含了父级作用域中不作为 <code>prop</code> 的属性绑定（<code>class</code> 和 <code>style</code> 除外），好像听起来有些不好理解？没事，看下代码就知道是什么意思了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件 index.vue</span><br><span class="line">&lt;list class&#x3D;&quot;list-box&quot; title&#x3D;&quot;标题&quot; desc&#x3D;&quot;描述&quot; :list&#x3D;&quot;list&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">&#x2F;&#x2F; 子组件 list.vue</span><br><span class="line">props: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    console.log(this.$attrs)  &#x2F;&#x2F; &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的父组件 <code>index.vue</code> 中我们给子组件 <code>list.vue</code> 传递了4个参数，但是在子组件内部 <code>props</code> 里只定义了一个 <code>list</code>，那么此时 <code>this.$attrs</code> 的值是什么呢？首先要去除 <code>props</code> 中已经绑定了的，然后再去除 <code>class</code> 和 <code>style</code>，最后剩下 <code>title</code> 和 <code>desc</code> 结果和打印的是一致的。基于上面代码的基础上，我们在给 子组件<code>list.vue</code> 中加一个子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 孙子组件 detail.vue</span><br><span class="line">&lt;detail v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;detial&gt;</span><br><span class="line">&#x2F;&#x2F; 不定义props，直接打印 $attrs</span><br><span class="line">mounted() &#123;</span><br><span class="line">    console.log(this.$attrs)  &#x2F;&#x2F; &#123;title: &quot;标题&quot;, desc: &quot;描述&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子组件中我们定义了一个 <code>v-bind=&quot;$attrs&quot;</code> 可以把父级传过来的参数，去除 <code>props</code>、<code>class</code> 和 <code>style</code> 之后剩下的继续往下级传递，这样就实现了跨级的组件通信。</p>
<p><code>$attrs</code> 是可以进行跨级的参数传递，实现父到子的通信；同样的，通过 <code>$listeners</code> 用类似的操作方式可以进行跨级的事件传递，实现子到父的通信。<code>$listeners</code> 包含了父作用域中不含 <code>.native</code> 修饰的 <code>v-on</code> 事件监听器，通过 <code>v-on=&quot;$listeners&quot;</code> 传递到子组件内部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;list @change&#x3D;&quot;change&quot; @update.native&#x3D;&quot;update&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">&#x2F;&#x2F; 子组件 list.vue</span><br><span class="line">&lt;detail v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;detail&gt;</span><br><span class="line">&#x2F;&#x2F; 孙子组件 detail.vue</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.$listeners.change()</span><br><span class="line">    this.$listeners.update() &#x2F;&#x2F; TypeError: this.$listeners.update is not a function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="provide-inject组合拳"><a href="#provide-inject组合拳" class="headerlink" title="provide/inject组合拳"></a>provide/inject组合拳</h3><p><code>provide/inject</code> 组合以允许一个祖先组件向其所有子孙后代注入一个依赖，可以注入属性和方法，从而实现跨级父子组件通信。在开发高阶组件和组件库的时候尤其好用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件 index.vue</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        title: &#39;bubuzou.com&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        detail: &#123;</span><br><span class="line">            title: this.title,</span><br><span class="line">            change: (val) &#x3D;&gt; &#123;</span><br><span class="line">                console.log( val )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 孙子组件 detail.vue</span><br><span class="line">inject: [&#39;detail&#39;],</span><br><span class="line">mounted() &#123;</span><br><span class="line">    console.log(this.detail.title)  &#x2F;&#x2F; bubuzou.com</span><br><span class="line">    this.detail.title &#x3D; &#39;hello world&#39;  &#x2F;&#x2F; 虽然值被改变了，但是父组件中 title 并不会重新渲染</span><br><span class="line">    this.detail.change(&#39;改变后的值&#39;)  &#x2F;&#x2F; 执行这句后将打印：改变后的值 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>provide</code> 和 <code>inject</code> 的绑定对于原始类型来说并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。这也就是为什么在孙子组件中改变了 <code>title</code>，但是父组件不会重新渲染的原因。</p>
</blockquote>
<h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>以上三种方式都是只能从父到子方向或者子到父方向进行组件的通信，而我就比较牛逼了😀，我还能进行兄弟组件之间的通信，甚至任意2个组件间通信。利用 <code>Vue</code> 实例实现一个 <code>EventBus</code> 进行信息的发布和订阅，可以实现在任意2个组件之间通信。有两种写法都可以初始化一个 <code>eventBus</code> 对象：</p>
<ol>
<li><p>通过导出一个 <code>Vue</code> 实例，然后再需要的地方引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; eventBus.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">export const EventBus &#x3D; new Vue()</span><br></pre></td></tr></table></figure>

<p>使用 <code>EventBus</code> 订阅和发布消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;EventBus&#125; from &#39;..&#x2F;utils&#x2F;eventBus.js&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 订阅处</span><br><span class="line">EventBus.$on(&#39;update&#39;, val &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发布处</span><br><span class="line">EventBus.$emit(&#39;update&#39;, &#39;更新信息&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>main.js</code> 中初始化一个全局的事件总线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">Vue.prototype.$eventBus &#x3D; new Vue()</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要订阅的地方</span><br><span class="line">this.$eventBus.$on(&#39;update&#39;, val &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 需要发布信息的地方</span><br><span class="line">this.$eventBus.$emit(&#39;update&#39;, &#39;更新信息&#39;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果想要移除事件监听，可以这样来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$eventBus.$off(&#39;update&#39;, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>上面介绍了两种写法，推荐使用第二种全局定义的方式，可以避免在多处导入 <code>EventBus</code> 对象。这种组件通信方式只要订阅和发布的顺序得当，且事件名称保持唯一性，理论上可以在任何 2 个组件之间进行通信，相当的强大。但是方法虽好，可不要滥用，建议只用于简单、少量业务的项目中，如果在一个大型繁杂的项目中无休止的使用该方法，将会导致项目难以维护。</p>
<h3 id="Vuex进行全局的数据管理"><a href="#Vuex进行全局的数据管理" class="headerlink" title="Vuex进行全局的数据管理"></a>Vuex进行全局的数据管理</h3><p><code>Vuex</code> 是一个专门服务于 <code>Vue.js</code> 应用的状态管理工具。适用于中大型应用。<code>Vuex</code> 中有一些专有概念需要先了解下：</p>
<ul>
<li><code>State</code>：用于数据的存储，是 <code>store</code> 中的唯一数据源；</li>
<li><code>Getter</code>：类似于计算属性，就是对 <code>State</code> 中的数据进行二次的处理，比如筛选和对多个数据进行求值等；</li>
<li><code>Mutation</code>：类似事件，是改变 <code>Store</code> 中数据的唯一途径，只能进行同步操作；</li>
<li><code>Action</code>：类似 <code>Mutation</code>，通过提交 <code>Mutation</code> 来改变数据，而不直接操作 <code>State</code>，可以进行异步操作；</li>
<li><code>Module</code>：当业务复杂的时候，可以把 <code>store</code> 分成多个模块，便于维护；</li>
</ul>
<p>对于这几个概念有各种对应的 <code>map</code> 辅助函数用来简化操作，比如 <code>mapState</code>，如下三种写法其实是一个意思，都是为了从 <code>state</code> 中获取数据，并且通过计算属性返回给组件使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">        return this.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        count: state &#x3D;&gt; state.count</span><br><span class="line">    &#125;),</span><br><span class="line">    ...mapState([&#39;count&#39;]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>又比如 <code>mapMutations</code>， 以下两种函数的定义方式要实现的功能是一样的，都是要提交一个 <code>mutation</code> 去改变 <code>state</code> 中的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.$store.commit(&#39;increment&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapMutations([&#39;increment&#39;]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就用一个极简的例子来展示 <code>Vuex</code> 中任意2个组件间的状态管理。1、 新建 <code>store.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">    </span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment(state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement(state) &#123;</span><br><span class="line">            state.count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2、 创建一个带 <code>store</code> 的 <code>Vue</code> 实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;utils&#x2F;store&#39;</span><br><span class="line">    </span><br><span class="line">new Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>3、 任意组件 <code>A</code> 实现点击递增</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;p @click&#x3D;&quot;increment&quot;&gt;click to increment：&#123;&#123;count&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;mapState, mapMutations&#125; from &#39;vuex&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ...mapState([&#39;count&#39;])</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...mapMutations([&#39;increment&#39;])</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>4、 任意组件 <code>B</code> 实现点击递减</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;p @click&#x3D;&quot;decrement&quot;&gt;click to decrement：&#123;&#123;count&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;mapState, mapMutations&#125; from &#39;vuex&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ...mapState([&#39;count&#39;])</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...mapMutations([&#39;decrement&#39;])</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>以上只是用最简单的 <code>vuex</code> 配置去实现组件通信，当然真实项目中的配置肯定会更复杂，比如需要对 <code>State</code> 数据进行二次筛选会用到 <code>Getter</code>，然后如果需要异步的提交那么需要使用<code>Action</code>，再比如如果模块很多，可以将 <code>store</code> 分模块进行状态管理。对于 <code>Vuex</code> 更多复杂的操作还是建议去看Vuex 官方文档，然后多写例子。</p>
<h3 id="Vue-observable实现mini-vuex"><a href="#Vue-observable实现mini-vuex" class="headerlink" title="Vue.observable实现mini vuex"></a>Vue.observable实现mini vuex</h3><p>这是一个 <code>Vue2.6</code> 中新增的 <code>API</code>，用来让一个对象可以响应。我们可以利用这个特点来实现一个小型的状态管理器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line"> </span><br><span class="line">export const state &#x3D; Vue.observable(&#123;</span><br><span class="line">    count: 0,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const mutations &#x3D; &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        state.count++</span><br><span class="line">    &#125;</span><br><span class="line">    decrement() &#123;</span><br><span class="line">        state.count--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;p&gt; count &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; state &#125; from &#39;..&#x2F;store&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count() &#123;</span><br><span class="line">            return state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">import  &#123; mutations &#125; from &#39;..&#x2F;store&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">            mutations.increment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="refs-children-parent-root"><a href="#refs-children-parent-root" class="headerlink" title="refs/children/parent/root"></a>refs/children/parent/root</h3><p>通过给子组件定义 <code>ref</code> 属性可以使用 <code>$refs</code> 来直接操作子组件的方法和属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child ref&#x3D;&quot;list&quot;&gt;&lt;&#x2F;child&gt;</span><br></pre></td></tr></table></figure>

<p>比如子组件有一个 <code>getList</code> 方法，可以通过如下方式进行调用，实现父到子的通信：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$refs.list.getList()</span><br></pre></td></tr></table></figure>

<p>除了 <code>$refs</code> 外，其他3个都是自 <code>Vue</code> 实例创建后就会自动包含的属性，使用和上面的类似</p>
<h2 id="8类可以掌握的修饰符"><a href="#8类可以掌握的修饰符" class="headerlink" title="8类可以掌握的修饰符"></a>8类可以掌握的修饰符</h2><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><p>表单类的修饰符都是和 <code>v-model</code> 搭配使用的，比如：<code>v-model.lazy</code>、<code>v-model.trim</code> 以及 <code>v-model.number</code> 等。</p>
<ul>
<li><p><code>.lazy</code>：对表单输入的结果进行延迟响应，通常和 <code>v-model</code> 搭配使用。正常情况下在 <code>input</code> 里输入内容会在 <code>p</code> 标签里实时的展示出来，但是加上 <code>.lazy</code> 后则需要在输入框失去焦点的时候才触发响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; v-model.lazy&#x3D;&quot;name&quot; &#x2F;&gt;</span><br><span class="line">&lt;p&gt; name &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.trim</code>：过滤输入内容的首尾空格，这个和直接拿到字符串然后通过 <code>str.trim()</code> 去除字符串首尾空格是一个意思。</p>
</li>
<li><p><code>.number</code>：如果输入的第一个字符是数字，那就只能输入数字，否则他输入的就是普通字符串。</p>
</li>
</ul>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p><code>Vue</code> 的事件修饰符是专门为 <code>v-on</code> 设计的，可以这样使用：<code>@click.stop=&quot;handleClick&quot;</code>，还能串联使用：<code>@click.stop.prevent=&quot;handleClick&quot;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div @click&#x3D;&quot;doDiv&quot;&gt;</span><br><span class="line">    click div</span><br><span class="line">    &lt;p @click&#x3D;&quot;doP&quot;&gt;click p&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.stop</code>：阻止事件冒泡，和原生 <code>event.stopPropagation()</code> 是一样的效果。如上代码，当点击 <code>p</code> 标签的时候，<code>div</code> 上的点击事件也会触发，加上 <code>.stop</code> 后事件就不会往父级传递，那父级的事件就不会触发了。</p>
</li>
<li><p><code>.prevent</code>：阻止默认事件，和原生的 <code>event.preventDefault()</code> 是一样的效果。比如一个带有 <code>href</code> 的链接上添加了点击事件，那么事件触发的时候也会触发链接的跳转，但是加上 <code>.prevent</code> 后就不会触发链接跳转了。</p>
</li>
<li><p><code>.capture</code>：默认的事件流是：捕获阶段-目标阶段-冒泡阶段，即事件从最具体目标元素开始触发，然后往上冒泡。而加上 <code>.capture</code> 后则是反过来，外层元素先触发事件，然后往深层传递。</p>
</li>
<li><p><code>.self</code>：只触发自身的事件，不会传递到父级，和 <code>.stop</code> 的作用有点类似。</p>
</li>
<li><p><code>.once</code>：只会触发一次该事件。</p>
</li>
<li><p><code>.passive</code>：当页面滚动的时候就会一直触发 <code>onScroll</code> 事件，这个其实是存在性能问题的，尤其是在移动端，当给他加上 <code>.passive</code> 后触发的就不会那么频繁了。</p>
</li>
<li><p><code>.native</code>：现在在组件上使用 <code>v-on</code> 只会监听自定义事件 (组件用 <code>$emit</code> 触发的事件)。如果要监听根元素的原生事件，可以使用 <code>.native</code> 修饰符，比如如下的 <code>el-input</code>，如果不加 <code>.native</code> 当回车的时候就不会触发 <code>search</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;name&quot; @keyup.enter.native&#x3D;&quot;search&quot;&gt;&lt;&#x2F;el-input&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>串联使用事件修饰符的时候，需要注意其顺序，同样2个修饰符进行串联使用，顺序不同，结果大不一样。<code>@click.prevent.self</code> 会阻止所有的点击事件，而 <code>@click.self.prevent</code> 只会阻止对自身元素的点击。</p>
</blockquote>
<h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul>
<li><code>.left</code>：鼠标左键点击；</li>
<li><code>.right</code>：鼠标右键点击；</li>
<li><code>.middle</code>：鼠标中键点击；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @click.right&#x3D;&quot;shout(1)&quot;&gt;ok&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="键盘按键修饰符"><a href="#键盘按键修饰符" class="headerlink" title="键盘按键修饰符"></a>键盘按键修饰符</h3><p><code>Vue</code> 提供了一些常用的按键码：</p>
<p>//普通键</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<p>//系统修饰键</p>
<ul>
<li>ctrl</li>
<li>alt</li>
<li>meta</li>
<li>shift</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; @keyup.enter&#x3D;&quot;shout(4)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>也可以通过全局 config.keyCodes 对象自定义按键修饰符别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以使用 &#96;v-on:keyup.f1&#96;</span><br><span class="line">Vue.config.keyCodes.f1 &#x3D; 112</span><br></pre></td></tr></table></figure>

<p>我们从上面看到，键分成了普通常用的键和系统修饰键，区别是什么呢？<br>当我们写如下代码的时候,我们会发现如果<strong>仅仅</strong>使用系统修饰键是无法触发keyup事件的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; @keyup.ctrl&#x3D;&quot;shout(4)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>那该如何呢？我们需要将系统修饰键和其他键码链接起来使用，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; @keyup.ctrl.67&#x3D;&quot;shout(4)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这样当我们同时按下ctrl+c时，就会触发keyup事件。<br>另，如果是鼠标事件，那就可以单独使用系统修饰符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @mouseover.ctrl&#x3D;&quot;shout(1)&quot;&gt;ok&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button @mousedown.ctrl&#x3D;&quot;shout(1)&quot;&gt;ok&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button @click.ctrl.67&#x3D;&quot;shout(1)&quot;&gt;ok&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>大概是什么意思呢，就是你不能<strong>单手指使用系统修饰键的修饰符</strong>（最少两个手指，可以多个）。你可以一个手指按住系统修饰键一个手指按住另外一个键来实现键盘事件。也可以用一个手指按住系统修饰键，另一只手按住鼠标来实现鼠标事件。</p>
<p>另外，你也可以直接将 <code>KeyboardEvent.key</code> 暴露的任意有效按键名转换为 <code>kebab-case</code> 来作为修饰符，比如可以通过如下的代码来查看具体按键的键名是什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input @keyup&#x3D;&quot;onKeyUp&quot;&gt;</span><br><span class="line">onKeyUp(event) &#123;</span><br><span class="line">    console.log(event.key)  &#x2F;&#x2F; 比如键盘的方向键向下就是 ArrowDown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="exact修饰符"><a href="#exact修饰符" class="headerlink" title=".exact修饰符"></a>.exact修饰符</h3><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>



<h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h3><p><code>.sync</code> 修饰符常被用于子组件更新父组件数据。直接看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父亲组件</span><br><span class="line">&lt;comp :myMessage&#x3D;&quot;bar&quot; @update:myMessage&#x3D;&quot;func&quot;&gt;&lt;&#x2F;comp&gt;</span><br><span class="line">&#x2F;&#x2F;js</span><br><span class="line">data()&#123;</span><br><span class="line">	return&#123;</span><br><span class="line">		bar:&quot;mode值&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">func(e)&#123;</span><br><span class="line"> this.bar &#x3D; e;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子组件js</span><br><span class="line">func2()&#123;</span><br><span class="line">  this.$emit(&#39;update:myMessage&#39;,params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个.sync修饰符就是简化了上面的步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;comp :myMessage.sync&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;comp&gt; </span><br><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">this.$emit(&#39;update:myMessage&#39;,params);</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li>使用sync的时候，子组件传递的事件名必须为update:value，其中value必须与子组件中props中声明的名称完全一致(如上例中的myMessage，不能使用my-message)</li>
<li>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</li>
<li>将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</li>
</ol>
</blockquote>
<p>如果需要设置多个 <code>prop</code>，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child :name.sync&#x3D;&quot;name&quot; :age.sync&#x3D;&quot;age&quot; :sex.sync&#x3D;&quot;sex&quot;&gt;&lt;&#x2F;child&gt;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>v-bind.sync</code> 简写成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child v-bind.sync&#x3D;&quot;person&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">person: &#123;</span><br><span class="line">    name: &#39;bubuzou&#39;,</span><br><span class="line">    age: 21,</span><br><span class="line">    sex: &#39;male&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Vue</code> 内部会自行进行解析把 <code>person</code> 对象里的每个属性都作为独立的 <code>prop</code> 传递进去，各自添加用于更新的 <code>v-on</code> 监听器。而从子组件进行更新的时候还是保持不变，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$emit(&#39;update:name&#39;, &#39;hello&#39;)</span><br></pre></td></tr></table></figure>



<h3 id="prop"><a href="#prop" class="headerlink" title=".prop"></a>.prop</h3><p>要学习这个修饰符，我们首先要搞懂两个东西的区别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Property：节点对象在内存中存储的属性，可以访问和设置。</span><br><span class="line">Attribute：节点对象的其中一个属性( property )，值是一个对象。</span><br><span class="line">可以通过点访问法 document.getElementById(&#39;xx&#39;).attributes 或者 document.getElementById(&#39;xx&#39;).getAttributes(&#39;xx&#39;) 读取，通过document.getElementById(&#39;xx&#39;).setAttribute(&#39;xx&#39;,value) 新增和修改。</span><br><span class="line">在标签里定义的所有属性包括 HTML 属性和自定义属性都会在 attributes 对象里以键值对的方式存在。</span><br></pre></td></tr></table></figure>

<p>其实attribute和property两个单词，翻译出来都是属性，但是《javascript高级程序设计》将它们翻译为特性和属性，以示区分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;uid&quot; title&#x3D;&quot;title1&quot; value&#x3D;&quot;1&quot; :index&#x3D;&quot;index&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里的id,value,style都属于property</span><br><span class="line">&#x2F;&#x2F;index属于attribute</span><br><span class="line">&#x2F;&#x2F;id、title等既是属性，也是特性。修改属性，其对应的特性会发生改变；修改特性，属性也会改变</span><br><span class="line">&#x2F;&#x2F;input.index &#x3D;&#x3D;&#x3D; undefined</span><br><span class="line">&#x2F;&#x2F;input.attributes.index &#x3D;&#x3D;&#x3D; this.index</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看到如果直接使用v-bind绑定，则默认会绑定到dom节点的attribute。<br>为了</p>
<ul>
<li>通过自定义属性存储变量，避免暴露数据</li>
<li>防止污染 HTML 结构</li>
</ul>
<p>我们可以使用这个修饰符，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;uid&quot; title&#x3D;&quot;title1&quot; value&#x3D;&quot;1&quot; :index.prop&#x3D;&quot;index&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;input.index &#x3D;&#x3D;&#x3D; this.index</span><br><span class="line">&#x2F;&#x2F;input.attributes.index &#x3D;&#x3D;&#x3D; undefined</span><br></pre></td></tr></table></figure>

<h3 id="camel"><a href="#camel" class="headerlink" title=".camel"></a>.camel</h3><p>由于HTML 特性是不区分大小写的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;svg :viewBox&#x3D;&quot;viewBox&quot;&gt;&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure>

<p>实际上会渲染为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;svg viewbox&#x3D;&quot;viewBox&quot;&gt;&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure>

<p>这将导致渲染失败，因为 SVG 标签只认 viewBox，却不知道 viewbox 是什么。<br>如果我们使用.camel修饰符，那它就会被渲染为驼峰名。<br>另，如果你使用字符串模版，则没有这些限制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  template: &#39;&lt;svg :viewBox&#x3D;&quot;viewBox&quot;&gt;&lt;&#x2F;svg&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="编写可复用模块的方式"><a href="#编写可复用模块的方式" class="headerlink" title="编写可复用模块的方式"></a>编写可复用模块的方式</h2><h3 id="通过自定义指令控制权限按钮的显示和隐藏"><a href="#通过自定义指令控制权限按钮的显示和隐藏" class="headerlink" title="通过自定义指令控制权限按钮的显示和隐藏"></a>通过自定义指令控制权限按钮的显示和隐藏</h3><p>除了 <code>Vue</code> 内置的一些指令比如 <code>v-model</code>、<code>v-if</code> 等，<code>Vue</code> 还允许我们自定义指令。在 <code>Vue2.0</code> 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 <code>DOM</code> 元素进行底层操作，这时候就会用到自定义指令。比如我们可以通过自定义一个指令来控制按钮的权限。我们期望设计一个如下形式的指令来控制按钮权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button v-auth&#x3D;&quot;[&#39;user&#39;]&quot;&gt;提交&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>通过在按钮的指令里传入一组权限，如果该按钮只有 <code>admin</code> 权限才可以提交，而我们传入一个别的权限，比如 <code>user</code>，那这个按钮就不应该显示了。接下来我们去注册一个全局的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; auth.js</span><br><span class="line">const AUTH_LIST &#x3D; [&#39;admin&#39;]</span><br><span class="line"></span><br><span class="line">function checkAuth(auths) &#123;</span><br><span class="line">    return AUTH_LIST.some(item &#x3D;&gt; auths.includes(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function install(Vue, options &#x3D; &#123;&#125;) &#123;</span><br><span class="line">    Vue.directive(&#39;auth&#39;, &#123;</span><br><span class="line">        inserted(el, binding) &#123;</span><br><span class="line">            if (!checkAuth(binding.value)) &#123;</span><br><span class="line">                el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123; install &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们需要在 <code>main.js</code> 里通过安装插件的方式来启用这个指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Auth from &#39;.&#x2F;utils&#x2F;auth&#39;</span><br><span class="line">Vue.use(Auth)</span><br></pre></td></tr></table></figure>



<h3 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h3><p><code>Vue</code> 提供了自定义过滤器的功能，主要应用场景是想要将数据以某种格式展示出来，而原始数据又不符合这种格式的时候。比如有一组关于人的数据，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    name: &#39;张茂&#39;,</span><br><span class="line">    population: &#39;young&#39;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    name: &#39;王丽&#39;,</span><br><span class="line">    population: &#39;middle&#39;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    name: &#39;郝鹏程&#39;,</span><br><span class="line">    population: &#39;child&#39;,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>其中有一项是关于按照年龄划分的群体类型 <code>population</code>，而它是用 <code>code</code> 进行标识的，我们希望在展示的时候能够显示成对应的中文意思，比如 <code>young</code> 显示成青年。那我们就可以定义一个如下的局部过滤器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    filters: &#123;</span><br><span class="line">        popuFilters(value) &#123;</span><br><span class="line">            if (!value) &#123; return &#39;未知&#39; &#125;</span><br><span class="line">            let index &#x3D; [&#39;child&#39;, &#39;lad&#39;, &#39;young&#39;, &#39;middle&#39;, &#39;wrinkly&#39;].indexOf(value)</span><br><span class="line">            return index &gt; 0 &amp;&amp; [&#39;儿童&#39;, &#39;少年&#39;, &#39;青年&#39;, &#39;中年&#39;, &#39;老年&#39;][index] || &#39;未知&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用过滤器的时候只要在 <code>template</code> 中这样使用即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt; item.population | popuFilters &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>



<h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><p>在某些情况下，我们封装的内容可能不需要使用者对其内部代码结构进行了解，其只需要熟悉我们提供出来的相应方法和 <code>api</code> 即可，这需要我们更系统性的将公用部分逻辑封装成插件，来为项目添加全局功能，比如常见的 <code>loading</code> 功能、弹框功能等。</p>
<p>开发 <code>Vue</code> 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象。可以通过如下4种方式来自定义插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyPlugin.install &#x3D; function (Vue, options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 1. 添加全局方法或 property</span><br><span class="line">  Vue.myGlobalMethod &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 逻辑...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2. 添加全局资源</span><br><span class="line">  Vue.directive(&#39;my-directive&#39;, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      &#x2F;&#x2F; 逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 3. 注入组件选项</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; 逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 4. 添加实例方法</span><br><span class="line">  Vue.prototype.$myMethod &#x3D; function (methodOptions) &#123;</span><br><span class="line">    &#x2F;&#x2F; 逻辑...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要在入口文件，比如 <code>main.js</code> 中注册插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import MyPlugin from &#39;.&#x2F;plugins&#x2F;plugins.js&#39;</span><br><span class="line">Vue.use(MyPlugin)</span><br></pre></td></tr></table></figure>



<h2 id="3种方式手写优雅代码"><a href="#3种方式手写优雅代码" class="headerlink" title="3种方式手写优雅代码"></a>3种方式手写优雅代码</h2><p>平时写项目的时候我们都是在第一时间完成需求功能的开发、提测修改 <code>bug</code> 等，然后开开心心的等待着发布生产以为没啥事情了。其实回过头来细细的看我们平时写的代码，可能会发现很多地方都是值得优化的，比如对于很多重复性很强的代码，比如对于某些写得很繁杂的地方。优雅的代码可以化机械为自动、化繁为简，看人开了如沐春风，心情大好。这里列了几个在 <code>Vue</code> 中一定会遇到的问题，然后通过优雅的方式进行解决。</p>
<h3 id="自动化导入多个路由文件"><a href="#自动化导入多个路由文件" class="headerlink" title="自动化导入多个路由文件"></a>自动化导入多个路由文件</h3><p>在开发一个稍微大点的项目的时候，会习惯将路由按照模块来划分，然后就可能会出现如下这种代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">&#x2F;&#x2F; 导入了一大堆路由文件</span><br><span class="line">import mediator from &#39;.&#x2F;mediator&#39;</span><br><span class="line">import judges from &#39;.&#x2F;judges&#39;</span><br><span class="line">import disputeMediation from &#39;.&#x2F;disputeMediation&#39;</span><br><span class="line">import onlineMediation from &#39;.&#x2F;onlineMediation&#39;</span><br><span class="line">import useraction from &#39;.&#x2F;useraction&#39;</span><br><span class="line">import organcenter from &#39;.&#x2F;organcenter&#39;</span><br><span class="line">import admin from &#39;.&#x2F;admin&#39;</span><br><span class="line"></span><br><span class="line">let routeList &#x3D; []</span><br><span class="line">routeList.push(mediator, judges, disputeMediation, onlineMediation, useraction, organcenter, admin)</span><br><span class="line"> </span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    mode: &#39;history&#39;,</span><br><span class="line">    routes: routeList,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其实真实的远远不止这么点，就我本地项目而言就有20几个路由文件，写了一大堆的导入代码，显得很臃肿，更无奈的是每当需要新增一个路由模块，还得再次 <code>import</code> 再次 <code>push</code>，那么有没有什么办法可以解决这个问题呢？答案自然是有的。</p>
<p>利用 <code>webpack</code> 的 <code>require.context</code> 就可以很优雅的解决这个问题，使用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require.context(</span><br><span class="line">    directory,  &#x2F;&#x2F; 搜索的目录</span><br><span class="line">    useSubdirectories &#x3D; true,  &#x2F;&#x2F; 是否搜索子目录</span><br><span class="line">    regExp &#x3D; &#x2F;^\.\&#x2F;.*$&#x2F;,  &#x2F;&#x2F; 匹配的目标文件格式</span><br><span class="line">    mode &#x3D; &#39;sync&#39;  &#x2F;&#x2F; 同步还是异步</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>有了这个语法，我们就能很容易的写出下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">let routeList &#x3D; []</span><br><span class="line">let importAll &#x3D; require.context(&#39;@&#x2F;publicResource&#x2F;router&#39;, false, &#x2F;\.js$&#x2F;)</span><br><span class="line">importAll.keys().map(path &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 因为 index.js 也在 @&#x2F;publicResource&#x2F;router 目录下，所以需要排除</span><br><span class="line">    if (!path.includes(&#39;index.js&#39;)) &#123;          </span><br><span class="line">        &#x2F;&#x2F;兼容处理：.default 获取 ES6 规范暴露的内容; 后者获取 commonJS 规范暴露的内容</span><br><span class="line">        let router &#x3D; importAll(path).default || importAll(path)</span><br><span class="line">        routeList(router)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    mode: &#39;history&#39;,</span><br><span class="line">    routes: routeList,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其实不仅仅只是用在导入路由模块这里，对于项目里任何需要导入大量本地模块的地方都可以使用这种方式来解决。</p>
<h3 id="模块化注册插件（element-ui）"><a href="#模块化注册插件（element-ui）" class="headerlink" title="模块化注册插件（element-ui）"></a>模块化注册插件（element-ui）</h3><p>相信写 <code>Vue</code> 的同学们都知道 <code>element-ui</code> 这个组件库，在使用这个组件库的时候大部分都是只使用某些个别的组件，所以基本上都是按需引入需要的组件，然后就有如下一堆<code>Vue.use()</code> 的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#123;</span><br><span class="line">    Input,</span><br><span class="line">    Radio,</span><br><span class="line">    RadioGroup,</span><br><span class="line">    Checkbox,</span><br><span class="line">    CheckboxGroup,</span><br><span class="line">    Select</span><br><span class="line">    &#x2F;&#x2F; 还有很多组件</span><br><span class="line">&#125; from &#39;element-ui&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Input)</span><br><span class="line">Vue.use(Radio)</span><br><span class="line">Vue.use(RadioGroup)</span><br><span class="line">Vue.use(Checkbox)</span><br><span class="line">Vue.use(CheckboxGroup)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure>

<p>这样写是没任何问题的，就是看着不够简洁舒服，那更优雅的做法是把这块逻辑抽到一个文件里，然后通过注册插件的方式来使用他们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; elementComponent.js</span><br><span class="line">import &#123;</span><br><span class="line">    Input,</span><br><span class="line">    Radio,</span><br><span class="line">    RadioGroup,</span><br><span class="line">    Checkbox,</span><br><span class="line">    CheckboxGroup,</span><br><span class="line">    Select</span><br><span class="line">    &#x2F;&#x2F; 还有很多组件</span><br><span class="line">&#125; from &#39;element-ui&#39;</span><br><span class="line"></span><br><span class="line">const components &#x3D; &#123;</span><br><span class="line">    Input,</span><br><span class="line">    Radio,</span><br><span class="line">    RadioGroup,</span><br><span class="line">    Checkbox,</span><br><span class="line">    CheckboxGroup,</span><br><span class="line">    Select</span><br><span class="line">&#125;</span><br><span class="line">function install(Vue)&#123;</span><br><span class="line">    Object.keys(components).forEach(key &#x3D;&gt; Vue.use(components[key]))</span><br><span class="line">&#125;</span><br><span class="line">export default &#123; install &#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>main.js</code> 里使用这个插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import elementComponent from &#39;.&#x2F;config&#x2F;elementComponent&#39;</span><br><span class="line">Vue.use(elementComponent)</span><br></pre></td></tr></table></figure>

<h3 id="优雅导出请求接口"><a href="#优雅导出请求接口" class="headerlink" title="优雅导出请求接口"></a>优雅导出请求接口</h3><p>不知道大伙是如何定义请求接口的，就我目前这个项目而言，是这么做的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; api.js</span><br><span class="line">import http from &#39;.&#x2F;config&#x2F;httpServer.js&#39;</span><br><span class="line"></span><br><span class="line"> &#x2F;* 登入页面获取公钥 *&#x2F;</span><br><span class="line">export const getPublicKey &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">    return http(&#123; url: &#39;&#x2F;userGateway&#x2F;user&#x2F;getPublicKey&#39; &#125;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户登录</span><br><span class="line">export const login &#x3D; data &#x3D;&gt; &#123;</span><br><span class="line">    return http(&#123; url: &#39;&#x2F;userGateway&#x2F;userSentry&#x2F;login&#39; &#125;, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 验证码登录</span><br><span class="line">export const loginByCode &#x3D; data &#x3D;&gt; &#123;</span><br><span class="line">    return http(&#123; url: &#39;&#x2F;userGateway&#x2F;userSentry&#x2F;loginByCode&#39; &#125;, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中使用接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; getPublicKey &#125; from &#39;.&#x2F;config&#x2F;api.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        getPublicKey().then(res &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; xxx</span><br><span class="line">        &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; xxx</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这一切都很正常，但，我们这个项目总共有200多个接口，按照上面这种定义方式的话，一个接口定义加上空行需要占用 5 行，所以如果把全部接口都定义到这个 <code>api.js</code> 里需要占用 1000 行左右，看了实在让人心很慌呀。所以觉得应该这个地方应该可以优化一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;userGateway&#x2F;user&#x2F;getPublicKey</span><br></pre></td></tr></table></figure>

<p>上面这是一个后端给接口路径，斜杆把这个路径划分成 3 个子串，而最后一个子串必定是唯一的，所以我们可以从中做文章。于是乎就有了下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; api.js</span><br><span class="line">const apiList &#x3D; [</span><br><span class="line">    &#39;&#x2F;userGateway&#x2F;user&#x2F;getPublicKey&#39;,  &#x2F;&#x2F; 登入页面获取公钥</span><br><span class="line">    &#39;&#x2F;userGateway&#x2F;userSentry&#x2F;login&#39;,  &#x2F;&#x2F; 用户登录</span><br><span class="line">    &#39;&#x2F;userGateway&#x2F;userSentry&#x2F;loginByCode&#39;,  &#x2F;&#x2F; 验证码登录</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let apiName, API &#x3D; &#123;&#125;</span><br><span class="line">apiList.forEach(path &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用正则取到接口路径的最后一个子串，比如: getPublicKey</span><br><span class="line">    apiName &#x3D; &#x2F;(?&lt;&#x3D;\&#x2F;)[^&#x2F;]+$&#x2F;.exec(path)[0]      </span><br><span class="line">    API[apiName] &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">        return http(&#123;url: path&#125;, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export &#123; API &#125;</span><br></pre></td></tr></table></figure>

<p>这样大概就把定义一个接口需要占用 5 行缩小到只需要 1 行了，大大减小了文件内容。在浏览这个文件的时候，我的鼠标滚轮也不会一直在滚滚滚了。</p>
<p>如果是这样定义接口的话，那在使用的时候还需要做点变化的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; API &#125; from &#39;.&#x2F;config&#x2F;api.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        API.getPublicKey().then(res &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; xxx</span><br><span class="line">        &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; xxx</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="4种-event传参方式"><a href="#4种-event传参方式" class="headerlink" title="4种$event传参方式"></a>4种$event传参方式</h2><p>在进行实际项目开发的时候经常会需要通过事件传递参数，这里总结了4种应用场景。</p>
<h3 id="用于组件通信"><a href="#用于组件通信" class="headerlink" title="用于组件通信"></a>用于组件通信</h3><p>比如子组件通过 <code>$emit</code> 来调用父组件方法的时候，可以在父组件中用 <code>$event</code> 接收到从子组件传递过来的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;button @click&#x3D;&quot;$emit(&#39;changeText&#39;, &#39;18px&#39;)&quot;&gt;点击加大字号&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;blog-post @changeText&#x3D;&quot;changeText(&#39;article&#39;, $event)&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line">changeText(type, value) &#123;</span><br><span class="line">    console.log(type, value)  &#x2F;&#x2F; &#39;article&#39; &#39;18px&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子组件传递过来的参数有多个，这个时候用 <code>$event</code> 就不太行了，此时可以用<code>arguments</code> 代替：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;button @click&#x3D;&quot;$emit(&#39;changeText&#39;, &#39;red&#39;, &#39;18px&#39;)&quot;&gt;点击改变样式&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;blog-post @changeText&#x3D;&quot;changeText(...arguments, &#39;article&#39;)&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line">changeText(...value) &#123;</span><br><span class="line">    console.log( value )  &#x2F;&#x2F; [&#39;red&#39;, &#39;18px&#39;, &#39;article&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="传递原生DOM事件对象"><a href="#传递原生DOM事件对象" class="headerlink" title="传递原生DOM事件对象"></a>传递原生DOM事件对象</h3><p>比如我们需要获取到当前的点击元素，就可以通过给点击事件传递 <code>$event</code> 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;submit(&#39;first&#39;, $event)&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">submit(type, event) &#123;</span><br><span class="line">    const target &#x3D; event.target.tagName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用于第三方类库事件回调"><a href="#用于第三方类库事件回调" class="headerlink" title="用于第三方类库事件回调"></a>用于第三方类库事件回调</h3><p>比如有一个组件里使用了好几个 <code>element-ui</code> 的分页组件，每个分页都有一个 <code>current-change</code> 事件，用来处理当分页改变之后的事情，这样的话我们就需要写多个回调函数，但是如果用以下方式，我们就也可以只写一个函数，通过 <code>type</code> 来判断是哪个分页的回调，而 <code>$event</code>则用来传递 <code>current-change</code> 回调默认的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 页面列表的分页</span><br><span class="line">&lt;el-pagination </span><br><span class="line">    @current-change&#x3D;&quot;changePage(&#39;main&#39;, $event)&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-pagination&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 弹窗A列表的分页</span><br><span class="line">&lt;el-pagination </span><br><span class="line">    @current-change&#x3D;&quot;changePage(&#39;modalA&#39;, $event)&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-pagination&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 弹窗B列表的分页</span><br><span class="line">&lt;el-pagination </span><br><span class="line">    @current-change&#x3D;&quot;changePage(&#39;modalB&#39;, $event)&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-pagination&gt;</span><br><span class="line">changePage(type, page) &#123;</span><br><span class="line">    const types &#x3D; [&#39;main&#39;, &#39;modalA&#39;, &#39;modalB&#39;]</span><br><span class="line">    types[type] &amp;&amp; (this[types[type]].pageIndex &#x3D; page) &amp;&amp; this.getList(type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用箭头函数处理"><a href="#使用箭头函数处理" class="headerlink" title="使用箭头函数处理"></a>使用箭头函数处理</h3><p>对于第三种场景，使用第三方类库组件的时候，需要给事件回调增加额外的参数，如果默认的回调参数只有1个那么我们就可以使用上面的那种方式，但是如果回调参数有多个的话，用 <code>$event</code> 就不好处理了，可以使用箭头函数。比如文件上传的时候，有个 <code>on-change</code> 属性，当文件变化的时候就会触发回调，正常情况下我们这样写是没问题的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-upload :on-change&#x3D;&quot;changeFile&quot;&gt;</span><br><span class="line">    &lt;el-button&gt;上传&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;el-upload&gt;</span><br><span class="line">changeFile(file, fileList) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果一个组件里有多个文件上传，而我们又不想写多个 <code>changeFile</code>，那就需要传递额外的参数 <code>type</code> 了 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-upload :on-change&#x3D;&quot;(file, fileList) &#x3D;&gt; changeFile(&#39;org&#39;, file, fileList)&quot;&gt;</span><br><span class="line">    &lt;el-button&gt;上传&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;el-upload&gt;</span><br><span class="line">changeFile(type, file, fileList) &#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3种深入watch的用法"><a href="#3种深入watch的用法" class="headerlink" title="3种深入watch的用法"></a>3种深入watch的用法</h2><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><p><code>watch</code> 是 <code>Vue</code> 中的侦听器，可以侦听一个 <code>Vue</code> 实例上的数据，当数据变动的时候，就会触发该侦听器。所以他的应用场景就是：当某个数据变动后需要做什么的时候就可以使用<code>watch</code> 啦。对于 <code>watch</code>，平常我们写得最多的估计是如下这种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    list: function(val) &#123;</span><br><span class="line">        this.getMsg()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们希望组件初始化的时候就执行一次 <code>getMsg</code> 方法，可以直接在 <code>mounted</code> 里调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    this.getMsg()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，还有一种更加简便的写法，通过给 <code>watch</code> 设置 <code>immediate: true</code> ，即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">        handler(val) &#123;  &#x2F;&#x2F; 注意别写错成 handle</span><br><span class="line">            this.getMsg()</span><br><span class="line">        &#125;,</span><br><span class="line">        immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深度监听"><a href="#深度监听" class="headerlink" title="深度监听"></a>深度监听</h3><p>侦听器对于属性变更后会自动调用一次，但是仅限于该属性本身，如果变更的是属性的属性，则不会触发侦听回调，如果想要实现这个功能可以给 <code>watch</code> 加上 ‘deep: true’ 即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">        handler(val) &#123; &#x2F;&#x2F; do something &#125;,</span><br><span class="line">        deep: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.obj.name &#x3D; &#39;bubuzou&#39;  &#x2F;&#x2F; 将触发 handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个handlers"><a href="#多个handlers" class="headerlink" title="多个handlers"></a>多个handlers</h3><p>实际上，<code>watch</code> 可以设置为数组，支持类型为 <code>String</code>、<code>Object</code> 和 <code>Function</code>。触发后，多个处理函数都将被调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj: [</span><br><span class="line">        &#39;print&#39;,</span><br><span class="line">        &#123;</span><br><span class="line">            handler: &#39;print&#39;,</span><br><span class="line">            deep: true</span><br><span class="line">        &#125;,</span><br><span class="line">        function(val, oldValue) &#123;</span><br><span class="line">            console.log(val)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(this.obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="watch详解"><a href="#watch详解" class="headerlink" title="watch详解"></a>watch详解</h3><p>handler：监听数组或对象的属性时用到的方法</p>
<p>deep：深度监听，为了发现对象内部值的变化，可以在选项参数中指定 deep:true 。注意监听数组的变动不需要这么做。</p>
<p>immediate: 在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调</p>
<p>tips: 只要bet中的属性发生变化（可被监测到的），便会执行handler函数；如果想监测具体的属性变化，如pokerHistory变化时，才执行handler函数，则可以利用计算属性computed做中间层。</p>
<p>watch 不能检测以下变动的数组：</p>
<ul>
<li>当你利用索引直接设置一个项时，例如：this.demo[1] = 5</li>
<li>当你修改数组的长度时，例如：this.demo.length = 2</li>
</ul>
<h4 id="1、普通的watch"><a href="#1、普通的watch" class="headerlink" title="1、普通的watch"></a>1、普通的watch</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      frontPoints: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    frontPoints(newValue, oldValue) &#123;</span><br><span class="line">      console.log(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、数组的watch"><a href="#2、数组的watch" class="headerlink" title="2、数组的watch"></a>2、数组的watch</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line"> return &#123;</span><br><span class="line"> 　　winChips: new Array(11).fill(0)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  winChips: &#123;</span><br><span class="line">     handler(newValue, oldValue) &#123;</span><br><span class="line">       for (let i &#x3D; 0; i &lt; newValue.length; i++) &#123;</span><br><span class="line">       if (oldValue[i] !&#x3D; newValue[i]) &#123;</span><br><span class="line">          console.log(newValue)　　　　　　　　</span><br><span class="line">         &#125;	</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,　</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、对象的watch"><a href="#3、对象的watch" class="headerlink" title="3、对象的watch"></a>3、对象的watch</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">　　return &#123;</span><br><span class="line">　　　　bet: &#123;</span><br><span class="line">　　　　　　pokerState: 53,</span><br><span class="line">　　　　　　pokerHistory: &#39;local&#39;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">　　bet: &#123;</span><br><span class="line">　　　　handler(newValue, oldValue) &#123;</span><br><span class="line">　　　　　　console.log(newValue)　　　　</span><br><span class="line">   		&#125;,</span><br><span class="line">　　	  deep: true</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、对象具体属性的watch［活用computed］"><a href="#4、对象具体属性的watch［活用computed］" class="headerlink" title="4、对象具体属性的watch［活用computed］"></a>4、对象具体属性的watch［活用computed］</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">　　return &#123;</span><br><span class="line">　　　　bet: &#123;</span><br><span class="line">　　　　　　pokerState: 53,</span><br><span class="line">　　　　　　pokerHistory: &#39;local&#39;</span><br><span class="line">　　　　&#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">　　pokerHistory() &#123;</span><br><span class="line">　　　　return this.bet.pokerHistory</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">　　pokerHistory(newValue, oldValue) &#123;</span><br><span class="line">　　　　console.log(newValue)</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、对象数组的watch"><a href="#5、对象数组的watch" class="headerlink" title="5、对象数组的watch"></a>5、对象数组的watch</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        demo:[</span><br><span class="line">             &#123;</span><br><span class="line">                  name:&#39;张三&#39;,</span><br><span class="line">                  age:18</span><br><span class="line">             &#125;,</span><br><span class="line">　　　　　　　　&#123;</span><br><span class="line">                  name:&#39;李四&#39;,</span><br><span class="line">                  age:20</span><br><span class="line">             &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    demo: &#123;</span><br><span class="line">      handler (val) &#123;</span><br><span class="line">        console.log(val)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 这里是关键，代表递归监听 demo 的变化</span><br><span class="line">      deep: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h4 id="6、watch和computed各自处理的数据关系场景不同"><a href="#6、watch和computed各自处理的数据关系场景不同" class="headerlink" title="6、watch和computed各自处理的数据关系场景不同"></a>6、watch和computed各自处理的数据关系场景不同</h4><p>watch擅长处理的场景：一个数据影响多个数据<br>computed擅长处理的场景：一个数据受多个数据影响</p>
<h4 id="7、method和computed触发条件不同"><a href="#7、method和computed触发条件不同" class="headerlink" title="7、method和computed触发条件不同"></a>7、method和computed触发条件不同</h4><p>computed只提供了缓存的值，而没有重新计算<br>只有符合：1.存在依赖型数据 2.依赖型数据发生改变这两个条件,computed才会重新计算。<br>而methods下的数据，是每次都会进行计算的</p>
<h2 id="4个其他开发小技巧"><a href="#4个其他开发小技巧" class="headerlink" title="4个其他开发小技巧"></a>4个其他开发小技巧</h2><h3 id="调试template（不推荐）"><a href="#调试template（不推荐）" class="headerlink" title="调试template（不推荐）"></a>调试template（不推荐）</h3><p>在开发调试的时候经常会需要通过 <code>console.log</code> 来打印出某个数据对象来查看其内部的结构或者字段值，但是这样做肯定不必在 <code>template</code> 里将其输出更直接。比如有这样一个数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj: &#123;</span><br><span class="line">    name: &#39;bubuzou&#39;,</span><br><span class="line">    age: 21,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模板中展示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt; obj &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>页面渲染完成后会看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &quot;name&quot;: &quot;bubuzou&quot;, &quot;age&quot;: 21 &#125;</span><br></pre></td></tr></table></figure>

<p>对于这样的渲染结果虽然没什么问题，但是如果这个 <code>obj</code> 是层级很深且字段很多的数据，显示出来就会一堆数据砸在一块，丝毫没有阅读体验。</p>
<p>因此基于这个背景，我们可以将 <code>console.log</code> 挂载在 <code>Vue</code> 的实例原型上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">Vue.prototype.$log &#x3D; window.console.log</span><br></pre></td></tr></table></figure>

<p>然后就可以开开心心在模板中使用他了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt; $log( obj ) &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>这样会在浏览器控制台输出当前的数据对象，在显示效果上和 <code>console.log</code> 直接打印别无二致。</p>
<p>但说了这么多，使用 <code>Vue</code> 进行开发调试还是强烈推荐官方的vue-devtools 工具，谁用谁知道。</p>
<h3 id="监听子组件的钩子函数"><a href="#监听子组件的钩子函数" class="headerlink" title="监听子组件的钩子函数"></a>监听子组件的钩子函数</h3><p>通常如果我们想在子组件钩子函数触发的时候通知父组件，我们可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;child @mounted&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">this.$emit(&#39;mounted&#39;)</span><br></pre></td></tr></table></figure>

<p>其实还有一种更加简单的写法，那就是使用 <code>hookEvent</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child @hook:mounted&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;child&gt;</span><br></pre></td></tr></table></figure>

<p>钩子函数除了以上用法，还可以通过动态注册做一些别的事情，比如组件销毁前进行资源的释放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    let setIntervalId &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(888);</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">    </span><br><span class="line">    this.$once(&quot;hook:beforeDestroy&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        clearInterval(setIntervalId)</span><br><span class="line">        setIntervalId &#x3D; null</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由参数解耦"><a href="#路由参数解耦" class="headerlink" title="路由参数解耦"></a>路由参数解耦</h3><p>参数解耦，啥意思呢？别着急，我们先来看比如对于这么一串路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; [&#123;</span><br><span class="line">    path: &#39;&#x2F;home&#x2F;:type&#x2F;:id&#39;,</span><br><span class="line">    name: &#39;Home&#39;,</span><br><span class="line">    component: Home,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>当前页面的路径是 <code>http://xxx/detail/preview/21?sex=male</code>，平时我们写代码的时候或多或少的会写出这种代码，在组件里使用 <code>$route</code> 给组件传参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    if (this.$route.params.type &#x3D;&#x3D;&#x3D; &#39;preview&#39;) &#123;</span><br><span class="line">        this.isPreview &#x3D; true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.isPreview &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    this.id &#x3D; this.$route.params.id</span><br><span class="line">    this.sex &#x3D; this.$route.query.sex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子写本身没什么问题，就是会使得组件和路由高度耦合，让组件只能在含有特定 <code>URL</code> 的页面中使用，限制了组件的通用性。其实，我们可以通过 <code>props</code> 传参，来解耦路由参数，将上面的路由配置改成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; [&#123;</span><br><span class="line">    path: &#39;&#x2F;home&#x2F;:type&#x2F;:id&#39;,</span><br><span class="line">    name: &#39;Home&#39;,</span><br><span class="line">    component: Home,</span><br><span class="line">    props: (route) &#x3D;&gt; (&#123;</span><br><span class="line">        type: route.params.type,</span><br><span class="line">        id: route.params.id,</span><br><span class="line">        sex: route.query.sex,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>然后在组件 <code>props</code> 加上参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: [&#39;type&#39;, &#39;id&#39;, &#39;sex&#39;]</span><br></pre></td></tr></table></figure>

<p>组件里使用参数的时候就不需要用 <code>this.$route</code>，而是可以直接 <code>this.type</code> 即可。这样一来，这个组件就可以在任何地方使用了。</p>
<h3 id="深度作用选择器"><a href="#深度作用选择器" class="headerlink" title="深度作用选择器"></a>深度作用选择器</h3><p>当给 <code>style</code> 加上 <code>scoped</code>，页面渲染完成后会给 <code>html</code> 和 <code>css</code> 选择器加上哈希值用于表示唯一性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;home&quot; data-v-fae5bece&gt;</span><br><span class="line">    &lt;button data-v-fae5bece class&#x3D;&quot;el-button el-button-primary&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.home .el-button[data-v-fae5bece] &#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于在 <code>style</code> 中被加了 <code>scoped</code> 的组件，其样式将只能作用于组件内部，不会对其子组件造成影响。比如有这样一个组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot;&gt;父按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">.home .el-button &#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;div class&#x3D;&quot;child&quot;&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot;&gt;子按钮&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>当页面渲染出来后，会是如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;home&quot; data-v-fae5bece&gt;</span><br><span class="line">    &lt;button data-v-fae5bece class&#x3D;&quot;el-button el-button-primary&quot;&gt;父按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child&quot; data-v-fae5bece&gt;</span><br><span class="line">        &lt;button class&#x3D;&quot;el-button el-button-primary&quot;&gt;子按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>根据上面的 <code>html</code>，我们可以看到 <code>.home .el-button[data-v-fae5bece]</code> 这个选择器作用不到子按钮这个 <code>button</code>。</p>
<p>在实际项目中，我们有时候需要让父组件的样式能作用到子组件，即使父组件的 <code>style</code> 上加了 <code>scoped</code>，那这个时候就需要用到深度作用选择器 <code>&gt;&gt;&gt;</code>，比如在刚刚的例子上可以给父组件样式加上深度作用选择器。</p>
<blockquote>
<p>深度作用选择器会被 <code>Vue Loader</code> 处理，且只能在有预处理器的地方使用。由于某些预处理器比如 <code>Sass</code> 不能正确解析 <code>&gt;&gt;&gt;</code>，所以我们可以使用它的别名：<code>/deep/</code> 或 <code>::v-deep</code> 来替代。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">.home &#123;</span><br><span class="line">    &#x2F;deep&#x2F; .el-button &#123;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>加上深度作用选择器后，选择器会由原来的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.home .el-button[data-v-fae5bece] &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>变成如下的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.home[data-v-fae5bece] .el-button &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint简介</title>
    <url>/2020/07/30/ESLint%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h4 id="ESLint简介"><a href="#ESLint简介" class="headerlink" title="ESLint简介"></a>ESLint简介</h4><p>ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。如果每次在代码提交之前都进行一次eslint代码检查，就不会因为某个字段未定义为undefined或null这样的错误而导致服务崩溃，可以有效的控制项目代码的质量。</p>
<p>在许多方面，它和 JSLint、JSHint 相似，除了少数的例外：</p>
<ul>
<li>ESLint 使用 Espree 解析 JavaScript。</li>
<li>ESLint 使用 AST 去分析代码中的模式。</li>
<li>ESLint 是完全插件化的。每一个规则都是一个插件并且你可以在运行时添加更多的规则。</li>
</ul>
<a id="more"></a>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ESLint 支持多种安装方式，可以通过 npm 来安装，也可以在 webpack(eslint-loader) 和 Gulp.js(gulp-eslint) 中使用。</p>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g eslint</span><br></pre></td></tr></table></figure>

<h3 id="局部安装（推荐）"><a href="#局部安装（推荐）" class="headerlink" title="局部安装（推荐）"></a>局部安装（推荐）</h3><p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D eslint</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>安装完毕后，接下来新建一个配置文件.eslintrc.js，或者使用如下的命令行来自动生成，命令如下：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>注意：如果你之前使用的版本低于 1.0.0，请查看 <a href="https://cn.eslint.org/docs/user-guide/migrating-to-1.0.0" target="_blank" rel="noopener">迁移指南</a>。<br>运行 eslint –init 之后，.eslintrc 文件会在你的文件夹中自动创建。文件的内容大体如下：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;es6&quot;: true,</span><br><span class="line">        &quot;node&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;no-console&quot;: 0,</span><br><span class="line">        &quot;no-unused-vars&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-use-before-define&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;linebreak-style&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;unix&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;quotes&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;single&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;semi&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;curly&quot;: [&quot;error&quot;, &quot;all&quot;],</span><br><span class="line">        &quot;default-case&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-else-return&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-empty-function&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-implicit-coercion&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-invalid-this&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-loop-func&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-multi-spaces&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-new-func&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-useless-return&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;global-require&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-path-concat&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-sync&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;array-bracket-spacing&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;never&quot; </span><br><span class="line">        ],</span><br><span class="line">        &quot;block-spacing&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;brace-style&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;1tbs&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;camelcase&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;comma-dangle&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always-multiline&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;comma-spacing&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;comma-style&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;last&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;key-spacing&quot;: [</span><br><span class="line">            &quot;error&quot;, </span><br><span class="line">            &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;lines-around-comment&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &#123; &quot;beforeBlockComment&quot;: true &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;newline-after-var&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;newline-before-return&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-multi-assign&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;max-params&quot;: [1, 3],</span><br><span class="line">        &quot;new-cap&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;newIsCap&quot;: true,</span><br><span class="line">                &quot;capIsNew&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;no-multiple-empty-lines&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;max&quot;: 2</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;no-shadow-restricted-names&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;no-undef-init&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;keyword-spacing&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;space-before-blocks&quot;: [</span><br><span class="line">            &quot;error&quot;,</span><br><span class="line">            &quot;always&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ESlint支持的可配置信息主要分为3类：</p>
<ul>
<li>Environments：Javascript 脚步将要运行在什么环境中（如：nodejs，browser，commonjs等）,ESlint支持的所有环境都可以在<a href="https://eslint.org/docs/user-guide/configuring#specifying-environments" target="_blank" rel="noopener">官网</a>查到。</li>
<li>Globals：执行代码时脚步需要访问的额外全局变量。</li>
<li>Rules：开启某些规则，也可以设置规则的等级。</li>
</ul>
<h3 id="检测规则"><a href="#检测规则" class="headerlink" title="检测规则"></a>检测规则</h3><p>接下来，可以在配置文件中设置一些规则。ESLint规则的三种级别：</p>
<ul>
<li>“off” 或者 0：关闭规则。</li>
<li>“warn” 或者 1：打开规则，并且作为一个警告（不影响exit code）。</li>
<li>“error” 或者 2：打开规则，并且作为一个错误（exit code将会是1）。</li>
</ul>
<p>例如，下面的一些配置规则：</p>
<ul>
<li><code>&quot;no-console&quot;:&quot;off&quot;</code>           禁用 console。</li>
<li><code>&quot;no-unused-vars&quot;:2</code>    禁止出现未使用过的变量。</li>
<li><code>&quot;no-use-before-define&quot;:2</code>  不允许在变量定义之前使用它们。</li>
<li><code>&quot;linebreak-style&quot;:[2, &quot;unix&quot;]</code>   强制使用一致的换行风格。</li>
<li><code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code>   强制使用一致的单引号。</li>
<li><code>&quot;semi&quot;:[&quot;error&quot;, &quot;always&quot;]</code>   控制行尾部分号。</li>
<li><code>&quot;curly&quot;:[&quot;error&quot;, &quot;all&quot;]</code>    强制所有控制语句使用一致的括号风格。</li>
</ul>
<ul>
<li><code>&quot;default-case&quot;: &quot;error&quot;</code>    switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告。</li>
<li><code>&quot;no-else-return&quot;:&quot;error&quot;</code>  禁止 if 语句中有 return 之后有 else。</li>
<li><code>&quot;no-implicit-coercion&quot;: &quot;error&quot;</code> 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。</li>
<li><code>&quot;no-invalid-this&quot;: &quot;error&quot;</code> 禁止 this 关键字出现在类和类对象之外。</li>
<li><code>&quot;no-loop-func&quot;:&quot;error&quot;</code> 禁止在循环中出现 function 声明和表达式。</li>
<li><code>&quot;no-multi-spaces&quot;:&quot;error&quot;</code> 禁止使用多个空格。</li>
<li><code>&quot;no-new-func&quot;:&quot;error&quot;</code> 禁止对 空Function 对象使用 new 操作符。</li>
<li><code>&quot;no-useless-return&quot;:&quot;error&quot;</code> 禁止没有任何内容的return;</li>
<li><code>&quot;global-require&quot;: &quot;error&quot;</code> 要求 require() 出现在顶层模块作用域中。</li>
<li><code>&quot;no-path-concat&quot;: &quot;error&quot;</code> 禁止对 dirname 和 filename进行字符串连接</li>
<li><code>&quot;no-sync&quot;: &quot;error&quot;</code> 禁用同步方法。</li>
<li><code>&quot;array-bracket-spacing&quot;: [&quot;error&quot;, &quot;never&quot;]</code> 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格。</li>
<li><code>&quot;block-spacing&quot;: [&quot;error&quot;, &quot;always&quot;]</code> 禁止或强制在单行代码块中使用空格(禁用)。</li>
<li><code>&quot;brace-style&quot;: [&quot;error&quot;, &quot;1tbs&quot;]</code></li>
<li><code>&quot;camelcase&quot;: &quot;error&quot;</code> 强制驼峰法命名。</li>
<li><code>&quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always-multiline&quot;]</code> 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗,always-multiline：多行模式必须带逗号，单行模式不能带逗号号。</li>
<li><code>&quot;comma-spacing&quot;: [&quot;error&quot;, { &quot;before&quot;: false, &quot;after&quot;: true }]</code> 控制逗号前后的空格。</li>
<li><code>&quot;comma-style&quot;: [&quot;error&quot;, &quot;last&quot;]</code> 控制逗号在行尾出现还是在行首出现 (默认行尾)。</li>
<li><code>&quot;key-spacing&quot;: [&quot;error&quot;, { &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true }]</code> 该规则规定了在对象字面量语法中，key和value之间的空白，冒号前不要空格，冒号后面需要一个空格。</li>
<li><code>&quot;lines-around-comment&quot;: [&quot;error&quot;, { &quot;beforeBlockComment&quot;: true }]</code> 要求在注释周围有空行 ( 要求在块级注释之前有一空行)。</li>
<li><code>&quot;newline-after-var&quot;: [&quot;error&quot;, &quot;always&quot;]</code> 要求或禁止 var 声明语句后有一行空行。</li>
<li><code>&quot;newline-before-return&quot;: &quot;error&quot;</code> 要求 return 语句之前有一空行。</li>
<li><code>&quot;no-multi-assign&quot;: &quot;error&quot;</code> 链接变量的赋值可能会导致意外的结果并难以阅读，不允许在单个语句中使用多个分配。</li>
<li><code>&quot;max-params&quot;: [1, 3] function</code> 定义中最多允许的参数数量。</li>
<li><code>&quot;new-cap&quot;: [&quot;error&quot;, { &quot;newIsCap&quot;: true, &quot;capIsNew&quot;: false}]</code> 构造函数首字母大写。</li>
<li><code>&quot;no-multiple-empty-lines&quot;: [&quot;error&quot;, {&quot;max&quot;: 2}]</code> 空行不能够超过2行。</li>
<li><code>&quot;no-shadow-restricted-names&quot;: &quot;error&quot;</code> 禁止对一些关键字或者保留字进行赋值操作，比如NaN、Infinity、undefined、eval、arguments等。</li>
<li><code>&quot;no-undef-init&quot;: &quot;error&quot;</code> 禁止把undefined赋值给一个变量。</li>
<li><code>&quot;keyword-spacing&quot;: &quot;error&quot;</code> keyword 前后需要空格。</li>
<li><code>&quot;space-before-blocks&quot;: [&quot;error&quot;,&quot;always&quot;]</code> 强制在块之前使用一致的空格。</li>
</ul>
<h3 id="忽略检测"><a href="#忽略检测" class="headerlink" title="忽略检测"></a>忽略检测</h3><p>既然有检测的规则，那么必然有忽略检测的配置。要新增忽略检测的规则，首先要在项目根目录创建一个 .eslintignore 文件告诉 ESLint 去忽略掉不需要检测的文件或者目录。</p>
<p>或者通过package.json文件设置需要忽略检测的对象，例如：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my_project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintConfig&quot;: &#123; &#x2F;&#x2F; 也可配置eslint</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;es6&quot;: true,</span><br><span class="line">      &quot;node&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintIgnore&quot;: [&quot;test.js&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gulp中使用ESLint"><a href="#Gulp中使用ESLint" class="headerlink" title="Gulp中使用ESLint"></a>Gulp中使用ESLint</h2><p>除了npm方式之外，ESLint还支持Gulp插件方式使用，使用之前需要先安装插件。</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-eslint</span><br></pre></td></tr></table></figure>

<p>如果要使用gulp-eslint进行eslint规则的校验，可以使用下面的方式：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gulp &#x3D; require(&#39;gulp&#39;);</span><br><span class="line">var eslint &#x3D; require(&#39;gulp-eslint&#39;);</span><br><span class="line">gulp.task(&#39;lint&#39;,function()&#123;</span><br><span class="line">    return gulp.src([&#39;app&#x2F;**&#x2F;*.js&#39;]) &#x2F;&#x2F;指定的校验路径</span><br><span class="line">        .pipe(eslint(&#123;configFle:&quot;.&#x2F;.eslintrc&quot;&#125;)) &#x2F;&#x2F;使用你的eslint校验文件</span><br><span class="line">        .pipe(eslint.format())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="ESLint技巧"><a href="#ESLint技巧" class="headerlink" title="ESLint技巧"></a>ESLint技巧</h1><h2 id="eslint-config-standard"><a href="#eslint-config-standard" class="headerlink" title="eslint-config-standard"></a>eslint-config-standard</h2><p>eslint-config-standard是一个标准的ESLint规则检测库，因此只需要安装这个库就可以省去配置ESLint规则。<br><img src alt="在这里插入图片描述"><br>然后，在项目的根目录里面手动创建一个.eslintrc文件，然后在里面添加如下代码：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完以上步骤，就可以使用ESLint这个工具来校验项目里的代码。</p>
<p>在Vue项目里，.vue文件写的是类似于html的格式，不是标准的JavaScript文件，ESLint无法直接识别.vue文件里的JavaScript代码，那么这个时候我们需要去安装一个工具，安装命令如下：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i eslint-plugin-html -D</span><br></pre></td></tr></table></figure>

<p>因为在vue文件里面写JavaScript代码也是写在script标签里面的，这个插件的作用就是识别一个文件里面script标签里面的JS代码，官方也是这么推荐的。所以我们要在.eslintrc文件里面新增一段脚本：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;html&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完以上步骤后，我们跳转到package.json文件里面的scripts里面新增一条命令：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;lint&quot;: &quot;eslint --ext .js --ext .jsx --ext .vue src&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的脚本命令中，ext后面需要写上指定检测文件的后缀，如.js、.jsx、 .vue等，紧接着后面要写上一个参数，这个参数就是我们要检测哪个目录下面的文件，一般项目文件都在src下面，所以在后面写上src/就好。</p>
<p>现在我们就可以到terminal里面输入$ npm run lint，来检验项目里的代码是否符合ESLint的规则。</p>
<h2 id="ESLint自动修复报错"><a href="#ESLint自动修复报错" class="headerlink" title="ESLint自动修复报错"></a>ESLint自动修复报错</h2><p>一般来说，当我们使用命令“npm run lint”检测JavaScript的时候，基本上都会出现非常的多报错，基本上就是满屏的error和warning。<br><img src alt="在这里插入图片描述"><br>在报这么多的错误之后，如果我们一条一条地去修复，就会变的非常的麻烦，相信刚接触ESLint的童鞋都深有体会。其实这些错误都可以让ESLint帮助我们自动地修复。具体来说，只需要在package.json文件里面的scripts里面新增一条命令即可：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;lint-fix&quot;: &quot;eslint --fix --ext .js --ext .jsx --ext .vue src&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>当我们再去terminal中执行命令：$ npm run lint-fix，你会发现没有那么多飘红的报错，也没有满屏的error和warning了。</p>
<p>当然，还有一种万能方法，就是在报错的JS文件中第一行写上/* eslint-disable */，具体可以参考<a href="https://cn.eslint.org/docs/1.10.3/user-guide/command-line-interface" target="_blank" rel="noopener">Command line Interface</a></p>
<h2 id="eslint-loader"><a href="#eslint-loader" class="headerlink" title="eslint-loader"></a>eslint-loader</h2><p>有时候，我们希望在项目开发的过程当中，每次修改代码都能够自动进行ESLint的检查。因为在我们改代码的过程中去做一次检查，如果有错误，我们就能够很快地去定位到问题并解决问题。这时候我们可以借助eslint-loader插件。</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i eslint-loader babel-eslint -D</span><br></pre></td></tr></table></figure>

<p>执行完安装操作后，我们还需要在.eslintrc文件里面配置如下脚本：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;html&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;parser&quot;: &quot;babel-eslint&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么我们要配置parser呢？因为我们的项目是基于webpack的，项目里的代码都是需要经过babel去处理的。babel处理的这种语法可能对ESLint不是特别的支持，然后我们使用loader处理ESLint的时候就会出现一些问题。所以一般来说，我们用webpack和babel来进行开发的项目，都会指定它的parser使用babel-eslint。</p>
<p>同时，使用webpack方式构建的项目，还需要在webpack.config.base.js的module下面的rules里面添加一个如下脚本：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: &#x2F;\.(vue|js|jsx)$&#x2F;,</span><br><span class="line">    loader: &#39;eslint-loader&#39;,</span><br><span class="line">    exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">    enforce: &#39;pre&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  ......</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后我们就可以使用命令 <code>$ npm run dev</code>就可以在开发环境进行ESLint错误检测。</p>
<p>附：<a href="https://cn.eslint.org/" target="_blank" rel="noopener">https://cn.eslint.org/</a></p>
<p>​    <a href="https://www.imooc.com/article" target="_blank" rel="noopener">https://www.imooc.com/article</a>…</p>
<p>​        <a href="https://segmentfault.com/a/1190000018328740" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018328740</a></p>
]]></content>
      <categories>
        <category>ESLint</category>
      </categories>
      <tags>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>H5移动端调试全攻略</title>
    <url>/2020/09/21/H5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E5%85%A8%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h2 id="H5-移动端调试全攻略"><a href="#H5-移动端调试全攻略" class="headerlink" title="H5 移动端调试全攻略"></a>H5 移动端调试全攻略</h2><h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><p>因为移动端操作系统分为 <code>iOS</code> 和 <code>Android</code> 两派，所以本文的调试技巧也会按照不同的系统来区分。寻找最合适高效的方式，才能让你事半功倍。</p>
<blockquote>
<p>文章会列举目前适合移动端调试的多种方案，快来选择你的最佳实践吧！</p>
</blockquote>
<a id="more"></a>

<h3 id="二、iOS-设备"><a href="#二、iOS-设备" class="headerlink" title="二、iOS 设备"></a>二、iOS 设备</h3><blockquote>
<p>Safari：iphone 调试利器，查错改样式首选，需要我们做如下设置：</p>
</blockquote>
<ul>
<li>浏览器设置：Safari - 偏好设置 - 高级 - 勾选「在菜单栏中显示开发」菜单</li>
<li>iphone 设置：设置 - Safari - 高级 - 打开 Web 检查器</li>
</ul>
<p>大功告成，这时候通过手机的 <code>Safari</code> 来打开 <code>H5</code> 页面，我们通过浏览器开发选项可以看到：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGn5BX8wYAAkWwC94klY7dgu8VHmbnTYC6q0n72vwzjsNgy0XFjhxeHg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p>iOS 模拟器：不需要真机，适合调试 <code>Webview</code> 和 <code>H5</code> 有频繁交互的功能页面。</p>
</blockquote>
<p>首先下载 <code>Xcode</code> ，运行项目，选择模拟器 <code>iphonex</code>，编译后就会打开模拟器，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPG2YGhibTb0YhQ8Z9T3XcbRliaREicZyAkhkD1Y9jp9VY0oN6ubAmd0TJTw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>可以看到 H5 已经在「壳子」中运行起来了，下来就可以尝试调用 <code>Webview</code> 的方法，和「壳子」交互了。更多的调试技巧可以参考文章：iOS 模拟器调试。</p>
<blockquote>
<p>具体的调试功能还是依赖浏览器的开发选项，与上无异，就不赘述了。</p>
</blockquote>
<h3 id="三、抓包"><a href="#三、抓包" class="headerlink" title="三、抓包"></a>三、抓包</h3><blockquote>
<p>Charles：Mac OS 系统首选的抓包工具，适合查看、控制网络请求，分析数据情况。</p>
</blockquote>
<p><code>Charles</code> 抓包首先需要配置手机代理，<code>Wifi</code> - 配置代理（IP 地址） - 手动，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGIP6SIiablZyr5dIVUR5cia8o0Q48e6HDWNDg7pGeKqF595UpxGQzdmRA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGicEHia9puWnLMbfFpugT6JyS0kvmfAjPiccKCneicr3a16wibKL3icI9eZEA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>配置好手机代理，这时候打开 <code>Charles</code> ，就会收到确认提醒，选择允许。接下来就可以捕获手机的请求了，但是这些都是常规操作，我们来点高级的。</p>
<blockquote>
<p>有意思的是：我们可以用本地文件来替换线上文件，方便调试，远程定位线上问题。</p>
</blockquote>
<p>选择 <code>Structure</code>，找到需要替换的文件，右键菜单 - <code>Map Local</code>，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPG74USxfw2vn2icibocyibnKstkO9ux4e63ck3Nun2gKEicCrIL9Hs7U6JpA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>这时候就会打开一个弹窗，填写具体的配置：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGReaE3gLGUgBaTj42WpmGvia2uibqJ7LL2ict6BmMbq9r5BwzJKfDOZ3qQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>OK，大功告成，快去改动本地文件吧，从此再也不怕线上调试了。需要注意的是如果抓取 <code>HTTPS</code> 请求，要安装信任证书，下文会详细说明。</p>
<blockquote>
<p>与之相应的是 Windows 平台的 Fiddler，功能大致相似，这里就不细说了。</p>
</blockquote>
<h3 id="四、Spy-Debugger"><a href="#四、Spy-Debugger" class="headerlink" title="四、Spy-Debugger"></a>四、Spy-Debugger</h3><blockquote>
<p>spy-debugger：移动端调试的利器，便捷的远程调试手机页面、抓包工具。</p>
</blockquote>
<p>我们先来安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sudo npm install spy-debugger -g</span><br></pre></td></tr></table></figure>

<p>启动命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; spy-debugger</span><br></pre></td></tr></table></figure>

<p>这时候，控制台会打印出如下信息，说明服务已经启动了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正在启动代理</span><br><span class="line">本机在当前网络下的IP地址为：10.200.24.46</span><br><span class="line">node-mitmproxy启动端口: 9888</span><br><span class="line">浏览器打开 ---&gt; http:&#x2F;&#x2F;127.0.0.1:50389</span><br></pre></td></tr></table></figure>

<p>最后一步，设置手机代理：<code>10.200.24.46</code>，端口号：<code>9888</code>。补充说明一下：</p>
<ul>
<li><code>Android</code> 设置代理步骤：设置 - <code>WLAN</code> - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动</li>
<li><code>iOS</code> 设置代理步骤：设置 - 无线局域网 - 选中网络 - <code>HTTP</code> 代理手动</li>
</ul>
<p>接下来，尝试一下抓包：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGfV4YjUQtJvCcz3YCmZlY3X2Uias1BVcD8dVfIxmAQEsuXu3hTRkgUQg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>再打开调试页面：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGWib9eta6RUGqoIDZ7ezGblAEC5ocWshv0GiavhfJlGsn08pbrYD9MXaw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p><code>HTTPS</code> 抓包，需要安装根证书，下文会详细说明。</p>
</blockquote>
<h3 id="五、Whistle"><a href="#五、Whistle" class="headerlink" title="五、Whistle"></a>五、Whistle</h3><p>上面推荐了一款操作简单的调试利器，升级一下，看看更加强大的调试工具 <code>whistle</code>。</p>
<blockquote>
<p>whistle：基于 <code>Node</code> 实现的跨平台 <code>Web</code> 调试代理工具。</p>
</blockquote>
<p><code>whistle</code>(读音[ˈwɪsəl]，拼音[wēisǒu])是基于 <code>Node</code>实现的跨平台抓包调试代理工具，有以下基本功能：</p>
<ol>
<li>查看 <code>HTTP</code>、<code>HTTPS</code>请求响应内容</li>
<li>查看 <code>WebSocket</code>、<code>Socket</code> 收发的帧数据</li>
<li>设置请求 <code>hosts</code>、上游 <code>http/socks</code> 代理</li>
<li>修改请求 <code>url</code> 、方法、头部、内容</li>
<li>修改响应状态码、头部、内容，并支持本地替换</li>
<li>修改 <code>WebSocket</code> 或 <code>Socket</code> 收发的帧数据</li>
<li>内置调试移动端页面的 <code>weinre</code> 和 <code>log</code></li>
<li>作为 <code>HTTP</code> 代理或反向代理</li>
<li>支持用 <code>Node</code> 编写插件扩展功能</li>
</ol>
<p>大致了解后，我们来尝试安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install -g whistle</span><br></pre></td></tr></table></figure>

<blockquote>
<p>淘宝镜像：npm install whistle -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</blockquote>
<p><code>whistle</code> 安装完成后，执行命令 <code>whistle help</code> 或 <code>w2 help</code>，查看 <code>whistle</code> 的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run       Start a front service</span><br><span class="line">start     Start a background service</span><br><span class="line">stop      Stop current background service</span><br><span class="line">restart   Restart current background service</span><br><span class="line">help      Display help information</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里只列出部分命令，更多请 w2 help 查看。</p>
</blockquote>
<p>看到上面的操作，我们何不试试缩写 <code>w2 start</code> 来启动服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w2 start</span><br></pre></td></tr></table></figure>

<p>看到如下的输出，说明服务已经正常启动了：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGYCUTtVOiakJN9LoAJGSe0Q3aEyiaZEAYibuDmzN9valO3tHbcKkKSicpWw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>这时候在浏览器打开链接，同时手机上配置代理（同 <code>Charles</code>），接下来就可以愉快的调试了。值得注意的是，<code>whistle</code> 的功能远非如此，更多的扩展请移步官网文档，贴张图先预览下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPG43iak9r6lQ2cO908NJdTN6JnOe9zJyzlicYRUMTibTNWaZMyR9zM6FWoA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p>记得开启拦截 <code>HTTPS</code>：勾选 <code>Capture HTTPS CONNECTs</code></p>
</blockquote>
<h3 id="六、安装-HTTPS-证书"><a href="#六、安装-HTTPS-证书" class="headerlink" title="六、安装 HTTPS 证书"></a>六、安装 HTTPS 证书</h3><p>对于 <code>Charles</code>，按照如下操作安装证书：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help-SSL - Proxying - install Charles root</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGTRe4npicqmibG2ZKhicTib5U30I0Ia2lzLZEH5uAbACwuYzbLStxuv3faA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>弹出安装证书的提示框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGMtQl9rGd7vdP2juoK81CS8oreAdqia1zwfAFzEPjwOyLpUNR52AftnQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p>按照提示去手机浏览器打开：<code>chls.pro/ssl</code>，安装信任证书即可。</p>
</blockquote>
<p>对于 <code>spy-debugger</code>，<code>HTTPS</code> 抓包，需要安装根证书，选择 <code>RootCA</code>，扫描二维码按照提示信任证书。安装证书的时候需要注意以下几件事情：</p>
<p>1.手机必须先设置完代理后再通过(非微信)手机浏览器访问 <code>http://s.xxx</code> (地址二维码)安装证书；<br>2.手机首次调试需要安装证书，已安装了证书的手机无需重复安装；<br>3.手机和 <code>PC</code> 保持在同一网络下（比如同时连到一个 <code>WIFI</code> 下）；</p>
<blockquote>
<p>切记：移动设备和 PC 必须在一个 WIFI 下。</p>
</blockquote>
<h3 id="七、真机调试"><a href="#七、真机调试" class="headerlink" title="七、真机调试"></a>七、真机调试</h3><p>上面说了很多，但是实际开发过程中，我们不会等上线了才去验证兼容性，所以你可能需要提前「真机调试」。这里提供两种方式：</p>
<blockquote>
<p><code>Chrome Remote Devices</code>：依赖 Chrome 来进行远程调试，适合安卓手机。</p>
</blockquote>
<p>首先，开启 <code>Android</code> 手机的「开发者选项」，勾选 「USB 调试」。<br>然后，<code>Chrome</code> 中输入：<code>chrome://inspect</code>，进入调试页面。</p>
<p>很全面的一篇文章，可以参考：Chrome 远程调试。</p>
<blockquote>
<p><code>localhost</code> 转 <code>ip</code>，扫描二维码手机显示，这个比较简单。</p>
</blockquote>
<p>可以在浏览器安装一个 <code>Chrome</code> 插件，用于将当前页面链接转换成二维码，这样就能边开发边真机预览，非常方便。</p>
<h3 id="八、调试工具"><a href="#八、调试工具" class="headerlink" title="八、调试工具"></a>八、调试工具</h3><p>这里推荐一款调试工具：vConsole，一个轻量、可拓展、针对手机网页的前端开发者调试面板。安装很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure>

<p>如果未使用 <code>AMD/CMD</code> 规范，可直接在 <code>HTML</code> 中引入 <code>vConsole</code> 模块。为了便于后续扩展，建议在 <code>&lt;head&gt;</code> 中引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;path&#x2F;to&#x2F;vconsole.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"> var vConsole &#x3D; new VConsole();</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>

<p>如果使用了 <code>AMD/CMD</code> 规范，可在 <code>module</code> 内使用 <code>require()</code> 引入模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var VConsole &#x3D; require(&#39;path&#x2F;to&#x2F;vconsole.min.js&#39;);</span><br><span class="line">var vConsole &#x3D; new VConsole();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，<code>VConsole</code> 只是 <code>vConsole</code> 的原型，而非一个已实例化的对象。</p>
</blockquote>
<p>所以在手动 <code>new</code> 实例化之前，<code>vConsole</code> 不会被插入到网页中。大概功能如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGgpGJKoNJU52RPRqRoTQk3icaicDxjQLLXCb3mjcsHxfr2xtOmucVKbLg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGf2t3W9eBQjBN03LB7ebQ5y6FAKypnUiboCic162ELGIUTg6xktpz167w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>看起来很完美，但是有个小缺点：网络请求，需要刷新页面，可是很多内嵌的 <code>H5</code> 页面是没有机会刷新页面的，所以需要客户端童鞋配合增加刷新的功能方便调试。</p>
<h3 id="九、场景分析"><a href="#九、场景分析" class="headerlink" title="九、场景分析"></a>九、场景分析</h3><blockquote>
<p>既然移动端调试有这么多种方案，那在实际操作中，我该如何取舍？</p>
</blockquote>
<p>说了这么多钟方案，这里总结一下各个方案的适用场景，根据不同的场景去选择最佳的调试方案，这样才能更快速的输出，<code>Carry</code> 全场：</p>
<p>1.<code>Safari</code>：<code>iPhone</code> 调试利器，查错改样式首选；<br>2.<code>iOS</code> 模拟器：不需要真机，适合调试 <code>Webview</code> 和 <code>H5</code> 有频繁交互的功能页面；<br>3.<code>Charles</code>：<code>Mac OS</code> 系统首选的抓包工具，适合查看、控制网络请求，分析数据情况；<br>4.<code>Fiddler</code>：适合 <code>Windows</code> 平台，与 <code>Charles</code> 类似，查看、控制网络请求，分析数据情况；<br>5.<code>Spy-Debugger</code>：移动端调试的利器，便捷的远程调试手机页面、抓包工具；<br>6.<code>Whistle</code>：基于 <code>Node</code> 实现的跨平台 <code>Web</code> 调试代理工具；<br>7.<code>Chrome Remote Devices</code>：依赖 <code>Chrome</code> 来进行远程调试，适合安卓手机远程调试静态页；<br>8.<code>localhost</code> 转 <code>ip</code>：真机调试，适合远程调试静态页面；<br>9.<code>vConsole</code>：内置于项目，打印移动端日志，查看网络请求以及查看 <code>Cookie</code> 和 <code>Storage</code>；</p>
<h3 id="十、白屏处理"><a href="#十、白屏处理" class="headerlink" title="十、白屏处理"></a>十、白屏处理</h3><blockquote>
<p>移动端的白屏是最头疼的问题，这里顺带提供几种分析问题的思路，以供参考。</p>
</blockquote>
<p><strong>1.方案分析 ☆</strong></p>
<p>一般上线后出现问题，我们最容易想到的就是：是否是新代码引起的问题。所以有效解决手段就是「控制变量法」。</p>
<p><strong>2.代码注释法 ☆</strong></p>
<p>莫名奇妙的白屏，适合页面无异常日志，同时无请求发送，问题集中在单一页面的情况。这种问题比较直观，肯定是某一页面出现了代码异常或是无效的 <code>return</code>，导致页面渲染终止，但并不属于异常。这时候，「代码注释法」将是你的最佳选择，逐行去注释可以代码，直到定位问题。</p>
<p><strong>3.类库异常，兼容问题 ☆</strong></p>
<p>这种场景也会经常遇到，我们需要用可以调试页面异常的方式，如 <code>Safari</code>，<code>Spy-Debugger</code>，<code>Whistle</code>，<code>vConsole</code> 查看异常日志，从而迅速定位类库位置，从而找寻替换或是兼容方案。</p>
<p><strong>4.try catch ☆☆</strong></p>
<p>如果你的项目没有异常监控，那么在可疑的代码片段中去 <code>Try Catch</code> 吧。</p>
<p><strong>5.Debug 包 ☆☆☆</strong></p>
<p>在你的项目中装上 <code>[vConsole](https://link.zhihu.com/?target=http%3A//jartto.wang/2018/11/01/mobile-debug/)</code>，并配合客户端 <code>debug</code> 插件，<code>360</code> 度无死角监控异常，这才是最有效的方式。</p>
<p><strong>6.ES6 语法兼容 ☆</strong></p>
<p>一般我们都会通过 <code>Babel</code> 来编译 <code>ES6</code> ，但是额外的第三方类库如果有不兼容的语法，低版本的移动设备就会异常。所以，先用上文讲述的调试方法，确定异常，然后去增加 <code>[polyfill](https://link.zhihu.com/?target=https%3A//polyfill.io/v2/docs/examples)</code> 来兼容吧。</p>
<p>参考链接：<a href="https://mp.weixin.qq.com/s/eUDhoFh7GhdY2oGoSnD88Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eUDhoFh7GhdY2oGoSnD88Q</a></p>
]]></content>
      <categories>
        <category>移动端调试</category>
      </categories>
      <tags>
        <tag>移动端调试</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5</title>
    <url>/2020/07/22/HTML5/</url>
    <content><![CDATA[<h3 id="h5知识点整理"><a href="#h5知识点整理" class="headerlink" title="h5知识点整理"></a>h5知识点整理</h3><blockquote>
<ol>
<li>任何class和id里都不能包含”ad” 这个关键字,否则会被一些广告屏蔽软件给过滤了</li>
</ol>
</blockquote>
<a id="more"></a>

<blockquote>
<ol start="2">
<li><input type="tel" placeholder="输入手机号" pattern="1[3-8][0-9]{9}" title="输入正确的手机号">
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><meter min="0" low="40" high="90" max="100" value="95"></meter></li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><p contenteditable="true">这里的内容可以编辑</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li><p>使用input数字number类型的时候maxlength无效，假设需要控制输入数量为5，可以用以下方式：</p>
<p>无效： <input type="number" maxlength="5"></p>
<p>有效：<input type="number" oninput="if(value.length>5)value=value.slice(0,5)"> </p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li><p>tel、email</p>
<p>例如说当type=tel的时候,在手机上打开页面会出现电话键盘(不是数字键盘,两者并不一样,电话键盘还包括*和#)</p>
<p>当type=email的时候,会出现带@和.com符号的全键盘(各设配各系统实现貌似有差异)</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="7">
<li><a href="http://www.baidu.com/link?url=gFF8MX53uYP6kl_JnWUbWmEEIn6gA5irf5C_fBWwLtTEccOmxfwGpe899O79mYaM" target="_blank" rel="noopener">HTML页面顶部出现空白部分(&amp;#65279)字符的完美解决办法</a></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;	</span><br><span class="line">   <span class="keyword">var</span> a=<span class="built_in">document</span>.body.innerHTML;   </span><br><span class="line">   <span class="built_in">document</span>.body.innerHTML=a.replace(<span class="regexp">/\ufeff/g</span>,<span class="string">''</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="8">
<li><p>ios的readonly不兼容</p>
<p>unselectable=”on” onfocus=”this.blur()”</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="9">
<li><p>form表单获取input</p>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/2bb1822c99ae4a2c8ea984da3389235a/clipboard.png" alt="img"></p>
<p>document.tmform.tmtext.value</p>
<p>document.tmform.halou.value</p>
</li>
</ol>
</blockquote>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/379f847913f84ae7b460e3cbbad01e88/clipboard.png" alt="img"></p>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/9899b3677e414966a858ad82672e734f/clipboard.png" alt="img"></p>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/822799eecfd840f984dceb5711939da9/clipboard.png" alt="img"></p>
<p>select</p>
<p><img src="/2020/07/22/HTML5/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/df2aea69272c4df2bf5e36c37900c36f/clipboard.png" alt="img"></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/08/06/Promise/</url>
    <content><![CDATA[<p>本质上Promise是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</p>
<p>假设现在有一个名为 <code>createAudioFileAsync()</code> 的函数，它接收一些配置和两个回调函数，然后异步地生成音频文件。一个回调函数在文件成功创建时的被调用，另一个则在出现异常时的被调用。</p>
<p>以下为使用 <code>createAudioFileAsync()</code> 的示例：</p>
<a id="more"></a>

<h3 id="promise定义和用法"><a href="#promise定义和用法" class="headerlink" title="promise定义和用法"></a>promise定义和用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 成功的回调函数</span><br><span class="line">function successCallback(result) &#123;</span><br><span class="line">  console.log(&quot;音频文件创建成功: &quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 失败的回调函数</span><br><span class="line">function failureCallback(error) &#123;</span><br><span class="line">  console.log(&quot;音频文件创建失败: &quot; + error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;普通定义和用法</span><br><span class="line">function createAudioFileAsync(params, successCallback, failureCallback) &#123;</span><br><span class="line">  console.log(params);</span><br><span class="line">  successCallback&amp;&amp;successCallback()</span><br><span class="line">  failureCallback&amp;&amp;failureCallback()</span><br><span class="line">&#125;</span><br><span class="line">createAudioFileAsync(&quot;我是传入参数&quot;, successCallback(&#39;result&#39;), failureCallback(&#39;error&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;promise定义和用法</span><br><span class="line">function createAudioFileAsync(params) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(</span><br><span class="line">      console.log(params)</span><br><span class="line">    )</span><br><span class="line">    reject(</span><br><span class="line">      console.log(&#39;reject--我是拒绝回调&#39;)</span><br><span class="line">    )</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">createAudioFileAsync(&quot;我是传入参数&quot;).then(successCallback(&#39;result&#39;), failureCallback(&#39;error&#39;));</span><br></pre></td></tr></table></figure>

<h3 id="promise链式调用"><a href="#promise链式调用" class="headerlink" title="promise链式调用"></a>promise链式调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在过去，要想做多重的异步操作，会导致经典的回调地狱：</span><br><span class="line">function doSomething(ftc,fail) &#123;</span><br><span class="line">  ftc &amp;&amp; ftc(&#39;doSomething&#39;)</span><br><span class="line">  fail &amp;&amp; fail()</span><br><span class="line">&#125;</span><br><span class="line">function doSomethingElse(ftc, callback, fail) &#123;</span><br><span class="line">  callback &amp;&amp; callback(ftc)</span><br><span class="line">  fail &amp;&amp; fail()</span><br><span class="line">&#125;</span><br><span class="line">function doThirdThing(ftc, callback, fail) &#123;</span><br><span class="line">  callback &amp;&amp; callback(ftc)</span><br><span class="line">  fail &amp;&amp; fail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(function (result) &#123;</span><br><span class="line">  doSomethingElse(result, function (newResult) &#123;</span><br><span class="line">    doThirdThing(newResult, function (finalResult) &#123;</span><br><span class="line">      console.log(finalResult);</span><br><span class="line">    &#125;,failureCallback);</span><br><span class="line">  &#125;,failureCallback);</span><br><span class="line">&#125;,failureCallback);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;现在，我们可以把回调绑定到返回的 Promise 上，形成一个 Promise 链：</span><br><span class="line">function doSomething() &#123;</span><br><span class="line">  return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    resolve(&#39;doSomething&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function doSomethingElse(name) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(name + &#39;1&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function doThirdThing(name) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(name + &#39;2&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">doSomething().then(function (result) &#123;</span><br><span class="line">  return doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(function (newResult) &#123;</span><br><span class="line">    return doThirdThing(newResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (finalResult) &#123;</span><br><span class="line">    console.log(&#39;Got the final result: &#39; + finalResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(failureCallback);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">doSomething().then(result&#x3D;&gt; &#123;</span><br><span class="line">  return doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(newResult&#x3D;&gt; &#123;</span><br><span class="line">    return doThirdThing(newResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(finalResult&#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;Got the final result: &#39; + finalResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(failureCallback);</span><br><span class="line"></span><br><span class="line">() &#x3D;&gt; x 是 () &#x3D;&gt; &#123; return x; &#125;的简写</span><br></pre></td></tr></table></figure>



<h3 id="Pomise-all的使用"><a href="#Pomise-all的使用" class="headerlink" title="Pomise.all的使用"></a>Pomise.all的使用</h3><p>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</p>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&#39;成功了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&#39;success&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p3 &#x3D; Promise.reject(&#39;失败&#39;)</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)               &#x2F;&#x2F;[&#39;成功了&#39;, &#39;success&#39;]</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.all([p1,p3,p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)      &#x2F;&#x2F; 失败了，打出 &#39;失败&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>Promse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。</strong></p>
<ul>
<li>代码模拟：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let wake &#x3D; (time) &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(&#96;$&#123;time &#x2F; 1000&#125;秒后醒来&#96;)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 &#x3D; wake(3000)</span><br><span class="line">let p2 &#x3D; wake(2000)</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)       &#x2F;&#x2F; [ &#39;3秒后醒来&#39;, &#39;2秒后醒来&#39; ]</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</strong></p>
<h3 id="Promise-race的使用"><a href="#Promise-race的使用" class="headerlink" title="Promise.race的使用"></a>Promise.race的使用</h3><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;success&#39;)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    reject(&#39;failed&#39;)</span><br><span class="line">  &#125;, 500)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.race([p1, p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)  &#x2F;&#x2F; 打开的是 &#39;failed&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise</tag>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vs</title>
    <url>/2020/07/15/Vs/</url>
    <content><![CDATA[<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>1.复制/剪切/删除整行代码</p>
<blockquote>
<p>1)如果你想复制一整行代码，只需将光标移至该行，再使用组合键“Ctrl+C”来完成复制操作，而无需选择整行。</p>
<p>2)如果你想剪切一整行代码，只需将光标移至该行，再使用组合键“Ctrl+X”来完成剪切操作，而无需选择整行。</p>
<p>3)如果你想删除一整行代码，只需将光标移至该行，再使用组合键“Ctrl+L”来完成剪切操作，而无需选择整行。</p>
</blockquote>
<p>2.撤销/反撤销</p>
]]></content>
      <categories>
        <category>vs</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>tool</tag>
        <tag>vs</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode</title>
    <url>/2020/07/15/VsCode/</url>
    <content><![CDATA[<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><blockquote>
<p>官网下载：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p>
</blockquote>
<a id="more"></a>

<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><blockquote>
<p>*<em>Alt+Z *</em>  (文件自动换行)</p>
<p><strong>Ctrl + /**</strong> （单行注释）</p>
<p>*<em>Shift + Alt + A *</em>（多行注释） 若要取消单行或多行注释在按一次该快捷键即可</p>
<p><strong>Ctrl + Shift + Enter</strong> （上方插入一行，鼠标光标在当前行的任意位置都可以直接换行到上一行）</p>
<p>*<em>Ctrl + Enter *</em>（下方插入一行，鼠标光标在当前行的任意位置都可以直接换行到下一行）</p>
<p>*<em>Alt + Shift + F *</em>（格式化代码，不需要全选中代码，直接格式化即可）</p>
<p>*<em>Ctrl + Shift + F *</em>（查找文件）</p>
<p>*<em>Ctrl + Shift + T *</em>（重新打开最近关闭的窗口）</p>
<p><strong>Ctrl + p</strong>右边会弹出所有快捷键目录</p>
<p><strong>Ctrl + Shift + [</strong>   (代码折叠)</p>
<p><strong>Ctrl + Shift + ]</strong>  (代码展开)</p>
<p>*<em>Shift + Alt + Up/Down *</em> （向上/向下 复制行）</p>
<p><strong>Ctrl + backspace</strong> （删除上一个单词）</p>
<p><strong>F2</strong>  (对当前文件某一个单词全部重命名，上下文中的引用都会被重命名)</p>
<p><strong>ctrl+F2</strong>  (找到当前文件所有某个单词，光标处于单词的末尾)</p>
<p>*<em>多行转一行 *</em>（选中，ctrl+shift+p 输入 join lines，点击设置可以设置快捷键alt+q）</p>
<p><strong>去掉尾随空格</strong></p>
<p><img src="/2020/07/15/VsCode/C:%5CUsers%5Cdali%5CDesktop%5C%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210205094421.jpg" alt="微信图片_20210205094421"></p>
</blockquote>
<h4 id="code改成中文"><a href="#code改成中文" class="headerlink" title="code改成中文"></a>code改成中文</h4><blockquote>
<p>方法一：点击插件按钮搜索 Chinese</p>
<p>方法二：</p>
<p>1）打开vscode工具；</p>
<p>2）使用快捷键组合【Ctrl+Shift+p】，在搜索框中输入“configure display language”，点击确定后；</p>
<p>3）修改locale.json文件下的属性“locale”为“zh-CN”;</p>
<p>4）重启vscode工具；</p>
<p>或者 汉化中文（插件）</p>
<p>点击插件按钮搜索 Chinese, 在弹出的选项中选择第一个中文简体</p>
<p>然后右边会弹出如下图安装界面，接着点击 Install 安装</p>
</blockquote>
<h4 id="自动保存设置"><a href="#自动保存设置" class="headerlink" title="自动保存设置"></a>自动保存设置</h4><blockquote>
<p>File（文件）- Preferences（首选项）- Setting （设置）然后弹出下面界面，选择User（一般会默认选中该选项）， </p>
<p>接着如下图选择afterdelay选项即可，下面有个数字1000表示1秒，这个可自行设置，表示多少秒以后自动保存</p>
</blockquote>
<h4 id="自动格式化代码"><a href="#自动格式化代码" class="headerlink" title="自动格式化代码"></a>自动格式化代码</h4><blockquote>
<p>File（文件）- Preferences（首选项）- Setting （设置）</p>
<p>User（用户）- Text-Editor（文本编辑）- Formatng（格式化）</p>
<p>然后勾选下图红色框中的选项后重启Vscode即可</p>
</blockquote>
<h4 id="Vscode更换主题"><a href="#Vscode更换主题" class="headerlink" title="Vscode更换主题"></a>Vscode更换主题</h4><blockquote>
<p>File（文件）- Preferences（首选项）- Color-Theme （颜色主题）</p>
<p>然后会出现下图红色框的界面，此时按键盘上的上下键即可实时查看主题颜色，直接回车可选中对应主题</p>
<p>注：可以点击插件直接搜索 theme 下载其它非内置主题</p>
</blockquote>
<h4 id="隐藏文件夹"><a href="#隐藏文件夹" class="headerlink" title="隐藏文件夹"></a>隐藏文件夹</h4><h5 id="1-点击快捷键Ctrl-Command-Shift-P，输入setting，选择User-Settings那一项；"><a href="#1-点击快捷键Ctrl-Command-Shift-P，输入setting，选择User-Settings那一项；" class="headerlink" title="1. 点击快捷键Ctrl/Command+Shift+P，输入setting，选择User Settings那一项；"></a>1. 点击快捷键Ctrl/Command+Shift+P，输入setting，选择User Settings那一项；</h5><p><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531092521602-901731205.png" alt="按快捷键Ctrl/Command+Shift+P"><br><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531092631020-909971842.png" alt="选择User Settings"></p>
<h5 id="2-点击VS-Code右上角的小图标查看脚本："><a href="#2-点击VS-Code右上角的小图标查看脚本：" class="headerlink" title="2. 点击VS Code右上角的小图标查看脚本："></a>2. 点击VS Code右上角的小图标查看脚本：</h5><p><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531092822279-1906753004.png" alt="点击小图标"><br><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531092939851-854795479.png" alt="查看脚本"></p>
<h5 id="3-在该脚本中，添加排除文件或排除文件夹的代码："><a href="#3-在该脚本中，添加排除文件或排除文件夹的代码：" class="headerlink" title="3. 在该脚本中，添加排除文件或排除文件夹的代码："></a>3. 在该脚本中，添加排除文件或排除文件夹的代码：</h5><p><img src="https://img2020.cnblogs.com/blog/1991547/202005/1991547-20200531093027056-1932271038.png" alt="示例"></p>
<h5 id="4-如果是隐藏指定后缀的文件，使用”-你要隐藏的文件后缀”-；如果是隐藏指定的文件夹，使用”-你要隐藏的文件夹名称”即可实现。详情如下："><a href="#4-如果是隐藏指定后缀的文件，使用”-你要隐藏的文件后缀”-；如果是隐藏指定的文件夹，使用”-你要隐藏的文件夹名称”即可实现。详情如下：" class="headerlink" title="4. 如果是隐藏指定后缀的文件，使用”/*.你要隐藏的文件后缀” ；如果是隐藏指定的文件夹，使用”/你要隐藏的文件夹名称”即可实现。详情如下："></a>4. 如果是隐藏指定后缀的文件，使用”<strong>/*.你要隐藏的文件后缀” ；如果是隐藏指定的文件夹，使用”</strong>/你要隐藏的文件夹名称”即可实现。详情如下：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;files.exclude&quot;: &#123;</span><br><span class="line">    &quot;*.metadata&quot;: true,</span><br><span class="line">    &quot;*.settings&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.pyc&quot;: true, &#x2F;&#x2F;隐藏所有pyc文件</span><br><span class="line">    &quot;**&#x2F;*.meta&quot;: true, &#x2F;&#x2F;隐藏所有meta文件</span><br><span class="line">    &quot;**&#x2F;*.prefab&quot;: true, &#x2F;&#x2F;隐藏所有prefab文件</span><br><span class="line">    &quot;**&#x2F;*.d.ts&quot;: true, &#x2F;&#x2F;隐藏所有d.ts文件</span><br><span class="line">    &quot;**&#x2F;*.fnt&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.sln&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.csproj&quot;: true,</span><br><span class="line">    &quot;**&#x2F;.vscode&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.anim&quot;: true,</span><br><span class="line">    &quot;**&#x2F;*.controller&quot;: true,</span><br><span class="line">    &quot;**&#x2F;Logs&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Pp]lugins&quot;: true, &#x2F;&#x2F;使用中括号时表示不区分大小写</span><br><span class="line">    &quot;**&#x2F;[Mm]aterials&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Aa]nimation&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Pp]ackages&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Tt]extures&quot;: true,</span><br><span class="line">    &quot;**&#x2F;[Ss]cenes&quot;: true,</span><br><span class="line">    &quot;**&#x2F;temp&quot;: true, &#x2F;&#x2F;隐藏temp文件夹</span><br><span class="line">    &quot;**&#x2F;library&quot;: true, &#x2F;&#x2F;隐藏library文件夹</span><br><span class="line">    &quot;**&#x2F;audio&quot;: true, &#x2F;&#x2F;隐藏audio文件夹</span><br><span class="line">    &quot;**&#x2F;video&quot;: true, &#x2F;&#x2F;隐藏video文件夹</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vscode-Tab补齐代码设置"><a href="#vscode-Tab补齐代码设置" class="headerlink" title="vscode Tab补齐代码设置"></a>vscode Tab补齐代码设置</h4><p><strong>步骤1：</strong><br>进入vscode里面 =&gt; 文件 =&gt; 首选项 =&gt; 设置=&gt; 工作台=&gt; 外观 =&gt; 在settings.json中编辑 进入编辑状态</p>
<p><strong>步骤2：</strong></p>
<p>添加这个之后保存即可<br>{<br>“emmet.triggerExpansionOnTab”:true<br>}</p>
<h4 id="console-log快捷键"><a href="#console-log快捷键" class="headerlink" title="console.log快捷键"></a>console.log快捷键</h4><ol>
<li>打开vscode,选择文件–首选项–用户代码片段</li>
<li>选择javascript类型，打开javascript.json文件</li>
<li>按照操作，设置快捷输入</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"Print to console"</span>: &#123;</span><br><span class="line">			<span class="string">"prefix"</span>: <span class="string">"lg"</span>,</span><br><span class="line">			<span class="string">"body"</span>: [</span><br><span class="line">				<span class="string">"console.log('$1');"</span>,</span><br><span class="line">			],</span><br><span class="line">			<span class="string">"description"</span>: <span class="string">"Log output to console"</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="VSCODE快速生成标签"><a href="#VSCODE快速生成标签" class="headerlink" title="VSCODE快速生成标签"></a>VSCODE快速生成标签</h4><h5 id="1、添加类、id、文本和属性"><a href="#1、添加类、id、文本和属性" class="headerlink" title="1、添加类、id、文本和属性"></a>1、添加类、id、文本和属性</h5><p>（1）输入 .box</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>（2）输入p#text</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;text&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>（3）类和id一起输入 .box #text</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;box&quot; class&#x3D;&quot;text&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>（4）元素和内容一块输出 p{你好}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;你好&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>（5）输出属性 a[href=#]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a&gt;href&#x3D;&quot;#&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>（6）给后代设置class1 ul&gt;.calss</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;calss&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p>（7）给后代设置class2 table&gt;.row&gt;.col</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;col&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>



<h5 id="2、同级和嵌套"><a href="#2、同级和嵌套" class="headerlink" title="2、同级和嵌套"></a>2、同级和嵌套</h5><p>（1）输入div+p(同级标签)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;p&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>（2）输入ul&gt;li*3&gt;a（嵌套标签）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>



<h5 id="3、分组"><a href="#3、分组" class="headerlink" title="3、分组"></a>3、分组</h5><p>可以通过嵌套和括号来快速生成一些代码块(.foo&gt;h1)+(.bar&gt;h2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;bar&quot;&gt;</span><br><span class="line">    &lt;h2&gt;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h5 id="4、定义多个带属性的元素"><a href="#4、定义多个带属性的元素" class="headerlink" title="4、定义多个带属性的元素"></a>4、定义多个带属性的元素</h5><p>（1）输入ul&gt;li.item$*3，代码输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item1&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item2&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;item3&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p>（2）自增符$ div.class&gt;div.class1_$*5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;class&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_3&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_4&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_5&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>（3）自增 从某数开始 div.class&gt;div.class1_$@3*4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;class&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_3&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_4&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_5&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_6&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>（4）自减 从某数开始 div.class&gt;div.class1_$@-3*4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;class&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_6&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_5&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_4&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;class1_3&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>tool</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue数据更新但页面没有更新的7种情况</title>
    <url>/2020/09/10/Vue%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BD%86%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%E7%9A%847%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h3 id="Vue-set与-vue-set在使用中的区别-delete和this-delete"><a href="#Vue-set与-vue-set在使用中的区别-delete和this-delete" class="headerlink" title="Vue.set与 vue.$set在使用中的区别(delete和this.$delete)"></a>Vue.set与 vue.$set在使用中的区别(delete和this.$delete)</h3><p>Vue.set 可以设置实例创建之后添加的属性，如sex，而this.$set/vue.$set/vm.$set只能设置实例创建后存在的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    name: <span class="string">"简书"</span>,</span><br><span class="line">    age: <span class="string">'3'</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">        content: <span class="string">'my name is test'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">var</span> key = <span class="string">'content'</span>;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data: data,</span><br><span class="line">    ready: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Vue.set(data,<span class="string">'sex'</span>, <span class="string">'男'</span>)</span><br><span class="line">        <span class="keyword">this</span>.$<span class="keyword">set</span>('sex', '女')</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Vue-无法检测对象-property-的添加或移除"><a href="#Vue-无法检测对象-property-的添加或移除" class="headerlink" title="Vue 无法检测对象 property 的添加或移除"></a>Vue 无法检测对象 property 的添加或移除</h3><p>原因：官方 - 由于 JavaScript（ES5） 的限制，Vue.js <strong>不能检测到对象属性的添加或删除</strong>。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 <code>data</code> 对象上才能让 Vue.js 转换它，才能让它是响应的。</p>
<p>场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      id: 001</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 页面不会变化</span><br><span class="line">  template: &#39;&lt;div&gt; obj.message &lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.obj.message &#x3D; &#39;hello&#39; &#x2F;&#x2F; 不是响应式的</span><br><span class="line">delete vm.obj.id       &#x2F;&#x2F; 不是响应式的</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态添加 - Vue.set</span><br><span class="line">Vue.set(vm.obj, propertyName, newValue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态添加 - vm.$set</span><br><span class="line">vm.$set(vm.obj, propertyName, newValue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态添加多个</span><br><span class="line">&#x2F;&#x2F; 代替 Object.assign(this.obj, &#123; a: 1, b: 2 &#125;)</span><br><span class="line">this.obj &#x3D; Object.assign(&#123;&#125;, this.obj, &#123; a: 1, b: 2 &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态移除 - Vue.delete</span><br><span class="line">Vue.delete(vm.obj, propertyName)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态移除 - vm.$delete</span><br><span class="line">vm.$delete(vm.obj, propertyName)</span><br></pre></td></tr></table></figure>


<h3 id="Vue-不能检测通过数组索引直接修改一个数组项"><a href="#Vue-不能检测通过数组索引直接修改一个数组项" class="headerlink" title="Vue 不能检测通过数组索引直接修改一个数组项"></a>Vue 不能检测通过数组索引直接修改一个数组项</h3><p>原因：官方 - 由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化；尤雨溪 - 性能代价和获得用户体验不成正比。</p>
<p>场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[1] &#x3D; &#39;x&#39; &#x2F;&#x2F; 不是响应性的</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue.set</span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; vm.$set</span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>



<h3 id="Vue-不能监测直接修改数组长度的变化"><a href="#Vue-不能监测直接修改数组长度的变化" class="headerlink" title="Vue 不能监测直接修改数组长度的变化"></a>Vue 不能监测直接修改数组长度的变化</h3><p>原因：官方 - 由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化；尤雨溪 - 性能代价和获得用户体验不成正比。</p>
<p>场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items.length &#x3D; 2 &#x2F;&#x2F; 不是响应性的</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>



<h3 id="在异步更新执行之前操作-DOM-数据不会变化-nextTick"><a href="#在异步更新执行之前操作-DOM-数据不会变化-nextTick" class="headerlink" title="在异步更新执行之前操作 DOM 数据不会变化(nextTick)"></a>在异步更新执行之前操作 DOM 数据不会变化(nextTick)</h3><p>原因：Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>
<p>场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;123&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message &#x3D; &#39;new message&#39; &#x2F;&#x2F; 更改数据</span><br><span class="line">vm.$el.textContent &#x3D;&#x3D;&#x3D; &#39;new message&#39; &#x2F;&#x2F; false</span><br><span class="line">vm.$el.style.color &#x3D; &#39;red&#39; &#x2F;&#x2F; 页面没有变化</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;123&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message &#x3D; &#39;new message&#39; &#x2F;&#x2F; 更改数据</span><br><span class="line">&#x2F;&#x2F;使用 Vue.nextTick(callback) callback 将在 DOM 更新完成后被调用</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  vm.$el.textContent &#x3D;&#x3D;&#x3D; &#39;new message&#39; &#x2F;&#x2F; true</span><br><span class="line">  vm.$el.style.color &#x3D; &#39;red&#39; &#x2F;&#x2F; 文字颜色变成红色</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>数据更新</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2020/09/14/WebSocket/</url>
    <content><![CDATA[<h2 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a><strong>什么是WebSocket</strong></h2><p>首先需要明白webSocket的概念，下边是维基百科的解释</p>
<blockquote>
<p>WebSocket是一种通信协议，可在单个TCP连接上进行全双工通信。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以建立持久性的连接，并进行双向数据传输。</p>
</blockquote>
<p>首先，要明白WebSocket是一种通信协议，区别于HTTP协议，HTTP协议只能实现客户端请求，服务端响应的这种单项通信。<br>而WebSocket可以实现客户端与服务端的双向通讯，说白了，最大也是最明显的区别就是可以做到服务端主动将消息推送给客户端。<br>其余的特点有：</p>
<ul>
<li>握手阶段采用 HTTP 协议。</li>
<li>数据格式轻量，性能开销小。客户端与服务端进行数据交换时，服务端到客户端的数据包头只有2到10字节，客户端到服务端需要加上另外4字节的掩码。HTTP每次都需要携带完整头部。</li>
<li>更好的二进制支持，可以发送文本，和二进制数据</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则是wss），请求的地址就是后端支持websocket的API。</li>
</ul>
<a id="more"></a>

<h2 id="几种与服务端实时通信的方法"><a href="#几种与服务端实时通信的方法" class="headerlink" title="几种与服务端实时通信的方法"></a><strong>几种与服务端实时通信的方法</strong></h2><p>我们都知道，不使用WebSocket与服务器实时交互，一般有两种方法。AJAX轮询和Long Polling长轮询。</p>
<h3 id="AJAX轮询"><a href="#AJAX轮询" class="headerlink" title="AJAX轮询"></a><strong>AJAX轮询</strong></h3><p>AJAX轮询也就是定时发送请求，也就是普通的客户端与服务端通信过程，只不过是无限循环发送，这样，可以保证服务端一旦有最新消息，就可以被客户端获取。</p>
<h3 id="Long-Polling长轮询"><a href="#Long-Polling长轮询" class="headerlink" title="Long Polling长轮询"></a><strong>Long Polling长轮询</strong></h3><p>客户端发起一个Long Polling，服务端如果没有数据要返回的话，<br>会hold住请求，等到有数据，就会返回给客户端。客户端又会再次发起一次Long Polling，再重复一次上面的过程。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>上边这两种方式都有个致命的弱点，开销太大，被动性。假设并发很高的话，这对服务端是个考验。<br>而WebSocket一次握手，持久连接，以及主动推送的特点可以解决上边的问题，又不至于损耗性能。</p>
<h2 id="WebSocket连接过程"><a href="#WebSocket连接过程" class="headerlink" title="WebSocket连接过程"></a><strong>WebSocket连接过程</strong></h2><p>客户端发起HTTP握手，告诉服务端进行WebSocket协议通讯，并告知WebSocket协议版本。服务端确认协议版本，升级为WebSocket协议。之后如果有数据需要推送，会主动推送给客户端。</p>
<p>连接开始时，客户端使用HTTP协议和服务端升级协议，升级完成后，后续数据交换遵循WebSocket协议。我们看看Request Headers</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: 127.0.0.1:3000</span><br><span class="line">Origin: http://localhost:3000</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br><span class="line">Sec-WebSocket-Key: bwb9SFiJONXhQ/A4pLaXIg==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>重点字段是这些：</p>
<ul>
<li>Connection: Upgrade 表示要升级协议</li>
<li>Upgrade: websocket 要升级协议到websocket协议</li>
<li>Sec-WebSocket-Version 表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li>
<li>Sec-WebSocket-Key 对应服务端响应头的Sec-WebSocket-Accept，由于没有同源限制，websocket客户端可任意连接支持websocket的服务。这个就相当于一个钥匙一把锁，避免多余的，无意义的连接。</li>
</ul>
<p>再看看看服务端响应的 Response Headers</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: 2jrbCWSCPlzPtxarlGTp4Y8XD20=</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>关键是这个字段</p>
<ul>
<li>Sec-WebSocket-Accept: 用来告知服务器愿意发起一个websocket连接， 值根据客户端请求头的Sec-WebSocket-Key计算出来</li>
</ul>
<h2 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a><strong>WebSocket API</strong></h2><p>客户端若想要与支持webScoket的服务器通信，可以使用WebSocket构造函数返回WebSocket对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:3000&#x2F;websocket&quot;);</span><br></pre></td></tr></table></figure>

<p>这样，客户端就会与服务端开始连接。</p>
<p>返回的实例对象的属性：</p>
<ul>
<li>WebSocket.onopen： 连接成功后的回调</li>
<li>WebSocket.onclose： 连接关闭后的回调</li>
<li>WebSocket.onerror： 连接失败后的回调</li>
<li>WebSocket.onmessage： 客户端接收到服务端数据的回调</li>
<li>webSocket.bufferedAmount： 未发送至服务器的二进制字节数</li>
<li>WebSocket.binaryType： 使用二进制的数据类型连接</li>
<li>WebSocket.protocol ： 服务器选择的下属协议</li>
<li>WebSocket.url ： WebSocket 的绝对路径</li>
<li>WebSocket.readyState： 当前连接状态，对应的四个常量</li>
</ul>
<p>WebSocket.CONNECTING: 0</p>
<p>WebSocket.OPEN: 1</p>
<p>WebSocket.CLOSING: 2</p>
<p>WebSocket.CLOSED: 3</p>
<p>方法：</p>
<ul>
<li>WebSocket.close() 关闭当前连接</li>
<li>WebSocket.send(data) 向服务器发送数据</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>讲了那么多概念以后，终于可以看看怎么用了。实现WebSocket通信，需要客户端和服务端配合。</p>
<p>自己写了一个例子，服务端在开始连接后，利用定时器主动向客户端发送随机数，客户端也可以发给服务器消息，然后服务器返回这条消息给客户端。客户端就是js+html，服务端用了express + express-ws来实现。</p>
<p>示例链接：<a href="https://github.com/neroneroffy/webSocketDemo" target="_blank" rel="noopener">https://github.com/neroneroffy/webSocketDemo</a></p>
<h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;判断当前浏览器是否支持WebSocket</span><br><span class="line">if (&#39;WebSocket&#39; in window) &#123;</span><br><span class="line">    var serviceIp &#x3D;&quot;172.168.0.16:8880&quot;;</span><br><span class="line">    this.websocket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;&quot;+serviceIp+&quot;&#x2F;system&#x2F;websocket&quot;);</span><br><span class="line">&#125;else if (&#39;MozWebSocket&#39; in window) &#123;</span><br><span class="line">    var serviceIp &#x3D;&quot;172.168.0.16:8880&quot;;</span><br><span class="line">    this.websocket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;&quot;+serviceIp+&quot;&#x2F;system&#x2F;websocket&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    console.log(&#39;当前浏览器 Not support websocket&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="vue中使用"><a href="#vue中使用" class="headerlink" title="vue中使用"></a>vue中使用</h2><h3 id="sockjs-client"><a href="#sockjs-client" class="headerlink" title="sockjs-client"></a>sockjs-client</h3><p><a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener">sockjs-client</a>是从SockJS中分离出来的用于客户端使用的通信模块.所以我们就直接来看看SockJS. SockJS是一个浏览器的JavaScript库,它提供了一个类似于网络的对象,SockJS提供了一个连贯的,跨浏览器的JavaScriptAPI,它在浏览器和Web服务器之间创建了一个低延迟,全双工,跨域通信通道. 你可能会问,我为什么不直接用原生的WebSocket而要使用SockJS呢?这得益于SockJS的一大特性,一些浏览器中缺少对WebSocket的支持,因此，回退选项是必要的，而Spring框架提供了基于SockJS协议的透明的回退选项。SockJS提供了浏览器兼容性,优先使用原生的WebSocket,如果某个浏览器不支持WebSocket,SockJS会自动降级为轮询.</p>
<h3 id="stomjs"><a href="#stomjs" class="headerlink" title="stomjs"></a>stomjs</h3><p>STOMP(Simple Text-Orientated Messaging Protocol) 面向消息的简单文本协议; WebSocket是一个消息架构,不强制使用任何特定的消息协议,它依赖于应用层解释消息的含义. 与HTTP不同,WebSocket是处在TCP上非常薄的一层,会将字节流转化为文本/二进制消息,因此,对于实际应用来说,WebSocket的通信形式层级过低,因此，可以在 WebSocket 之上使用STOMP协议，来为浏览器 和 server间的 通信增加适当的消息语义。</p>
<p><strong>STOMP与WebSocket 的关系:</strong></p>
<ol>
<li>HTTP协议解决了web浏览器发起请求以及web服务器响应请求的细节,假设HTTP协议不存在,只能使用TCP套接字来编写web应用,你可能认为这是一件疯狂的事情;</li>
<li>直接使用WebSocket(SockJS)就很类似于使用TCP套接字来编写web应用,因为没有高层协议,就需要我们定义应用间发送消息的语义,还需要确保连接的两端都能遵循这些语义;</li>
<li>同HTTP在TCP套接字上添加请求-响应模型层一样,STOMP在WebSocket之上提供了一个基于帧的线路格式层,用来定义消息语义.</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码中除了最基本的连接,还设置了一个定时器,每隔十秒发送一条数据到服务器端,如果发生错误,catch这个错误,重新建立连接.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装并引入相关模块</span><br><span class="line">import SockJS from  &#39;sockjs-client&#39;;  </span><br><span class="line">import  Stomp from &#39;stompjs&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        dataList: []</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted:function()&#123;</span><br><span class="line">      this.initWebSocket();</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; 页面离开时断开连接,清除定时器</span><br><span class="line">      this.disconnect();</span><br><span class="line">      clearInterval(this.timer);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      initWebSocket() &#123;</span><br><span class="line">        this.connection();</span><br><span class="line">        let self &#x3D; this;</span><br><span class="line">        &#x2F;&#x2F; 断开重连机制,尝试发送消息,捕获异常发生时重连</span><br><span class="line">        this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            self.stompClient.send(&quot;test&quot;);</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            console.log(&quot;断线了: &quot; + err);</span><br><span class="line">            self.connection();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">      &#125;,</span><br><span class="line">      removeTab(targetName) &#123;</span><br><span class="line">        console.log(targetName)</span><br><span class="line">      &#125;,</span><br><span class="line">      connection() &#123;</span><br><span class="line">      &#x2F;&#x2F; 建立连接对象</span><br><span class="line">        this.socket &#x3D; new SockJS(&#39;http:&#x2F;&#x2F;xxxxxx:8089&#x2F;ws&#39;);&#x2F;&#x2F;连接服务端提供的通信接口，连接以后才可以订阅广播消息和个人消息</span><br><span class="line">        &#x2F;&#x2F; 获取STOMP子协议的客户端对象</span><br><span class="line">        this.stompClient &#x3D; Stomp.over(this.socket);</span><br><span class="line">        &#x2F;&#x2F; 定义客户端的认证信息,按需求配置</span><br><span class="line">        var headers &#x3D; &#123;</span><br><span class="line">          login: &#39;mylogin&#39;,</span><br><span class="line">          passcode: &#39;mypasscode&#39;,</span><br><span class="line">          &#x2F;&#x2F; additional header</span><br><span class="line">          &#39;client-id&#39;: &#39;my-client-id&#39;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 向服务器发起websocket连接</span><br><span class="line">        this.stompClient.connect(headers,(frame) &#x3D;&gt; &#123;</span><br><span class="line">          this.stompClient.subscribe(&#39;&#x2F;topic&#x2F;chat_msg&#39;, (msg) &#x3D;&gt; &#123; &#x2F;&#x2F; 订阅服务端提供的某个topic</span><br><span class="line">           consolel.log(msg.body);  &#x2F;&#x2F; msg.body存放的是服务端发送给我们的信息</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 连接发生错误时的处理函数</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 断开连接</span><br><span class="line">      disconnect() &#123;</span><br><span class="line">        if (this.stompClient !&#x3D; null) &#123;</span><br><span class="line">          this.stompClient.disconnect();</span><br><span class="line">          console.log(&quot;Disconnected&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>链接：<a href="https://juejin.im/post/6844903664721592327" target="_blank" rel="noopener">https://juejin.im/post/6844903664721592327</a></p>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>Xftp5之初见</title>
    <url>/2020/10/30/Xftp5%E4%B9%8B%E5%88%9D%E8%A7%81/</url>
    <content><![CDATA[<p>Xftp是一个功能强大的<a href="https://baike.baidu.com/item/SFTP/1184182" target="_blank" rel="noopener">SFTP</a>、<a href="https://baike.baidu.com/item/FTP/13839" target="_blank" rel="noopener">FTP</a> 文件传输软件。使用了 Xftp 以后，Windows 用户能安全地在 Linux 和 Windows之间传输文件。</p>
<h3 id="Xftp5软件使用详解"><a href="#Xftp5软件使用详解" class="headerlink" title="Xftp5软件使用详解"></a>Xftp5软件使用详解</h3><p>一、首先运行Xftp5，然后导航栏上面有个小加号，点击进去。</p>
<p><img src="https://images2018.cnblogs.com/blog/1126989/201808/1126989-20180831103255255-1718023639.png" alt="img"></p>
<a id="more"></a>

<p>二、接着出现如下界面，在这里填写名称（这个随意填写），主机填写要连接的主机的IP地址，然后协议的话，Linux系统一般选择SFTP协议，端口默认即可。</p>
<p><img src="https://images2018.cnblogs.com/blog/1126989/201808/1126989-20180831103722673-442496041.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1126989/201808/1126989-20180831104017917-1276627074.png" alt="img"></p>
<p>三、接着输入主机的账号密码。注意这儿不能用root账号（也就是超级管理员账号）登入，否则会出现“SSH服务器拒绝了密码。请再试一次”的错误。</p>
<p> <img src="https://images2018.cnblogs.com/blog/1126989/201808/1126989-20180831104400855-608176423.png" alt="img"></p>
<p>四、点击确定。如此就可以进行两个主机之间文件的传输服务了，包括文件上传，下载等等。</p>
<p><img src="https://images2018.cnblogs.com/blog/1126989/201808/1126989-20180831104619735-986809902.png" alt="img"></p>
<p>温馨提示：如果出现不能连接到IP地址的情况，如下图所示。有很大的可能是Linux的ssh服务没有开启。解决方法：</p>
<p>　　1、检查ssh服务是否安装，输入以下命令：</p>
<p>　　　　$ ps -e | grep ssh  看到“ssh-agent”和“sshd”，否则表示没有安装服务，或没有开机启动。</p>
<p>　　2、安装ssh,输入命令：</p>
<p>　　　　$ sudo apt-get install openssh-server  </p>
<p>　　3、启动服务，输入命令：</p>
<p>　　　　$ /etc/init.d/ssh start。这样解决这个问题了，可以使用Xftp5进行连接了。</p>
<p><img src="https://images2018.cnblogs.com/blog/1126989/201808/1126989-20180831104835774-817519508.png" alt="img"></p>
]]></content>
      <categories>
        <category>ftp</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>axios之get和post</title>
    <url>/2020/09/27/axios%E4%B9%8Bget%E5%92%8Cpost/</url>
    <content><![CDATA[<p>1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内</p>
<p>2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制</p>
<p>3.get后退不会有影响，post后退会重新进行提交</p>
<p>4.get请求可以被缓存，post不可以被缓存</p>
<p>5.get请求只URL编码，post支持多种编码方式</p>
<p>6.get请求的记录会留在历史记录中，post请求不会留在历史记录</p>
<p>7.get只支持ASCII字符，post没有字符类型限制</p>
<h3 id="什么是GET和POST请求"><a href="#什么是GET和POST请求" class="headerlink" title="什么是GET和POST请求"></a>什么是GET和POST请求</h3><p>GET：向指定路径资源发送请求，通常用于获取数据</p>
<p>POST：向指定路径资源提交数据进行处理请求，通常用于提交表单或者上传文件</p>
<h3 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h3><p>1，GET一般是从服务器上获取数据，POST是向服务器提交数据。</p>
<p>2，GET通过URL提交数据，数据在URL中可以看到，POST则是在HEADER内提交。</p>
<p>3，GET提交的数据不能大于2KB，而POST不受限制。</p>
<p>4，GET数据容易泄露，POST较为安全</p>
<a id="more"></a>

<p><img src="https://exp-picture.cdn.bcebos.com/dd58d02c5b1b1edea3f5908d981fceecd2d90fbd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>Content-Type是指发送信息至服务器时的内容编码类型，常见的表单提交或上传文件的常用的资源类型有application/x-www-form-urlencoded、multipart/form-data、 application/json、 application/xml，默认情况下为application/x-www-form-unlencoded。</p>
<h3 id="axios发送GET请求"><a href="#axios发送GET请求" class="headerlink" title="axios发送GET请求"></a>axios发送GET请求</h3><p>get发送请求时参数附在URL上，已键值对的形式呈现，如<a href="http://localhost:8000/test/?name=kevinfan&amp;&amp;age=18,这里传递的就是name=kevinfan&amp;&amp;age=18两个参数。" target="_blank" rel="noopener">http://localhost:8000/test/?name=kevinfan&amp;&amp;age=18,这里传递的就是name=kevinfan&amp;&amp;age=18两个参数。</a></p>
<p><img src="https://exp-picture.cdn.bcebos.com/125ed0ecd3d96975afeddc2dd243040149fe09bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p> 那么axios发送请求的时候就可以这样写</p>
<p><img src="https://exp-picture.cdn.bcebos.com/49bf00425d6b04d12c00aa3cb213e8e5edee01bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p>get除了可以发送一些简单的参数也可以携带请求头参数，比如说我想把token通过请求头的形式发送至后台，这里我在headers中定义了Authorization=token，通过验证token来获取用户信息。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/edafb3bcbe2f47702b31ef6e6f3b3b86032179bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p>后台接受请求头信息时应该用request.META.get(‘HTTP_AUTHORIZATION’)，而且这里我们需要注意的是，前端发过来的字段是Authorization，而后台接受时确是HTTP_AUTHORIZATION。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/4e168d5653bbf82012d2a6bfba21056105a36ebd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<h3 id="axios发送POST请求"><a href="#axios发送POST请求" class="headerlink" title="axios发送POST请求"></a>axios发送POST请求</h3><p>post发送请求时参数放在HEADER的请求体中，axios默认发送数据时，数据格式是Request Payload（请求头 Content-Type: application/json），而我们常用的是Form Data（请求头 Content-Type: application/x-www-form-urlencoded）格式。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/04201aa355e983ae95fe699e68efe078153169bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p>如果我们直接将如上所示的数据发送给Django后台的话收到的数据会是None，这里我们可以看到发送的数据格式为Request Payload（请求头 Content-Type: application/json）,这时我们就不能以json形式传参，而是通过键值对形式传参。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/586bfdefe07814315d9f02d8dc6699cf035362bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p>解决办法：axios中提供了qs模块，可以对数据格式进行转换，在axios中引入this.$qs.stringify()，这样在传参前将数据自动处理成键值对形式，这里我们可以看到发送的数据格式为Form Data（请求头 Content-Type: application/x-www-form-urlencoded），后台也正常接收到了数据。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/332d496699cf0253a84a13316b36e29146e85fbd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<p><img src="https://exp-picture.cdn.bcebos.com/22c4fe36e29147e8bfc909c6b603bbea3f8658bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<h3 id="axios通过POST传文件"><a href="#axios通过POST传文件" class="headerlink" title="axios通过POST传文件"></a>axios通过POST传文件</h3><p>POST除了可以发送数据之后，还可以用于发送文件（如传图片等），那么这时文件就是个对象而并不是参数。这是我们就需要申明一个FormData对象，以formData.append(‘键’,对象)形式将对象添加到formData中然后传递。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/46a92de039723d0334c30e32bb486143d6d457bd.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Vue实战032：axios如何使用get和post发送请求"></p>
<h3 id="八大请求方式"><a href="#八大请求方式" class="headerlink" title="八大请求方式"></a>八大请求方式</h3><p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180810112625596-2103906128.png" alt="img"></p>
<p><strong>讲解</strong></p>
<p>1、OPTIONS</p>
<p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p>
<p>2、HEAD</p>
<p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p>
<p>3、GET</p>
<p>向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url</p>
<p>4、POST</p>
<p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form</p>
<p>5、PUT</p>
<p>向指定资源位置上传其最新内容</p>
<p>6、DELETE</p>
<p>请求服务器删除Request-URL所标识的资源</p>
<p>7、TRACE</p>
<p>回显服务器收到的请求，主要用于测试或诊断</p>
<p>8、CONNECT</p>
<p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>注意：</p>
<p>1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。</p>
<p>2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。</p>
]]></content>
      <categories>
        <category>axios</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
        <tag>get</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/2020/07/27/axios/</url>
    <content><![CDATA[<h3 id="vue中使用axios"><a href="#vue中使用axios" class="headerlink" title="vue中使用axios"></a>vue中使用axios</h3><h4 id="安装axios"><a href="#安装axios" class="headerlink" title="安装axios"></a>安装axios</h4><p>npm：</p>
<p>$ npm install axios -S</p>
<p>cdn：</p>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

<a id="more"></a>

<h4 id="配置axios"><a href="#配置axios" class="headerlink" title="配置axios"></a>配置axios</h4><p>在项目中新建api/index.js文件，用以配置axios</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">api/index.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">let</span> http = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'http://localhost:8080/'</span>,</span><br><span class="line">  withCredentials: <span class="literal">true</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded;charset=utf-8'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newData = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(k) === <span class="literal">true</span>) &#123;</span><br><span class="line">        newData += <span class="built_in">encodeURIComponent</span>(k) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[k]) + <span class="string">'&amp;'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newData;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apiAxios</span>(<span class="params">method, url, params, response</span>) </span>&#123;</span><br><span class="line">  http(&#123;</span><br><span class="line">    method: method,</span><br><span class="line">    url: url,</span><br><span class="line">    data: method === <span class="string">'POST'</span> || method === <span class="string">'PUT'</span> ? params : <span class="literal">null</span>,</span><br><span class="line">    params: method === <span class="string">'GET'</span> || method === <span class="string">'DELETE'</span> ? params : <span class="literal">null</span>,</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    response(res);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    response(err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (url, params, response) &#123;</span><br><span class="line">    <span class="keyword">return</span> apiAxios(<span class="string">'GET'</span>, url, params, response)</span><br><span class="line">  &#125;,</span><br><span class="line">  post: <span class="function"><span class="keyword">function</span> (<span class="params">url, params, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apiAxios(<span class="string">'POST'</span>, url, params, response)</span><br><span class="line">  &#125;,</span><br><span class="line">  put: <span class="function"><span class="keyword">function</span> (<span class="params">url, params, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apiAxios(<span class="string">'PUT'</span>, url, params, response)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">delete</span>: <span class="function"><span class="keyword">function</span> (<span class="params">url, params, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apiAxios(<span class="string">'DELETE'</span>, url, params, response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里的配置了POST、GET、PUT、DELETE方法。并且自动将<span class="built_in">JSON</span>格式数据转为URL拼接的方式</span><br><span class="line">同时配置了跨域，不需要的话将withCredentials设置为<span class="literal">false</span>即可</span><br><span class="line">并且设置了默认头部地址为：http:<span class="comment">//localhost:8080/，这样调用的时候只需写访问方法即可</span></span><br></pre></td></tr></table></figure>



<h4 id="请求拦截与响应拦截"><a href="#请求拦截与响应拦截" class="headerlink" title="请求拦截与响应拦截"></a>请求拦截与响应拦截</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">api&#x2F;index.js</span><br><span class="line"></span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">&#x2F;&#x2F; 请求拦截（配置发送请求的信息）</span><br><span class="line">&#x2F;&#x2F; 只要配置了拦截器，那么所有的请求都会走拦截器</span><br><span class="line">&#x2F;&#x2F; 因此，可以在拦截器中统一处理headers（处理：除了登录接口以外的所以接口，都需要将token传递给服务器）</span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理请求之前的配置</span><br><span class="line">  if(!config.url.endsWith(&#39;&#x2F;login&#39;))&#123;</span><br><span class="line">        &#x2F;&#x2F; 判断如果是登录接口，就不需要添加 Authorization 请求头</span><br><span class="line">        config.headers[&#39;Authorization&#39;]&#x3D;localStorage.getItem(&#39;token&#39;) </span><br><span class="line">        &#x2F;&#x2F;将token设置在请求头，传递给服务器接口，这样才能正确的调用这个接口</span><br><span class="line">	&#125;, </span><br><span class="line">	return config;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  &#x2F;&#x2F; 请求失败的处理</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 响应拦截（配置请求回来的信息）</span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理响应数据</span><br><span class="line">  &#x2F;&#x2F;在获取到响应的时候做一些事情， </span><br><span class="line">  if(response.data.meta.status&#x3D;&#x3D;&#x3D;401)&#123;&#x2F;&#x2F;只要token失效，就跳转回登录页面</span><br><span class="line">      &#x2F;&#x2F;因为现在不是在组件中，因此无法通过this.$router来访问到路由实例</span><br><span class="line">      &#x2F;&#x2F; 但是可以直接通过 上面导入的路由模块中的 router来访问到路由</span><br><span class="line">      router.push(&#39;&#x2F;login&#39;) &#x2F;&#x2F;跳转到登录页</span><br><span class="line">      localStorage.removeItem(&#39;token&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  return response</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理响应失败</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="使用axios"><a href="#使用axios" class="headerlink" title="使用axios"></a>使用axios</h4><p>注：PUT请求默认会发送两次请求，第一次预检请求不含参数，所以后端不能对PUT请求地址做参数限制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">首先在main.js中引入方法</span><br><span class="line"><span class="keyword">import</span> Api <span class="keyword">from</span> <span class="string">'./api/index.js'</span>;</span><br><span class="line">Vue.prototype.$api = Api;</span><br><span class="line"></span><br><span class="line">然后在需要的地方调用即可</span><br><span class="line"><span class="keyword">this</span>.$api.post(<span class="string">'user/login.do(地址)'</span>, &#123;</span><br><span class="line">    <span class="string">"参数名"</span>: <span class="string">"参数值"</span></span><br><span class="line">&#125;, response =&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.data);\\请求成功，response为成功信息参数</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.message);\\请求失败，response为失败信息</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">page.js</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getInfo () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$axios.get(<span class="string">'/fcg_myqq_toplist.fcg'</span>, &#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line">          <span class="string">'authorization'</span>: <span class="keyword">this</span>.token</span><br><span class="line">        &#125;,</span><br><span class="line">        params: &#123;</span><br><span class="line">          g_tk: <span class="number">5381</span>,</span><br><span class="line">          uin: <span class="number">0</span>,</span><br><span class="line">          format: <span class="string">'json'</span>,</span><br><span class="line">          inCharset: <span class="string">'utf-8'</span>,</span><br><span class="line">          outCharset: <span class="string">'utf-8'</span>,</span><br><span class="line">          notice: <span class="number">0</span>,</span><br><span class="line">          platform: <span class="string">'h5'</span>,</span><br><span class="line">          needNewCode: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.discList = res.data.data.topList</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.discList)</span><br><span class="line">      &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err.response.status)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    axios.get(<span class="string">'/api/extensys/exten_action.php?act=get_userinfo&amp;unionid=oaNquuJBYcTrl4EJOXYaINXN7xZo'</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.user = response.data.userInfo</span><br><span class="line">            <span class="keyword">this</span>.id = response.data.loginResult.player.userid</span><br><span class="line">            resolve(<span class="keyword">this</span>.id);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">'/api/extensys/action.php?act=get_levelinfo&amp;userid='</span>+id) <span class="comment">// 重要，注意添加了return</span></span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response.data)</span><br><span class="line">            <span class="keyword">return</span> response <span class="comment">// 重要，return了，下一层才可以用</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="keyword">void</span> <span class="built_in">console</span>.log(response))</span><br><span class="line"></span><br><span class="line">简写</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  axios.get(<span class="string">'/api/extensys/exten_action.php?act=get_userinfo&amp;unionid=oaNquuJBYcTrl4EJOXYaINXN7xZo'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.user = response.data.userInfo</span><br><span class="line">      <span class="keyword">this</span>.id = response.data.loginResult.player.userid</span><br><span class="line">      resolve(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> axios.get(<span class="string">'/api/extensys/action.php?act=get_levelinfo&amp;userid='</span>+id) <span class="comment">// 重要，注意添加了return</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="keyword">void</span> <span class="built_in">console</span>.log(response))</span><br><span class="line"></span><br><span class="line">  .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)<span class="comment">//报错信息</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



<p>这里有个小细节说下，<code>axios.get()</code>方法和<code>axios.post()</code>在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！</p>
<p>api.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const apiAddress &#x3D; p &#x3D;&gt; post(&#39;api&#x2F;v1&#x2F;users&#x2F;my_address&#x2F;address_edit_before&#39;, p);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; apiAddress &#125; from &#39;@&#x2F;request&#x2F;api&#39;;&#x2F;&#x2F; 导入我们的api接口</span><br><span class="line">export default &#123;        </span><br><span class="line">    name: &#39;Address&#39;,    </span><br><span class="line">    created () &#123;</span><br><span class="line">        this.onLoad();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;            </span><br><span class="line">        &#x2F;&#x2F; 获取数据            </span><br><span class="line">        onLoad() &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用api接口，并且提供了两个参数                </span><br><span class="line">            apiAddress(&#123;                    </span><br><span class="line">                type: 0,                    </span><br><span class="line">                sort: 1                </span><br><span class="line">            &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取数据成功后的其他操作</span><br><span class="line">                ………………                </span><br><span class="line">            &#125;)            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>http.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**axios封装</span><br><span class="line"> * 请求拦截、相应拦截、错误统一处理</span><br><span class="line"> *&#x2F;</span><br><span class="line">import axios from &#39;axios&#39;;import QS from &#39;qs&#39;;</span><br><span class="line">import &#123; Toast &#125; from &#39;vant&#39;;</span><br><span class="line">import store from &#39;..&#x2F;store&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 环境的切换</span><br><span class="line">if (process.env.NODE_ENV &#x3D;&#x3D; &#39;development&#39;) &#123;    </span><br><span class="line">    axios.defaults.baseURL &#x3D; &#39;&#x2F;api&#39;;</span><br><span class="line">&#125; else if (process.env.NODE_ENV &#x3D;&#x3D; &#39;debug&#39;) &#123;    </span><br><span class="line">    axios.defaults.baseURL &#x3D; &#39;&#39;;</span><br><span class="line">&#125; else if (process.env.NODE_ENV &#x3D;&#x3D; &#39;production&#39;) &#123;    </span><br><span class="line">    axios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;api.123dailu.com&#x2F;&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请求超时时间</span><br><span class="line">axios.defaults.timeout &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post请求头</span><br><span class="line">axios.defaults.headers.post[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请求拦截器</span><br><span class="line">axios.interceptors.request.use(    </span><br><span class="line">    config &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了</span><br><span class="line">        &#x2F;&#x2F; 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</span><br><span class="line">        const token &#x3D; store.state.token;        </span><br><span class="line">        token &amp;&amp; (config.headers.Authorization &#x3D; token);        </span><br><span class="line">        return config;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    error &#x3D;&gt; &#123;        </span><br><span class="line">        return Promise.error(error);    </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 响应拦截器</span><br><span class="line">axios.interceptors.response.use(    </span><br><span class="line">    response &#x3D;&gt; &#123;        </span><br><span class="line">        if (response.status &#x3D;&#x3D;&#x3D; 200) &#123;            </span><br><span class="line">            return Promise.resolve(response);        </span><br><span class="line">        &#125; else &#123;            </span><br><span class="line">            return Promise.reject(response);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 服务器状态码不是200的情况    </span><br><span class="line">    error &#x3D;&gt; &#123;        </span><br><span class="line">        if (error.response.status) &#123;            </span><br><span class="line">            switch (error.response.status) &#123;                </span><br><span class="line">                &#x2F;&#x2F; 401: 未登录                </span><br><span class="line">                &#x2F;&#x2F; 未登录则跳转登录页面，并携带当前页面的路径                </span><br><span class="line">                &#x2F;&#x2F; 在登录成功后返回当前页面，这一步需要在登录页操作。                </span><br><span class="line">                case 401:                    </span><br><span class="line">                    router.replace(&#123;                        </span><br><span class="line">                        path: &#39;&#x2F;login&#39;,                        </span><br><span class="line">                        query: &#123; redirect: router.currentRoute.fullPath &#125; </span><br><span class="line">                    &#125;);</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 403 token过期                </span><br><span class="line">                &#x2F;&#x2F; 登录过期对用户进行提示                </span><br><span class="line">                &#x2F;&#x2F; 清除本地token和清空vuex中token对象                </span><br><span class="line">                &#x2F;&#x2F; 跳转登录页面                </span><br><span class="line">                case 403:                     </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: &#39;登录过期，请重新登录&#39;,                        </span><br><span class="line">                        duration: 1000,                        </span><br><span class="line">                        forbidClick: true                    </span><br><span class="line">                    &#125;);                    </span><br><span class="line">                    &#x2F;&#x2F; 清除token                    </span><br><span class="line">                    localStorage.removeItem(&#39;token&#39;);                    </span><br><span class="line">                    store.commit(&#39;loginSuccess&#39;, null);                    </span><br><span class="line">                    &#x2F;&#x2F; 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;                        </span><br><span class="line">                        router.replace(&#123;                            </span><br><span class="line">                            path: &#39;&#x2F;login&#39;,                            </span><br><span class="line">                            query: &#123; </span><br><span class="line">                                redirect: router.currentRoute.fullPath </span><br><span class="line">                            &#125;                        </span><br><span class="line">                        &#125;);                    </span><br><span class="line">                    &#125;, 1000);                    </span><br><span class="line">                    break; </span><br><span class="line">                &#x2F;&#x2F; 404请求不存在                </span><br><span class="line">                case 404:                    </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: &#39;网络请求不存在&#39;,                        </span><br><span class="line">                        duration: 1500,                        </span><br><span class="line">                        forbidClick: true                    </span><br><span class="line">                    &#125;);                    </span><br><span class="line">                break;                </span><br><span class="line">                &#x2F;&#x2F; 其他错误，直接抛出错误提示                </span><br><span class="line">                default:                    </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: error.response.data.message,                        </span><br><span class="line">                        duration: 1500,                        </span><br><span class="line">                        forbidClick: true                    </span><br><span class="line">                    &#125;);            </span><br><span class="line">            &#125;            </span><br><span class="line">            return Promise.reject(error.response);        </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">&#x2F;** </span><br><span class="line"> * get方法，对应get请求 </span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址] </span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数] </span><br><span class="line"> *&#x2F;</span><br><span class="line">export function get(url, params)&#123;    </span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt;&#123;        </span><br><span class="line">        axios.get(url, &#123;            </span><br><span class="line">            params: params        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .then(res &#x3D;&gt; &#123;            </span><br><span class="line">            resolve(res.data);        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .catch(err &#x3D;&gt; &#123;            </span><br><span class="line">            reject(err.data)        </span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** </span><br><span class="line"> * post方法，对应post请求 </span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址] </span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数] </span><br><span class="line"> *&#x2F;</span><br><span class="line">export function post(url, params) &#123;    </span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;         </span><br><span class="line">        axios.post(url, QS.stringify(params))        </span><br><span class="line">        .then(res &#x3D;&gt; &#123;            </span><br><span class="line">            resolve(res.data);        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .catch(err &#x3D;&gt; &#123;            </span><br><span class="line">            reject(err.data)        </span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>axios</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>betterScroll</title>
    <url>/2020/07/27/betterScroll/</url>
    <content><![CDATA[<h3 id="better-scroll解释"><a href="#better-scroll解释" class="headerlink" title="better-scroll解释"></a>better-scroll解释</h3><ol>
<li><p>引入</p>
<p><code>npm install better-scroll --save</code></p>
<a id="more"></a>
</li>
<li><p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">"better-scroll"</span>;</span><br><span class="line"><span class="keyword">this</span>.scroll = <span class="keyword">new</span> Bscroll(<span class="keyword">this</span>.$res.wrapper, &#123;</span><br><span class="line">  click: <span class="literal">true</span>,</span><br><span class="line">  probeType: <span class="keyword">this</span>.probeType,</span><br><span class="line">  pullUpLoad: <span class="keyword">this</span>.pullUpLoad</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">startX: <span class="number">0</span> 开始的X轴位置</span><br><span class="line">startY: <span class="number">0</span> 开始的Y轴位置</span><br><span class="line">scrollY: <span class="literal">true</span> 滚动方向为 Y 轴</span><br><span class="line">scrollX: <span class="literal">true</span> 滚动方向为 X 轴</span><br><span class="line">click: <span class="literal">true</span> 是否派发click事件，通常判断浏览器派发的click还是betterscroll派发的click，可以用_constructed，若是bs派发的则为<span class="literal">true</span></span><br><span class="line">directionLockThreshold: <span class="number">5</span></span><br><span class="line">momentum: <span class="literal">true</span> 当快速滑动时是否开启滑动惯性</span><br><span class="line">bounce: <span class="literal">true</span> 是否启用回弹动画效果</span><br><span class="line">selectedIndex: <span class="number">0</span> wheel 为 <span class="literal">true</span> 时有效，表示被选中的 wheel 索引</span><br><span class="line">rotate: <span class="number">25</span> wheel 为 <span class="literal">true</span> 时有效，表示被选中的 wheel 每一层的旋转角度</span><br><span class="line">wheel: <span class="literal">false</span> 该属性是给 picker 组件使用的，普通的列表滚动不需要配置</span><br><span class="line">snap: <span class="literal">false</span> 该属性是给 slider 组件使用的，普通的列表滚动不需要配置</span><br><span class="line">snapLoop: <span class="literal">false</span> 是否可以无缝循环轮播</span><br><span class="line">snapThreshold: <span class="number">0.1</span> 用手指滑动时页面可切换的阈值，大于这个阈值可以滑动的下一页</span><br><span class="line">snapSpeed: <span class="number">400</span>, 轮播图切换的动画时间</span><br><span class="line">swipeTime: <span class="number">2500</span> swipe 持续时间</span><br><span class="line">bounceTime: <span class="number">700</span> 弹力动画持续的毫秒数</span><br><span class="line">adjustTime: <span class="number">400</span> wheel 为 <span class="literal">true</span> 有用，调整停留位置的时间</span><br><span class="line">swipeBounceTime: <span class="number">1200</span> swipe 回弹 时间</span><br><span class="line">deceleration: <span class="number">0.001</span> 滚动动量减速越大越快，建议不大于<span class="number">0.01</span></span><br><span class="line">momentumLimitTime: <span class="number">300</span> 符合惯性拖动的最大时间</span><br><span class="line">momentumLimitDistance: <span class="number">15</span> 符合惯性拖动的最小拖动距离</span><br><span class="line">resizePolling: <span class="number">60</span> 重新调整窗口大小时，重新计算better-scroll的时间间隔</span><br><span class="line">preventDefault: <span class="literal">true</span> 是否阻止默认事件</span><br><span class="line">preventDefaultException: &#123; <span class="attr">tagName</span>: <span class="regexp">/^(INPUT|TEXTAREA|BUTTON|SELECT)$/</span> &#125; 阻止默认事件</span><br><span class="line">HWCompositing: <span class="literal">true</span> 是否启用硬件加速</span><br><span class="line">useTransition: <span class="literal">true</span> 是否使用CSS3的Transition属性</span><br><span class="line">useTransform: <span class="literal">true</span> 是否使用CSS3的Transform属性</span><br><span class="line">probeType: <span class="number">1</span> 滚动的时候会派发scroll事件，会截流。<span class="number">2</span>滚动的时候实时派发scroll事件，不会截流。 <span class="number">3</span>除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件</span><br><span class="line">pullingUp: boolean 启用上拉加载</span><br></pre></td></tr></table></figure>
</li>
<li><p>Events 事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeScrollStart - 滚动开始之前触发</span><br><span class="line">scrollStart - 滚动开始时触发</span><br><span class="line">scroll - 滚动时触发（自带参数，x和y轴移动的距离）</span><br><span class="line">scrollCancel - 取消滚动时触发</span><br><span class="line">scrollEnd - 滚动结束时触发</span><br><span class="line">touchend - 手指移开屏幕时触发</span><br><span class="line">flick - 触发了 fastclick 时的回调函数</span><br><span class="line">refresh - 当 better-scroll 刷新时触发</span><br><span class="line">destroy - 销毁 better-scroll 实例时触发</span><br></pre></td></tr></table></figure>
</li>
<li><p>特别注意</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pullingUp() </span><br><span class="line">监听上拉加载事件</span><br><span class="line"></span><br><span class="line">finishPullUp()</span><br><span class="line">在请求完下一页数据的时候，结束下拉加载，必须加，否则下拉失效</span><br><span class="line"></span><br><span class="line">scrollTo(x, y, time, easing)</span><br><span class="line">滚动到某个位置，x,y 代表坐标，time 表示动画时间，easing 表示缓动函数</span><br><span class="line">scroll.scrollTo(0, 500)</span><br><span class="line"></span><br><span class="line">scrollToElement(el, time, offsetX, offsetY, easing)</span><br><span class="line">滚动到某个元素，el（必填）表示 dom 元素，time 表示动画时间，offsetX 和 offsetY 表示坐标偏移量，easing 表示缓动函数</span><br><span class="line"></span><br><span class="line">refresh()</span><br><span class="line">强制 scroll 重新计算，当 better-scroll 中的元素发生变化的时候调用此方法</span><br><span class="line">DOM树结构改变时</span><br><span class="line">图片列表等展示形式中 图片加载完成时</span><br><span class="line"></span><br><span class="line">getCurrentPage()</span><br><span class="line">snap 为 true 时，获取滚动的当前页，返回的对象结构为 &#123;x, y, pageX, pageY&#125;，其中 x,y 代表滚动横向和纵向的位置；pageX，pageY 表示横向和纵向的页面索引。用法如：getCurrentPage().pageX</span><br><span class="line"></span><br><span class="line">goToPage(x, y, time, easing)</span><br><span class="line">snap 为 true，滚动到对应的页面，x 表示横向页面索引，y 表示纵向页面索引， time 表示动画，easing 表示缓动函数（可省略不写）</span><br><span class="line"></span><br><span class="line">enable()启用 better-scroll，默认开启</span><br><span class="line"></span><br><span class="line">disable()  禁用 better-scroll</span><br><span class="line"></span><br><span class="line">destroy() 销毁 better-scroll，解绑事件</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>对better-scroll的二次封装 举例</p>
<ul>
<li>在better-scroll的封装文件中（vue）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"wrapper"</span> ref=<span class="string">"wrapper"</span>&gt;</span><br><span class="line">    &lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> &lt;script&gt;</span></span><br><span class="line"><span class="regexp">import BScroll from "better-scroll";</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: "alley-BScroll",</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    this.scroll = new BScroll(this.$refs.wrapper, &#123;</span></span><br><span class="line"><span class="regexp">      tap: true,</span></span><br><span class="line"><span class="regexp">      pullDownRefresh: true, /</span><span class="regexp">/这个配置用于做下拉刷新功能，默认为 false。当设置为 true 或者是一个 Object 的时候，可以开启下拉刷新</span></span><br><span class="line"><span class="regexp">      pullUpLoad: true, /</span><span class="regexp">/这个配置用于做上拉加载功能，默认为 false。当设置为 true 或者是一个 Object 的时候，可以开启上拉加载</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/下拉刷新加载数据</span></span><br><span class="line"><span class="regexp">    handlepullingDown(callback) &#123;</span></span><br><span class="line"><span class="regexp">      this.scroll.on("pullingDown", () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        callback();</span></span><br><span class="line"><span class="regexp">      &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/下拉刷新加载数据完毕通知better-scroll</span></span><br><span class="line"><span class="regexp">    handlefinishPullDown() &#123;</span></span><br><span class="line"><span class="regexp">      this.scroll.finishPullDown(); /</span><span class="regexp">/通知bettwer-scroll已经加载完毕</span></span><br><span class="line"><span class="regexp">      this.scroll.refresh(); /</span><span class="regexp">/重新计算 better-scroll，当 DOM 结构发生变化的时候务必要调用确保滚动的效果正常。</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/上拉加载更多</span></span><br><span class="line"><span class="regexp">    handlepullingUp(callback) &#123;</span></span><br><span class="line"><span class="regexp">      this.scroll.on("pullingUp", () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        callback();</span></span><br><span class="line"><span class="regexp">      &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    handlefinishPullUp() &#123;</span></span><br><span class="line"><span class="regexp">      this.scroll.finishPullUp();</span></span><br><span class="line"><span class="regexp">      this.scroll.refresh();</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &lt;style&gt;</span><br><span class="line">.wrapper &#123;</span><br><span class="line">  height: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在要使用该使用该封装的组件，只需要用这个组件将要出现效果的元素包裹起来即可，如下所示，包起来后，内容便可以有弹性的滑动了。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">alley-BScroll</span> <span class="attr">ref</span>=<span class="string">"alleyscroll"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"movie_body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"movie_item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(item,index) in movieList"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">click</span>=<span class="string">"handleclick()"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"movie_item_pic"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"item.img |ToImg('128.180')"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"movie_item_info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;item.nm&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          观众评:</span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"grade"</span>&gt;</span>&#123;item.sc&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          主演：</span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;item.star&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;item.showInfo&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:class</span>=<span class="string">"item.globalReleased?'movie_item_btn asale':'movie_item_btn ticket'"</span></span></span><br><span class="line"><span class="tag">      &gt;</span>&#123;item.globalReleased?'购票':'预售'&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alley-BScroll</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接下来便可以调用封装组件里的方法了，因为需要获取DOM元素，便要写在mounted这个生命周期内。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line"><span class="comment">//下拉刷新</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.alleyscroll.handlepullingDown(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">7</span>);</span><br><span class="line">      <span class="keyword">let</span> arr = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">59</span>]</span><br><span class="line">      <span class="keyword">let</span> data = <span class="keyword">await</span> movie_now_api(arr[n]);</span><br><span class="line">      <span class="keyword">this</span>.movieList = data.data.movieList;</span><br><span class="line">      sessionStorage.setItem(<span class="string">"movieList"</span>,<span class="built_in">JSON</span>.stringify(data.data.movieList))</span><br><span class="line">      <span class="keyword">this</span>.$refs.alleyscroll.handlefinishPullDown();<span class="comment">//下拉刷新完成后，通知better-scroll，下拉刷新已经完成。</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>//上拉加载更多
this.$refs.alleyscroll.handlepullingUp(async ()=&gt;{
    let n = parseInt(Math.random()*7);
    let arr = [10,1,20,40,50,55,59]
    let data = await movie_now_api(arr[n]);
    this.movieList = [...this.movieList,...data.data.movieList];
    sessionStorage.setItem(&quot;movieList&quot;,JSON.stringify(data.data.movieList))
    this.$refs.alleyscroll.handlefinishPullUp();
})</code></pre><p>   }<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>better-scroll</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>插件</tag>
        <tag>better-scroll</tag>
      </tags>
  </entry>
  <entry>
    <title>cd</title>
    <url>/2020/07/29/cd/</url>
    <content><![CDATA[<h3 id="cd就是change-directory的缩写，即改变目录。"><a href="#cd就是change-directory的缩写，即改变目录。" class="headerlink" title="cd就是change directory的缩写，即改变目录。"></a>cd就是change directory的缩写，即改变目录。</h3><p>cd desktop 进入桌面<br>mkdir movietalk 新建movietalk 文件夹<br>.则是表示目前所在的目录，<br>..则表示目前目录位置的上一层目录。<br>cd    进入用户主目录；<br>cd ~  进入用户主目录；<br>cd -  返回进入此目录之前所在的目录；<br>cd ..  返回上级目录（若当前目录为“/“，则执行完后还在“/“；”..”为上级目录的意思）；<br>cd ../..  返回上两级目录；</p>
<a id="more"></a>

<p>讲cd命令之前，先来看看提示符是什么意思。现在的提示符是<a href="https://www.baidu.com/s?wd=c%3A&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">c:</a>&gt;</p>
<p><strong>c:说明现在的工作盘是c盘，\告诉我们当前的工作目录是根目录。</strong></p>
<p>&gt;的作用是把工作目录和我们要输入的命令分隔开来。</p>
<p>好，下面就开始列举cd的各种命令。</p>
<p><strong>1.如果想要进入C盘下的任意文件或文件夹。</strong></p>
<p>直接<strong>cd+空格+文件或文件夹的路径</strong>（这个路径省略最开始的根目录，即C盘）</p>
<p>比如想要进入C盘下的Program Files里的Java文件里，敲cd Program Files\Java就可以。</p>
<p><img src="https://www.pianshen.com/images/684/779bf1f7d5e264a8033ae59aa24b8dbc.png" alt="img"></p>
<p><strong>2.想要返回到上一级目录或者当前工作目录下的根目录</strong></p>
<p>返回到上一句目录：<strong>cd+..</strong></p>
<p><img src="https://www.pianshen.com/images/664/229c207f9464aae73fcc4fa06fa55040.png" alt="img"></p>
<p>返回到根目录：cd + \</p>
<p><img src="https://www.pianshen.com/images/100/c1407b1edb67c5f461b501e16ffb82ec.png" alt="img"></p>
<p><strong>3.提醒一下，如果需要访问非当前根目录下的目录文件，</strong></p>
<p>应该<strong>先输入该盘符，敲回车，然后再用cd命令</strong></p>
<p><img src="https://www.pianshen.com/images/412/3211d3df1f59785fd5aeecaeed8131cc.png" alt="img"></p>
<p>如果要切换到D:\Program Files目录下，大多数人会想当然的在命令行窗口输入 cd D:\Program Files回车。</p>
<p>如下所示：</p>
<p><img src="https://www.pianshen.com/images/6/a8b579fcd4973d87692cb9d8fe23327e.png" alt="img"></p>
<p>发现并没有切换到D:\Program Files。</p>
<p>正确的做法是输入D:  回车。</p>
<p><img src="https://www.pianshen.com/images/92/14aa82211ef63d1c6821eb7a563bce04.png" alt="img"></p>
<p><img src="https://blog.csdn.net/chengdongyuan/article/details/73256862" alt="img"></p>
<p>发现已经切换到D盘下。</p>
<p>输入cd Program Files 回车。</p>
<p><img src="https://www.pianshen.com/images/677/fb9789051e08119e0d15766b11e2d0f5.png" alt="img"></p>
<p><img src="https://blog.csdn.net/chengdongyuan/article/details/73256862" alt="img"></p>
<p>成功切换到D:\Program Files目录下。</p>
]]></content>
      <categories>
        <category>cd</category>
      </categories>
      <tags>
        <tag>cd</tag>
      </tags>
  </entry>
  <entry>
    <title>charles抓包</title>
    <url>/2020/09/07/charles%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>一、</p>
<p>安装前提：配置好了Jdk环境</p>
<p>若不进行破解，则每次只能试用30分钟，30分钟后工具自动关闭</p>
<p>破解方法：将破解补丁charles.jar文件复制到lib文件夹下，替换掉同名jar包</p>
<a id="more"></a>

<p>二、</p>
<p>工具简单介绍：</p>
<p>1：清空列表所有请求</p>
<p>2：开始抓取 / 停止抓取</p>
<p>3：开启节流 / 停止节流</p>
<p>4：开启断点 / 结束断点</p>
<p>5：编辑请求</p>
<p>6：重发请求</p>
<p>7：校验请求的结果</p>
<p>8：快捷工具箱</p>
<p>9：快捷设置</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/082B867F5C764ABAA14C14322D09D3DB/3025" alt="img"></p>
<p>Structure：</p>
<p>以域名划分请求信息，可清晰地看到请求的数据结构</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/C161DEF842DD42AAADBD03B7392FBD7F/3088" alt="img"></p>
<p>Sequence：</p>
<p>可清晰看到全部请求，不用一层一层点开，按数据请求的时间顺序执行</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/E8011D8C641746F5B991A65C49125440/3085" alt="img"></p>
<p>三、</p>
<p>快捷搜索功能：通过ctrl+F进入搜索页面</p>
<p>1、关键词输入框：可输入正则表达式，不必区分大小写</p>
<p>2、搜索路径：</p>
<p>（1）全部会话</p>
<p>（2）当前会话</p>
<p>（3）指定的请求路径，在右侧输入框中输入</p>
<p>3、搜索范围：</p>
<p>（1）请求URL</p>
<p>（2）请求Header</p>
<p>（3）请求Body</p>
<p>（4）返回Header</p>
<p>（5）返回Body</p>
<p>4、搜索结果显示</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/ED862148378A4175B9EABF9BF984E650/3067" alt="img"></p>
<p>四、抓取手机请求</p>
<p>1、使手机与电脑处于同一局域网下（如连同一WiFi），如图，连接网络tczc，连接成功后打开代理设置，设置为【手动】</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/7A10EC84A6E04279ACCDF8BAD8B28DCF/3098" alt="img"></p>
<p>2、windows+R，输入cmd进入命令行，使用ipconfig命令查看电脑的ip地址</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/0E9A457E28C74B9F8285DD4CAE17E1B6/3151" alt="img"></p>
<p>3、在服务器一栏中填入电脑ip地址，端口号填8888。（端口号在Proxy-Proxy Settings下自己设置的）</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/DF82AAABD8794629A6423D47DA9183E4/3102" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/1598911FB55A482799C85BAF44980F5B/3115" alt="img"></p>
<p>4、注意：首次设置代理网络时，如果电脑端的Charles是打开的，则会提示是否允许设备连接Charles，这时必须应许，否则无法抓包，手机也无法连接网络；若这样设置后还是无法上网，则尝试重启电脑+手机。</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/8C44E37C6AE74B5684F13E0E725F6620/3158" alt="img"></p>
<p>如果不小心点了Deny，可以到Proxy - Access Control Settings下去查看，可手动移除或新增允许访问的IP地址。</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/E3CAFDF8DF5C42ECB711881E3258E6C4/3167" alt="img"></p>
<p>至此代理已经设置成功，可以抓取手机端的http请求。</p>
<p>5、若想抓取手机端的https请求，则必须安装手机端证书。</p>
<p>方法：在手机浏览器中输入 <a href="http://charlesproxy.com/getssl" target="_blank" rel="noopener">http://charlesproxy.com/getssl</a> 去安装证书。</p>
<p>ios系统的，在设置 - 通用 - 描述文件与设备管理下可查看安装的证书。</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/E9C3DF391F6C4E92952960FD048E0EA1/3180" alt="img"></p>
<p>另外要注意的是，在通用 - 关于本机 - 证书信任设置中，要开启对此证书的信任，否则同样抓取不到https请求。</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/F802904FA3DE4A63A624650F526B88A4/3183" alt="img"></p>
<p>6、以上设置完毕后，可以试着访问某个APP，如图，虽然能看到发出的请求，但请求和响应中出现了乱码：</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/7756E14FD7AF4D43ABD3A1168C17E64B/3205" alt="img"></p>
<p>解决方案是：</p>
<p>Proxy - SSL Proxying Settings下，将出现乱码的该域名添加进去</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/133548E8DE6940228B09DA265763D7B0/3209" alt="img"></p>
<p>设置完毕后，清除所有会话，重新访问一次，当当当当！！！成功了！！</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/C666882664FF44EDACE773A9E6FBED23/3215" alt="img"></p>
<p>五、抓取电脑请求</p>
<p>1、抓取电脑http请求：勾选这一项即可 Proxy - Windows Proxy</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/2C7CDF862BC147D9B5AF62664A434926/3235" alt="img"></p>
<p>2、抓取电脑端https请求，同样需要安装证书。</p>
<p>电脑端证书安装：Proxy - SSL Proxying - Install Charles Root Certificate</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/AB331E14DD4D40AAA1B3C2B0EB05A225/3222" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/830E7DC1B2054B318078EC01B2777E2C/3229" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/7D30139836A54643BECE96A0EDB08CF3/3231" alt="img"></p>
<p>六、其他功能点（选中会话，点击右键）</p>
<p>1、Repeat：重复执行请求</p>
<p>2、Repeat Advanced：可以指定请求的遍数</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/CCE4DDB106B1408594E49D61541B03F5/3245" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/98F9FE68FD4B4F189ECA0C03CCA94658/3257" alt="img"></p>
<p>3、Focus</p>
<p>右键某会话，点击Focus，可以使该域名置顶，其他域名统一被放到下面的Other Hosts下：</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/307B6C6B1D3A4D53B0B4F3988DB35703/3269" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/6925C705DCC6400F8A96BE193D6E2E59/3271" alt="img"></p>
<p>除了通过这种方法设置，也可在View - Focused Hosts下统一设置</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/603213AF038847838EADD5D81C238329/3277" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/8069161252554DC1BC8C03022028A5B7/3281" alt="img"></p>
<p>4、黑名单 / 白名单</p>
<p>Black List：黑名单中的域名不能联网</p>
<p>White List：白名单开启后，只有在白名单中的域名可以访问网络，不在白名单中的不能联网</p>
<p>（如果一个域名既在黑名单，又在白名单，那么也不能联网）</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/0735CCE2871A426DB534AD44307D8641/3287" alt="img"></p>
<p>5、导出会话功能</p>
<p>Export：可将会话导出到本地，下次可通过File - Open Session打开</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/88D11E6684F44747ADA1BD7AD87A32FF/3301" alt="img"></p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/D04C613AFBB64560940B2DC1072D68A9/3307" alt="img"></p>
<p>6、比较功能</p>
<p>Compare：在左侧列表中选中两个请求，右键即可看到此选项，可用于比对两个请求的入参和出参</p>
<p><img src="http://note.youdao.com/yws/public/resource/e0eb6de484b77856b775ffe7a656f27d/xmlnote/CB4FEC96F91E4F029D5B3A7A7D58D0F3/3311" alt="img"></p>
<p>未完待续….</p>
<p>有道云笔记地址：</p>
]]></content>
      <categories>
        <category>charles</category>
      </categories>
      <tags>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie/session/localstorage/sessionstorage</title>
    <url>/2020/10/30/cookie-session-localstorage-sessionstorage/</url>
    <content><![CDATA[<p>HTML4的本地存储 cookie</p>
<p>浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互。</p>
<p>一、cookie和session</p>
<p>cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
<p>区别：</p>
<a id="more"></a>

<p>1、保持状态：cookie保存在浏览器端，session保存在服务器端</p>
<p>2、使用方式：</p>
<p>（1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。</p>
<p>   Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它</p>
<p>（2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。</p>
<p>3、存储内容：cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)</p>
<p>4、存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。</p>
<p>5、安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。</p>
<p>　　　　　　原因如下：（1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；</p>
<p>　　　　　　　　　　　（2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；</p>
<p>　　　　　　　　　　　（3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。</p>
<p>　　　　　　　　　　　（4）sessionID是加密的</p>
<p>　　　　　　　　　　　（5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。</p>
<p>6、应用场景：</p>
<p>cookie：（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p>
<p>　　　　（2）保存上次登录的时间等信息。</p>
<p>　　　　（3）保存上次查看的页面</p>
<p>　　　　（4）浏览计数</p>
<p><img src="https://images2018.cnblogs.com/blog/1287779/201804/1287779-20180404062350828-745185789.png" alt="img"></p>
<p>session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。</p>
<p>　　（1）网上商城中的购物车</p>
<p>　　（2）保存用户登录信息</p>
<p>　　（3）将某些数据放入session中，供同一用户的不同页面使用</p>
<p>　　（4）防止用户非法登录</p>
<p> 7、缺点：cookie：（1）大小受限</p>
<p>　　　　　　　　（2）用户可以操作（禁用）cookie，使功能受限</p>
<p>　　　　　　　　（3）安全性较低</p>
<p>　　　　　　　　（4）有些状态不可能保存在客户端。</p>
<p>　　　　　　　　（5）每次访问都要传送cookie给服务器，浪费带宽。</p>
<p>　　　　　　　　（6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</p>
<p> 　　　session：（1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p>
<p>　　　　　　　　（2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全</p>
<p>　　　　　　　　（3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。</p>
<p> <img src="https://images2018.cnblogs.com/blog/1287779/201804/1287779-20180404063034678-394744286.png" alt="img"></p>
<p> HTML5的本地存储</p>
<p>解释一</p>
<p>HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。</p>
<p>本文主要来讲解Web Storage</p>
<p>我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，你会发现，用cookie存储永久数据存在以下几个问题：</p>
<p>1.大小：cookie的大小被限制在4KB。</p>
<p>2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。</p>
<p>3.复杂性：要正确的操纵cookie是很困难的。</p>
<p>针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。</p>
<p>具体来说，Web Storage又分为两种：</p>
<p>1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。</p>
<p>2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p>
<p>这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。</p>
<p>到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。</p>
<p>解释二</p>
<p>WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。</p>
<p>WebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。</p>
<p>HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。</p>
<p>1、生命周期：</p>
<p>​    <strong>localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</strong></p>
<p>​     <strong>sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。</strong></p>
<p>2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB</p>
<p>3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。</p>
<p>4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</p>
<p>5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。</p>
<p>6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；</p>
<p>WebStorage的优点：</p>
<p>（1）存储空间更大：cookie为4KB，而WebStorage是5MB；</p>
<p>（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；</p>
<p>（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；</p>
<p>（4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；</p>
<p>（5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；</p>
<p>（6）WebStorage提供了一些方法，数据操作比cookie方便；</p>
<p>　　　　setItem (key, value) ——  保存数据，以键值对的方式储存信息。</p>
<p>   　　 getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</p>
<p>​    　　removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</p>
<p>​    　　clear () ——  删除所有的数据</p>
<p>​    　　key (index) —— 获取某个索引的key</p>
<p>cookie 、sessionStorage与localStorage的区别</p>
<p><img src="https://images2018.cnblogs.com/blog/1287779/201804/1287779-20180404065845701-1111813120.png" alt="img"></p>
<p>sessionStorage与localStorage的使用示例。</p>
]]></content>
      <categories>
        <category>储存</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>localstorage</tag>
        <tag>sessionstorage</tag>
      </tags>
  </entry>
  <entry>
    <title>easy-mock</title>
    <url>/2020/07/30/easy-mock/</url>
    <content><![CDATA[<h3 id="easy-mock的使用"><a href="#easy-mock的使用" class="headerlink" title="easy-mock的使用"></a>easy-mock的使用</h3><p>Easy Mock 是一个可视化，并且能快速生成模拟数据的持久化服务。简单来说，easy-mock可以提供api接口，让程序员在写好程序以后进行数据模拟。</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>创建一个项目</p>
<a id="more"></a>

<p><img src="/2020/07/30/easy-mock/clipboard.png" alt="clipboard"></p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>填写信息，这里项目名和url都是按照自己的意愿来填写，这会为最后生成的api数据接口提供地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/18143787-9f66b8a931aa6e8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>创建mock</p>
<p>![clipboard (1)](easy-mock.assets/clipboard (1).png)</p>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>最后就可以在这里写下mock的代码啦！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/18143787-26185e5f83289a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>easy-mock 本地部署（坑）</p>
<p><a href="https://blog.csdn.net/qq_40895460/article/details/105029475" target="_blank" rel="noopener">https://blog.csdn.net/qq_40895460/article/details/105029475</a></p>
]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>mock</tag>
        <tag>easy-mock</tag>
      </tags>
  </entry>
  <entry>
    <title>css3</title>
    <url>/2020/07/23/css3/</url>
    <content><![CDATA[<h3 id="日常积累"><a href="#日常积累" class="headerlink" title="日常积累"></a>日常积累</h3><a id="more"></a>

<ol>
<li><p>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</p>
<blockquote>
<ul>
<li>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin </li>
<li>低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin</li>
</ul>
</blockquote>
</li>
<li><p>box-sizing属性</p>
<blockquote>
<p>用来控制元素的盒子模型的解析模式，默认为content-box </p>
<ul>
<li>context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽 </li>
<li>border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽</li>
</ul>
</blockquote>
</li>
<li><p>CSS选择器有哪些？哪些属性可以继承？</p>
<blockquote>
<ul>
<li>CSS选择符：id选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child）</li>
<li>可继承的属性：font-size, font-family, color</li>
<li>不可继承的样式：border, padding, margin, width, height</li>
<li>优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ] </li>
<li>!important 比内联优先级高</li>
</ul>
</blockquote>
</li>
<li><p>CSS优先级算法如何计算？</p>
<blockquote>
<p>元素选择符： 1 </p>
<p>class选择符： 10 </p>
<p>id选择符：100 </p>
<p>元素标签：1000</p>
<p>!important声明的样式优先级最高，如果冲突再进行计算。 </p>
<p>如果优先级相同，则选择最后出现的样式。 </p>
<p>继承得到的样式的优先级最低。</p>
</blockquote>
</li>
<li><p>CSS3伪类有那些?</p>
<blockquote>
<ul>
<li><p>p:first-of-type 选择属于其父元素的首个元素 </p>
</li>
<li><p>p:last-of-type 选择属于其父元素的最后元素 </p>
</li>
<li><p>p:only-of-type 选择属于其父元素唯一的元素 </p>
</li>
<li><p>p:only-child 选择属于其父元素的唯一子元素 </p>
</li>
<li><p>p:nth-child(2) 选择属于其父元素的第二个子元素 </p>
</li>
<li><p>plate:nth-of-type(even) 或 plate:nth-of-type(2n)  选中所有偶数的plate</p>
<p>plate:nth-of-type(odd) 或 plate:nth-of-type(2n+1)  奇数项</p>
<p>plate:nth-of-type(2n+3) 选择偶数项并从第三个开始</p>
<p>plate:nth-of-type(3n) 选择3的倍数</p>
</li>
<li><p>:enabled :disabled 表单控件的禁用状态。 </p>
</li>
<li><p>:checked 单选框或复选框被选中。</p>
</li>
<li><p>bento ~ pickle  bento旁边的pickle元素  </p>
</li>
</ul>
</blockquote>
</li>
<li><p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p>
<blockquote>
<ul>
<li><p>div：</p>
<p>border: 1px solid red; </p>
<p>margin: 0 auto; </p>
<p>height: 50px; </p>
<p>width: 80px; </p>
</li>
<li><p>浮动元素的上下左右居中：</p>
<p>border: 1px solid red; </p>
<p>float: left; </p>
<p>position: absolute; </p>
<p>width: 200px; </p>
<p>height: 100px; </p>
<p>left: 50%; </p>
<p>top: 50%; </p>
<p>margin: -50px 0 0 -100px; </p>
</li>
<li><p>绝对定位的左右居中：</p>
<p>border: 1px solid black; </p>
<p>position: absolute; </p>
<p>width: 200px; </p>
<p>height: 100px; </p>
<p>margin: 0 auto; </p>
<p>left: 0; </p>
<p>right: 0;</p>
</li>
<li><p>flex布局所有元素在范围内水平垂直分布</p>
</li>
</ul>
<p>​      display: flex;</p>
<p>​      flex-wrap: wrap;</p>
<p>​      align-items: center;</p>
<p>​      justify-content: center;</p>
<p>​     所有子级元素</p>
<p>​    &gt; h1, &gt; h2, p {</p>
<p>​           width: 100%;</p>
<p>​           text-align: center;</p>
<p>​     }</p>
</blockquote>
</li>
<li><p>position的值</p>
<blockquote>
<ul>
<li>static（默认）：按照正常文档流进行排列； </li>
<li>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位； </li>
<li>absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位； </li>
<li>fixed(固定定位)：所固定的参照对像是可视窗口。</li>
</ul>
</blockquote>
</li>
<li><p>CSS3有哪些新特性</p>
<blockquote>
<ul>
<li><p>对长的不可分割单词换行 word-wrap：break-word </p>
</li>
<li><p>英文和数字不换行 word-break: break-all;</p>
</li>
<li><p>文字超出行数以省略号显示</p>
<p>display: -webkit-box !important;</p>
<p>-ms-text-overflow: ellipsis;</p>
<p>text-overflow: ellipsis;</p>
<p>overflow: hidden;</p>
<p>word-break: break-all;</p>
<p>-webkit-box-orient: vertical;</p>
<p>-webkit-line-clamp: 3; // 可显示行数</p>
</li>
<li><p>取消a标签在移动端点击时的蓝色</p>
<p>-webkit-tap-highlight-color: rgba(255, 255, 255, 0);</p>
<p>-webkit-user-select: none;</p>
<p>-moz-user-focus: none;</p>
<p>-moz-user-select: none;</p>
</li>
<li><p>指定位置剪切图片</p>
<p>img{</p>
<p>position:absolute; </p>
<p>​    clip:rect(0px 500px 150px 0px); </p>
<p>}</p>
</li>
<li><p>阻止旋转屏幕时自动调整字体大小</p>
<p>移动端开发时，屏幕有竖屏和横屏模式，当屏幕进行旋转时，字体大小则有可能会发生变化，从而影响页面布局的整体样式，为避免此类情况发生，只需设置如下样式即可</p>
<p>{ -webkit-text-size-adjust: none;}</p>
</li>
<li><p>修改移动端难看的点击的高亮效果，iOS和安卓下都有效</p>
<p> -webkit-tap-highlight-color: rgba(0,0,0,0);</p>
</li>
<li><p>禁止在input中输入中文</p>
<p>用文本框的CSS属性ime-mode实现。 </p>
<input onpaste="return false" ondragenter="return false" style="ime-mode:disabled"> 

<p> 提示：设置ime-mode为disabled的意思是禁止在输入时禁止用户激活输入中文，韩文，日文等的输入法（IME）状态，因为这个只能检测到键盘的输入，对通过鼠标操作的粘贴和拖放无效。 </p>
</li>
</ul>
</blockquote>
</li>
<li><p>icon字体</p>
<blockquote>
<p>1.引入css</p>
<link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_918569_2pxb1owlzc1.css">

<p>2.使用</p>
<p><span class="iconfont icon-xiaoxi"></span></p>
</blockquote>
</li>
<li><p>三角</p>
<blockquote>
<p>![01 (1)](css3.assets/01 (1).png)</p>
<p>width: 0;<br>height: 0;<br>border: 50px solid;<br>border-color: red yellow green blue;</p>
<p>![01 (2)](css3.assets/01 (2).png)</p>
<p>width: 0;<br>height: 0;<br>border: 50px solid;<br>border-color: red transparent transparent transparent;</p>
</blockquote>
<p>​</p>
<p>​</p>
</li>
<li><p>对勾</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tesy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.tesy</span> &#123;</span></span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 110px;</span><br><span class="line">    top: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">、  <span class="selector-class">.tesy</span><span class="selector-pseudo">:before</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    content: '';</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 6px;</span><br><span class="line">    height: 15px;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#1137a0</span>;</span></span><br><span class="line">    border-bottom: 1px solid;</span><br><span class="line">    border-right: 1px solid;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    -webkit-transform-origin: center;</span><br><span class="line">            transform-origin: center;</span><br><span class="line">    transform: translate(-50%, -30%) rotate(45deg);</span><br><span class="line">    -webkit-transform: translate(-50%, -30%) rotate(45deg);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>三角突出效果</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rongpi"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wenan"</span>&gt;</span>跟团游<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sanjiao"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">.rongpi&#123;</span><br><span class="line">			height: 15px;</span><br><span class="line">			overflow: hidden;</span><br><span class="line">			position: absolute;</span><br><span class="line">			top:0;</span><br><span class="line">			left: 0;</span><br><span class="line">		&#125;</span><br><span class="line">		.wenan&#123;</span><br><span class="line">			float: left;</span><br><span class="line">			position: relative;</span><br><span class="line">			z-index: 3;</span><br><span class="line">			height: 15px;</span><br><span class="line">			padding-left: 4px;</span><br><span class="line">			line-height: 16px;</span><br><span class="line">			color:white;</span><br><span class="line">			background: red;</span><br><span class="line">			font-size: 10px;</span><br><span class="line">		&#125;</span><br><span class="line">		.sanjiao&#123;</span><br><span class="line">			width:0;</span><br><span class="line">			height: 0;</span><br><span class="line">			border-right: 20px solid transparent;</span><br><span class="line">			border-top: 30px solid red;</span><br><span class="line">			float: right;</span><br><span class="line">			margin-left: -9px;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>渐变</p>
<blockquote>
<ul>
<li><p>背景颜色渐变色</p>
<p>background:linear-gradient(116deg,rgba(247,209,177,1) 0%,rgba(210,162,122,1) 100%);</p>
<p><a href="https://blog.csdn.net/qq_36538012/article/details/79467097" target="_blank" rel="noopener">https://blog.csdn.net/qq_36538012/article/details/79467097</a></p>
<p><a href="https://blog.csdn.net/qq_16390749/article/details/77718834" target="_blank" rel="noopener">https://blog.csdn.net/qq_16390749/article/details/77718834</a></p>
</li>
<li><p>字体颜色渐变色</p>
<p><a href="https://blog.csdn.net/qq_34122603/article/details/78684445" target="_blank" rel="noopener">https://blog.csdn.net/qq_34122603/article/details/78684445</a></p>
</li>
</ul>
</blockquote>
</li>
<li><p>判断机型（页面大小）</p>
<blockquote>
<ul>
<li><p>iphoneX</p>
<p>@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {</p>
<p>​     .BottomProgress {</p>
<p>​        bottom: 34px !important;</p>
<p>​    }</p>
<p>}</p>
</li>
</ul>
</blockquote>
</li>
<li><p>彩色进度条</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">progress: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> filldiv = $(<span class="string">"#filldiv"</span>);</span><br><span class="line">  <span class="keyword">var</span> percent = $(<span class="string">"#percent"</span>);</span><br><span class="line">  <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#filldiv"</span>).css(<span class="string">"width"</span>, i++ + <span class="string">'%'</span>)</span><br><span class="line">    $(<span class="string">"#filldiv"</span>).css(<span class="string">"background"</span>, self.getColor())</span><br><span class="line">    $(<span class="string">"#percent"</span>).innerHTML = <span class="built_in">parseInt</span>(i * <span class="number">100</span> / <span class="number">500</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">100</span>) &#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">////获取十六进制的随机颜色值</span></span><br><span class="line">getColor: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">"0123456789abcdef"</span>;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="string">"#"</span>;</span><br><span class="line">  <span class="keyword">var</span> rand;</span><br><span class="line">  <span class="comment">//str有下标 0-15</span></span><br><span class="line">  <span class="comment">//获取0-15的随机数</span></span><br><span class="line">  <span class="comment">//通过这个随机数作为str的下标，</span></span><br><span class="line">  <span class="comment">//获取随机字符</span></span><br><span class="line">  <span class="comment">//获取六个随机字符拼成一个字符串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    rand = self.getRand(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    color += str.charAt(rand);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> color;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//获取min-max之间的随机整数</span></span><br><span class="line">getRand: <span class="function"><span class="keyword">function</span> (<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>条纹滚动进度条</p>
<p><img src="/2020/07/23/css3/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/a9c3115c2406484ea92d78187053848c/1c0ba1a3675e9eeb2b43efe126b06d4.png" alt="img"></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">progressBar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  self.progressText = <span class="string">''</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"progress-container "</span>).style.width = i++ + <span class="string">'%'</span>;</span><br><span class="line">    self.progressText = $(<span class="string">"progress-container "</span>).style.width</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="string">"progress-container "</span>).style.width &gt;= <span class="string">"98%"</span>) &#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;,</span><br><span class="line">html</span><br><span class="line">  &lt; div <span class="class"><span class="keyword">class</span></span>=<span class="string">"progress-container"</span> id = <span class="string">"progress-container "</span> &gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"progress-cont"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span> &gt;</span><br><span class="line">  样式</span><br><span class="line">    .progress - container &#123;</span><br><span class="line">  height: <span class="number">100</span> %;</span><br><span class="line">  width: <span class="number">100</span> %;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br><span class="line">.progress - cont &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">-1000</span>px;</span><br><span class="line">  height: <span class="number">100</span> %;</span><br><span class="line">  width: <span class="number">2000</span>px;</span><br><span class="line">  background - image: linear - gradient(90deg, transparent 0rem, transparent 2rem, #FFEBEC 2em, #FFEBEC 4rem, transparent 4rem);</span><br><span class="line">  background - color: #FFF2F2;</span><br><span class="line">  background - size: <span class="number">40</span>px <span class="number">100</span> %;</span><br><span class="line">  background - repeat: repeat - x;</span><br><span class="line">  transform: skewX(<span class="number">-30</span>deg)!important;</span><br><span class="line">&#125;</span><br><span class="line">.progress - cont &#123;</span><br><span class="line">  animation: reverse progress - bar - stripes <span class="number">0.40</span>s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes progress - bar - stripes &#123;</span><br><span class="line">  <span class="keyword">from</span> &#123;</span><br><span class="line">    background - position: <span class="number">40</span>px <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  to &#123;</span><br><span class="line">    background - position: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>CSS选择器合集</p>
<blockquote>
<p>\1. div &gt;a</p>
<p>这个选择器将使我们能够选择所有父元素是div标签的元素。</p>
<!-- This one will be selected --> 

<div>   

<p>​     <a></a></p>
</div>

<!-- This one won't be selected -->

<p>   

<pre><code>&lt;a&gt;&lt;/a&gt;</code></pre></p>

<p>\2. div +a</p>
<p>选择紧接在div元素之后的每个标签。如果我们在div和a标签之间有一个元素，则不会选择该元素。</p>
<main>

<!-- This one will be selected --> 

   <div></div>  

<p>   <a></a></p>
<!-- This one won't be selected -->  

  <div></div> 

   <p></p>  

<p>   <a></a></p>
</main>

<p>\3. div ~a</p>
<p>如果a标签具有div标签作为同级元素，则将选择该标签。</p>
<main>

<!-- This one will be selected -->

<p>​    <div></div> </p>
<p>​    <a></a></p>
<!-- This one will be selected -->

<p>​    <div></div></p>
<p>​    </p><p></p> <p></p>
<p>​    <a></a> </p>
<section>

<!-- This one will be selected -->

<p>​    <div></div> </p>
<p>​    </p><p></p>  <p></p>
<p>​    <a></a>  </p>
 </section>

<footer>

<!-- This one won't be selected -->

<p>​    </p><p></p> <p></p>
<p>​    <a></a>   </p>
 </footer>

</main>

<p>\4. [属性^=值]</p>
<p>例如：[class ^ =“ list-”]此选择器将选择每个包含class属性且其值以list-开头的元素。</p>
<main>

<!-- This one will be selected -->

<p>​    <div class="list-element"></div></p>
<!-- This one will be selected -->

<p>​    <div class="list-container"></div></p>
<!-- This one will be selected -->

<p>​    <div class="list-item"></div></p>
<!-- This one won't be selected -->

<p>​    <div class="list__footer"></div></p>
</main>

<p>\5. [属性$=值]</p>
<p>例如：[src $ =“.png”]这将选择每个值以.png结尾的src属性。</p>
<div>

<!-- This one will be selected -->

<p>​    <img src="/2020/07/23/css3/image1.png"></p>
<!-- This one will be not selected -->

<p>​    <img src="/2020/07/23/css3/image2.jpg"></p>
<!-- This one will be selected -->

<p>​    <img src="/2020/07/23/css3/image3.png"></p>
<!-- This one won't be selected -->

<p>​    <img src="/2020/07/23/css3/image4.svg"></p>
</div>

<p>\6. [属性*=值]</p>
<p>例如：[class * =“-list”]此选择器将选择其class属性包含-list的每个元素。 不管-list是在类值的开头，中间还是结尾都没有关系。最重要的是该值必须包含-list。</p>
<main>

<!-- This one will be selected -->

<p>​    <div class="main-list-container"></div></p>
<!-- This one will be selected -->

<p>​    <div class="primary-list"></div></p>
<!-- This one will be selected -->

<p>​    <div class="primary-list-item"></div></p>
<!-- This one won't be selected -->

<p>​    <div class="list-footer"></div></p>
</main>
</blockquote>
</li>
<li><p>使用text-transform转换字母为大写</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;movie-poster&quot;&gt;Star Wars: The Force Awakens&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">.movie-poster &#123;</span><br><span class="line">	text-transform: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="19">
<li>Em, Rem与px</li>
</ol>
<p>设置元素与文本的大小应该用哪种单位，em，rem，还是px？一直以来都有很多的争论。事实是，这三种选择都是可行的，都有其利弊。</p>
<p>在什么时候在什么项目使用哪种单位是没有一个定论的，开发人员的习惯不同，项目的要求不同，都可能会使用不同的单位。然而，虽然没有固定的规则，但是每种单位还是有一些要注意的地方的：</p>
<ul>
<li>em - 设置元素为1em，其大小与父元素的font-size属性有关。这个单位用于媒体查询中，特别适用于响应式开发，但是由于em单位在每一级中都是相对于父元素进行计算的，所以要得出某个子元素em单位对应的px值，有时候是很麻烦的。</li>
<li>rem - 相对于<html>元素的font-size大小计算，rem使得统一改变页面上的所有标题和段落文本大小变得非常容易。</html></li>
<li>px - 像素单位是最精确的，但是不适用于自适应的设计。px单位是可靠的，并且易于理解，我们可以精细的控制元素的大小和移动到1px。</li>
</ul>
<p>最重要的是，不要害怕尝试，尝试所有方法，看看最适合什么。有时候，em和rem可以节省很多工作，尤其是在构建响应式页面时。</p>
<ol start="20">
<li>CSS 利用transform达到居中效果</li>
</ol>
<blockquote>
<body>

<pre><code>&lt;div class=&quot;center&quot;&gt;
    ....
&lt;/div&gt;</code></pre></body>

<p>让left和top都是50%，这在水平方向上让div的最左与屏幕的最左相距50%，垂直方向上一样，所以再用transform向左（上）平移它自己宽度（高度）的50%，也就达到居中效果了</p>
<p>.center{<br>    text-align: center;<br>    background-color: #fff;<br>    border-radius: 20px;<br>    width: 300px;<br>    height: 350px;<br>    position: absolute;<br>    left: 50%;<br>    top: 50%;<br>    transform: translate(-50%,-50%);<br>}</p>
</blockquote>
<ol start="21">
<li>一行 CSS 为网页添加暗黑模式支持</li>
</ol>
<blockquote>
<p>html[theme=’dark-mode’] {<br>  filter: invert(1) hue-rotate(180deg);<br>}</p>
<p>我们还将向HTML元素添加一个 <code>transition</code> ，以确保过渡不会过于花哨!</p>
<p>html {<br>    transition: color 300ms, background-color 300ms;<br>}</p>
<p><code>filter</code> CSS 属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p>
<p>对于暗黑模式，将使用两个 <code>filter</code> ：<code>invert</code> 和 <code>hue-rotate</code></p>
<p><strong>invert</strong>：反转配色。黑色变为白色，白色变为黑色，所有颜色都是如此</p>
<p><strong>hue-rotate</strong>：帮助我们处理所有其他非黑色和白色的颜色。将色相旋转180度，我们确保应用程序的颜色主题不会改变，而只是减弱其颜色。</p>
</blockquote>
<ol start="22">
<li>文字竖向排版</li>
</ol>
<blockquote>
<p>第一种</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/eXCSRjyNYcYU0xWZN4hLpZlic52RVnK5xj4toUBicq3q2hWpX6UGLtxia8cx5mFQ9ndmHCSE6SKCEmiciazONichGfpQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<style>  
.one {  
    width: 20px;  
    margin: 0 auto;  
    line-height: 24px;  
    font-size: 20px;
}
.two {  
    width: 15px;  
    margin: 0 auto;  
    line-height: 24px;  
    font-size: 20px;  
    word-wrap: break-word;/*英文的时候需要加上这句，自动换行*/  
}  
</style>  
<body>  
    <div class="one">我是竖列排版</div>  
    <div class="two">I AM ENGLISH</div>

</body>

<p>第二种</p>
<p><img src="/2020/07/23/css3/image-20200914175703225.png" alt="image-20200914175703225"></p>
<style>  
.one {  
    margin: 0 auto;  
    height: 140px;  
    writing-mode: vertical-lr;/*从左向右 从右向左是 writing-mode: vertical-rl;*/  
    writing-mode: tb-lr;/*IE浏览器的从左向右 从右向左是 writing-mode: tb-rl；*/  
}  
</style>  
<body>  
    <div class="one">欲话毗陵君反袂，欲言夏口我沾衣。谁知临老相逢日，悲叹声多语笑稀。</div>  
    <div class="one">I AM ENGLISH</div>
</body>

<p>第三种</p>
<p><img src="/2020/07/23/css3/image-20200914175815863.png" alt="image-20200914175815863"></p>
<style>
.one {
    margin: 150px auto;
    width: 200px;
    font-size: 20px; 
    line-height: 24px;
    transform:rotate(90deg);
    -ms-transform:rotate(90deg);     /* IE 9 */
    -moz-transform:rotate(90deg);     /* Firefox */
    -webkit-transform:rotate(90deg); /* Safari 和 Chrome */
    -o-transform:rotate(90deg);     /* Opera */
}
</style>
<body>
    <div class="one">欲话毗陵君反袂</div>
    <div class="one">ENGLISH</div>
</body>
</blockquote>
<ol start="23">
<li>单侧投影</li>
</ol>
<blockquote>
<p>果阴影的模糊半径，与负的扩张半径一致，那么我们将看不到任何阴影，因为生成的阴影将被包含在原来的元素之下，除非给它设定一个方向的偏移量。所以这个时候，我们给定一个方向的偏移值，即可实现单侧投影：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eXCSRjyNYcaY1AYPXeaTj5zK4qzBIwWxqaOGCww1luEoUc2ZDpoPtnqXHFWol4pa0dhnfWMCcm5kxMGESvOQKg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
</blockquote>
<ol start="24">
<li>使用负 letter-spacing 倒序排列文字</li>
</ol>
<blockquote>
<p>letter-spacing: -72px;</p>
</blockquote>
<ol start="25">
<li>立即执行延迟动画</li>
</ol>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;g-container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt; </span><br><span class="line">    &lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">    &lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.item &#123;</span><br><span class="line">  transform: rotate(0) translate(-80px, 0) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item:nth-child(1) &#123;</span><br><span class="line">  animation: rotate 3s infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item:nth-child(2) &#123;</span><br><span class="line">  animation: rotate 3s infinite -1s linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item:nth-child(3) &#123;</span><br><span class="line">  animation: rotate 3s infinite -2s linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@keyframes rotate &#123;</span><br><span class="line">  100% &#123;</span><br><span class="line">      transform: rotate(360deg) translate(-80px, 0) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="23">
<li>attr()</li>
</ol>
<blockquote>
<p><code>attr</code> 函数用于获取所选元素的属性值。它接受三个参数，<code>属性名称</code>，<code>类型</code>和<code>默认值</code>。</p>
<blockquote>
<p>语法: attr( attribute-name? [,]? )</p>
</blockquote>
<p>事例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p data-text&#x3D;&quot;the attr function&quot;</span><br><span class="line">  data-tooltip&#x3D;&quot;Hi from attr!&quot; class&#x3D;&quot;attr&quot;&gt;This text is combined with&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p::after &#123;</span><br><span class="line">  content: &#39; &#39; attr(data-text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.attr:hover::after &#123;</span><br><span class="line">  content: &#39; &#39; attr(data-tooltip);</span><br><span class="line">  background-color: orange;</span><br><span class="line">  color: white</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="24">
<li>word-wrap和word-break</li>
</ol>
<p>word-wrap:break-word;（换行后截断）</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/2050/201208/201208101725587335.png" alt="01"></p>
<p>word-break：break-all（直接截断）</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/2050/201208/201208101726046184.png" alt="01"></p>
<ol start="25">
<li>classList对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;myDIV&quot;).classList.add(&quot;mystyle&quot;);</span><br><span class="line"></span><br><span class="line">add(class1, class2, ...)	在元素中添加一个或多个类名。</span><br><span class="line">如果指定的类名已存在，则不会添加</span><br><span class="line"></span><br><span class="line">contains(class)	返回布尔值，判断指定的类名是否存在。</span><br><span class="line">可能值：</span><br><span class="line">true - 元素包已经包含了该类名</span><br><span class="line">false - 元素中不存在该类名</span><br><span class="line">item(index)	返回元素中索引值对应的类名。索引值从 0 开始。</span><br><span class="line">如果索引值在区间范围外则返回 null</span><br><span class="line"></span><br><span class="line">remove(class1, class2, ...)	移除元素中一个或多个类名。</span><br><span class="line">注意： 移除不存在的类名，不会报错。</span><br><span class="line"></span><br><span class="line">toggle(class, true|false)	在元素中切换类名。</span><br><span class="line">第一个参数为要在元素中移除的类名，并返回 false。</span><br><span class="line">如果该类名不存在则会在元素中添加类名，并返回 true。</span><br><span class="line"></span><br><span class="line">第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在。例如：</span><br><span class="line"></span><br><span class="line">移除一个 class: element.classList.toggle(&quot;classToRemove&quot;, false);</span><br><span class="line">添加一个 class: element.classList.toggle(&quot;classToAdd&quot;, true);</span><br><span class="line"></span><br><span class="line">注意： Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。</span><br></pre></td></tr></table></figure>

<ol start="26">
<li>画一条0.5px的直线？</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">height: 1px;</span><br><span class="line">transform: scale(0.5);</span><br></pre></td></tr></table></figure>

<p>27.选中每几个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;:nth-child(5n+5)&#123;</span><br><span class="line">    margin-right: 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<ol start="24">
<li>8种让人眼前一亮的hover效果</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/dNR0ZykPSDEW1z6qH7iCMg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dNR0ZykPSDEW1z6qH7iCMg</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>echarts属性记录</title>
    <url>/2021/01/08/echarts%E5%B1%9E%E6%80%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>参考链接</p>
<p><a href="https://www.cnblogs.com/zhangxiaoxia/p/9832201.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxiaoxia/p/9832201.html</a></p>
<h3 id="柱状图属性详解"><a href="#柱状图属性详解" class="headerlink" title="柱状图属性详解"></a>柱状图属性详解</h3><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 基于准备好的dom，初始化echarts实例</span><br><span class="line">var myChart &#x3D; echarts.init(document.getElementById(&#39;_top&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定图表的配置项和数据</span><br><span class="line">var option &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;--------------    标题 title  ----------------  </span><br><span class="line">    title: &#123;</span><br><span class="line">        text: &#39;主标题&#39;,</span><br><span class="line">        textStyle: &#123;                 &#x2F;&#x2F;---主标题内容样式   </span><br><span class="line">            color: &#39;#fff&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        subtext: &#39;副标题&#39;,          &#x2F;&#x2F;---副标题内容样式</span><br><span class="line">        subtextStyle: &#123;</span><br><span class="line">            color: &#39;#bbb&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        padding: [0, 0, 100, 100]               &#x2F;&#x2F;---标题位置,因为图形是是放在一个dom中,因此用padding属性来定位</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;----------------   图例 legend  -----------------</span><br><span class="line">    legend: &#123;</span><br><span class="line">        type: &#39;plain&#39;,               &#x2F;&#x2F;----图例类型，默认为&#39;plain&#39;，当图例很多时可使用&#39;scroll&#39;</span><br><span class="line">        top: &#39;1%&#39;,                   &#x2F;&#x2F;----图例相对容器位置,top\bottom\left\right           </span><br><span class="line">        selected: &#123;</span><br><span class="line">            &#39;销量&#39;: true,          &#x2F;&#x2F;----图例选择,图形加载出来会显示选择的图例，默认为true</span><br><span class="line">        &#125;,</span><br><span class="line">        textStyle: &#123;                 &#x2F;&#x2F;----图例内容样式</span><br><span class="line">            color: &#39;#fff&#39;,               &#x2F;&#x2F;---所有图例的字体颜色</span><br><span class="line">            &#x2F;&#x2F;backgroundColor:&#39;black&#39;,  &#x2F;&#x2F;---所有图例的字体背景色</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;                   &#x2F;&#x2F;图例提示框，默认不显示</span><br><span class="line">            show: true,</span><br><span class="line">            color: &#39;red&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">        data: [                      &#x2F;&#x2F;----图例内容</span><br><span class="line">            &#123;</span><br><span class="line">                name: &#39;销量&#39;,</span><br><span class="line">                icon: &#39;circle&#39;,          &#x2F;&#x2F;----图例的外框样式</span><br><span class="line">                textStyle: &#123;</span><br><span class="line">                    color: &#39;#fff&#39;,       &#x2F;&#x2F;----单独设置某一个图例的颜色</span><br><span class="line">                    &#x2F;&#x2F;backgroundColor:&#39;black&#39;,&#x2F;&#x2F;---单独设置某一个图例的字体背景色</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;--------------   提示框 -----------------</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        show: true,                  &#x2F;&#x2F;---是否显示提示框,默认为true</span><br><span class="line">        trigger: &#39;item&#39;,             &#x2F;&#x2F;---数据项图形触发</span><br><span class="line">        axisPointer: &#123;               &#x2F;&#x2F;---指示样式</span><br><span class="line">            type: &#39;shadow&#39;,</span><br><span class="line">            axis: &#39;auto&#39;,</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        padding: 5,</span><br><span class="line">        textStyle: &#123;                 &#x2F;&#x2F;---提示框内容样式</span><br><span class="line">            color: &quot;#fff&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;-------------  grid区域  ----------------</span><br><span class="line">    grid: &#123;</span><br><span class="line">        show: false,                 &#x2F;&#x2F;---是否显示直角坐标系网格</span><br><span class="line">        top: 80,                     &#x2F;&#x2F;---相对位置，top\bottom\left\right </span><br><span class="line">        containLabel: false,         &#x2F;&#x2F;---grid 区域是否包含坐标轴的刻度标签</span><br><span class="line">        tooltip: &#123;                   &#x2F;&#x2F;---鼠标焦点放在图形上，产生的提示框</span><br><span class="line">            show: true,</span><br><span class="line">            trigger: &#39;item&#39;,         &#x2F;&#x2F;---触发类型</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                color: &#39;#666&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;-------------   x轴   -------------------</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        show: true,                  &#x2F;&#x2F;---是否显示</span><br><span class="line">        position: &#39;bottom&#39;,          &#x2F;&#x2F;---x轴位置</span><br><span class="line">        offset: 0,                   &#x2F;&#x2F;---x轴相对于默认位置的偏移</span><br><span class="line">        type: &#39;category&#39;,            &#x2F;&#x2F;---轴类型，默认&#39;category&#39;</span><br><span class="line">        name: &#39;月份&#39;,              &#x2F;&#x2F;---轴名称</span><br><span class="line">        nameLocation: &#39;end&#39;,         &#x2F;&#x2F;---轴名称相对位置</span><br><span class="line">        nameTextStyle: &#123;             &#x2F;&#x2F;---坐标轴名称样式</span><br><span class="line">            color: &quot;#fff&quot;,</span><br><span class="line">            padding: [5, 0, 0, -5], &#x2F;&#x2F;---坐标轴名称相对位置</span><br><span class="line">        &#125;,</span><br><span class="line">        nameGap: 15,                 &#x2F;&#x2F;---坐标轴名称与轴线之间的距离</span><br><span class="line">        &#x2F;&#x2F;nameRotate:270,           &#x2F;&#x2F;---坐标轴名字旋转</span><br><span class="line"></span><br><span class="line">        axisLine: &#123;                  &#x2F;&#x2F;---坐标轴 轴线</span><br><span class="line">            show: true,                  &#x2F;&#x2F;---是否显示</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;------------------- 箭头 -------------------------</span><br><span class="line">            symbol: [&#39;none&#39;, &#39;arrow&#39;],   &#x2F;&#x2F;---是否显示轴线箭头</span><br><span class="line">            symbolSize: [8, 8],         &#x2F;&#x2F;---箭头大小</span><br><span class="line">            symbolOffset: [0, 7],         &#x2F;&#x2F;---箭头位置</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;------------------- 线 -------------------------</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                color: &#39;#fff&#39;,</span><br><span class="line">                width: 1,</span><br><span class="line">                type: &#39;solid&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        axisTick: &#123;                  &#x2F;&#x2F;---坐标轴 刻度</span><br><span class="line">            show: true,                  &#x2F;&#x2F;---是否显示</span><br><span class="line">            inside: true,                &#x2F;&#x2F;---是否朝内</span><br><span class="line">            lengt: 3,                    &#x2F;&#x2F;---长度</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                &#x2F;&#x2F;color:&#39;red&#39;,          &#x2F;&#x2F;---默认取轴线的颜色</span><br><span class="line">                width: 1,</span><br><span class="line">                type: &#39;solid&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        axisLabel: &#123;                 &#x2F;&#x2F;---坐标轴 标签</span><br><span class="line">            show: true,                  &#x2F;&#x2F;---是否显示</span><br><span class="line">            inside: false,               &#x2F;&#x2F;---是否朝内</span><br><span class="line">            rotate: 0,                   &#x2F;&#x2F;---旋转角度  </span><br><span class="line">            margin: 5,                  &#x2F;&#x2F;---刻度标签与轴线之间的距离</span><br><span class="line">            &#x2F;&#x2F;color:&#39;red&#39;,              &#x2F;&#x2F;---默认取轴线的颜色</span><br><span class="line">        &#125;,</span><br><span class="line">        splitLine: &#123;                 &#x2F;&#x2F;---grid 区域中的分隔线</span><br><span class="line">            show: false,                 &#x2F;&#x2F;---是否显示，&#39;category&#39;类目轴不显示，此时我的X轴为类目轴，splitLine属性是无意义的</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                &#x2F;&#x2F;color:&#39;red&#39;,</span><br><span class="line">                &#x2F;&#x2F;width:1,</span><br><span class="line">                &#x2F;&#x2F;type:&#39;solid&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        splitArea: &#123;                 &#x2F;&#x2F;--网格区域</span><br><span class="line">            show: false,                 &#x2F;&#x2F;---是否显示，默认false</span><br><span class="line">        &#125;,</span><br><span class="line">        data: [&quot;1月&quot;, &quot;2月&quot;, &quot;3月&quot;, &quot;4月&quot;, &quot;5月&quot;, &quot;6月&quot;, &quot;7月&quot;, &quot;8月&quot;, &quot;9月&quot;, &quot;10月&quot;, &quot;11月&quot;, &quot;12月&quot;],&#x2F;&#x2F;内容</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;----------------------  y轴  ------------------------</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        show: true,                  &#x2F;&#x2F;---是否显示</span><br><span class="line">        position: &#39;left&#39;,            &#x2F;&#x2F;---y轴位置</span><br><span class="line">        offset: 0,                   &#x2F;&#x2F;---y轴相对于默认位置的偏移</span><br><span class="line">        type: &#39;value&#39;,           &#x2F;&#x2F;---轴类型，默认&#39;category&#39;</span><br><span class="line">        name: &#39;销量&#39;,              &#x2F;&#x2F;---轴名称</span><br><span class="line">        nameLocation: &#39;end&#39;,         &#x2F;&#x2F;---轴名称相对位置value</span><br><span class="line">        nameTextStyle: &#123;             &#x2F;&#x2F;---坐标轴名称样式</span><br><span class="line">            color: &quot;#fff&quot;,</span><br><span class="line">            padding: [5, 0, 0, 5],  &#x2F;&#x2F;---坐标轴名称相对位置</span><br><span class="line">        &#125;,</span><br><span class="line">        nameGap: 15,                 &#x2F;&#x2F;---坐标轴名称与轴线之间的距离</span><br><span class="line">        &#x2F;&#x2F;nameRotate:270,           &#x2F;&#x2F;---坐标轴名字旋转</span><br><span class="line"></span><br><span class="line">        axisLine: &#123;                  &#x2F;&#x2F;---坐标轴 轴线</span><br><span class="line">            show: true,                  &#x2F;&#x2F;---是否显示</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;------------------- 箭头 -------------------------</span><br><span class="line">            symbol: [&#39;none&#39;, &#39;arrow&#39;],   &#x2F;&#x2F;---是否显示轴线箭头</span><br><span class="line">            symbolSize: [8, 8],         &#x2F;&#x2F;---箭头大小</span><br><span class="line">            symbolOffset: [0, 7],         &#x2F;&#x2F;---箭头位置</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;------------------- 线 -------------------------</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                color: &#39;#fff&#39;,</span><br><span class="line">                width: 1,</span><br><span class="line">                type: &#39;solid&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        axisTick: &#123;                  &#x2F;&#x2F;---坐标轴 刻度</span><br><span class="line">            show: true,                  &#x2F;&#x2F;---是否显示</span><br><span class="line">            inside: true,                &#x2F;&#x2F;---是否朝内</span><br><span class="line">            lengt: 3,                    &#x2F;&#x2F;---长度</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                &#x2F;&#x2F;color:&#39;red&#39;,          &#x2F;&#x2F;---默认取轴线的颜色</span><br><span class="line">                width: 1,</span><br><span class="line">                type: &#39;solid&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        axisLabel: &#123;                 &#x2F;&#x2F;---坐标轴 标签</span><br><span class="line">            show: true,                  &#x2F;&#x2F;---是否显示</span><br><span class="line">            inside: false,               &#x2F;&#x2F;---是否朝内</span><br><span class="line">            rotate: 0,                   &#x2F;&#x2F;---旋转角度  </span><br><span class="line">            margin: 8,                  &#x2F;&#x2F;---刻度标签与轴线之间的距离</span><br><span class="line">            &#x2F;&#x2F;color:&#39;red&#39;,              &#x2F;&#x2F;---默认取轴线的颜色</span><br><span class="line">        &#125;,</span><br><span class="line">        splitLine: &#123;                 &#x2F;&#x2F;---grid 区域中的分隔线</span><br><span class="line">            show: true,                  &#x2F;&#x2F;---是否显示，&#39;category&#39;类目轴不显示，此时我的y轴为类目轴，splitLine属性是有意义的</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                color: &#39;#666&#39;,</span><br><span class="line">                width: 1,</span><br><span class="line">                type: &#39;dashed&#39;,          &#x2F;&#x2F;---类型</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        splitArea: &#123;                 &#x2F;&#x2F;--网格区域</span><br><span class="line">            show: false,                 &#x2F;&#x2F;---是否显示，默认false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;------------ 内容数据  -----------------</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &#39;销量&#39;,             &#x2F;&#x2F;---系列名称</span><br><span class="line">            type: &#39;bar&#39;,                &#x2F;&#x2F;---类型</span><br><span class="line">            legendHoverLink: true,       &#x2F;&#x2F;---是否启用图例 hover 时的联动高亮</span><br><span class="line">            label: &#123;                     &#x2F;&#x2F;---图形上的文本标签</span><br><span class="line">                show: false,</span><br><span class="line">                position: &#39;insideTop&#39;,   &#x2F;&#x2F;---相对位置</span><br><span class="line">                rotate: 0,               &#x2F;&#x2F;---旋转角度</span><br><span class="line">                color: &#39;#eee&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">            itemStyle: &#123;                 &#x2F;&#x2F;---图形形状</span><br><span class="line">                color: &#39;blue&#39;,</span><br><span class="line">                barBorderRadius: [18, 18, 0, 0],</span><br><span class="line">            &#125;,</span><br><span class="line">            barWidth: &#39;20&#39;,              &#x2F;&#x2F;---柱形宽度</span><br><span class="line">            barCategoryGap: &#39;20%&#39;,       &#x2F;&#x2F;---柱形间距</span><br><span class="line">            data: [3020, 4800, 3600, 6050, 4320, 6200, 5050, 7200, 4521, 6700, 8000, 5020]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用刚指定的配置项和数据显示图表。</span><br><span class="line">myChart.setOption(option);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>echarts项目实战记录</title>
    <url>/2020/11/09/echarts%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><h4 id="初始化圆角"><a href="#初始化圆角" class="headerlink" title="初始化圆角"></a>初始化圆角</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">series : [</span><br><span class="line">                &#123;</span><br><span class="line">                    name:&#39;蒸发量&#39;,</span><br><span class="line">                    type:&#39;bar&#39;,</span><br><span class="line">                    data:[2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name:&#39;降水量&#39;,</span><br><span class="line">                    type:&#39;bar&#39;,</span><br><span class="line">                    data:[2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3],</span><br><span class="line">                    &#x2F;&#x2F;顶部数字展示pzr</span><br><span class="line">                    barWidth: 14,</span><br><span class="line">                    itemStyle: &#123;</span><br><span class="line">                        &#x2F;&#x2F;柱形图圆角，鼠标移上去效果</span><br><span class="line">                        emphasis: &#123;</span><br><span class="line">                            barBorderRadius: [10, 10, 10, 10]&#x2F;&#x2F;barBorderRadius:11</span><br><span class="line">                        &#125;,</span><br><span class="line">                         </span><br><span class="line">                        normal: &#123;</span><br><span class="line">                            &#x2F;&#x2F;柱形图圆角，初始化效果</span><br><span class="line">                            barBorderRadius:[10, 10, 10, 10] &#x2F;&#x2F;barBorderRadius:11</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="设置渐变"><a href="#设置渐变" class="headerlink" title="设置渐变"></a>设置渐变</h4><p>设置itemStyle的color为new echarts.graphic.LinearGradient()线性渐变即可. 这个API在官方文档里面都没找到, 经过测试前四个参数设置为0, 0, 1, 0可以从左到右渐变. 设置为0,0,0,1可以从上到下渐变. 第5个参数数组表示开始的颜色和结束的颜色.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">itemStyle: &#123;</span><br><span class="line">                    emphasis: &#123;</span><br><span class="line">                        barBorderRadius: 7</span><br><span class="line">                    &#125;,</span><br><span class="line">                    normal: &#123;</span><br><span class="line">                        barBorderRadius: 7,</span><br><span class="line">                        color: new echarts.graphic.LinearGradient(</span><br><span class="line">                            0, 0, 1, 0,</span><br><span class="line">                            [</span><br><span class="line">                                &#123;offset: 0, color: &#39;#3977E6&#39;&#125;,</span><br><span class="line">                                &#123;offset: 1, color: &#39;#37BBF8&#39;&#125;</span><br><span class="line"> </span><br><span class="line">                            ]</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">或者</span><br><span class="line">itemStyle: &#123;</span><br><span class="line">                            normal: &#123;</span><br><span class="line">                                &#x2F;&#x2F;柱体的颜色</span><br><span class="line">                                color: function (params) &#123;</span><br><span class="line">                                    var colorList &#x3D; [</span><br><span class="line">                                        [&#39;#FFB54D&#39;, &#39;#E6D417&#39;],</span><br><span class="line">                                        [&#39;#FFB54D&#39;, &#39;#E6D417&#39;],</span><br><span class="line">                                        [&#39;#FFB54D&#39;, &#39;#E6D417&#39;],</span><br><span class="line">                                        [&#39;#FFB54D&#39;, &#39;#E6D417&#39;],</span><br><span class="line">                                        [&#39;#FFB54D&#39;, &#39;#E6D417&#39;],</span><br><span class="line">                                        [&#39;#FFB54D&#39;, &#39;#E6D417&#39;],</span><br><span class="line">                                        </span><br><span class="line">                                    ];</span><br><span class="line">                                    var colorItem &#x3D; colorList[params.dataIndex];</span><br><span class="line">                                    return new echarts.graphic.LinearGradient(0, 0, 1, 0, [</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            offset: 0,</span><br><span class="line">                                            color: colorItem[0]</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            offset: 1,</span><br><span class="line">                                            color: colorItem[1]</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ], false);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="设置网格线"><a href="#设置网格线" class="headerlink" title="设置网格线"></a>设置网格线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置网格线颜色</span><br><span class="line">xAxis: &#123;</span><br><span class="line">    type: ‘value’,</span><br><span class="line">    &#x2F;&#x2F;设置网格线颜色</span><br><span class="line">    splitLine: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        lineStyle:&#123;</span><br><span class="line">        color: [’#315070’],</span><br><span class="line">		opacity:0.5,</span><br><span class="line">        width: 1,</span><br><span class="line">        type: ‘solid’</span><br><span class="line">        &#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">隐藏网格线</span><br><span class="line">xAxis: &#123;</span><br><span class="line">    type: ‘value’,</span><br><span class="line">    &#x2F;&#x2F;隐藏网格线</span><br><span class="line">    splitLine:&#123;show: false&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="文字重叠可换行"><a href="#文字重叠可换行" class="headerlink" title="文字重叠可换行"></a>文字重叠可换行</h3><p><a href="https://blog.csdn.net/Misnice/article/details/108493844?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-108493844.nonecase&amp;utm_term=echarts%E9%A5%BC%E5%9B%BE%E6%98%BE%E7%A4%BA%E4%B8%80%E5%8D%8A&amp;spm=1000.2123.3001.4430" target="_blank" rel="noopener">https://blog.csdn.net/Misnice/article/details/108493844?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-108493844.nonecase&amp;utm_term=echarts%E9%A5%BC%E5%9B%BE%E6%98%BE%E7%A4%BA%E4%B8%80%E5%8D%8A&amp;spm=1000.2123.3001.4430</a></p>
<h3 id="图表显示不全，缩到一起"><a href="#图表显示不全，缩到一起" class="headerlink" title="图表显示不全，缩到一起"></a>图表显示不全，缩到一起</h3><p>需要强行设置宽高px</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;chartContainer&quot; style&#x3D;&quot;height:450px;width:1030px;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h3 id="lengend读取值和改变位置"><a href="#lengend读取值和改变位置" class="headerlink" title="lengend读取值和改变位置"></a>lengend读取值和改变位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">                    formatter: function (name) &#123;</span><br><span class="line">                        var index &#x3D; 0;</span><br><span class="line">                            debugger</span><br><span class="line">                        that.pressData.normalData.forEach(function (value, i) &#123;</span><br><span class="line">                            if (value.name &#x3D;&#x3D; name) &#123;</span><br><span class="line">                                index &#x3D; i;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        return name + &quot;  &quot; + that.pressData.normalData[index].num;</span><br><span class="line">                        &#x2F;&#x2F; 正常 11</span><br><span class="line">                    &#125;,</span><br><span class="line">                    orient: &#39;vertical&#39;,&#x2F;&#x2F;分行分布</span><br><span class="line">                    &#x2F;&#x2F; bottom:-10,</span><br><span class="line">                    textStyle: &#123;</span><br><span class="line">                        color: &#39;#ffffff&#39;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    icon: &#39;circle&#39;,&#x2F;&#x2F;改变icon的形状（圆形方形等）</span><br><span class="line">                    data: [&#39;正常&#39;, &#39;异常&#39;]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;区分多个lengend的样式和颜色</span><br><span class="line">color:[&quot;blue&quot;,&quot;red&quot;]</span><br><span class="line">legend: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        right: &quot;20%&quot;,</span><br><span class="line">                        textStyle: &#123;</span><br><span class="line">                            color: &#39;#ffffff&#39;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        data: [seriesNameOne]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        left: &quot;right&quot;,</span><br><span class="line">                        textStyle: &#123;</span><br><span class="line">                            color: &#39;#ffffff&#39;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        data: [seriesNameTwo]</span><br><span class="line">					&#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>



<h3 id="设置最小刻度单位"><a href="#设置最小刻度单位" class="headerlink" title="设置最小刻度单位"></a>设置最小刻度单位</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xAxis: &#123;</span><br><span class="line">                    type: &#39;value&#39;,</span><br><span class="line">                    position: &#39;bottom&#39;,</span><br><span class="line">                    &#x2F;&#x2F;x轴坐标点开始与结束点位置都不在最边缘</span><br><span class="line">                    boundaryGap: true,</span><br><span class="line">                    &#x2F;&#x2F;最小刻度单位</span><br><span class="line">                    minInterval: 1,</span><br><span class="line">                    &#x2F;&#x2F;柱宽</span><br><span class="line">                    barWidth:20,</span><br><span class="line">                    &#x2F;&#x2F;柱间距</span><br><span class="line">                    barCategoryGap:&#39;60%&#39;,</span><br><span class="line">                    &#x2F;&#x2F;刻度间距</span><br><span class="line">                    splitNumber : 5,</span><br><span class="line">                    &#x2F;&#x2F;最小刻度</span><br><span class="line">                    min:0,</span><br><span class="line">                    &#x2F;&#x2F;最大间距</span><br><span class="line">                    max:100</span><br><span class="line">                &#125;,</span><br></pre></td></tr></table></figure>



<h3 id="echarts圆饼图设置默认选中项并在中间显示文字"><a href="#echarts圆饼图设置默认选中项并在中间显示文字" class="headerlink" title="echarts圆饼图设置默认选中项并在中间显示文字"></a>echarts圆饼图设置默认选中项并在中间显示文字</h3><p><a href="https://www.cnblogs.com/javascripter/p/11549666.html" target="_blank" rel="noopener">https://www.cnblogs.com/javascripter/p/11549666.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myChart.setOption(option);</span><br><span class="line">    &#x2F;&#x2F;设置默认选中高亮部分</span><br><span class="line">    myChart.dispatchAction(&#123;type: &#39;highlight&#39;,seriesIndex: 0,dataIndex: 0&#125;);</span><br><span class="line">    &#x2F;&#x2F; 当鼠标移入时，如果不是第一项，则把当前项置为选中，如果是第一项，则设置第一项为当前项</span><br><span class="line">    myChart.on(&#39;mouseover&#39;,function(e)&#123;</span><br><span class="line">      myChart.dispatchAction(&#123;type: &#39;downplay&#39;,seriesIndex: 0,dataIndex:0&#125;); </span><br><span class="line">      if(e.dataIndex !&#x3D; index)&#123;            </span><br><span class="line">        myChart.dispatchAction(&#123;type: &#39;downplay&#39;, seriesIndex: 0, dataIndex: index  &#125;);     </span><br><span class="line">      &#125;</span><br><span class="line">      if(e.dataIndex &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        myChart.dispatchAction(&#123;type: &#39;highlight&#39;,seriesIndex: 0,dataIndex:e.dataIndex&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当鼠标离开时，把当前项置为选中 </span><br><span class="line">    myChart.on(&#39;mouseout&#39;,function(e)&#123;</span><br><span class="line">        index &#x3D; e.dataIndex;</span><br><span class="line">        myChart.dispatchAction(&#123;type: &#39;highlight&#39;,seriesIndex: 0,dataIndex: e.dataIndex&#125;);    </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>&#39;element-ui&#39;</title>
    <url>/2020/11/02/element-ui/</url>
    <content><![CDATA[<h3 id="vue引入"><a href="#vue引入" class="headerlink" title="vue引入"></a>vue引入</h3><h4 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h4><p>npm i element-ui -S</p>
<p>在 main.js 中写入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</p>
<h4 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h4><p>借助 <a href="https://github.com/QingWei-Li/babel-plugin-component" target="_blank" rel="noopener">babel-plugin-component</a>，我们可以只引入需要的组件，以达到减小项目体积的目的。</p>
<p>首先，安装 babel-plugin-component：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后，将 .babelrc 修改为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [[<span class="string">"es2015"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="attr">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.component(Button.name, Button);</span><br><span class="line">Vue.component(Select.name, Select);</span><br><span class="line"><span class="comment">/* 或写为</span></span><br><span class="line"><span class="comment"> * Vue.use(Button)</span></span><br><span class="line"><span class="comment"> * Vue.use(Select)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>在引入 Element 时，可以传入一个全局配置对象。该对象目前支持 <code>size</code> 与 <code>zIndex</code> 字段。<code>size</code> 用于改变组件的默认尺寸，<code>zIndex</code> 设置弹框的初始 z-index（默认值：2000）。按照引入 Element 的方式，具体操作如下：</p>
<p>完整引入 Element：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line">Vue.use(Element, &#123; <span class="attr">size</span>: <span class="string">'small'</span>, <span class="attr">zIndex</span>: <span class="number">3000</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>按需引入 Element：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$ELEMENT = &#123; <span class="attr">size</span>: <span class="string">'small'</span>, <span class="attr">zIndex</span>: <span class="number">3000</span> &#125;;</span><br><span class="line">Vue.use(Button);</span><br></pre></td></tr></table></figure>



<h3 id="批量input验证方法-prop-”‘snList-’-index-’-sn’”的循环验证"><a href="#批量input验证方法-prop-”‘snList-’-index-’-sn’”的循环验证" class="headerlink" title="批量input验证方法(:prop=”‘snList.’+index+’.sn’”的循环验证)"></a>批量input验证方法(:prop=”‘snList.’+index+’.sn’”的循环验证)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html</span><br><span class="line"></span><br><span class="line">&lt;el-form :model&#x3D;&quot;formSnList&quot; ref&#x3D;&quot;formSnList&quot;&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;终端SN:&quot; label-width&#x3D;&quot;80px&quot; v-for&#x3D;&quot;(item,index) in formSnList.snList&quot; :key&#x3D;&quot;index&quot; :prop&#x3D;&quot;&#39;snList.&#39;+index+&#39;.sn&#39;&quot; :rules&#x3D;&quot;rules.sn&quot;&gt;</span><br><span class="line">            &lt;el-input v-model&#x3D;&quot;item.sn&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line">    </span><br><span class="line">js</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">	formSnList:&#123;snList: [&#123; sn: &quot;&quot; &#125;]&#125;,</span><br><span class="line">	rules: &#123;</span><br><span class="line">        sn: [&#123; required: true, message: &#39;请输入终端SN&#39;, trigger: &#39;blur&#39; &#125;, &#123; validator: checkSN, trigger: 	&#39;blur&#39; &#125;],</span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>给el-date-picker添加默认时间（当天减一天，当天）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value1: [new Date(new Date().getTime() - 24 * 60 * 60 * 1000),new Date()],</span><br></pre></td></tr></table></figure>



<p>‘autocomplete=”off”‘在Chrome中不起作用解决方案</p>
<p><a href="https://blog.csdn.net/xw505501936/article/details/52129579" target="_blank" rel="noopener">https://blog.csdn.net/xw505501936/article/details/52129579</a></p>
<p>el-table</p>
<p>在表格容器增加一个类，在该类下粘贴如下代码，即可轻松设置表格数据<strong>居中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">&#x2F;deep&#x2F;.el-table th &gt; .cell &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;deep&#x2F;.el-table .cell &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改某列的颜色和行的样式与原生js设置某行的颜色</p>
<p><a href="https://blog.csdn.net/weixin_44986077/article/details/106714117" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44986077/article/details/106714117</a></p>
<p>更改表格中某个单元格的样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:cell-style</span>=<span class="string">"&#123;background:'pink'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:cell-style</span>=<span class="string">"cellStyle"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">//在method里面写上方法</span><br><span class="line">cellStyle(&#123;row, column, rowIndex, columnIndex&#125;)&#123;</span><br><span class="line">    if(rowIndex === 1 &amp;&amp; columnIndex === 2)&#123; //指定坐标</span><br><span class="line">        return 'background:pink'</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return ''</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//某一列</span><br><span class="line">cellStyle(&#123;row, column, rowIndex, columnIndex&#125;)&#123;</span><br><span class="line">            if(columnIndex === 1)&#123;//指定列号</span><br><span class="line">                return 'background:pink'</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return ''</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="列内容超长时，可以在列表只显示部分内容，鼠标上去hover显示全部内容。"><a href="#列内容超长时，可以在列表只显示部分内容，鼠标上去hover显示全部内容。" class="headerlink" title="列内容超长时，可以在列表只显示部分内容，鼠标上去hover显示全部内容。"></a>列内容超长时，可以在列表只显示部分内容，鼠标上去hover显示全部内容。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column prop&#x3D;&quot;diagnose&quot; **:show-overflow-tooltip&#x3D;&quot;true&quot;** label&#x3D;&quot;入科诊断&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure>



<h3 id="下拉框模糊查询"><a href="#下拉框模糊查询" class="headerlink" title="下拉框模糊查询"></a>下拉框模糊查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-select style&#x3D;&quot;width:140px&quot; **filterable** v-model&#x3D;&quot;selectOption&quot; @change&#x3D;&#39;huanchuang()&#39; &gt;</span><br><span class="line">    &lt;el-option v-for&#x3D;&quot;(item,index) in bedList&quot; :key&#x3D;&quot;index&quot; :value&#x3D;&quot;item.id&quot; :label&#x3D;&quot;item.name&quot;&gt;</span><br><span class="line">    &lt;&#x2F;el-option&gt;</span><br><span class="line">&lt;&#x2F;el-select&gt;</span><br></pre></td></tr></table></figure>



<h3 id="清空表单验证"><a href="#清空表单验证" class="headerlink" title="清空表单验证"></a>清空表单验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$refs[formName].clearValidate();</span><br></pre></td></tr></table></figure>



<h3 id="多选功能"><a href="#多选功能" class="headerlink" title="多选功能"></a>多选功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table</span><br><span class="line">    ref&#x3D;&quot;multipleTable&quot;</span><br><span class="line">    :data&#x3D;&quot;tableData&quot;</span><br><span class="line">    tooltip-effect&#x3D;&quot;dark&quot;</span><br><span class="line">    :reserve-selection&#x3D;&quot;true&quot; &#x2F;&#x2F;数据更新时记住上次勾选</span><br><span class="line">    style&#x3D;&quot;width: 100%&quot;</span><br><span class="line">    @selection-change&#x3D;&quot;handleSelectionChange&quot;&gt;</span><br><span class="line">    &lt;el-table-column</span><br><span class="line">      type&#x3D;&quot;selection&quot;</span><br><span class="line">      width&#x3D;&quot;55&quot;&gt;</span><br><span class="line">    &lt;&#x2F;el-table-column&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style&#x3D;&quot;margin-top: 20px&quot;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;toggleSelection([tableData[1], tableData[2]])&quot;&gt;切换第二、第三行的选中状态&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;toggleSelection()&quot;&gt;取消选择&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">  </span><br><span class="line">  methods: &#123;</span><br><span class="line">  &#x2F;&#x2F;选中指定行</span><br><span class="line">      toggleSelection(rows) &#123;</span><br><span class="line">        if (rows) &#123;</span><br><span class="line">          rows.forEach(row &#x3D;&gt; &#123;</span><br><span class="line">            this.$refs.multipleTable.toggleRowSelection(row);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;清空多选</span><br><span class="line">          this.$refs.multipleTable.clearSelection();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F;记录所选行</span><br><span class="line">      handleSelectionChange(val) &#123;</span><br><span class="line">        this.multipleSelection &#x3D; val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  tips:手动添加一个el-table-column，设type属性为selection即可,</span><br></pre></td></tr></table></figure>



<h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><p>要使用 Radio 组件，只需要设置<code>v-model</code>绑定变量，选中意味着变量的值为相应 Radio <code>label</code>属性的值，<code>label</code>可以是<code>String</code>、<code>Number</code>或<code>Boolean</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-radio v-model&#x3D;&quot;radio&quot; label&#x3D;&quot;1&quot;&gt;备选项&lt;&#x2F;el-radio&gt;</span><br><span class="line">&lt;el-radio v-model&#x3D;&quot;radio&quot; label&#x3D;&quot;2&quot;&gt;备选项&lt;&#x2F;el-radio&gt;</span><br></pre></td></tr></table></figure>



<p>结合<code>el-radio-group</code>元素和子元素<code>el-radio</code>可以实现单选组，在<code>el-radio-group</code>中绑定<code>v-model</code>，在<code>el-radio</code>中设置好<code>label</code>即可，无需再给每一个<code>el-radio</code>绑定变量，另外，还提供了<code>change</code>事件来响应变化，它会传入一个参数<code>value</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-radio-group v-model&#x3D;&quot;radio&quot;&gt;</span><br><span class="line">    &lt;el-radio :label&#x3D;&quot;3&quot;&gt;备选项&lt;&#x2F;el-radio&gt;</span><br><span class="line">    &lt;el-radio :label&#x3D;&quot;6&quot;&gt;备选项&lt;&#x2F;el-radio&gt;</span><br><span class="line">    &lt;el-radio :label&#x3D;&quot;9&quot;&gt;备选项&lt;&#x2F;el-radio&gt;</span><br><span class="line">&lt;&#x2F;el-radio-group&gt;</span><br></pre></td></tr></table></figure>



<h3 id="Vue-Vuex-Element-UI动态全局主题颜色"><a href="#Vue-Vuex-Element-UI动态全局主题颜色" class="headerlink" title="Vue + Vuex + Element UI动态全局主题颜色"></a>Vue + Vuex + Element UI动态全局主题颜色</h3><p>1、封装一个theme-picker组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-color-picker</span><br><span class="line">    class&#x3D;&quot;theme-picker&quot;</span><br><span class="line">    popper-class&#x3D;&quot;theme-picker-dropdown&quot;</span><br><span class="line">    v-model&#x3D;&quot;theme&quot;</span><br><span class="line">    :size&#x3D;&quot;size&quot;&gt;</span><br><span class="line">  &lt;&#x2F;el-color-picker&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>HTML</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../stores/commons/types.js'</span></span><br><span class="line"><span class="keyword">const</span> version = <span class="built_in">require</span>(<span class="string">'element-ui/package.json'</span>).version</span><br><span class="line"><span class="keyword">const</span> ORIGINAL_THEME = <span class="string">'#409EFF'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'ThemePicker'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 默认主题，可由外部传入</span></span><br><span class="line">    <span class="keyword">default</span>: &#123; </span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: localStorage.getItem(<span class="string">'COLOR_THEME'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    size: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'small'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      chalk: <span class="string">''</span>, <span class="comment">// content of theme-chalk css</span></span><br><span class="line">      theme: ORIGINAL_THEME,</span><br><span class="line">      showSuccess: <span class="literal">true</span> <span class="comment">// 是否弹出换肤成功消息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.default != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.theme = <span class="keyword">this</span>.default</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'onThemeChange'</span>, <span class="keyword">this</span>.theme)</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(types.M_THEME_COLOR, <span class="keyword">this</span>.theme)</span><br><span class="line">      <span class="keyword">this</span>.showSuccess = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    theme (val, oldVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val !== <span class="string">'string'</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">const</span> themeCluster = <span class="keyword">this</span>.getThemeCluster(val.replace(<span class="string">'#'</span>, <span class="string">''</span>))</span><br><span class="line">      <span class="keyword">const</span> originalCluster = <span class="keyword">this</span>.getThemeCluster(oldVal.replace(<span class="string">'#'</span>, <span class="string">''</span>))</span><br><span class="line">      <span class="keyword">const</span> getHandler = <span class="function">(<span class="params">variable, id</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> originalCluster = <span class="keyword">this</span>.getThemeCluster(ORIGINAL_THEME.replace(<span class="string">'#'</span>, <span class="string">''</span>))</span><br><span class="line">          <span class="keyword">const</span> newStyle = <span class="keyword">this</span>.updateStyle(<span class="keyword">this</span>[variable], originalCluster, themeCluster)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> styleTag = <span class="built_in">document</span>.getElementById(id)</span><br><span class="line">          <span class="keyword">if</span> (!styleTag) &#123;</span><br><span class="line">            styleTag = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span><br><span class="line">            styleTag.setAttribute(<span class="string">'id'</span>, id)</span><br><span class="line">            <span class="built_in">document</span>.head.appendChild(styleTag)</span><br><span class="line">          &#125;</span><br><span class="line">          styleTag.innerText = newStyle</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> chalkHandler = getHandler(<span class="string">'chalk'</span>, <span class="string">'chalk-style'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.chalk) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`https://unpkg.com/element-ui@<span class="subst">$&#123;version&#125;</span>/lib/theme-chalk/index.css`</span></span><br><span class="line">        <span class="keyword">this</span>.getCSSString(url, chalkHandler, <span class="string">'chalk'</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        chalkHandler()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> styles = [].slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">'style'</span>))</span><br><span class="line">        .filter(<span class="function"><span class="params">style</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> text = style.innerText</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(oldVal, <span class="string">'i'</span>).test(text) &amp;&amp; !<span class="regexp">/Chalk Variables/</span>.test(text)</span><br><span class="line">        &#125;)</span><br><span class="line">      styles.forEach(<span class="function"><span class="params">style</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; innerText &#125; = style</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> innerText !== <span class="string">'string'</span>) <span class="keyword">return</span></span><br><span class="line">        style.innerText = <span class="keyword">this</span>.updateStyle(innerText, originalCluster, themeCluster)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应外部操作</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'onThemeChange'</span>, val)</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(types.M_THEME_COLOR, val)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.showSuccess) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message(&#123;</span><br><span class="line">          message: <span class="string">'换肤成功'</span>,</span><br><span class="line">          type: <span class="string">'success'</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.showSuccess = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateStyle (style, oldCluster, newCluster) &#123;</span><br><span class="line">      <span class="keyword">let</span> newStyle = style</span><br><span class="line">      oldCluster.forEach(<span class="function">(<span class="params">color, index</span>) =&gt;</span> &#123;</span><br><span class="line">        newStyle = newStyle.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(color, <span class="string">'ig'</span>), newCluster[index])</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> newStyle</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getCSSString (url, callback, variable) &#123;</span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">      xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>[variable] = xhr.responseText.replace(<span class="regexp">/@font-face&#123;[^&#125;]+&#125;/</span>, <span class="string">''</span>)</span><br><span class="line">          callback()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">      xhr.send()</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getThemeCluster (theme) &#123;</span><br><span class="line">      <span class="keyword">const</span> tintColor = <span class="function">(<span class="params">color, tint</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> red = <span class="built_in">parseInt</span>(color.slice(<span class="number">0</span>, <span class="number">2</span>), <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">let</span> green = <span class="built_in">parseInt</span>(color.slice(<span class="number">2</span>, <span class="number">4</span>), <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">let</span> blue = <span class="built_in">parseInt</span>(color.slice(<span class="number">4</span>, <span class="number">6</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tint === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> [red, green, blue].join(<span class="string">','</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          red += <span class="built_in">Math</span>.round(tint * (<span class="number">255</span> - red))</span><br><span class="line">          green += <span class="built_in">Math</span>.round(tint * (<span class="number">255</span> - green))</span><br><span class="line">          blue += <span class="built_in">Math</span>.round(tint * (<span class="number">255</span> - blue))</span><br><span class="line"></span><br><span class="line">          red = red.toString(<span class="number">16</span>)</span><br><span class="line">          green = green.toString(<span class="number">16</span>)</span><br><span class="line">          blue = blue.toString(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="string">`#<span class="subst">$&#123;red&#125;</span><span class="subst">$&#123;green&#125;</span><span class="subst">$&#123;blue&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> shadeColor = <span class="function">(<span class="params">color, shade</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> red = <span class="built_in">parseInt</span>(color.slice(<span class="number">0</span>, <span class="number">2</span>), <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">let</span> green = <span class="built_in">parseInt</span>(color.slice(<span class="number">2</span>, <span class="number">4</span>), <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">let</span> blue = <span class="built_in">parseInt</span>(color.slice(<span class="number">4</span>, <span class="number">6</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        red = <span class="built_in">Math</span>.round((<span class="number">1</span> - shade) * red)</span><br><span class="line">        green = <span class="built_in">Math</span>.round((<span class="number">1</span> - shade) * green)</span><br><span class="line">        blue = <span class="built_in">Math</span>.round((<span class="number">1</span> - shade) * blue)</span><br><span class="line"></span><br><span class="line">        red = red.toString(<span class="number">16</span>)</span><br><span class="line">        green = green.toString(<span class="number">16</span>)</span><br><span class="line">        blue = blue.toString(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`#<span class="subst">$&#123;red&#125;</span><span class="subst">$&#123;green&#125;</span><span class="subst">$&#123;blue&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> clusters = [theme]</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        clusters.push(tintColor(theme, <span class="built_in">Number</span>((i / <span class="number">10</span>).toFixed(<span class="number">2</span>))))</span><br><span class="line">      &#125;</span><br><span class="line">      clusters.push(shadeColor(theme, <span class="number">0.1</span>))</span><br><span class="line">      <span class="keyword">return</span> clusters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.theme-picker</span> <span class="selector-class">.el-color-picker__trigger</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.theme-picker-dropdown</span> <span class="selector-class">.el-color-dropdown__link-btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>commit</code>向<code>store</code>里面存储颜色。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(types.M_THEME_COLOR, <span class="keyword">this</span>.theme)</span><br></pre></td></tr></table></figure>

<p>JavaScript</p>
<p>然后通过<code>state</code>获取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    themeColor: <span class="function"><span class="params">state</span> =&gt;</span> state.commons.themeColor</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>JavaScript</p>
<p>最后我们页面可以直接使用<code>themeColor</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :style&#x3D;&quot;&#123;</span><br><span class="line">  &#39;border-color&#39;: themeColor, </span><br><span class="line">  &#39;background-color&#39;: backgroundColor</span><br><span class="line">&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>HTML</p>
<p>细心的小伙伴是不是发现这里过了一个变量<code>backgroundColor</code>，这个是通过<code>themeColor</code>重新计算的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">backgroundColor () &#123;</span><br><span class="line">  <span class="comment">// 返回某个颜色的三原色</span></span><br><span class="line">  <span class="keyword">const</span> tintColor = <span class="function">(<span class="params">color</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> red = <span class="built_in">parseInt</span>(color.slice(<span class="number">0</span>, <span class="number">2</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">let</span> green = <span class="built_in">parseInt</span>(color.slice(<span class="number">2</span>, <span class="number">4</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">let</span> blue = <span class="built_in">parseInt</span>(color.slice(<span class="number">4</span>, <span class="number">6</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [red, green, blue]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> color = <span class="keyword">this</span>.themeColor.replace(<span class="string">'#'</span>, <span class="string">''</span>)</span><br><span class="line">  color = tintColor(color)</span><br><span class="line">  <span class="comment">// 转成rgba格式的，并添加透明度</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`rgba(<span class="subst">$&#123;color[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;color[<span class="number">1</span>]&#125;</span>, <span class="subst">$&#123;color[<span class="number">2</span>]&#125;</span>, .3)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="el-date-picker限制时间选择范围"><a href="#el-date-picker限制时间选择范围" class="headerlink" title="el-date-picker限制时间选择范围"></a>el-date-picker限制时间选择范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-date-picker </span><br><span class="line">     v-model&#x3D;&quot;ruleForm.date&quot;</span><br><span class="line">      type&#x3D;&quot;daterange&quot;</span><br><span class="line">      range-separator&#x3D;&quot;-&quot;</span><br><span class="line">      start-placeholder&#x3D;&quot;开始日期&quot;</span><br><span class="line">      end-placeholder&#x3D;&quot;结束日期&quot;</span><br><span class="line">      value-format&#x3D;&quot;yyyy-MM-dd&quot;</span><br><span class="line">       format&#x3D;&quot;yyyy-MM-dd&quot;</span><br><span class="line">        :picker-options&#x3D;&quot;pickerOptionsTime&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-date-picker&gt;</span><br><span class="line">&#x2F;&#x2F;组件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;限制在data中增加改属性</span><br><span class="line">data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		pickerOptionsTime: &#123;</span><br><span class="line">            disabledDate(time) &#123;</span><br><span class="line">            	return time.getTime() &gt; Date.now() - 8.64e6</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>eleui之input正则记录</title>
    <url>/2020/11/02/eleui%E4%B9%8Binput%E6%AD%A3%E5%88%99%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;^[1-9][0-9]*$&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="手机号"><a href="#手机号" class="headerlink" title="手机号"></a>手机号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;^1[3|4|5|7|8][0-9]\d&#123;8&#125;$&#x2F; 或者 &#x2F;^1[0-9]&#123;10&#125;$&#x2F;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>reg</category>
      </categories>
      <tags>
        <tag>reg</tag>
      </tags>
  </entry>
  <entry>
    <title>es6之arrayFrom</title>
    <url>/2020/09/28/es6%E4%B9%8BarrayFrom/</url>
    <content><![CDATA[<p>Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。</p>
<p>　　那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象。</p>
<p>　　1、将类数组对象转换为真正数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    0: &#39;tom&#39;, </span><br><span class="line">    1: &#39;65&#39;,</span><br><span class="line">    2: &#39;男&#39;,</span><br><span class="line">    3: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;],</span><br><span class="line">    &#39;length&#39;: 4</span><br><span class="line">&#125;</span><br><span class="line">let arr &#x3D; Array.from(arrayLike)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [&#39;tom&#39;,&#39;65&#39;,&#39;男&#39;,[&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;]]</span><br></pre></td></tr></table></figure>

<p>　　那么，如果将上面代码中length属性去掉呢？实践证明，答案会是一个长度为0的空数组。</p>
<p>　　这里将代码再改一下，就是具有length属性，但是对象的属性名不再是数字类型的，而是其他字符串型的，代码如下：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    &#39;name&#39;: &#39;tom&#39;, </span><br><span class="line">    &#39;age&#39;: &#39;65&#39;,</span><br><span class="line">    &#39;sex&#39;: &#39;男&#39;,</span><br><span class="line">    &#39;friends&#39;: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;],</span><br><span class="line">    length: 4</span><br><span class="line">&#125;</span><br><span class="line">let arr &#x3D; Array.from(arrayLike)</span><br><span class="line">console.log(arr)  &#x2F;&#x2F; [ undefined, undefined, undefined, undefined ]</span><br></pre></td></tr></table></figure>

<p>　　会发现结果是长度为4，元素均为undefined的数组</p>
<p>　　由此可见，要将一个类数组对象转换为一个真正的数组，必须具备以下条件：</p>
<p>　　1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。</p>
<p>　　2、该类数组对象的属性名必须为数值型或字符串型的数字</p>
<p>　　ps: 该类数组对象的属性名可以加引号，也可以不加引号</p>
<p>　　2、将Set结构的数据转换为真正的数组：　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [12,45,97,9797,564,134,45642]</span><br><span class="line">let set &#x3D; new Set(arr)</span><br><span class="line">console.log(Array.from(set))  &#x2F;&#x2F; [ 12, 45, 97, 9797, 564, 134, 45642 ]</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　<code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [12,45,97,9797,564,134,45642]</span><br><span class="line">let set &#x3D; new Set(arr)</span><br><span class="line">console.log(Array.from(set, item &#x3D;&gt; item + 1)) &#x2F;&#x2F; [ 13, 46, 98, 9798, 565, 135, 45643 ]</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　3、将字符串转换为数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let  str &#x3D; &#39;hello world!&#39;;</span><br><span class="line">console.log(Array.from(str)) &#x2F;&#x2F; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot;]</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　4、Array.from参数是一个真正的数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Array.from([12,45,47,56,213,4654,154]))</span><br></pre></td></tr></table></figure>

<p>　　像这种情况，Array.from会返回一个一模一样的新数组</p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>arrayFrom</tag>
      </tags>
  </entry>
  <entry>
    <title>es6-Class</title>
    <url>/2020/08/07/es6-Class/</url>
    <content><![CDATA[<h1 id="你真的理解ES6的Class吗"><a href="#你真的理解ES6的Class吗" class="headerlink" title="你真的理解ES6的Class吗"></a><a href="https://segmentfault.com/a/1190000019792333" target="_blank" rel="noopener">你真的理解ES6的Class吗</a></h1><blockquote>
<p>在面向对象的编程中,类是一个用于创建对象，为状态（成员变量）和行为实现（成员函数或方法）提供初始值的可扩展程序代码模板。（提供封装在一起的变量和函数）</p>
</blockquote>
<p>在实际开发中，我们往往需要创建很多相同类型的对象，如用户、商品或其他对象。我们知道，通过new一个function可以创建一个对象，但在现代的JavaScript里，有一个更高级的“类”结构，对于面向对象编程提供了一些很不错的特性。</p>
<h2 id="Class语法"><a href="#Class语法" class="headerlink" title="Class语法"></a>Class语法</h2><a id="more"></a>

<p>基本的class语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    constructor()&#123;&#125;</span><br><span class="line">    method1()&#123;&#125;</span><br><span class="line">    method2()&#123;&#125;</span><br><span class="line">    method3()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过<strong>new MyClass()</strong>来创建一个拥有以上方法的对象实例，与此同时，通过<strong>new</strong>操作符,<strong>构造方法(constructor)</strong>是被自动调用,的，这意味着在构造方法中我们可以做一些初始化的工作。</p>
<p>列如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    showUInfo()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Usage:</span><br><span class="line">let user &#x3D; new User(&#39;Darkcode&#39;)</span><br><span class="line">user.showUInfo()</span><br></pre></td></tr></table></figure>

<p>当<strong>new User(‘Darkcode’)</strong>被调用的时候：</p>
<ul>
<li>创建了一个新的对象</li>
<li>构造方法通过给定的参数运行，并为其分配this.name</li>
</ul>
<p>然后我们能够调用方法，如user.showUInfo()</p>
<p><em>注意：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类方法之间是没有逗号的</span><br></pre></td></tr></table></figure>



<h2 id="究竟什么是类？"><a href="#究竟什么是类？" class="headerlink" title="究竟什么是类？"></a>究竟什么是类？</h2><p>其实，在JavaScript中，类是函数的一种。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    showUInfo()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(typeof User)&#x2F;&#x2F;function</span><br></pre></td></tr></table></figure>

<p><strong>class User {…}</strong>做了什么呢：</p>
<ol>
<li>创建一个名为User的函数，该函数将成为类声明的结果</li>
<li>在User.prototype中存储所有方法，例如showUInfo</li>
</ol>
<p>之后，对于新对象，当我们调用一个方法的时候，它就是从原型中获取的，因此新的User对象就可以访问到类方法了。</p>
<p>我们可以将<strong>class User</strong>的声明做如下简述：<br><img src="https://segmentfault.com/img/bVbvcLM?w=780&h=171" alt="class User过程图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">  	this.name &#x3D; name</span><br><span class="line">  &#125;</span><br><span class="line">  showUInfo()&#123;</span><br><span class="line">  	alert(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">alert(typeof User)&#x2F;&#x2F;function</span><br><span class="line"></span><br><span class="line">alert(User &#x3D;&#x3D;&#x3D; User.prototype.constructor)&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">alert(User.prototype.showUInfo)&#x2F;&#x2F; alert(this.name);</span><br><span class="line"></span><br><span class="line">alert(Object.getOwnPropertyNames(User.prototype)); &#x2F;&#x2F; constructor, showUInfo</span><br></pre></td></tr></table></figure>

<h2 id="并不只是语法糖-比较"><a href="#并不只是语法糖-比较" class="headerlink" title="并不只是语法糖(比较)"></a>并不只是语法糖(比较)</h2><p>一些人说在JavaScript中class是一种”语法糖”，因为我们实际上可以在没有class关键字的情况下声明一个类。在Es6之前，es5我们可以通过function去实现一个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. Create constructor function</span><br><span class="line">function User(name) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; any function prototype has constructor property by default,</span><br><span class="line">&#x2F;&#x2F; so we don&#39;t need to create it</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. Add the method to prototype</span><br><span class="line">User.prototype.showUInfo &#x3D; function () &#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Usage:</span><br><span class="line">let user &#x3D; new User(&#39;Darkcode&#39;)</span><br><span class="line">user.showUInfo()</span><br></pre></td></tr></table></figure>

<p>这个定义的结果大致相同。因此，确实可以将类视为一种语法糖来定义构造函数及其原型方法。但与class的方式创建一个类有着重要的差异。</p>
<p>首先，<strong>由class创建的函数由特殊的内部属性标记</strong>[[FunctionKind]]:”classConstructor”<strong>.所以它与手动创建并不完全相同</strong>。与常规函数不同，如果没有new，则无法调用类构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(typeof User); &#x2F;&#x2F; function</span><br><span class="line">User(); &#x2F;&#x2F; Error: Class constructor User cannot be invoked without &#39;new&#39;</span><br></pre></td></tr></table></figure>

<p>此外，大多数JavaScript引擎中的类构造函数的字符串表示形式都以“class …”开头。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(User); &#x2F;&#x2F; class User &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>其次，<strong>类方法是不可枚举的</strong>。对于原型中的所有方法，类定义将enumerable标志设置为false。</p>
<p>最后，<strong>类总是使用严格模式的。这意味着类构造中的所有代码都自动处于严格模式</strong>。</p>
<p>此外，除了基本操作之外，类语法还带来了许多其他功能，稍后我们将对其进行探讨。</p>
<p>来个例子对比一下：<br>ES6之前，生成实例对象的传统方法是通过构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x &#x3D;x;</span><br><span class="line">  this.y&#x3D;y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString &#x3D; function() &#123;</span><br><span class="line">  return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;;</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; new Point(1,2)</span><br></pre></td></tr></table></figure>

<p>上面的代码用ES6改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x,y)&#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString()&#123;</span><br><span class="line">     return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面ES6改写的代码注意看两点：</p>
<blockquote>
<p>1.ES6写法定义了一个类，可以看到Point类里面有个constructor方法（构造方法）—-ES5的构造函数Point，就对应的是ES6的Point类的构造方法<br>2.Point类中我们还看到了toString方法。注意，定义<code>类</code>的方法的时候，在方法前不要加<code>function</code>关键字，直接把函数定义放进去即可。还需要注意一点，方法之间是不能用逗号分隔的，否则会报错。</p>
</blockquote>
<p>ES6的类，完全可看作构造函数的另一种写法（在类的实例上面调用方法，其实就是调用原型上的方法），这两句话用代码说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##demo1</span><br><span class="line">class liumz()&#123;&#125;</span><br><span class="line">typeof liumz &#x2F;&#x2F;&quot;function&quot;</span><br><span class="line">liumz &#x3D;&#x3D;&#x3D; liumz.prototype.constructor &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">##demo2</span><br><span class="line">class B &#123;&#125;</span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype &#x3D; &#123;</span><br><span class="line">  constructor() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于类的方法都定义在prototype对象上，所以类的新方法可以添加在protype对象上面:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">Object.assign(Point.protype,&#123;</span><br><span class="line">  toValue()&#123;&#125;,</span><br><span class="line">  toString()&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看到上面一堆的代码与定义文字说明，不妨小憩一下，回顾上面到底说了个啥：</p>
<blockquote>
<p>ES6新引进了Class这个概念，这个概念的引入只是让对象原型的写法更清晰（Class的绝大部分功能在ES5中都可以实现），ES5中的构造函数相当于Class中的构造方法。类的数据类型就是函数，类本身指向构造函数。<br>构造函数是有prototype属性的，这个属性在ES6的类上是继续存在的，只是换了一种写法.</p>
</blockquote>
<p>在充分理解了上面的内容时，我们继续深入，ES6的类，内部定义的方法，都是不可枚举的，啥意思？看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">  constructor(x,y)&#123;&#125;</span><br><span class="line">  toString()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.keys(Point.prototype) &#x2F;&#x2F;[]</span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)&#x2F;&#x2F;[&quot;constructor&quot;,&quot;toString&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><p>就像函数一样，类可以在另一个表达式中定义，传递，返回，分配等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let User &#x3D; class &#123;</span><br><span class="line">         showUInfo() &#123;</span><br><span class="line">             alert(&quot;Hello&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">new User().showUInfo()</span><br></pre></td></tr></table></figure>

<p>与命名函数表达式类似，类表达式可能有也可能没有名称。</p>
<p>如果<strong>类表达式具有名称，则它仅在类中可见</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let User &#x3D; class MyClass &#123;</span><br><span class="line">    showUInfo() &#123;</span><br><span class="line">      alert(&quot;MyClass&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let test &#x3D; new MyClass()&#x2F;&#x2F; 失效报错</span><br><span class="line">let test &#x3D; new User()&#x2F;&#x2F; 有效</span><br><span class="line">test.showUInfo()</span><br></pre></td></tr></table></figure>

<p>我们甚至可以“按需”动态创建类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function makeClass(phrase) &#123;</span><br><span class="line">    &#x2F;&#x2F; declare a class and return it</span><br><span class="line">    return class &#123;</span><br><span class="line">        showUInfo() &#123;</span><br><span class="line">            alert(phrase);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create a new class</span><br><span class="line">let User &#x3D; makeClass(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">new User().showUInfo(); &#x2F;&#x2F; Hello</span><br></pre></td></tr></table></figure>

<h2 id="Getters-Setters"><a href="#Getters-Setters" class="headerlink" title="Getters/Setters"></a>Getters/Setters</h2><p>类可能包括getter / setter，生成器，计算属性等。这里通过使用get/set来实现user.name</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this._name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get name()&#123;</span><br><span class="line">        return this._name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set name(value)&#123;</span><br><span class="line">        if(value.length&lt;4)&#123;</span><br><span class="line">            alert(&quot;名字长度不够.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this._name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;get</span><br><span class="line">let user &#x3D; new User(&#39;Darkcode&#39;)</span><br><span class="line">console.log(user.name);&#x2F;&#x2F;Darkcode</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;set</span><br><span class="line">let user &#x3D; new User()</span><br><span class="line">user.name &#x3D; &#39;165&#39;</span><br><span class="line">console.log(user.name);&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<p>在User的原型对象中，通过类声明创建get/set：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperties(User.prototype, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return this._name</span><br><span class="line">    &#125;,</span><br><span class="line">    set(name) &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>在上面的列子中，User类中仅仅添加了简单的方法，现在来添加一些属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  name &#x3D; &quot;Anonymous&quot;;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(&#96;Hello, $&#123;this.name&#125;!&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new User().sayHi();</span><br></pre></td></tr></table></figure>

<p>该属性未放入User的原型中。相反，它是由new创建的，分别为每个对象创建。因此，该属性永远不会在同一个类的不同对象之间共享。</p>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h3><hr>
<blockquote>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#39;hello&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() &#x2F;&#x2F; &#39;hello&#39;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">&#x2F;&#x2F; TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure>

<p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static bar() &#123;</span><br><span class="line">    this.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  static baz() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() &#x2F;&#x2F; hello</span><br></pre></td></tr></table></figure>

<p>虽然既然类的静态方法不可被实例所继承，但是却可以被子类继承，不赘述。</p>
<h3 id="3-实例属性的新写法"><a href="#3-实例属性的新写法" class="headerlink" title="3.实例属性的新写法"></a>3.实例属性的新写法</h3><hr>
<p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。写法对比：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实例属性this._count定义在constructor()方法里面</span><br><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._count &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&#39;Getting the current value!&#39;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;属性定义在类的最顶层，其它不变</span><br><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  _count &#x3D; 0;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&#39;Getting the current value!&#39;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>
</blockquote>
<h3 id="4-静态属性"><a href="#4-静态属性" class="headerlink" title="4.静态属性"></a>4.静态属性</h3><hr>
<blockquote>
<p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop &#x3D; 1;</span><br><span class="line">Foo.prop &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-class-fields" target="_blank" rel="noopener">提案</a>提供了类的静态属性，写法是在实例属性法的前面，加上<code>static</code>关键字。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">class Foo &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">Foo.prop &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">class Foo &#123;</span><br><span class="line">  static prop &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>es6之map和set结构</title>
    <url>/2020/09/14/es6%E4%B9%8Bmap%E5%92%8Cset%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="一-Map结构数据"><a href="#一-Map结构数据" class="headerlink" title="一.Map结构数据"></a>一.Map结构数据</h2><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-625e0db86d075be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</blockquote>
<a id="more"></a>

<h4 id="1-传统对象键名必须为字符串"><a href="#1-传统对象键名必须为字符串" class="headerlink" title="1. 传统对象键名必须为字符串"></a>1. 传统对象键名必须为字符串</h4><p>let obj = {a:1, 666:2}; console.log(666);–&gt;报错</p>
<h4 id="2-map结构数据是一种“值-值”对应关系"><a href="#2-map结构数据是一种“值-值”对应关系" class="headerlink" title="2.map结构数据是一种“值-值”对应关系"></a>2.map结构数据是一种“值-值”对应关系</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Map();</span><br><span class="line">m.<span class="keyword">set</span>(<span class="number">123</span>,<span class="string">'abc'</span>);</span><br><span class="line">console.log(m.<span class="keyword">get</span>(<span class="number">123</span>));</span><br><span class="line">--&gt; abc</span><br></pre></td></tr></table></figure>

<h2 id="二-Map结构数据初始化和方法"><a href="#二-Map结构数据初始化和方法" class="headerlink" title="二.Map结构数据初始化和方法"></a>二.Map结构数据初始化和方法</h2><h4 id="1-可直接传入键值对二维数组"><a href="#1-可直接传入键值对二维数组" class="headerlink" title="1. 可直接传入键值对二维数组"></a>1. 可直接传入键值对二维数组</h4><h4 id="2-get-获得数据"><a href="#2-get-获得数据" class="headerlink" title="2. get()-获得数据"></a>2. get()-获得数据</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Map([</span><br><span class="line">    [<span class="meta">123,'abc'</span>],</span><br><span class="line">    [<span class="meta">'a',&#123;x:1,y:2&#125;</span>],</span><br><span class="line">    [<span class="meta">3&gt;1,666</span>]</span><br><span class="line">]);</span><br><span class="line">获得数据</span><br><span class="line">console.log(m.<span class="keyword">get</span>(<span class="literal">true</span>));</span><br><span class="line">--&gt;返回<span class="number">666</span></span><br></pre></td></tr></table></figure>

<h4 id="3-has-查找有没有字符串对应的值"><a href="#3-has-查找有没有字符串对应的值" class="headerlink" title="3. has()-查找有没有字符串对应的值"></a>3. has()-查找有没有字符串对应的值</h4><p>接上面例子</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">m.has(<span class="string">'a'</span>);--&gt;<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="4-delete-删除"><a href="#4-delete-删除" class="headerlink" title="4. delete()-删除"></a>4. delete()-删除</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m.<span class="keyword">delete</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h2 id="三-map结构对象键名特点"><a href="#三-map结构对象键名特点" class="headerlink" title="三.map结构对象键名特点"></a>三.map结构对象键名特点</h2><h4 id="1-传址特点–对象作为键名，传输的是地址，所以下例中的两个-x-1-虽然长相一样，但实际值不同（存储在堆内存的两个位置）"><a href="#1-传址特点–对象作为键名，传输的是地址，所以下例中的两个-x-1-虽然长相一样，但实际值不同（存储在堆内存的两个位置）" class="headerlink" title="1. 传址特点–对象作为键名，传输的是地址，所以下例中的两个{x:1}虽然长相一样，但实际值不同（存储在堆内存的两个位置）"></a>1. 传址特点–对象作为键名，传输的是地址，所以下例中的两个{x:1}虽然长相一样，但实际值不同（存储在堆内存的两个位置）</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,<span class="string">'cdf'</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;));</span><br><span class="line">--&gt;<span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>可以修改成下面形式</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [obj,<span class="string">'cdf'</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(obj));</span><br><span class="line">--&gt;cdf</span><br></pre></td></tr></table></figure>

<h2 id="四-map结构遍历"><a href="#四-map结构遍历" class="headerlink" title="四.map结构遍历"></a>四.map结构遍历</h2><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-97f1f22420a77e1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/952/format/webp" alt="img"></p>
</blockquote>
<h4 id="1-keys-–-gt-将键名都取出来，组成一个可遍历的数据集合"><a href="#1-keys-–-gt-将键名都取出来，组成一个可遍历的数据集合" class="headerlink" title="1. keys()–&gt;将键名都取出来，组成一个可遍历的数据集合"></a>1. keys()–&gt;将键名都取出来，组成一个可遍历的数据集合</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'a'</span>,<span class="string">'hahaha'</span>],</span><br><span class="line">    [<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> m.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;<span class="number">123</span> a <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="2-values"><a href="#2-values" class="headerlink" title="2. values()"></a>2. values()</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'a'</span>,<span class="string">'hahaha'</span>],</span><br><span class="line">    [<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> m.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;abc hahaha baidu.com</span><br></pre></td></tr></table></figure>

<h4 id="3-entries"><a href="#3-entries" class="headerlink" title="3. entries()"></a>3. entries()</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">let m = <span class="keyword">new</span> Map([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'a'</span>,<span class="string">'hahaha'</span>],</span><br><span class="line">    [<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span>(let x of m.entries())&#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br><span class="line"><span class="keyword">Array</span>[<span class="number">123</span>,<span class="string">'abc'</span>]</span><br><span class="line"><span class="keyword">Array</span>[<span class="string">'a'</span>,<span class="string">'hahaha'</span>]</span><br><span class="line"><span class="keyword">Array</span>[<span class="keyword">false</span> ,<span class="string">'baidu.com]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-forEach-–第一个参数代表键值，第二个参数代表键名"><a href="#4-forEach-–第一个参数代表键值，第二个参数代表键名" class="headerlink" title="4. forEach()–第一个参数代表键值，第二个参数代表键名"></a>4. forEach()–第一个参数代表键值，第二个参数代表键名</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">123</span>,<span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'a'</span>,<span class="string">'hahaha'</span>],</span><br><span class="line">    [<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'baidu.com'</span>]</span><br><span class="line">]);</span><br><span class="line">m.forEach(<span class="function"><span class="params">x</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;)</span><br><span class="line">--&gt;返回abc hahaha baidu.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m.forEach(<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;)</span><br><span class="line">--&gt;返回</span><br><span class="line">abc <span class="number">123</span> </span><br><span class="line">hahaha a</span><br><span class="line">baidu.com <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="五-map结构扩展运算符"><a href="#五-map结构扩展运算符" class="headerlink" title="五.map结构扩展运算符"></a>五.map结构扩展运算符</h2><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-0243bc74a207350d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/734/format/webp" alt="img"></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-29c920ecbfe9d944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/668/format/webp" alt="img"></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-4b3a1d9eed0acb8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/992/format/webp" alt="img"></p>
<p>输出hd</p>
</blockquote>
<blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-fcd1a0816cc30ab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/990/format/webp" alt="img"></p>
</blockquote>
<h2 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————-"></a>——————————————————-</h2><h2 id="一-Set结构数据"><a href="#一-Set结构数据" class="headerlink" title="一.Set结构数据"></a>一.Set结构数据</h2><h4 id="1-set结构的数据类似于数组，但成员值都是没有重复的唯一值。"><a href="#1-set结构的数据类似于数组，但成员值都是没有重复的唯一值。" class="headerlink" title="1. set结构的数据类似于数组，但成员值都是没有重复的唯一值。"></a>1. set结构的数据类似于数组，但成员值都是没有重复的唯一值。</h4><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-95dfcd842c22cbdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1162/format/webp" alt="img"></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-c5a33afd58d42fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/986/format/webp" alt="img"></p>
<p>s-&gt;Set[1,2,3,4]//注意：此时他是set结构数据，不是数组</p>
</blockquote>
<h2 id="二-数组去重"><a href="#二-数组去重" class="headerlink" title="二.数组去重"></a>二.数组去重</h2><h4 id="1-可以用作数组去重的功能"><a href="#1-可以用作数组去重的功能" class="headerlink" title="1. 可以用作数组去重的功能"></a>1. 可以用作数组去重的功能</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'3'</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">s-&gt;<span class="built_in">Set</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'3'</span>];注意此时s为<span class="keyword">set</span>结构数据</span><br></pre></td></tr></table></figure>

<h4 id="2-将set结构数据变成数组–-gt-扩展运算符…"><a href="#2-将set结构数据变成数组–-gt-扩展运算符…" class="headerlink" title="2. 将set结构数据变成数组–&gt;扩展运算符…"></a>2. 将set结构数据变成数组–&gt;扩展运算符…</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'3'</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...s];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr-&gt;<span class="built_in">Array</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">'3'</span>];</span><br></pre></td></tr></table></figure>

<h4 id="3-方法二：Array-from-方法可将数据转化成数组"><a href="#3-方法二：Array-from-方法可将数据转化成数组" class="headerlink" title="3. 方法二：Array.from()方法可将数据转化成数组"></a>3. 方法二：Array.from()方法可将数据转化成数组</h4><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-bab71776f3ab4159.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</blockquote>
<h2 id="三-set结构数据方法"><a href="#三-set结构数据方法" class="headerlink" title="三.set结构数据方法"></a>三.set结构数据方法</h2><ul>
<li><h4 id="set实例的属性和方法"><a href="#set实例的属性和方法" class="headerlink" title="set实例的属性和方法"></a>set实例的属性和方法</h4></li>
</ul>
<blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-9e7c4298bbb198d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1172/format/webp" alt="img"></p>
</blockquote>
<h4 id="1-add-value"><a href="#1-add-value" class="headerlink" title="1. add(value);"></a>1. add(value);</h4><ul>
<li><strong>s.size获得set数据的长度</strong></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s.size);</span><br><span class="line">--&gt;<span class="number">4</span></span><br><span class="line">s.add(<span class="number">6</span>);</span><br><span class="line">s.add(<span class="number">6</span>);</span><br><span class="line">s.add(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">s--&gt;<span class="built_in">Set</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2-delete-value"><a href="#2-delete-value" class="headerlink" title="2. delete(value)"></a>2. delete(value)</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">s--&gt;<span class="built_in">Set</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="3-has-value"><a href="#3-has-value" class="headerlink" title="3. has(value)"></a>3. has(value)</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">7</span>));</span><br><span class="line">--&gt;<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="4-clear"><a href="#4-clear" class="headerlink" title="4. clear()"></a>4. clear()</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">s.clear();</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">--&gt;<span class="built_in">Set</span>[];</span><br></pre></td></tr></table></figure>

<h2 id="四-set结构数据遍历"><a href="#四-set结构数据遍历" class="headerlink" title="四.set结构数据遍历"></a>四.set结构数据遍历</h2><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-31d5191deb76df59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp" alt="img"></p>
</blockquote>
<ul>
<li><h4 id="遍历器只能用for…of…来遍历"><a href="#遍历器只能用for…of…来遍历" class="headerlink" title="遍历器只能用for…of…来遍历"></a>遍历器只能用for…of…来遍历</h4></li>
<li><h4 id="补充：对象中的键名和键值-eg-a-1-b-2-–-gt-a-b为键名，1-2为键值"><a href="#补充：对象中的键名和键值-eg-a-1-b-2-–-gt-a-b为键名，1-2为键值" class="headerlink" title="补充：对象中的键名和键值 eg:{a:1,b:2}–&gt;a,b为键名，1,2为键值"></a>补充：对象中的键名和键值 eg:{a:1,b:2}–&gt;a,b为键名，1,2为键值</h4></li>
</ul>
<h4 id="1-for…of…用来遍历遍历器"><a href="#1-for…of…用来遍历遍历器" class="headerlink" title="1. for…of…用来遍历遍历器"></a>1. for…of…用来遍历遍历器</h4><h4 id="2-keys-–-gt-将set数据里的键名全部拢在一起，再利用for-of遍历"><a href="#2-keys-–-gt-将set数据里的键名全部拢在一起，再利用for-of遍历" class="headerlink" title="2. keys()–&gt;将set数据里的键名全部拢在一起，再利用for of遍历"></a>2. keys()–&gt;将set数据里的键名全部拢在一起，再利用for of遍历</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'a'</span>]);</span><br><span class="line"><span class="keyword">for</span> ( x <span class="keyword">of</span> s.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;a b c d</span><br></pre></td></tr></table></figure>

<ul>
<li>set数据不分键名和键值，所以keys和values一样</li>
</ul>
<h4 id="3-values"><a href="#3-values" class="headerlink" title="3. values()"></a>3. values()</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'a'</span>]);</span><br><span class="line"><span class="keyword">for</span> ( x <span class="keyword">of</span> s.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;a b c d</span><br></pre></td></tr></table></figure>

<h4 id="4-entries-键值对指键名与键值的集合"><a href="#4-entries-键值对指键名与键值的集合" class="headerlink" title="4.entries();键值对指键名与键值的集合"></a>4.entries();键值对指键名与键值的集合</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'a'</span>]);</span><br><span class="line"><span class="keyword">for</span> ( x <span class="keyword">of</span> s.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;<span class="built_in">Array</span>[<span class="string">'a'</span>,<span class="string">'a'</span>] </span><br><span class="line"><span class="built_in">Array</span>[<span class="string">'b'</span>,<span class="string">'b'</span>]</span><br><span class="line"><span class="built_in">Array</span>[<span class="string">'c'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="built_in">Array</span>[<span class="string">'d'</span>,<span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="5-forEach-；与数组forEach-循环方法一样"><a href="#5-forEach-；与数组forEach-循环方法一样" class="headerlink" title="5. forEach()；与数组forEach()循环方法一样"></a>5. forEach()；与数组forEach()循环方法一样</h4><blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/5417256-7845549dc0dfb2f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</blockquote>
<p>链接：<a href="https://www.jianshu.com/p/7f934c99c4dd" target="_blank" rel="noopener">https://www.jianshu.com/p/7f934c99c4dd</a></p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>es6之扩展运算符</title>
    <url>/2020/09/14/es6%E4%B9%8B%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a><strong>含义</strong></h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">&#x2F;&#x2F; 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">&#x2F;&#x2F; 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(&#39;div&#39;)]</span><br><span class="line">&#x2F;&#x2F; [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>该运算符主要用于函数调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [4, 38];</span><br><span class="line">add(...numbers) &#x2F;&#x2F; 42</span><br></pre></td></tr></table></figure>

<p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f(v, w, x, y, z) &#123; &#125;</span><br><span class="line">const args &#x3D; [0, 1];</span><br><span class="line">f(-1, ...args, 2, ...[3]);</span><br></pre></td></tr></table></figure>

<p>扩展运算符后面还可以放置表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [</span><br><span class="line">  ...(x &gt; 0 ? [&#39;a&#39;] : []),</span><br><span class="line">  &#39;b&#39;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...[], 1]</span><br><span class="line">&#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure>

<p>注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(...[1, 2])</span><br><span class="line">&#x2F;&#x2F; Uncaught SyntaxError: Unexpected number</span><br><span class="line"></span><br><span class="line">console.log((...[1, 2]))</span><br><span class="line">&#x2F;&#x2F; Uncaught SyntaxError: Unexpected number</span><br><span class="line"></span><br><span class="line">console.log(...[1, 2])</span><br><span class="line">&#x2F;&#x2F; 1 2</span><br></pre></td></tr></table></figure>

<p>上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。</p>
<h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a><strong>替代函数的 apply 方法</strong></h3><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5 的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">var args &#x3D; [0, 1, 2];</span><br><span class="line">f.apply(null, args);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">let args &#x3D; [0, 1, 2];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure>

<p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5 的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5的 写法</span><br><span class="line">var arr1 &#x3D; [0, 1, 2];</span><br><span class="line">var arr2 &#x3D; [3, 4, 5];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 的写法</span><br><span class="line">let arr1 &#x3D; [0, 1, 2];</span><br><span class="line">let arr2 &#x3D; [3, 4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure>

<p>上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">new (Date.bind.apply(Date, [null, 2015, 1, 1]))</span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">new Date(...[2015, 1, 1]);</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a><strong>扩展运算符的应用</strong></h3><p><strong>（1）复制数组</strong></p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 &#x3D; [1, 2];</span><br><span class="line">const a2 &#x3D; a1;</span><br><span class="line"></span><br><span class="line">a2[0] &#x3D; 2;</span><br><span class="line">a1 &#x2F;&#x2F; [2, 2]</span><br></pre></td></tr></table></figure>

<p>上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。</p>
<p>ES5 只能用变通方法来复制数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 &#x3D; [1, 2];</span><br><span class="line">const a2 &#x3D; a1.concat();</span><br><span class="line"></span><br><span class="line">a2[0] &#x3D; 2;</span><br><span class="line">a1 &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure>

<p>上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 &#x3D; [1, 2];</span><br><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">const a2 &#x3D; [...a1];</span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">const [...a2] &#x3D; a1;</span><br></pre></td></tr></table></figure>

<p>上面的两种写法，a2都是a1的克隆。</p>
<p><strong>（2）合并数组</strong></p>
<p>扩展运算符提供了数组合并的新写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [&#39;a&#39;, &#39;b&#39;];</span><br><span class="line">const arr2 &#x3D; [&#39;c&#39;];</span><br><span class="line">const arr3 &#x3D; [&#39;d&#39;, &#39;e&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES5 的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</span><br></pre></td></tr></table></figure>

<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 &#x3D; [&#123; foo: 1 &#125;];</span><br><span class="line">const a2 &#x3D; [&#123; bar: 2 &#125;];</span><br><span class="line"></span><br><span class="line">const a3 &#x3D; a1.concat(a2);</span><br><span class="line">const a4 &#x3D; [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[0] &#x3D;&#x3D;&#x3D; a1[0] &#x2F;&#x2F; true</span><br><span class="line">a4[0] &#x3D;&#x3D;&#x3D; a1[0] &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。</p>
<p><strong>（3）与解构赋值结合</strong></p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">a &#x3D; list[0], rest &#x3D; list.slice(1)</span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">[a, ...rest] &#x3D; list</span><br></pre></td></tr></table></figure>

<p>下面是另外一些例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [first, ...rest] &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">first &#x2F;&#x2F; 1</span><br><span class="line">rest  &#x2F;&#x2F; [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] &#x3D; [];</span><br><span class="line">first &#x2F;&#x2F; undefined</span><br><span class="line">rest  &#x2F;&#x2F; []</span><br><span class="line"></span><br><span class="line">const [first, ...rest] &#x3D; [&quot;foo&quot;];</span><br><span class="line">first  &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line">rest   &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [...butLast, last] &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">&#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p><strong>（4）字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...&#39;hello&#39;]</span><br><span class="line">&#x2F;&#x2F; [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure>

<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;x\uD83D\uDE80y&#39;.length &#x2F;&#x2F; 4</span><br><span class="line">[...&#39;x\uD83D\uDE80y&#39;].length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function length(str) &#123;</span><br><span class="line">  return [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(&#39;x\uD83D\uDE80y&#39;) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &#39;x\uD83D\uDE80y&#39;;</span><br><span class="line"></span><br><span class="line">str.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">&#x2F;&#x2F; &#39;y\uDE80\uD83Dx&#39;</span><br><span class="line"></span><br><span class="line">[...str].reverse().join(&#39;&#39;)</span><br><span class="line">&#x2F;&#x2F; &#39;y\uD83D\uDE80x&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p>
<p><strong>（5）实现了 Iterator 接口的对象</strong></p>
<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let nodeList &#x3D; document.querySelectorAll(&#39;div&#39;);</span><br><span class="line">let array &#x3D; [...nodeList];</span><br></pre></td></tr></table></figure>

<p>上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number.prototype[Symbol.iterator] &#x3D; function*() &#123;</span><br><span class="line">  let i &#x3D; 0;</span><br><span class="line">  let num &#x3D; this.valueOf();</span><br><span class="line">  while (i &lt; num) &#123;</span><br><span class="line">    yield i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log([...5]) &#x2F;&#x2F; [0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>上面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">  &#39;0&#39;: &#39;a&#39;,</span><br><span class="line">  &#39;1&#39;: &#39;b&#39;,</span><br><span class="line">  &#39;2&#39;: &#39;c&#39;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot spread non-iterable object.</span><br><span class="line">let arr &#x3D; [...arrayLike];</span><br></pre></td></tr></table></figure>

<p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<p><strong>（6）Map 和 Set 结构，Generator 函数</strong></p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map([</span><br><span class="line">  [1, &#39;one&#39;],</span><br><span class="line">  [2, &#39;two&#39;],</span><br><span class="line">  [3, &#39;three&#39;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [...map.keys()]; &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const go &#x3D; function*()&#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;a: 1, b: 2&#125;;</span><br><span class="line">let arr &#x3D; [...obj]; &#x2F;&#x2F; TypeError: Cannot spread non-iterable object</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>扩展运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>es6特性</title>
    <url>/2020/07/30/es6%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符"></a>展开操作符</h3><p>顾名思义，用于对象或数组之前的展开操作符（…），将一个结构展开为列表。</p>
<p>演示一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let firstHalf &#x3D; [ &#39;one&#39;, &#39;two&#39;];</span><br><span class="line"></span><br><span class="line">let secondHalf &#x3D; [&#39;three&#39;, &#39;four&#39;, ...firstHalf];</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这种写法够优雅，够简洁吧？如果不用展开操作符</p>
<p>我们得这么写：</p>
<p>let firstHalf = [ ‘one’, ‘two’];</p>
<p>let secondHalf = [‘three’, ‘four’];</p>
<p>for(var i=0, i &lt;firstHalf.length; i++ ) {</p>
<p>  secondHalf.push(firstHalf[i]);</p>
<p>}</p>
<p>展开操作符也适用于合并对象的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hero &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &#39;Xena - Warrior Princess&#39;,</span><br><span class="line"></span><br><span class="line">  realName: &#39;Lucy Lawless&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const heroWithSword &#x3D; &#123;</span><br><span class="line"></span><br><span class="line"> ...hero,</span><br><span class="line"></span><br><span class="line"> weapon: &#39;sword&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不用展开操作符的话，需要遍历对象的属性：</p>
<p>let keys = Object.keys(hero);</p>
<p>let obj = {};</p>
<p>for(var i=0; i&lt; keys.length; i++) {</p>
<p>   obj[keys[i]] = keys[props[i]];</p>
<p>}</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数将剩余的参数收入数列。JavaScript 的特性是参数数目很灵活。通常会有一个 arguments 变量收集参数。</p>
<p>让我们看一个例子：</p>
<p>function add(first, second, …remaining) {</p>
<p>  return first + second;</p>
<p>}</p>
<p>上面的一段代码仅仅将 first 和 second 加起来，也就是说，调用 add(1, 2) 和 add(1, 2, 3, 4) 会得到相同的结果。</p>
<p>下面我们修正一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(first, second, ...remaining) &#123;</span><br><span class="line"></span><br><span class="line">  return first + second + remaining.reduce((acc, curr) &#x3D;&gt; acc + curr, 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如前所述，…remaining 收集了剩余的参数，为我们提供了这些参数的命名，清楚地表明我们打算处理剩余的参数。我记得至迟 ES5 已经有 arguments 了，不过少有人知。</p>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p>见过这样的语句吗？</p>
<p>class Product {</p>
<p> constructor(name, description, price) {</p>
<p>   this.name = name;</p>
<p>   this.description = description;</p>
<p>   this.price = price;</p>
<p> }</p>
<p>getDescription() {</p>
<p>   return “ Full description \n” +</p>
<p>   “ name: “ + this.name +</p>
<p>   “ description: “ + this.description</p>
<p> }</p>
<p>}</p>
<p>当然，我指的是 getDescription() 方法中那个可读性不佳的多行长语句。大多数编程语言中都存在类似现象。一些语言提供了字符串插值，幸运的是，JavaScript 正是其中之一。</p>
<p>我们改写一下 getDescription() 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getDescription() &#123;</span><br><span class="line"></span><br><span class="line">   return &#96;Full description \n:</span><br><span class="line"></span><br><span class="line">   name: $&#123;this.name&#125;</span><br><span class="line"></span><br><span class="line">   description $&#123;this.description&#125;</span><br><span class="line"></span><br><span class="line">   &#96;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一对 包起来的字符串中可以使用 ${} 插值。现在看起来舒服多了。</p>
<h3 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h3><p>在 ES5 中必须这么写：</p>
<p>function createCoord(x, y) {</p>
<p>  return {</p>
<p>​    x: x,</p>
<p>​    y: y</p>
<p>  }</p>
<p>}</p>
<p>ES6 以后可以使用简写属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createCoord(x, y) &#123;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line"></span><br><span class="line">    x,</span><br><span class="line"></span><br><span class="line">    y</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看起来更清爽了吧？</p>
<h3 id="方法属性"><a href="#方法属性" class="headerlink" title="方法属性"></a>方法属性</h3><p>方法属性是在对象中定义指向方法的属性。</p>
<p>考虑下面一段 ES5 代码作为例子：</p>
<p>const math = {</p>
<p>  add: function(a,b) { return a + b; },</p>
<p>  sub: function(a,b) { return a - b; },</p>
<p>  multiply: function(a,b) { return a * b; }</p>
<p>}</p>
<p>ES6 以后只需这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const math &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  add(a,b) &#123; return a + b; &#125;,</span><br><span class="line"></span><br><span class="line">  sub(a,b) &#123; return a - b; &#125;,</span><br><span class="line"></span><br><span class="line">  multiply(a,b) &#123; return a * b; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值有利于开发者本人的心理健康。</p>
<p>考虑下面的代码：</p>
<p>function handle(req, res) {</p>
<p> const name = req.body.name;</p>
<p> const description = req.body.description;</p>
<p> const url = req.url;</p>
<p> log(‘url endpoint’, url);</p>
<p> // 大量代码逻辑</p>
<p> dbService.createPerson(name, description)</p>
<p>}</p>
<p>不管从什么角度来看，上面的代码都不完美，但它确实体现了一种应用场景，我们想要从对象的不同层次获取数据。你也许会问，这里有什么问题？好吧，我可以不用声明这么多变量，省下一些敲击键盘的次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function handle(req, res) &#123;</span><br><span class="line"></span><br><span class="line"> const &#123; body: &#123; name, description &#125;, url &#125; &#x3D; req;</span><br><span class="line"></span><br><span class="line"> log(&#39;url endpoint&#39;, url);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 大量代码逻辑</span><br><span class="line"></span><br><span class="line"> dbService.createPerson(name, description)</span><br></pre></td></tr></table></figure>



<p>看，我们上面的代码将三行压缩成了一行。</p>
<p>解构赋值并不仅仅局限于对象。它同样适用于数组。</p>
<p>考虑下面的代码：</p>
<p>const array = [1,2,3,4,5,6];</p>
<p>const a = array[0];</p>
<p>const c = array[2];</p>
<p>上面的代码可以用更优雅的方式改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array &#x3D; [1,2,3,4,5,6];</span><br><span class="line"></span><br><span class="line">const [a, ,c, ...remaining] &#x3D; arr;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; remaining &#x3D; [4,5,6]</span><br></pre></td></tr></table></figure>

<p>我们可以使用上面的模式匹配分解数组的值。我们使用 , , 跳过某些值。上面提到过的剩余参数这里也能用，在这里我们通过剩余参数捕获了剩余的数组成员。</p>
<p>解构赋值还可以用于函数和参数。函数有不止 2-3 个参数时，使用一个对象收集所有参数是 JavaScript 的事实标准。</p>
<p>例如，下面一个函数：</p>
<p>function doSomething(config) {</p>
<p>  if(config.a) { … }</p>
<p>  if(config.b) { … }</p>
<p>  if(config.c) { … }</p>
<p>}</p>
<p>有更好的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function doSomething(&#123; a, b, c &#125;) &#123;</span><br><span class="line"></span><br><span class="line">  if(a) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  if(b) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  if(c) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数解构的默认参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 解构 —— 只获得 name 属性</span><br><span class="line">&#x2F;&#x2F; 参数默认分配空对象 &#123;&#125;</span><br><span class="line">function test(&#123;name&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  console.log (name || &#39;unknown&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map 是 ES2015(ES6) 引入的新的对象类型，允许您存储键值对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(color) &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用 switch case 语句，根据颜色找出对应的水果</span><br><span class="line">  switch (color) &#123;</span><br><span class="line">    case &#39;red&#39;:</span><br><span class="line">      return [&#39;apple&#39;, &#39;strawberry&#39;];</span><br><span class="line">    case &#39;yellow&#39;:</span><br><span class="line">      return [&#39;banana&#39;, &#39;pineapple&#39;];</span><br><span class="line">    case &#39;purple&#39;:</span><br><span class="line">      return [&#39;grape&#39;, &#39;plum&#39;];</span><br><span class="line">    default:</span><br><span class="line">      return [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试结果</span><br><span class="line">test(null); &#x2F;&#x2F; []</span><br><span class="line">test(&#39;yellow&#39;); &#x2F;&#x2F; [&#39;banana&#39;, &#39;pineapple&#39;]</span><br></pre></td></tr></table></figure>

<p>优化后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用对象字面量，根据颜色找出对应的水果</span><br><span class="line">  const fruitColor &#x3D; &#123;</span><br><span class="line">    red: [&#39;apple&#39;, &#39;strawberry&#39;],</span><br><span class="line">    yellow: [&#39;banana&#39;, &#39;pineapple&#39;],</span><br><span class="line">    purple: [&#39;grape&#39;, &#39;plum&#39;]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">function test(color) &#123;</span><br><span class="line">  return fruitColor[color] || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 Map ，根据颜色找出对应的水果</span><br><span class="line">  const fruitColor &#x3D; new Map()</span><br><span class="line">    .set(&#39;red&#39;, [&#39;apple&#39;, &#39;strawberry&#39;])</span><br><span class="line">    .set(&#39;yellow&#39;, [&#39;banana&#39;, &#39;pineapple&#39;])</span><br><span class="line">    .set(&#39;purple&#39;, [&#39;grape&#39;, &#39;plum&#39;]);</span><br><span class="line"></span><br><span class="line">function test(color) &#123;</span><br><span class="line">  return fruitColor.get(color) || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>ES6 引入了许多有用的数组方法，例如：</p>
<ul>
<li>find()，查找列表中的成员，返回 null 表示没找到</li>
<li>findIndex()，查找列表成员的索引</li>
<li>some()，检查某个断言是否至少在列表的一个成员上为真</li>
<li>includes，列表是否包含某项</li>
</ul>
<p>下面的代码有助于你理解它们的用法：</p>
<p>const array = [{ id: 1, checked: true }, { id: 2 }];</p>
<p>arr.find(item =&gt; item.id === 2) // { id: 2 }</p>
<p>arr.findIndex(item =&gt; item.id === 2) // 1</p>
<p>arr.some(item =&gt; item.checked) // true</p>
<p>const numberArray = [1,2,3,4];</p>
<p>numberArray.includes(2) // true</p>
<p>Promises + Async/Await</p>
<p>如果你在这个圈子里呆了些年头，也许会记得曾经有一个时期我们只有回调</p>
<p>就像这样：</p>
<p>function doSomething(cb) {</p>
<p>  setTimeout(() =&gt;  {</p>
<p>​    cb(‘done’)</p>
<p>  }, 3000)</p>
<p>}</p>
<p>doSomething((arg) =&gt; {</p>
<p> console.log(‘done here’, arg);</p>
<p>})</p>
<p>我们使用回调是因为有些操作是异步的，需要时间来完成。后来我们有了 promise 库，人们开始使用它。然后 JavaScript 逐渐加入了对 promise 的原生支持。</p>
<p>function doSomething() {</p>
<p>  return new Promise((resolve, reject) =&gt; {</p>
<p>​    setTimeout(() =&gt;  {</p>
<p>​      resolve(‘done’)</p>
<p>​    }, 3000)</p>
<p>  })</p>
<p>}</p>
<p>doSomething().then(arg =&gt; {</p>
<p> console.log(‘done here’, arg);</p>
<p>})</p>
<p>我们甚至可以这样调用，将 promise 串起来：</p>
<p>getUser()</p>
<p>  .then(getOrderByUser)</p>
<p>  .then(getOrderItemsByOrder)</p>
<p>  .then(orderItems =&gt; {</p>
<p>​    // 处理排序后的成员</p>
<p>  })</p>
<p>后来生活更加美好，我们有了 async/await</p>
<p>上面一段代码可以这样写：</p>
<p>async function getItems() {</p>
<p>  try {</p>
<p>​    const user = await getUser();</p>
<p>​    const order = await getOrderByUser(user);</p>
<p>​    const items = await getOrderItemsByOrder(order);</p>
<p>​    return items;</p>
<p>  } catch(err) {</p>
<p>​    // 在这里处理错误，建议返回某个值或者重新抛出错误</p>
<p>  }</p>
<p>}</p>
<p>getItems().then(items =&gt; {</p>
<p>  // 处理排序后的成员</p>
<p>})</p>
<p>###模块</p>
<p>差不多任何编程语言都支持模块这一概念，也就是将代码分为多个文件，每个文件是一个自我包含的单元（模块）。</p>
<p>考虑下面的代码：</p>
<p>// math.js</p>
<p>export function add(a,b) { return a + b; }</p>
<p>export function sub(a,b) { return a - b; }</p>
<p>export default mult(a,b) =&gt; a * b;</p>
<p>// main.js</p>
<p>import mult, { add, sub } from ‘./math’;</p>
<p>mult(2, 4) // 8</p>
<p>add(1,1)   // 2</p>
<p>sub(1,2)   // -1</p>
<p>我们在上面用 export 关键字注明了 add 和 sub 这两个结构对任何引入该模块的模块都公开可见。export default 关键字则注明仅仅 import 模块时得到的结构。在 main.js 中，我们将导入的 default 命名为 mult，同时指明我们引入 add() 和 sub() 这两个方法。箭头函数和字典作用域 this</p>
<p>我在这篇文章中很多地方都用到了箭头函数，它不过是另一种函数表示法。</p>
<p>过去我们只能这么声明函数：</p>
<p>function printArray(arr) {</p>
<p> // 具体操作</p>
<p>}</p>
<p>现在我们也可以这么写：</p>
<p>const printArray = (arr) =&gt; {</p>
<p> // 具体操作</p>
<p>}</p>
<p>我们也可以将函数声明写到一行里：</p>
<p>const add = (a,b) =&gt; a + b</p>
<p>上面的代码表明我们进行操作并返回结果。</p>
<p>我们也可以采用下面的语法返回一个对象：</p>
<p>const create = (a,b) = &gt; ({ x: a, y: b })</p>
<p>过去会碰到搞不清 this 是什么的问题。考虑下面的代码：</p>
<p>let array = [1,2,3];</p>
<p>function sum() {</p>
<p>  this.total = 0;</p>
<p>  arr.forEach(function(item) {</p>
<p>​    this.total+= item;  // 糟糕，<code>this</code> 是内层函数的 <code>this</code></p>
<p>  })</p>
<p>  return total;</p>
<p>}</p>
<p>上面代码中的 this 指向 forEach 内部函数的 this，这可不是我们想要的。</p>
<p>过去我们通过以下方式解决这个问题：</p>
<p>function sum() {</p>
<p>  this.total = 0;</p>
<p>  var self = this;</p>
<p>  arr.forEach(function(item) {</p>
<p>​    self.total+= item;  // 这里我们使用 <code>self</code>，它能解决问题，但是感觉有点别扭</p>
<p>  })</p>
<p>  return total;</p>
<p>}</p>
<p>箭头函数可以解决问题，再也不用 self 了</p>
<p>现在代码看起来是这样的：</p>
<p>function sum() {</p>
<p>  this.total = 0;</p>
<p>  arr.forEach((item) =&gt; {</p>
<p>​    this.total+= item;  // 一切安好，<code>this</code> 指向外层函数</p>
<p>  })</p>
<p>  return total;</p>
<p>}</p>
<h3 id="Object-is-方法，它具有-的一些特点，而且更好、更精确"><a href="#Object-is-方法，它具有-的一些特点，而且更好、更精确" class="headerlink" title="Object.is() 方法，它具有 === 的一些特点，而且更好、更精确"></a>Object.is() 方法，它具有 === 的一些特点，而且更好、更精确</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.is(0 , &#39; &#39;); &#x2F;&#x2F;false</span><br><span class="line">Object.is(null, undefined); &#x2F;&#x2F;false</span><br><span class="line">Object.is([1], true); &#x2F;&#x2F;false</span><br><span class="line">Object.is(NaN, NaN); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="ES2020-中-Javascript-10-个你应该知道的新功能"><a href="#ES2020-中-Javascript-10-个你应该知道的新功能" class="headerlink" title="ES2020 中 Javascript 10 个你应该知道的新功能"></a>ES2020 中 Javascript 10 个你应该知道的新功能</h3><h3 id="1-BigInt"><a href="#1-BigInt" class="headerlink" title="1: BigInt"></a>1: BigInt</h3><p>BigInt，Javascript 中最期待的新功能终于落地。它允许开发者在 JS 中使用更大的整数进行数据处理。</p>
<p>之前，Javascript 中最大的整数是 <code>pow(2, 53) \- 1</code>。但是，BigInt 不受此限制。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGwarDI032t9wha7b0IahtTzo8zIeuwhUs1HJBGYfW7pjwd7ibbB5Mdow/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>然而，就如你在上面看到，你需要在数字后面添加一个 <code>n</code>。这个 <code>n</code> 说明这是一个 BigInt，Javascript 引擎应该特殊处理（不管是 V8，还是其它引擎）。</p>
<p>因为传统的数字系统是 IEEE754（它不支持这种大数字），因此，这个改进并不会向后兼容。</p>
<h3 id="2：动态引入"><a href="#2：动态引入" class="headerlink" title="2：动态引入"></a>2：动态引入</h3><p>Javascript 的动态引入，允许你把 JS 文件作为一个模块动态的引入到你的应用中。这就像你使用 webpack 和 Babel 一样。</p>
<p>这个功能可以帮助你处理按需加载的代码，拆分代码，而且，并不需要 webpack 或者其它模块处理器。如果，你喜欢也可以在 if-else 块中加载代码。</p>
<p>在 if-else 块中引入一个模块，这样的好处是：不会污染全局命名空间。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGLpBPLYgYRwZ5ib0tx951uC6yTocZIZ6OicfltYmhNGa1D7yCE5L4K9TQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="3-空值合并"><a href="#3-空值合并" class="headerlink" title="3: 空值合并"></a>3: 空值合并</h3><p>空值合并可以真正的检查 <code>nullish</code> 值，而不是 <code>falsely</code> 值。你或许会问：<code>nullish</code>和 <code>falsely</code> 之间有什么不同呢？</p>
<p>在 Javascript 中有很多值都是 <code>falsely</code>。比如：空字符串、数字 0、<code>undefined</code>、<code>null</code>、 <code>false</code> 、<code>NaN</code> 等。</p>
<p>然而，很多情况下你只想检测一个变量是否为空值 – <code>undefined</code> 或者 <code>null</code>，就像变量可以是一个空字符串甚至是一个假值。</p>
<p>在这个示例中，你将会看到新的空值合并操作符：<code>??</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGGCVd9L1a8WDLibedRyLc0CeOEOUCZha5JXiacCp2KzXicJDR1mXB96zlQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>你可以清楚的看到 OR 操作符总是返回一个真值，但是，空值操作符返回一个非空值。</p>
<h3 id="4：可选链"><a href="#4：可选链" class="headerlink" title="4：可选链"></a>4：可选链</h3><p>可选链语法允许你访问嵌套更深的对象属性，而不用担心属性是否存在。如果，存在很好。反之，会返回 <code>undefined</code>。</p>
<p>它不仅仅可操作对象属性，也可以操作函数的调用或者数组。这样更加方便！以下是个演示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGdbuZJu6Ms94TdPHNp5iaMwyHico9kpkFh90iboBGbTpCM0zZ2ZX2nTssA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="5-Promise-allSettled"><a href="#5-Promise-allSettled" class="headerlink" title="5: Promise.allSettled"></a>5: Promise.allSettled</h3><p><code>Promise.allSettled</code> 方法接收一组 Promise，并且会返回所有的结果 - 而不管是 resolved 还是 rejected。</p>
<p>在之前，这是不可能的，尽管有些类似的实现比如：<code>race</code> 和 <code>all</code>。它只会“运行所有的 promise - 而不关心它们的结果”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uv6XVHS9fJfeCggKwEYnvPGGLZEQbV3z7SI6bA2v7rjFXkib2tosiaLIsfg0gmlpjDibVxetuBn5fVmQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="6-String-matchAll"><a href="#6-String-matchAll" class="headerlink" title="6: String#matchAll"></a>6: String#matchAll</h3><h3 id="举例解决问题"><a href="#举例解决问题" class="headerlink" title="举例解决问题"></a>举例解决问题</h3><h4 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h4><p>在此示例中，我们使用了散布运算符（…），Array的reverse方法和String的join方法来反转给定的字符串。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWS5QUCFTBa7CHlWarkPicvMmxPX22TIc1rAnKbuDfKyWWichiakwjfx5PhQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="2、计算数字的阶乘"><a href="#2、计算数字的阶乘" class="headerlink" title="2、计算数字的阶乘"></a>2、计算数字的阶乘</h4><p>要计算给定数字的阶乘，我们使用箭头函数和嵌套三元运算符。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSqibNic0gumhUb1xeBcKSFmbiaE2bsOPtByxJDOibhau4T7FM4PQQBQ8vag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="3、将数字转换为数字数组"><a href="#3、将数字转换为数字数组" class="headerlink" title="3、将数字转换为数字数组"></a>3、将数字转换为数字数组</h4><p>在此示例中，我们使用了散布运算符（…），Array的map方法以及将该给定数字转换为一个单数数组的parseInt 函数 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSIcozwmwiavIspqX1uMyaNh4RAZibudxVCX97BW27YbT3b9zLQ7Ou02yQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="4、检查数字是否为2的幂"><a href="#4、检查数字是否为2的幂" class="headerlink" title="4、检查数字是否为2的幂"></a>4、检查数字是否为2的幂</h4><p>这很简单。我们检查这number不是虚假的，并使用按位AND运算符 （&amp;）确定是否number为2的幂。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSFJLTkng2dHxMDYiaXQxVDwQzvIGCElMUmUVYYUsXUiaibRHfMdV6Pbib0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="5、从对象创建键-值对数组"><a href="#5、从对象创建键-值对数组" class="headerlink" title="5、从对象创建键-值对数组"></a><strong>5、从对象创建键-值对数组</strong></h4><p>在此示例中，我们使用Object中的keys方法和 Array中的map方法来映射Object的键，并创建一个键值对数组。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSSnDonmibictDW2MVbXE1DSJKvhefIcAYq3kf61YS9Wstuu55ia7D4LJQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="6、从数组中返回-Number-个最大元素"><a href="#6、从数组中返回-Number-个最大元素" class="headerlink" title="6、从数组中返回[Number]个最大元素"></a><strong>6、从数组中返回[Number]个最大元素</strong></h4><p>为了从数组中返回最大元素，我们使用了一个箭头函数，该函数获取数组和希望函数返回的元素数。我们使用了散布运算符（…）以及Array中的sort和slice方法。请注意，如果不提供第二个参数，则number默认值为1，因此仅返回一个最大元素。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWS7D5ZtxhHKCfEibEWvtxf5VgK6kR3CH3tTiaCEStFLVNglVp9rkqE4jNA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="7、检查数组中的所有元素是否相等"><a href="#7、检查数组中的所有元素是否相等" class="headerlink" title="7、检查数组中的所有元素是否相等"></a><strong>7、检查数组中的所有元素是否相等</strong></h4><p>在这个简短的示例中，我们使用Array中的every方法检查数组中的所有元素是否相等。我们基本上检查每个元素是否等于数组中的第一个元素。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWStVhG8l1dPzWm8IZEH4gQJpxdpUuL0gaFQLGDWAW6L5VflYxNcfTjQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="8、返回两个数的平均值"><a href="#8、返回两个数的平均值" class="headerlink" title="8、返回两个数的平均值"></a><strong>8、返回两个数的平均值</strong></h4><p>在此示例中，我们使用了spread运算符（…）和Array中的reduce方法来返回两个给定数字或一个数组的平均值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSS5Piaz8PhaFjX1Adpo4l0ZJqiatS4icRkJTIHCQrmlDj9icol1V0a0GkVg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="9、返回两个或多个数字的和"><a href="#9、返回两个或多个数字的和" class="headerlink" title="9、返回两个或多个数字的和"></a><strong>9、返回两个或多个数字的和</strong></h4><p>要返回两个或多个给定数字或一个数组的总和，我们再次使用散布运算符（…） 和 Array中的reduce方法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWSeMEuicAyVrjHB3SpicVpTEmvUoYuKz6gjA0hescic1zwF6BAWluq7NjHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="10、返回数字数组的幂集"><a href="#10、返回数字数组的幂集" class="headerlink" title="10、返回数字数组的幂集"></a><strong>10、返回数字数组的幂集</strong></h4><p>在最后一个示例中，我们要返回数字数组的幂集。因此，我们使用Array中的reduce，map和concat方法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbG4VhLbRDf5lpFt1sagtWS2ibeNSm54ZT0LReAsd2IfbKUtveW6Lnx2afRIxlhB1cxVgfm2QMdIMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>更细解说：<a href="https://mp.weixin.qq.com/s/xyHVGYlcng5kucjayOOdwA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xyHVGYlcng5kucjayOOdwA</a></p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>export与importi详解</title>
    <url>/2020/07/30/export%E4%B8%8Eimporti%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>es6模块规范</p>
<p>1、export default 向外暴露的成员，可以使用任意变量来接收</p>
<p>2、在一个模块中，export default 只允许向外暴露一次</p>
<p>3、在一个模块中，可以同时使用export default 和export 向外暴露成员</p>
<p>4、使用export向外暴露的成员，只能使用{ }的形式来接收，这种形式，叫做【按需导出】</p>
<p>5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义</p>
<p>6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收</p>
<p>7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名</p>
<a id="more"></a>

<p>举例</p>
<p>导出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; profile.js</span><br><span class="line">一：</span><br><span class="line">export var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">export var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">export var year &#x3D; 1958;</span><br><span class="line"></span><br><span class="line">二：</span><br><span class="line">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">var year &#x3D; 1958;</span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br><span class="line"></span><br><span class="line">三：</span><br><span class="line">export function multiply(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">四：</span><br><span class="line">function v1() &#123; ... &#125;</span><br><span class="line">function v2() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">  v1 as streamV1,</span><br><span class="line">  v2 as streamV2,</span><br><span class="line">  v2 as streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引入一个</span><br><span class="line"></span><br><span class="line">import &#123;firstName, lastName, year&#125; from &#39;.&#x2F;profile&#39;</span><br><span class="line"></span><br><span class="line">如果想重新给导入的变量一个名字，可以用as关键字，</span><br><span class="line">import &#123; lastName as surname &#125; from &#39;.&#x2F;profile&#39;;</span><br><span class="line"></span><br><span class="line">引入全部</span><br><span class="line">import * as circle from &#39;.&#x2F;circle&#39;;</span><br></pre></td></tr></table></figure>



<p>export default</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认输出</span><br><span class="line">export default function crc32() &#123; &#x2F;&#x2F; 输出</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import crc32 from &#39;crc32&#39;; &#x2F;&#x2F; 输入</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正常输出</span><br><span class="line">export function crc32() &#123; &#x2F;&#x2F; 输出</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">import &#123;crc32&#125; from &#39;crc32&#39;; &#x2F;&#x2F; 输入</span><br></pre></td></tr></table></figure>



<p>CommonJS模块规范（nodejs使用中）</p>
<p>Node应用由模块组成，采用CommonJS模块规范。</p>
<p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 5;</span><br><span class="line"></span><br><span class="line">var addX &#x3D; function (value) &#123;  return value + x;&#125;;</span><br><span class="line"></span><br><span class="line">module.exports.x &#x3D; x;</span><br><span class="line"></span><br><span class="line">module.exports.addX &#x3D; addX;</span><br><span class="line"></span><br><span class="line">上面代码通过module.exports输出变量x和函数addX。</span><br></pre></td></tr></table></figure>



<p>require方法用于加载模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example &#x3D; require(&#39;.&#x2F;example.js&#39;);</span><br><span class="line"></span><br><span class="line">console.log(example.x);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">console.log(example.addX(1));</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 6</span><br><span class="line"></span><br><span class="line">exports 与 module.exports</span><br></pre></td></tr></table></figure>



<p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>
<p>var exports = module.exports;</p>
<p>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
        <tag>export</tag>
        <tag>import</tag>
        <tag>module</tag>
        <tag>require</tag>
      </tags>
  </entry>
  <entry>
    <title>express和koa</title>
    <url>/2020/09/15/express%E5%92%8Ckoa/</url>
    <content><![CDATA[<p>Koa和Express都是NodeJS的主流应用开发框架。</p>
<p>Express是一个完整的nodejs应用框架。Koa是由Express团队开发的，但是它有不同的关注点。Koa致力于核心中间件功能。nodejs中间件是访问请求对象（req）和响应对象（res）的例程。这些例程在路由处理程序之前被调用，因此它们位于客户端与生成响应的路由逻辑的“中间”。nodejs应用程序可以将中间件例程“链接”到自定义请求/响应管道中。管道可以根据请求和响应进行操作，包括头和主体。Express和Koa都包含中间件，但实现方法却截然不同。</p>
 <a id="more"></a>

<p>核心Koa模块只是中间件内核。而Express包含一个完整的应用程序框架，具有路由和模板等功能。Koa确实有这些功能的选项，但它们是单独的模块。因此，Koa的模块化程度更高；您只需包含所需的模块即可。核心KOA模块只有大约2千行代码，因此，如果您只需要核心请求应答上下文对象，则Koa占用空间非常小。相比较而言，Express较为庞大，内置了一整套中间件功能，好处是对于大部分应用场合你可以省掉自己选择和组合模块的时间。</p>
<p>Koa对Express进行了扩展，并充分利用了ES7新的语法。Koa的Context对象是对Express核心请求和应答对象的扩展，另外利用async/await来消除回调（callback）陷阱。</p>
<p>回调的语法类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction(params, callback)&#123; </span><br><span class="line">    &#x2F;&#x2F;make async call here  </span><br><span class="line">    asyncCall(params, function(res) &#123; </span><br><span class="line">        callback(res); </span><br><span class="line">    &#125;) </span><br><span class="line">&#125; </span><br><span class="line">myFunction(myParams, function(data)&#123;   </span><br><span class="line">    &#x2F;&#x2F;do something with &#39;data&#39; here </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>异步语法async/await类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async myFunction()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        let res &#x3D; await asyncCall();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(err)&#123;</span><br><span class="line">        console.log(&quot;Error: &quot; + err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let result &#x3D; await myFunction();</span><br></pre></td></tr></table></figure>

<p>回调陷阱（大量嵌套的回调函数）问题这里略过，写过大型JS应用的，应该都深有体会，下面的async/await语法除了执行顺序更加清楚之外，异常处理也更容易。对异步问题的处理方式是Koa和Express两者一个显著区别。</p>
<p>关于性能，这两个框架相差无几，Koa略好，这里略过具体的测试用例了，基本上都能达到几千req/s。</p>
<p>最后简单总结下，如何选型：</p>
<ol>
<li>如果是新项目，运行环境对ES7语法没有限制，对性能比较看重，团队有较高的定制化需求和技能，那么优先选择Koa；</li>
<li>如果是Express的老项目，那么建议继续使用Express，没必要只是为了用新技术而来迁移，Koa和Express也不那么兼容；</li>
<li>如果你不想自己选择和搭建各种模块组件并有可能需要处理兼容问题，而喜欢一体的、快速集成开发，那么选择Express，Express是一套成熟的应用开发框架，而不仅仅提供核心模块</li>
</ol>
<p>参考链接: <a href="https://www.cnblogs.com/leolovexx/p/12212552.html" target="_blank" rel="noopener">https://www.cnblogs.com/leolovexx/p/12212552.html</a></p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>flex</title>
    <url>/2020/10/28/flex/</url>
    <content><![CDATA[<p>父级属性</p>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>![clipboard (10)](flex.assets/clipboard (10).png)</p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>![clipboard (11)](flex.assets/clipboard (11).png)</p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>![clipboard (12)](flex.assets/clipboard (12).png)</p>
<h3 id="align-items-stretch在子项没有高度才能使用-，在子项为单行的时候有效"><a href="#align-items-stretch在子项没有高度才能使用-，在子项为单行的时候有效" class="headerlink" title="align-items(stretch在子项没有高度才能使用)，在子项为单行的时候有效"></a>align-items(stretch在子项没有高度才能使用)，在子项为单行的时候有效</h3><p>![clipboard (13)](flex.assets/clipboard (13).png)</p>
<h3 id="align-content-适用于多行"><a href="#align-content-适用于多行" class="headerlink" title="align-content(适用于多行)"></a>align-content(适用于多行)</h3><p>![clipboard (14)](flex.assets/clipboard (14).png)</p>
<p>区别</p>
<p>![clipboard (15)](flex.assets/clipboard (15).png)</p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>![clipboard (16)](flex.assets/clipboard (16).png)</p>
<p>子级属性</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>![clipboard (17)](flex.assets/clipboard (17).png)</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>![clipboard (18)](flex.assets/clipboard (18).png)</p>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>![clipboard (19)](flex.assets/clipboard (19).png)</p>
<p><strong>flex布局如何左对齐并且间距相同</strong>(适用于少于一行排满的个数或者多余一行但是少于两行)</p>
<p>给item的父类加一个伪类，如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.top-list</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>height一定要给0；width和item的width一致；conten给空即可</strong></p>
<p>改变布局方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">justify-content: space-between;</span><br><span class="line">改后</span><br><span class="line">align-content: flex-start;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>gitExtensions/git/kdiff3/</title>
    <url>/2020/08/18/gitExtensions-git-kdiff3/</url>
    <content><![CDATA[<h3 id="Git-Extension工具安装及使用"><a href="#Git-Extension工具安装及使用" class="headerlink" title="Git Extension工具安装及使用"></a><a href="https://www.cnblogs.com/sumuncle/p/7675921.html" target="_blank" rel="noopener">Git Extension工具安装及使用</a></h3><p>以下界面所示的三个工具，如果没安装过，则勾上让其安装。MsysGit为Git的Windows版本，必须要安装；Kdiff为对比/合并工具，可选安装，可以换为使用其它的相关工具；最后一个Windows Credential Store for Git用于在Windows Credential Manager中存储仓库的密码，这在老版本中没有，也安上吧</p>
<a id="more"></a>

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016110809365-1747214992.png" alt="img"></p>
<p><strong>比较概述：</strong><br>SSH客户端，OpenSSH是命令行的，PuTTY是图形界面的： </p>
<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016110829146-357896798.png" alt="img"></p>
<p>若选择PuTTY则安装成功后,如果有问题，需要进行以下配置:</p>
<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016111207302-993527291.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016111228881-2045654478.png" alt="img"></p>
<p><strong>以下以OpenSSH为例做以下操作:</strong></p>
<p>第一步：安装</p>
<p>1.双击：GitExtensions24703SetupComplete.msi</p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101101099-1387852818.png" alt="img"></p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101117256-804768133.png" alt="img"></p>
<p>选择安装路径</p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101147552-1825946550.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101203974-535514155.png" alt="img"></p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101229693-2058253143.png" alt="img"></p>
<p>点击Install之后跳出以下窗口，点击我接受</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101522412-1379845039.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101539021-1719148735.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101554959-1954911635.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101609834-1365194592.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101624006-1861780982.png" alt="img"></p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101921490-1403912771.png" alt="img"></p>
<p>点击完成后跳出以下窗口，点击Next</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016101936334-848543012.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102131974-817517735.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102210724-1255385702.png" alt="img"></p>
<ignore_js_op> 

<p><img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102231287-1365215914.png" alt="img"></p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102248131-721962200.png" alt="img"></p>
<p>点击后等待安装完成</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102318115-1652078200.png" alt="img"></p>
<p>安装完成后自动关闭窗口，跳转到领一个窗口！点击Finish</p>
<p>点击Finish后，工具就全部安装完成啦！</p>
<p>温馨提示：安装过程中开启的程序可以直接关闭</p>
<p>第二步：配置！</p>
<p>双击软件图标:软件</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102545084-1071616752.png" alt="img"></p>
<p>打开后如下图：进入设置页面，选择全局设置</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102602006-1411834690.png" alt="img"></p>
<p>全局是设置如下图</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102619881-334267455.png" alt="img"></p>
<p>全局设置要求如下：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102632209-937526562.png" alt="img"></p>
<p>SSH设置如下</p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102821959-978142230.png" alt="img"></p>
<p>设置完成后点击应用、接着点击确定</p>
<p>然后出现如下页面：点击克隆档案库</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102859443-624421601.png" alt="img"></p>
<p>出现如下页面：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016102916068-1828212738.png" alt="img"></p>
<p>此页面具体设置方法如下图：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103539490-342843931.png" alt="img"></p>
<p>例如配置下图档案库：</p>
<p>档案库地址在：<a href="http://mc.kuaikuai.cn/" target="_blank" rel="noopener">http://mc.kuaikuai.cn</a></p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103647474-1178722425.png" alt="img"></p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103708521-1159470095.png" alt="img"></p>
<p>则文件最终存储的目录为：D:\KuaiKuai_MC_Server\ lostforest</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103733709-556038027.png" alt="img"></p>
<p>点击克隆：弹出输入账户密码窗口，账户由我们快快官方提供</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016103806021-1359103381.png" alt="img"></p>
<p>选择路径之后点击克隆，出现以下窗口，输入用户名、点击回车</p>
<p>输入密码</p>
<p>注意：输入密码时看不见输入的键值，光标也不会移动</p>
<p>如果右上角红色X，表示用户名账户验证失败</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104026287-1169565778.png" alt="img"></p>
<p>出现绿色勾为账户验证正确，点击确定。</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104039756-1950152715.png" alt="img"></p>
<p>这个过程中将会把服务器已经存在的文件下载到本地，然后由服主自行替换文件，再上传！</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104108927-1727956402.png" alt="img"></p>
<p>创建成功后如下：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104129771-693242118.png" alt="img"></p>
<p>第三步：上传</p>
<p>点击下图：提交</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104206506-704711939.png" alt="img"></p>
<p>进入以下页面：</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104237177-1050313354.png" alt="img"></p>
<p>1区是对应文件夹下的所有文件，选择你需要上传的文件，双击它进入3区！</p>
<p>（注意：1区只显示最新修改的文件，未修改的文件不会显示出来）</p>
<p>2区是显示文本文件的内容。</p>
<p>3区是选择好后需要上传的文件，双击它取消选择</p>
<p>4区是填写操作原因</p>
<p>文件选择完毕之后，填写原因.例如下图：然后点击提交</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104311224-1833734551.png" alt="img"></p>
<p>出现对话框，点击确定</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104336037-321937142.png" alt="img"></p>
<p>进入以下页面，最上方的表示最新创建的任务。等待上传的文件！</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104358318-1599399045.png" alt="img"></p>
<p>如下图：选择第一项，然后点击蓝色向上箭头</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104427256-1658293722.png" alt="img"></p>
<p>点击箭头后出现下图窗口:无需任何操作，直接点击“推送”按钮</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104446568-1900158592.png" alt="img"></p>
<p>点击“推送”后需要验证账户：操作方法与之前一样</p>
<ignore_js_op> 

<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104513709-1152268099.png" alt="img"></p>
<p>账户验证成功后文件自动上传，出现绿色勾选项表示正确</p>
<p> <img src="https://images2017.cnblogs.com/blog/732403/201710/732403-20171016104536412-1454555876.png" alt="img"></p>
<p>安装完成，Git Extensions会弹出配置界面，如果有问题，一般就是选择一下相关组件的路径即可：</p>
<p>注意：3.0版本之后，git和kdiff3都要手动安装，一直next就可以了(下图为手动添加kdiff3为对比工具)</p>
<p><img src="https://i.loli.net/2020/08/18/KQMzZ7O2gdXVyw8.png" alt="kdiff3.png"></p>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><blockquote>
<p>SSH是一种<strong>网络协议</strong>，用于计算机之间的<strong>加密</strong>登录。对于SSH详情了解可以去看看这个：<a href="http://www.findme.wang/blog/detail/id/258.html" target="_blank" rel="noopener">http://www.findme.wang/blog/detail/id/258.html</a></p>
</blockquote>
<p>　　每台电脑上会产生出一个ssh key，然后自己有一个远程账户，但是自己有可能有很多台电脑，包括家里的电脑还有公司的电脑，我们可以在任意一台电脑上工作，但是如果想要每台电脑都和远程版本库时刻保持着通讯， 就需要将每台电脑的ssh key添加到远程账户，添加到远程版本库之后，远程版本库就会和已经添加的电脑进行通讯而不会和其他电脑进行通讯。建议：所有的Git操作都通过ssh key进行，因为简单</p>
<h3 id="ssh-key配置-用git命令生成"><a href="#ssh-key配置-用git命令生成" class="headerlink" title="ssh key配置(用git命令生成)"></a><strong>ssh key配置</strong>(用git命令生成)</h3><h5 id="本地电脑配置"><a href="#本地电脑配置" class="headerlink" title="本地电脑配置"></a>本地电脑配置</h5><p>右键空白处，选择Git Bash Here打开相关命令窗口</p>
<p>　　 配置用户名和邮箱（如果已经配置，就跳过）  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;  --引号中自定义</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure>

<p>  之后就会在C:\Users\Administrator下创建一个.gitconfig文件</p>
<p>　　注意：</p>
<ul>
<li>username和email即github的登陆帐号和注册邮箱</li>
<li>git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置</li>
</ul>
<h5 id="检查下自己之前有没有已经生成ssh"><a href="#检查下自己之前有没有已经生成ssh" class="headerlink" title="检查下自己之前有没有已经生成ssh"></a>检查下自己之前有没有已经生成ssh</h5><blockquote>
<p>　　<strong>cd ~/.ssh</strong></p>
</blockquote>
<p>　　证明有ssh存在</p>
<p><img src="https://img2018.cnblogs.com/blog/1691475/201910/1691475-20191017221620652-8123436.png" alt="img"></p>
<p> 　当cd ~/.ssh命令执行后窗口返回“no such file or directory”的时候，表示我们的电脑并没有ssh key，所以需要我们创建ssh ke</p>
<blockquote>
<p>　<strong>ssh-keygen -t rsa -C “<a href="mailto:xxx@xx.com">xxx@xx.com</a>“</strong>  –创建.ssm文件，如果没有这个文件执行即可，接着按三个回车即可。　</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：如果本地有ssh，执行以上命令会出现正面的提示，这里选择y，表示覆盖本地的ssh key，其实也就是ssh秘钥删除的意思</span><br></pre></td></tr></table></figure>



<p>执行命令完成后,默认会在window的C:\Users\Administrator.ssh下面生成如下两个名称的文件:</p>
<p>   C:\Users\Administrator.ssh</p>
<p>​    id_rsa(私钥，不能泄露出去)</p>
<p>​    id_rsa.pub(公钥)</p>
<p>​    known_hosts(不用管)</p>
<p><img src="https://img2018.cnblogs.com/blog/1691475/201910/1691475-20191017222436228-327194399.png" alt="img"></p>
<h3 id="https-和-SSH-的区别"><a href="#https-和-SSH-的区别" class="headerlink" title="https 和 SSH 的区别"></a>https 和 SSH 的区别</h3><blockquote>
<p>1.前者可以随意克隆github上的项目，而不管是谁的；</p>
<p>　　而后者则是你必须是你要克隆的项目的拥有者或管理员，需要先添加 SSH key ，否则无法克隆。</p>
<p>2.https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的；</p>
<p>　　如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。</p>
</blockquote>
<h3 id="Git-Gui生成SSH-Key"><a href="#Git-Gui生成SSH-Key" class="headerlink" title="Git Gui生成SSH Key"></a>Git Gui生成SSH Key</h3><h4 id="打开Git-Gui-选择【help】，点击【Show-SSH-KEY】"><a href="#打开Git-Gui-选择【help】，点击【Show-SSH-KEY】" class="headerlink" title="打开Git Gui, 选择【help】，点击【Show SSH KEY】"></a>打开Git Gui, 选择【help】，点击【Show SSH KEY】</h4><p><img src="https://img-blog.csdn.net/20171213173841712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="由于之前没有配置过SSH-KEY，此时会显示没有任何SSH-公钥"><a href="#由于之前没有配置过SSH-KEY，此时会显示没有任何SSH-公钥" class="headerlink" title="由于之前没有配置过SSH KEY，此时会显示没有任何SSH 公钥"></a>由于之前没有配置过SSH KEY，此时会显示没有任何SSH 公钥</h4><p><img src="https://img-blog.csdn.net/20171213173922842?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="点击右上角【Generate-key】，此时会弹出一个界面，要求你输入passphrase"><a href="#点击右上角【Generate-key】，此时会弹出一个界面，要求你输入passphrase" class="headerlink" title="点击右上角【Generate key】，此时会弹出一个界面，要求你输入passphrase"></a>点击右上角【Generate key】，此时会弹出一个界面，要求你输入passphrase</h4><p><img src="https://img-blog.csdn.net/20171213174146021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="然后再次确认输入passpahrase"><a href="#然后再次确认输入passpahrase" class="headerlink" title="然后再次确认输入passpahrase ."></a>然后再次确认输入passpahrase .</h4><h4 id="此时就会生成一个SSH-Key"><a href="#此时就会生成一个SSH-Key" class="headerlink" title="此时就会生成一个SSH Key"></a>此时就会生成一个SSH Key</h4><p><img src="https://img-blog.csdn.net/20171213174304458?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="如果以后需要查看SSH-Key。此时可以在Git-Gui界面上点击【help】-》【Show-SSH-KEY】，查看此次生成的SSH-Key。"><a href="#如果以后需要查看SSH-Key。此时可以在Git-Gui界面上点击【help】-》【Show-SSH-KEY】，查看此次生成的SSH-Key。" class="headerlink" title="如果以后需要查看SSH Key。此时可以在Git Gui界面上点击【help】-》【Show SSH KEY】，查看此次生成的SSH Key。"></a>如果以后需要查看SSH Key。此时可以在Git Gui界面上点击【help】-》【Show SSH KEY】，查看此次生成的SSH Key。</h4><p><img src="https://img-blog.csdn.net/20171213174406094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9iYnlfZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="TortoiseGit生成SSH-Key"><a href="#TortoiseGit生成SSH-Key" class="headerlink" title="TortoiseGit生成SSH Key"></a>TortoiseGit生成SSH Key</h3><p>1）运行PuTTYGen，在Conversions菜单中点击Import key，选择ssh-keygen生成的私钥文件所在位置，比如id_rsa文件。</p>
<p>2）点击Save private key按钮，将其保存为.ppk文件。</p>
<p>3）打开Pageant，点击Add Key，选择前一步所保存的.ppk文件所在的位置即可。</p>
<p><a href="https://www.cnblogs.com/sumuncle/p/7675921.html" target="_blank" rel="noopener">参考文章</a></p>
</ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op></ignore_js_op>]]></content>
      <categories>
        <category>gitExtensions</category>
      </categories>
      <tags>
        <tag>gitExtensions</tag>
        <tag>git</tag>
        <tag>kdiff3</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令合集</title>
    <url>/2020/07/30/git%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq 保存提交信息</span><br><span class="line">q 退出</span><br><span class="line"></span><br><span class="line">git branch dali 创建分支</span><br><span class="line">git branch 或者git branch --list查看分支</span><br><span class="line">git branch -a 查看当前所在分支 </span><br><span class="line">git branch -r 查看远程分支</span><br><span class="line">git branch -m dali dali01 重命名成dali01</span><br><span class="line">git branch -d dali01 删除分支dali01</span><br><span class="line">git checkout dali 切换分支</span><br><span class="line"></span><br><span class="line">git push -u origin master 将本地推送到远程</span><br><span class="line">git clone https:&#x2F;&#x2F;git 新名字</span><br><span class="line">git fetch 提取远程代码</span><br><span class="line"></span><br><span class="line">git merge dali 将dali分支合到本地分支 </span><br><span class="line">git fast-forward 出现代表快速合并，本地没有任何提交，会直接合并</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;git 添加远程库</span><br><span class="line">git remote 查看远程库</span><br><span class="line">git remote -v更详细的远程库</span><br><span class="line"></span><br><span class="line">git 或者 git help --查看帮助</span><br><span class="line">git help -a --查看所有命令</span><br><span class="line">git help -g --查看所有手册</span><br><span class="line">git help add --加上命令或名称，查看详细内容 （F键向下，B键向上翻页，Q键退出）</span><br><span class="line"></span><br><span class="line">git config --global user.name &#39;dali&#39; 设置用户名</span><br><span class="line">git config --global user.email &#39;dali.com&#39;设置邮箱</span><br><span class="line">git config --List 查看用户信息</span><br><span class="line">git config --unset --global user.name 清空用户名</span><br><span class="line">git config color.ui true 设置颜色</span><br><span class="line">git config --global alias.co checkout 给checkout起一个co的别名</span><br><span class="line">cat &#96;&#x2F;.gitconfig 查看当前用户的配置</span><br><span class="line"></span><br><span class="line">git init 初始化git</span><br><span class="line">git status 查看分支什么的</span><br><span class="line"></span><br><span class="line">git add . 添加所有文件到暂存区</span><br><span class="line">git add &#39;index.html&#39; 添加具体文件到暂存区</span><br><span class="line">git commit -m &#39;新建index.html文件&#39;</span><br><span class="line">git commit -am &#39;省略add，直接commit&#39;</span><br><span class="line"></span><br><span class="line">git diff 查看前后对比</span><br><span class="line">git diff --staged 查看暂存区和git上的区别</span><br><span class="line"></span><br><span class="line">git mv style.css  theme.css   将style重命名成theme</span><br><span class="line">git mv theme.css css&#x2F;    将theme.css移动到css文件夹下</span><br><span class="line">git mv css asset&#x2F;    将css移动到asset文件夹下</span><br><span class="line"></span><br><span class="line">git rm theme.css 删除theme.css文件</span><br><span class="line">git rm theme.css style.css文件（多个文件以空格分离）</span><br><span class="line">git rm -r 我的文件夹&#x2F; （删除目录以及所有内容 加上 -r  和目录的名称 表示递归）</span><br><span class="line"></span><br><span class="line">git checkout HEAD  -- index.html 恢复上一次修改</span><br><span class="line">git checkout HEAD^  -- index.html 恢复上一次提交</span><br><span class="line">git revert (提交id) --撤销某一次提交</span><br><span class="line"></span><br><span class="line">其中HEAD代表版本库，index代表暂存区，另外还有一个我们增删改代码的工作区。</span><br><span class="line">--hard : 回退版本库，暂存区，工作区。（因此我们修改过的代码就没了，需要谨慎使用）</span><br><span class="line">--mixed: 回退版本库，暂存区。(--mixed为git reset的默认参数，即当任何参数都不加的时候的参数)</span><br><span class="line">--soft: 回退版本库。</span><br><span class="line">只commit 没有push</span><br><span class="line">git reset --soft （提交id）--撤销commit，工作区代码本地更改留存</span><br><span class="line">git reset --hard（提交id）--慎用 撤销commit，工作区代码本地更改不留存</span><br><span class="line">git reset --mixed（提交id）--版本库和暂存区都将进行了代码回退，工作区代码没动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git diff master..dali 查看两个分支的不同</span><br><span class="line">git diff master..dali index.html 具体文件的不同</span><br><span class="line"></span><br><span class="line">abort 放弃合并</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt; HEAD和&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;之间是本地的代码</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 和&gt;&gt;&gt;&gt;&gt;之间是远程的代码</span><br><span class="line"></span><br><span class="line">git log --oneline --decorate --all -10 --graph --atuhor&#x3D;&#39;dali&#39;  --grep&#x3D;&#39;index.html&#39; --before&#x3D;’2020-20-02‘ </span><br><span class="line">--before&#x3D;&#39;1 week&#39; --before&#x3D;&#39;3 days&#39; 提交日志</span><br><span class="line"> --oneline一行显示</span><br><span class="line"> decorate 查看具体分支</span><br><span class="line"> --all -10前十条</span><br><span class="line"> --graph 图形化</span><br><span class="line"> --atuhor作者</span><br><span class="line"> --grep包含 </span><br><span class="line">--before某个日期之前的，一周内，三天内的提交 </span><br><span class="line"></span><br><span class="line">stash 保存修改&#x2F;工作进度</span><br><span class="line">git stash save &#39;增加一条工作进度&#39;</span><br><span class="line">git stash list 保存工作进度的列表</span><br><span class="line">git stash apply stash@&#123;0&#125;恢复工作进度</span><br><span class="line">git stash drop stash@&#123;0&#125;删除工作进度</span><br><span class="line">git stash show -p stash@&#123;0&#125;显示区别（-p是指 以patch form的的方式展示diff）</span><br></pre></td></tr></table></figure>

<p>补充链接 <a href="https://mp.weixin.qq.com/s/-DjGBDi7HQfVpGNY8sOCmw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-DjGBDi7HQfVpGNY8sOCmw</a></p>
<p>​                <a href="https://mp.weixin.qq.com/s/4vfifX-UkhrfpZjHycthOA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4vfifX-UkhrfpZjHycthOA</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>google</title>
    <url>/2020/07/22/google/</url>
    <content><![CDATA[<h3 id="你不知道的隐藏快捷方式"><a href="#你不知道的隐藏快捷方式" class="headerlink" title="你不知道的隐藏快捷方式"></a>你不知道的隐藏快捷方式</h3><h4 id="曾经，在线调伪类样式困扰过你？"><a href="#曾经，在线调伪类样式困扰过你？" class="headerlink" title="曾经，在线调伪类样式困扰过你？"></a>曾经，在线调伪类样式困扰过你？</h4><p><img src="/2020/07/22/google/640.webp" alt="640"></p>
<a id="more"></a>



<h4 id="联调接口失败时，后台老哥总管你要response？"><a href="#联调接口失败时，后台老哥总管你要response？" class="headerlink" title="联调接口失败时，后台老哥总管你要response？"></a>联调接口失败时，后台老哥总管你要response？</h4><p>![640 (1)](google.assets/640 (1).gif)</p>
<h4 id="你还一层层展开dom？Alt-Click"><a href="#你还一层层展开dom？Alt-Click" class="headerlink" title="你还一层层展开dom？Alt + Click"></a>你还一层层展开dom？Alt + Click</h4><p>![640 (2)](google.assets/640 (2).gif)</p>
<h4 id="是不是报错了，你才去打断点？"><a href="#是不是报错了，你才去打断点？" class="headerlink" title="是不是报错了，你才去打断点？"></a>是不是报错了，你才去打断点？</h4><p>![640 (3)](google.assets/640 (3).gif)</p>
<h4 id="你是不是经常想不起来，在哪绑定事件的？"><a href="#你是不是经常想不起来，在哪绑定事件的？" class="headerlink" title="你是不是经常想不起来，在哪绑定事件的？"></a>你是不是经常想不起来，在哪绑定事件的？</h4><p>![640 (4)](google.assets/640 (4).gif)</p>
<h4 id="你是不是打断点时还要去改代码？"><a href="#你是不是打断点时还要去改代码？" class="headerlink" title="你是不是打断点时还要去改代码？"></a>你是不是打断点时还要去改代码？</h4><p>![640 (5)](google.assets/640 (5).gif)</p>
<h4 id="看dom层级的最直观的方式？"><a href="#看dom层级的最直观的方式？" class="headerlink" title="看dom层级的最直观的方式？"></a>看dom层级的最直观的方式？</h4><p>![640 (6)](google.assets/640 (6).gif)</p>
<h4 id="查一些特定的请求，过滤器Filter用过吗？"><a href="#查一些特定的请求，过滤器Filter用过吗？" class="headerlink" title="查一些特定的请求，过滤器Filter用过吗？"></a>查一些特定的请求，过滤器Filter用过吗？</h4><p>![640 (7)](google.assets/640 (7).gif)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">domain：资源所在的域，即url中的域名部分。如 domain:api.github.com</span><br><span class="line"></span><br><span class="line">has-response-header：资源是否存在响应头，无论其值是什么。如 has-response-header：Access-Control-Allow-Origin</span><br><span class="line"></span><br><span class="line">is：当前时间点在执行的请求。当前可用值：running</span><br><span class="line"></span><br><span class="line">larger-than：显示大于指定值大小规格的资源。单位是字节(B),但是K(kB)和M(MB)也是可以的~ 如larger-than:150K</span><br><span class="line"></span><br><span class="line">method：使用何种HTTP请求方式。如 GET</span><br><span class="line"></span><br><span class="line">mime-type：也写作content-type，是资源类型的标识符。如 text&#x2F;html</span><br><span class="line"></span><br><span class="line">scheme：协议规定。如 HTTPS</span><br><span class="line"></span><br><span class="line">set-cookie-name：服务器设置的cookies名称</span><br><span class="line"></span><br><span class="line">set-cookie-value：服务器设置的cookies的值</span><br><span class="line"></span><br><span class="line">set-cookie-domain：服务器设置的cookies的域</span><br><span class="line"></span><br><span class="line">status-code：HTTP响应头的状态码</span><br></pre></td></tr></table></figure>



<h4 id="在Elements面板调整dom结构很不方便？"><a href="#在Elements面板调整dom结构很不方便？" class="headerlink" title="在Elements面板调整dom结构很不方便？"></a>在Elements面板调整dom结构很不方便？</h4><p>![640 (8)](google.assets/640 (8).gif)</p>
<h4 id="想知道，某图片加载的代码在哪？Initiator！！"><a href="#想知道，某图片加载的代码在哪？Initiator！！" class="headerlink" title="想知道，某图片加载的代码在哪？Initiator！！"></a>想知道，某图片加载的代码在哪？Initiator！！</h4><p>![640 (1)](google.assets/640 (1).webp)</p>
<p>![640 (2)](google.assets/640 (2).webp)</p>
<p>![640 (3)](google.assets/640 (3)-1600053530223.webp)</p>
<h4 id="不想加载某个文件了？"><a href="#不想加载某个文件了？" class="headerlink" title="不想加载某个文件了？"></a>不想加载某个文件了？</h4><p>![640 (4)](google.assets/640 (4).webp)</p>
<p>![640 (5)](google.assets/640 (5).webp)</p>
<h4 id="滚动元素到视图"><a href="#滚动元素到视图" class="headerlink" title="滚动元素到视图"></a>滚动元素到视图</h4><p>在调试<code>DOM</code>元素的时候，我们已经聚焦到相关的<code>DOM</code>结构上了，但是对应的元素并没有在可视窗口上展示，那么我们可以将其快速滚动到可视窗口。</p>
<blockquote>
<p>控制面板 =&gt; Elements =&gt; 右击选中的DOM节点 =&gt; Scroll into view</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjdvicoInLic0fkZNNmrMfCaKd1N4iabxpBib5czRDYEk8SsGPIHJVjMzMc6g/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片">scroll</p>
<h4 id="预设移动端设备"><a href="#预设移动端设备" class="headerlink" title="预设移动端设备"></a>预设移动端设备</h4><p>在进行调试的时候，我们手头上没有那么多设备。特别是开发移动端的<strong>猿儿</strong>，在没有充足调试机的情况下，我们就靠调试工具进行模拟。那么，除了谷歌浏览器默认设备的几个值，比如<code>iPhone X, iPad</code>。我们还可以自定义自己需要的设备。</p>
<blockquote>
<p>控制面板 =&gt; setting图标 =&gt; Devices =&gt; Add custom device…</p>
</blockquote>
<p>我们添加一个一个尺寸为<strong>300 * 800</strong>且<code>DPR</code>为<strong>3</strong>的设备。<img src="https://mmbiz.qpic.cn/mmbiz_gif/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjdtEJwjg2rj8dn9iatvMVJE3ctiawFgbDnNy0RN0GNQJ8SFhUsfNM0PYiaQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片">)之后，在调试设备的时候，我们可以选择预设设备进行预览～<img src="https://mmbiz.qpic.cn/mmbiz_gif/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjdTzyOSicXZ1GUotLtMxkghkLvRI58ddGLj8VqLibDv655xemwJ1cHEjJw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h4 id="预设网络状况"><a href="#预设网络状况" class="headerlink" title="预设网络状况"></a>预设网络状况</h4><p>我们不能把控用户使用我们产品的网络下载速度，所以我们得模拟不同网速下面的产品表现情况，以检查我们对产品的优化是否符合预期效果。同理，我们也可以自定义网络的状况，一般情况下默认是<code>online</code>。</p>
<blockquote>
<p>控制面板 =&gt; setting图标 =&gt; Throttling =&gt; Add custom profile…</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjdtibwdmYRnlRjOGyKD26zz889ibr1g0dandPMzTkb2P7HgRDj7uhXZ1Zw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片">custom_network</p>
<h4 id="捕获快照"><a href="#捕获快照" class="headerlink" title="捕获快照"></a>捕获快照</h4><p><code>communication</code>省心省力的原则之一是：<strong>图文并茂地沟通</strong>。在跟上下流的人员进行沟通的时候，推敲产品的途中，少不了对一个产品的截图。作为一个开发者，你还在使用截图工具或聊天工具进行操作？我们有更加方便的方案～</p>
<blockquote>
<p>控制面板 =&gt; command + shift + p =&gt; capture full size screenshot</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjdxbRzqeWlCcptJ1JXArNXf0gECXv653DH6mW35z8TCEY90klauia7qmA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片">![图片](<a href="https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH47" target="_blank" rel="noopener">https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH47</a></p>
<h4 id="捕获局部快照"><a href="#捕获局部快照" class="headerlink" title="捕获局部快照"></a>捕获局部快照</h4><blockquote>
<p>控制面板 =&gt; 审查元素 =&gt; command + shift + p =&gt; capture node screenshot</p>
</blockquote>
<p>我选择掘金个人资料的<strong>头像部分</strong>进行截取示范～<img src="https://mmbiz.qpic.cn/mmbiz_gif/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjdEiacCSrI53ygTia3KkZZBlcgHrK0GBX9oBd2eibOE1qI5eqGedxm42Gxw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片">正确操作后，截取到的就是目标审核元素，</p>
<h4 id="快速清空站点缓存"><a href="#快速清空站点缓存" class="headerlink" title="快速清空站点缓存"></a>快速清空站点缓存</h4><p>有时候开发调试，我们需要清空缓存信息。与其手动一个个信息清空，还不如一步到位，直接清空这个站点的信息 💨</p>
<blockquote>
<p>控制面板 =&gt; command + shift + p =&gt; clear site data</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjddlHtQTXOlCVBjAROYxkg5NrjLYj5flg2tZ0icbnHdaLtfslpIN4N1LQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片">嗯～就此打住吧，写了不少了～等等，才<strong>八个技巧</strong>而已么，得加一条 🐱<strong>Because NINE is my lucky number.</strong><img src="https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjdvFqzWujr8o3YoNZ8IoCmN7QjOblLsyuwc6cUJbsQOkkpMK7I1Ssg4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="更改调试面板主题"><a href="#更改调试面板主题" class="headerlink" title="更改调试面板主题"></a>更改调试面板主题</h4><p>在开发调试中，默认主题难免让眼睛审美疲劳。而且，作为一个开发者，要高冷，高冷，高冷…暗黑色调妥妥的。通过下面的操作，你可以选择适合自己的风格。</p>
<blockquote>
<p>控制面板 =&gt; setting设置图标 =&gt; Preferences =&gt; Appearance =&gt; Theme</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/j3vcKBBdH47Sb5hqjfon4bFmrcb2AZjdWcDoCHSFXkYYN2v0LK9JLoMibvgXZCsdyqxSUjA4QWHNjm9WmgO31Cg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h4 id="手动改定位信息"><a href="#手动改定位信息" class="headerlink" title="手动改定位信息"></a>手动改定位信息</h4><p>Chrome中模拟定位信息，清除定位信息</p>
<p>chrome  F12进入调试模式后，点击右上角的 三个点的标志，如下图</p>
<p><img src="/2020/07/22/google/image-20200914112312655.png" alt="image-20200914112312655"></p>
<p>将其Geolocation中的下拉更改为Custom Location（或者直接选择other），在下方填入经纬度信息即可模拟当前位置；</p>
<p>如果要清除位置信息，需将Geolocation修改为No override，并且关闭浏览器，重启启动后才会生效，</p>
<p>切记重启浏览器，否则你可以在调试时看到你传入的经纬度信息依旧是你之前设置的数据，</p>
<p>如果再没有生效，可将浏览器数据清除重试</p>
<h4 id="浏览器复制console-log打印的对象"><a href="#浏览器复制console-log打印的对象" class="headerlink" title="浏览器复制console.log打印的对象"></a>浏览器复制console.log打印的对象</h4><p>找到想要复制的对象右键 <strong>store as global variable</strong><br><img src="https://img-blog.csdnimg.cn/20190516212308883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUxOTEzNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在弹出的console中copy temp1</p>
<p>ctrl+v出来咯~</p>
<p><img src="https://img-blog.csdnimg.cn/20190516212358116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUxOTEzNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><blockquote>
<p>json-handle</p>
<p>postwoman</p>
</blockquote>
<h4 id="清空控制台"><a href="#清空控制台" class="headerlink" title="清空控制台"></a>清空控制台</h4><p> console.clear</p>
<h4 id="t参数支持换行"><a href="#t参数支持换行" class="headerlink" title="\t参数支持换行"></a>\t参数支持换行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(JSON.stringify(&#123; alpha: &#39;A&#39;, beta: &#39;B&#39; &#125;, null, &#39;\t&#39;));</span><br><span class="line">&#x2F;&#x2F; Result:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;alpha&quot;: &quot;A&quot;,</span><br><span class="line">	&quot;beta&quot;: &quot;B&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="追加："><a href="#追加：" class="headerlink" title="追加："></a>追加：</h4><p>8个Chrome面板内容</p>
<p><a href="https://mp.weixin.qq.com/s/-1jf4c7bYhbn-zKVr74hrw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-1jf4c7bYhbn-zKVr74hrw</a></p>
<p>最详细的解释</p>
<p><a href="https://blog.csdn.net/weixin_40876986/article/details/89703977" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40876986/article/details/89703977</a></p>
]]></content>
      <categories>
        <category>soft</category>
        <category>google</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp及gulpfile.js</title>
    <url>/2020/07/30/gulp%E5%8F%8Agulpfile-js/</url>
    <content><![CDATA[<h3 id="一、什么是gulp"><a href="#一、什么是gulp" class="headerlink" title="一、什么是gulp"></a>一、什么是gulp</h3><p>简单来说：就是压缩前端代码，实现浏览器自动刷新的工具。</p>
<p>完整地说：gulp是一个前端的自动化构建工具，是基于Node.js的自动化任务运行期，能自动化完成javascript/sass/less/html/image/css等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成、并监听文件在改动后重复指定（在gulpfile.js中指定）的这些步骤。</p>
<a id="more"></a>

<h3 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h3><p><strong>1、全局安装</strong></p>
<p><strong>（1）安装NodeJS环境：（这里直接使用淘宝镜像）</strong></p>
<p>在cmd中输入：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<p>然后就开始下载安装，如下图:</p>
<p><img src="https://img-blog.csdn.net/20180820093107903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1hoaXVfaHVhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>（2）全局安装gulp：</strong></p>
<p>上一步安装结束后，再在cmd下接着输入（这里cnpm也可换成npm，cnpm是在淘宝镜像下载，npm是在国外官网下载，实际上两者相同，这里就看心情选择吧^^）：cnpm install gulp -g</p>
<p><img src="https://img-blog.csdn.net/20180820093141838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1hoaXVfaHVhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>2、局部安装：</strong></p>
<p><strong>（1）在项目中生成package.json文件：</strong></p>
<p>全局安装完成后，开始局部安装。首先，选择一个文件夹，这个文件夹就是你项目的最外层文件夹，在这个文件夹下打开cmd（比如我自己来说，有一个项目名为a，那我就在a下的文件夹里边打开cmd）。</p>
<p><img src="https://img-blog.csdn.net/20180820093609888?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1hoaXVfaHVhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p> 在上图所示的cmd中输入：cnpm init -y，等待下载安装</p>
<p><strong>（2）在项目本地安装gulp：</strong></p>
<p>上一步安装完成后，接着输入：cnpm install gulp –sava-dev</p>
<p><strong>（3）安装gulp插件：</strong></p>
<p><strong>插件介绍：</strong>gulp-clean-css（压缩css的插件）、gulp-htmlmin（压缩html的插件）、gulp-uglify（压缩js）、gulp-babel（将es6转换成es5）、gulp-rename（重命名）、gulp-connect（部署静态资源，实现自动刷新）。。。还有很多，可在<a href="https://www.npmjs.com/package中搜索插件" target="_blank" rel="noopener">https://www.npmjs.com/package中搜索插件</a></p>
<p><strong>安装插件：</strong>（2）下载安装完成后，继续输入：cnpm i 插件名 -D）（比如：cnpm i gulp-clean-css -D），等待下载安装</p>
<p><strong>（4）在项目根目录下，创建gulpfile.js，在里面书写代码，用于操控插件：</strong>书写内容详情见 三 。</p>
<p><strong>（5）执行任务：</strong>（3）安装完成并（4）中的gulpfile.js编写完成后，接着在cmd中输入：gulp 任务名称</p>
<h3 id="三、gulpfile-js编写："><a href="#三、gulpfile-js编写：" class="headerlink" title="三、gulpfile.js编写："></a>三、gulpfile.js编写：</h3><blockquote>
<p>//定义变量，引入gulp及各个插件</p>
<p>const gulp = require(“gulp”),<br>​    sass = require(“gulp-sass”),<br>​    connect = require(“gulp-connect”),<br>​    uglify = require(“gulp-uglify”),<br>​    babel = require(“gulp-babel”),<br>​    htmlmin = require(“gulp-htmlmin”);</p>
<p>// 编译SCSS文件<br>gulp.task(“sass”, function() {<br>​    gulp.src(“./src/scss/<em>.scss”)<br>​        .pipe(sass({outputStyle:”compressed”}))<br>​        .pipe(gulp.dest(“./src/css”))<br>​        .pipe(connect.reload());<br>});<br>// html文件修改刷新<br>gulp.task(“html”, function() {<br>​    gulp.src(“./src/**/</em>.html”)<br>​        .pipe(connect.reload());<br>});<br>// js文件修改刷新<br>gulp.task(“js”, function() {<br>​    gulp.src(“./src/js/<em>.js”)<br>​        .pipe(connect.reload());<br>});<br>// 启动服务器<br>gulp.task(“connect”, function() {<br>​    connect.server({<br>​        root : “src”,<br>​        livereload : true<br>​    });<br>});<br>// 监视任务<br>gulp.task(“watch”, function(){<br>​    gulp.watch(“./src/**/</em>.html”, [“html”]);<br>​    gulp.watch(“./src/js/<em>.js”, [“js”]);<br>​    gulp.watch(“./src/scss/</em>.scss”, [“sass”]);<br>});<br>// 开发环境下的gulp任务<br>gulp.task(“dev”, [“sass”, “html”, “js”, “connect”, “watch”]);</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>// 生产环境下的 gulp 任务，将项目生成到 dist 目录下<br>// dist 目录下的资源是直接用于生产环境（发布项目）的资源<br>// 编译SCSS文件：生产环境<br>gulp.task(“prod_sass”, function() {<br>​    gulp.src(“./src/scss/<em>.scss”)<br>​        .pipe(sass({outputStyle:”compressed”}))<br>​        .pipe(gulp.dest(“./dist/css”))<br>​        .pipe(connect.reload());<br>});<br>// html文件压缩<br>gulp.task(“prod_html”, function() {<br>​    gulp.src(“./src/**/</em>.html”)<br>​        .pipe(htmlmin({collapseWhitespace: true}))<br>​        .pipe(gulp.dest(“./dist”))<br>​        .pipe(connect.reload());<br>});<br>// JS转换及压缩<br>gulp.task(“prod_js”, function() {<br>​    gulp.src(“./src/js/<em>.js”)<br>​        .pipe(babel({<br>​            presets: [‘env’]<br>​        }))<br>​        .pipe(uglify())<br>​        .pipe(gulp.dest(“./dist/js”))<br>​        .pipe(connect.reload());<br>});<br>// 复制源文件夹下资源到目标文件夹<br>gulp.task(“copy-images”, function() {<br>​    gulp.src(“./src/images/**/</em>.*”)<br>​        .pipe(gulp.dest(“./dist/images”));<br>});<br>gulp.task(“copy-lib”, function() {<br>​    gulp.src(“./src/lib/<strong>/<em>.</em>“)<br>​        .pipe(gulp.dest(“./dist/lib”));<br>});<br>gulp.task(“prod_copy”, [“copy-images”, “copy-lib”]);<br>// 监视任务<br>gulp.task(“prod_watch”, function(){<br>​    gulp.watch(“./src/</strong>/<em>.html”, [“prod_html”]);<br>​    gulp.watch(“./src/js/</em>.js”, [“prod_js”]);<br>​    gulp.watch(“./src/scss/*.scss”, [“prod_sass”]);<br>});<br>// 启动服务器<br>gulp.task(“prod_connect”, function() {<br>​    connect.server({<br>​        root : “dist”,<br>​        livereload : true<br>​    });<br>});<br>// 生产环境gulp任务<br>gulp.task(“production”, [“prod_sass”, “prod_html”, “prod_js”, “prod_copy”, “prod_connect”, “prod_watch”]);</p>
</blockquote>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>前端自动化压缩</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git之错误分支开发的三种情况</title>
    <url>/2020/09/16/git%E4%B9%8B%E9%94%99%E8%AF%AF%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h3 id="还没有commit"><a href="#还没有commit" class="headerlink" title="还没有commit"></a>还没有commit</h3><p>在这种情况下我们可以在当前分支下使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<p>这个命令表示<strong>把我们当前修改的内容暂存起来，然后我们的工作区就恢复到在没有开发新功能之前的样子。</strong></p>
<p>这个时候我们需要切换到正确的工作分支，然后运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="已经在commit了，但是还没有push到远程仓库"><a href="#已经在commit了，但是还没有push到远程仓库" class="headerlink" title="已经在commit了，但是还没有push到远程仓库"></a>已经在commit了，但是还没有<code>push</code>到远程仓库</h3><h4 id="新的功能需要添加在一个新的分支"><a href="#新的功能需要添加在一个新的分支" class="headerlink" title="新的功能需要添加在一个新的分支"></a>新的功能需要添加在一个新的分支</h4><p>首先我们需要知道在我们添加新功能之前，当前分支处于哪一个提交。可以运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>

<p>查看当前分支的提交，可以看到有以下内容的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">085095f (HEAD -&gt; master) update 5</span><br><span class="line">47e52ae update 3</span><br><span class="line">14fefac update 2</span><br><span class="line">fd01444 add README.md</span><br><span class="line">3c76ad1 init</span><br></pre></td></tr></table></figure>

<p>找到我们添加新功能时，当前分支所处的提交。假如是<code>fd01444</code>，那么我们接下来要做的操作就是将<code>HEAD</code>指针指向<code>fd01444</code>，也就是把我们当前分支已提交的内容重置到我们开发新功能之前的样子。我们需要运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset fd01444 # fd01444是某次提交的hash值</span><br></pre></td></tr></table></figure>

<p>如果没有指明重置的模式的话，默认会使用<code>--mixed</code>模式，这样的话我们在<code>fd01444</code>这次提交之后的所有提交都会被重置为没有提交的状态。接下来我们需要把这些新开发的功能迁移到一个新的分支。这时候我们可以使用下面的命令进行操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;newbranch&gt;</span><br></pre></td></tr></table></figure>

<p>这样我们就创建了一个新的分支，并且把新添加的功能也都迁移了过去，接下来就是常规的添加和提交操作了。</p>
<h4 id="新功能需要添加在另一个分支上"><a href="#新功能需要添加在另一个分支上" class="headerlink" title="新功能需要添加在另一个分支上"></a>新功能需要添加在另一个分支上</h4><p>如果我们需要把当前添加的新功能迁移到另一个已经存在的分支，那么我们需要做的前几个步骤跟上面的操作是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline # 查找新功能开发之前的提交</span><br><span class="line">git reset &lt;commit hash&gt; # 将当前分支重置到新功能开发之前的提交</span><br></pre></td></tr></table></figure>

<p>接下来我们现在的状态就回到了<strong>新功能还没有提交的状态</strong>，那么就可以继续使用<code>git stash</code>相关的命令去操作了。</p>
<p>我们还有另外一个方法也能够将已提交到当前分支的功能添加到另一个分支上，那就是使用<code>git cherry-pick</code>命令。首先我们还是先用<code>git log --oneline</code>查找当前已提交的功能的hash值，然后切换到目标分支，运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commit hash&gt;</span><br></pre></td></tr></table></figure>

<p>这样就把我们在另一个分支开发的功能，添加到我们想要的分支了。如果有冲突的话，需要手动处理一下冲突。然后我们回到最初的分支，再次运行<code>git reset &lt;commit hash&gt;</code>命令，把已提交的内容进行重置，然后运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- .</span><br></pre></td></tr></table></figure>



<h2 id="新功能已经commit了，且push到了远程仓库"><a href="#新功能已经commit了，且push到了远程仓库" class="headerlink" title="新功能已经commit了，且push到了远程仓库"></a>新功能已经commit了，且<code>push</code>到了远程仓库</h2><p>第三种情况就是，我们已经把新开发的功能<code>push</code>到远程的仓库了，但是我们忽然发现新功能不应该在这个分支开发，我们这个时候应该怎么办呢？</p>
<p><strong>首先我们应该保持当前的工作区是没有修改的，是一个干净的状态。不然使用撤销命令的时候会提示你需要把当前的文件内容变更先提交或者生成快照</strong>。当我们的工作区的状态是干净的时候，我们就可以进行撤销操作了。</p>
<p>首先需要知道我们应该撤销那一次提交的状态。使用<code>git log --oneline</code>查看要撤销的提交的索引，然后运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p>这个时候命令运行的终端会进入编辑器模式，让你填写提交的信息。当然你也可以使用参数<code>--no-edit</code>这样就不会在进行撤销操作的时候打开编辑模式了。</p>
<p><strong>如果需要撤销的提交比较多的话，我们可以使用<code>..</code>表示一个提交记录的范围。比如<code>c1..c2</code>就表示<code>c2</code>的可达提交，且排除<code>c1</code>的可达提交</strong>。所谓<strong>可达的提交</strong>指的是：<strong>提交本身及其祖先链中提交的集合</strong>。</p>
<p>我们可以举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... a - b - c - d - HEAD</span><br></pre></td></tr></table></figure>

<p>如果上面表示的是某个分支的提交记录，那么对于<code>b..d</code>表示的就是<code>c d</code>这两个提交，对于<code>a..d</code>表示的就是<code>b c d</code>这三个提交。如果大家想了解更多相关的内容，可以在git-rev-list这里深入的学习一下。</p>
<p>所以我们如果想快速的撤销一段范围的提交的话，可以运行类似下面这样的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert 54dc134..a72d612 --no-edit</span><br></pre></td></tr></table></figure>

<p>上述命令的<code>54dc134</code>就表示<code>c1</code>，<code>a72d612</code>就表示<code>c2</code>，<code>--no-edit</code>表明我们在运行撤销操作的时候不打开编辑模式。</p>
<p><strong>我们如果需要对远程的分支进行撤销的话，首先考虑的就是使用<code>git revert</code>命令，因为<code>git revert</code>命令不会修改历史的提交记录，只是在原来的提交基础上添加新的提交，所以不会造成代码的丢失。在多人合作的情况下使用<code>git revert</code>命令撤销<code>push</code>到远程的操作还是很有必要的。</strong></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>错误分支</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoQuest</title>
    <url>/2020/07/15/hexoQuest/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>hexo开发过程中遇到的小坑大坑各种坑合集</p>
<p>部署失败时（deploy处将https改为SSH）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repository: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repository：git@github.com:username&#x2F;username.github.io.git</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="（1）检查是否有SSH-key"><a href="#（1）检查是否有SSH-key" class="headerlink" title="（1）检查是否有SSH key"></a>（1）检查是否有SSH key</h4><p>登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接跳到第（3）步；如果没有，则继续。</p>
<h4 id="（2）新建-SSH-key，在git-shell-或者git-bash等命令窗口-，注意大小写："><a href="#（2）新建-SSH-key，在git-shell-或者git-bash等命令窗口-，注意大小写：" class="headerlink" title="（2）新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写："></a>（2）新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮箱名&quot;</span><br></pre></td></tr></table></figure>

<p>然后会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;dell&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>

<p>直接回车就可以。<br>然后会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p>要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>
<p>注意：输入密码的时候没有*字样的，直接输入就好。<br>然后会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;dell&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;dell&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">65:69:······02:4b emailname@email.com</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|       .   o .   |</span><br><span class="line">|    . o o &#x3D; o    |</span><br><span class="line">|   . o * &#x3D; o     |</span><br><span class="line">|  E  o + o .     |</span><br><span class="line">| . o.   . .      |</span><br><span class="line">|     ..          |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<p>至此，密钥已经成功生成。</p>
<h4 id="（3）接下来在github上添加SSH-key："><a href="#（3）接下来在github上添加SSH-key：" class="headerlink" title="（3）接下来在github上添加SSH key："></a>（3）接下来在github上添加SSH key：</h4><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/dell/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>
<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>
<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。</p>
<h4 id="（4）测试设置是否成功："><a href="#（4）测试设置是否成功：" class="headerlink" title="（4）测试设置是否成功："></a>（4）测试设置是否成功：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>有可能会出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (192.30.252.1)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>

<p>或者是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (192.30.252.1)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>

<p>这种情况下，直接 yes 回车</p>
<p>然后会出现（也可能在 <em>++$ ssh -T <a href="mailto:git@github.com">git@github.com</a>++</em> 之后，直接出现的就是这个，我就是这样~）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi username! You&#39;ve successfully authenticated, but GitHub does not </span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure>

<h4 id="（5）设置用户信息："><a href="#（5）设置用户信息：" class="headerlink" title="（5）设置用户信息："></a>（5）设置用户信息：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;用户名&quot;</span><br><span class="line">$ git config --global user.email  &quot;你希望的邮箱名&quot;</span><br></pre></td></tr></table></figure>

<h4 id="（6）然后就可以部署你的博客到github啦"><a href="#（6）然后就可以部署你的博客到github啦" class="headerlink" title="（6）然后就可以部署你的博客到github啦~"></a>（6）然后就可以部署你的博客到github啦~</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>参考文章 <a href="https://www.cnblogs.com/xsilence/p/6001938.html" target="_blank" rel="noopener">ssh</a></p>
]]></content>
      <categories>
        <category>mysoft</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoStart</title>
    <url>/2020/07/15/hexoStart/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fhexo.io%2Fzh-cn%2Fdocs%2Findex.html" target="_blank" rel="noopener">Hexo</a>框架，基于Node.js，搭建博客首先需要有一个GitHub账号并且配置了SSH Keys</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol>
<li><p>github仓库创建</p>
<a id="more"></a>

</li>
</ol>
<p>点击New repository创建，注意：仓库名称一定是<code>username.github.io</code>这种格式，username替换一个你喜欢的名字。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4120931-5b31c3ac628564b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/767/format/webp" alt="img"></p>
<ol start="2">
<li><p>Git安装（此处不多做说明，网上很多教程）</p>
<blockquote>
<p>验证：执行<code>git --version</code>如果输出类似<code>git version 2.15.0</code>说明安装成功了</p>
</blockquote>
</li>
<li><p>nodeJs安装（此处不多做说明，网上很多教程）</p>
<blockquote>
<p>验证：执行<code>npm --version</code>如果输出类似<code>5.5.1</code>说明安装成功了</p>
</blockquote>
</li>
<li><p>hexo安装</p>
</li>
</ol>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><ol>
<li><p>hexo文件夹创建</p>
<p>安装 Hexo 完成后，在你喜欢的目录下新建一个文件夹命名为<code>username</code>（替换成你喜欢的名字），然后cd到username文件夹下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd username</span><br><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>执行完毕后你将看到在你刚创建的文件夹下会有很多资源</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4120931-51990266dab56f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/220/format/webp" alt="img"></p>
<ol start="2">
<li><p>基础配置</p>
<p>接下来打开username下的<code>_config.yml</code>文件（上图中的第一个文件），修改一下里面几个关键的信息，修改完记得保存，注意：冒号后面要有空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: my_杨哥      &#x2F;&#x2F;你博客的名字</span><br><span class="line">author: Li Yang    &#x2F;&#x2F;你的名字</span><br><span class="line">language: zh-Hans  &#x2F;&#x2F;语言-简体中文</span><br></pre></td></tr></table></figure>

<p>上面这3个字段是关键信息，如需修改其他信息请参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fhexo.io%2Fzh-cn%2Fdocs%2Fconfiguration.html" target="_blank" rel="noopener">配置</a></p>
</li>
<li><p>主题安装</p>
<p>username下的<code>themes</code>文件夹中存放的是主题，默认的是landscape主题，如果你不喜欢可以安装其他主题。</p>
<p><strong>NexT</strong>主题是一套简约的主题，是目前使用最火的一个主题，下面我们安装一下该主题，你也可参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ftheme-next.iissnan.com%2Fgetting-started.html" target="_blank" rel="noopener">安装NexT</a>。</p>
<p>Hexo还有<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fhexo.io%2Fthemes%2F" target="_blank" rel="noopener">更多主题</a>供你选择</p>
</li>
</ol>
<ul>
<li><p>安装NexT主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd username        &#x2F;&#x2F;进入到username文件夹下</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用NexT主题：<br>打开username下的<code>_config.yml</code>文件（上图中的第一个文件），找到<code>theme</code>字段将其值更改为<code>next</code></p>
</li>
<li><p>验证主题：</p>
<p><em>注意：每次切换主题之后、验证主题之前都要清除 Hexo 的缓存</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean    &#x2F;&#x2F;清除缓存</span><br></pre></td></tr></table></figure>

<p>开始验证：启动Hexo本地服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>然后你将会看到终端输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000&#x2F;. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>这行的意思是说你用浏览器打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
<p>便可看到你的博客了，这只是本地的测试，如果测试没问题就执行Ctrl+C退出去，此时该地址就不能访问了。</p>
</li>
</ul>
<p>OK，现在，你已经成功安装并启用了 NexT 主题。接下来就是对该主题的一些设置，详细可参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ftheme-next.iissnan.com%2Fgetting-started.html%23theme-settings" target="_blank" rel="noopener">NexT主题设定</a></p>
<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><ol>
<li><p>文章新建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new layout title</span><br></pre></td></tr></table></figure>

<p>layout：模板，如果不写将使用默认模板，一般不写，直接<code>$ hexo new title</code></p>
<p>title：文章标题，如果标题包含空格的话，请使用引号括起来。</p>
<p>新建的文章将会存在<code>username/source/_posts</code>中，<code>_posts</code>就是默认模板，文章文件名称将会是<code>title.md</code>，接下来就可以打开该文件进行编辑写你的文章了。</p>
</li>
<li><p>静态文件生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地服务器启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>本地服务器启动完之后就如同上面验证主题一样，访问 <a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A4000" target="_blank" rel="noopener">http://localhost:4000</a> 来验证一下你写的文章预览效果。</p>
</li>
<li><p>网站部署</p>
<p>安装部署工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>安装完毕后打开username下的<code>_config.yml</code>文件，翻到最底部找到deploy节点编辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;YoungerLi&#x2F;youngerli.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>其中<code>https://github.com/YoungerLi/youngerli.github.io.git</code>就是你GitHub中创建的仓库地址，在这复制即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4120931-8525599433d095b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/442/format/webp" alt="img"></p>
<p>repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d        &#x2F;&#x2F;hexo deploy的缩写</span><br></pre></td></tr></table></figure>

<p>第一次执行这一步的时候会让你输入你的GitHub的用户名及密码，输入正确无误后执行完毕，任何人就可以访问 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fyoungerli.github.io" target="_blank" rel="noopener">https://youngerli.github.io</a> 进入你的博客了。</p>
<p>以后每次写完文章之后依次执行以下命令就可以发布更新了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean      &#x2F;&#x2F; 清除缓存</span><br><span class="line">$ hexo g          &#x2F;&#x2F; 生成静态网页文件</span><br><span class="line">$ hexo d          &#x2F;&#x2F; 将本地博客发布到github</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="hexo文章中插入图片"><a href="#hexo文章中插入图片" class="headerlink" title="hexo文章中插入图片"></a>hexo文章中插入图片</h3><p>安装图片插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190410220529100.png" alt="在这里插入图片描述"></p>
<p>在_config.yml配置文件中，修改为 post_asset_folder: true， 然后新建一篇文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post ceshi</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190410220540714.png" alt="在这里插入图片描述"></p>
<p>这个时候会出现一个ceshi.md 和 ceshi的文件夹</p>
<p>然后就可以在文章中引用了 <img src="https://img-blog.csdnimg.cn/20190410220553413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5OTY1NjU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>重新编译一下 然后启动服务</p>
<h3 id="博客备份和恢复"><a href="#博客备份和恢复" class="headerlink" title="博客备份和恢复"></a>博客备份和恢复</h3><h4 id="1-博客备份"><a href="#1-博客备份" class="headerlink" title="1. 博客备份"></a>1. 博客备份</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init &#x2F;&#x2F;git初始化</span><br><span class="line">$ git add . &#x2F;&#x2F;git 文件添加</span><br><span class="line">$ git commit -m &quot;init&quot; &#x2F;&#x2F;git 提交</span><br><span class="line">$ git pull origin hexo &#x2F;&#x2F;pull到hexo分支</span><br><span class="line">$ git push origin hexo &#x2F;&#x2F;push到hexo分支</span><br></pre></td></tr></table></figure>

<h4 id="2-博客恢复"><a href="#2-博客恢复" class="headerlink" title="2. 博客恢复"></a>2. 博客恢复</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（一）配置 ssh 连接 Github</span><br><span class="line">$ cd ~&#x2F;.ssh 或cd .ssh &#x2F;&#x2F;检查本机是否有ssh key设置</span><br><span class="line">$ cd ~  &#x2F;&#x2F;若没有 ssh ，则切换当前路径在 ”~” 下</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;user@example.com&quot; &#x2F;&#x2F;引号内为自己邮箱，三个回车后生成ssh key;添加id_rsa.pub内容到Github;</span><br><span class="line">$ git config --global user.name “your_username”  &#x2F;&#x2F;设置用户名</span><br><span class="line">$ git config --global user.email “your_registered_github_Email”  &#x2F;&#x2F;设置邮箱地址(建议用注册giuhub的邮箱)</span><br><span class="line">$ ssh -T git@github.com &#x2F;&#x2F;测试ssh key是否设置成功</span><br><span class="line">（二）安装 Node.js；Git；Hexo；</span><br><span class="line">$ git clone -b hexo git@github.com:user&#x2F;user.github.io.git  &#x2F;&#x2F;将Github中hexo分支clone到本地</span><br><span class="line">$ cd user.github.io &#x2F;&#x2F;切换到hexo目录下</span><br><span class="line">$ npm install hexo</span><br><span class="line">$ npm install </span><br><span class="line">$ npm install hexo *** &#x2F;&#x2F;安装需要的插件：feed;deployer;abbrlink;sitemap;pdf;nofollow;baidu-url-submit等</span><br><span class="line">$ hexo g -d &#x2F;&#x2F;测试能否正常编译上传</span><br></pre></td></tr></table></figure>

<h4 id="3-博主安装的插件："><a href="#3-博主安装的插件：" class="headerlink" title="3. 博主安装的插件："></a>3. 博主安装的插件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo-abbrlink &#x2F;&#x2F; Hexo 链接优化</span><br><span class="line">hexo-baidu-url-submit &#x2F;&#x2F; 百度链接主动提交</span><br><span class="line">hexo-blog-encrypt &#x2F;&#x2F; 博客文章加密</span><br><span class="line">hexo-autonofollow &#x2F;&#x2F; 出站链接优化</span><br><span class="line">hexo-deployer-git &#x2F;&#x2F; 上传部署</span><br><span class="line">hexo-generator-baidu-sitemap &#x2F;&#x2F;百度站点地图</span><br><span class="line">hexo-generator-feed &#x2F;&#x2F; RSS 插件</span><br><span class="line">hexo-generator-searchdb &#x2F;&#x2F; 站内搜索</span><br><span class="line">hexo-generator-sitemap &#x2F;&#x2F; 站点地图</span><br><span class="line">hexo-neat &#x2F;&#x2F; 博客压缩</span><br><span class="line">hexo-pdf &#x2F;&#x2F; 博客文章 PDF 显示</span><br><span class="line">hexo-wordcount &#x2F;&#x2F; 计数插件</span><br><span class="line">hexo-lazyload-image &#x2F;&#x2F;图片懒加载</span><br></pre></td></tr></table></figure>

<p>参考文档：<a href="https://www.jianshu.com/p/51617690f8ca" target="_blank" rel="noopener">hexo搭建</a></p>
<p>​           <a href="https://www.jianshu.com/p/74673c8bbc12" target="_blank" rel="noopener">hexo其他</a></p>
]]></content>
      <categories>
        <category>mysoft</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoTheme</title>
    <url>/2020/07/15/hexoTheme/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；</p>
<p>另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为<strong>站点配置文件</strong>， 后者称为<strong>主题配置文件</strong>。</p>
<p>备注: 以下所有终端执行的命令都在你的Hexo根目录下</p>
<h4 id="1、基本信息配置"><a href="#1、基本信息配置" class="headerlink" title="1、基本信息配置"></a>1、基本信息配置</h4><p>打开 <strong>站点配置文件</strong> ，找到Site模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>

<hr>
<a id="more"></a>

<h4 id="2、菜单设置"><a href="#2、菜单设置" class="headerlink" title="2、菜单设置"></a>2、菜单设置</h4><p>我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 <strong>主题配置文件</strong> 找到<code>Menu Settings</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home                          &#x2F;&#x2F;首页</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive          &#x2F;&#x2F;归档</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th           &#x2F;&#x2F;分类</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags                     &#x2F;&#x2F;标签</span><br><span class="line">  about: &#x2F;about&#x2F; || user                   &#x2F;&#x2F;关于</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar        &#x2F;&#x2F;日程表</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap        &#x2F;&#x2F;站点地图</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat          &#x2F;&#x2F;公益404</span><br></pre></td></tr></table></figure>

<p>备注：看看你需要哪个菜单就把哪个取消注释打开就行了；</p>
<p>关于后面的格式，以<code>archives: /archives/ || archive</code>为例：</p>
<p><code>||</code> 之前的<code>/archives/</code>表示标题“归档”，关于标题的格式可以去<code>themes/next/languages/zh-Hans.yml</code>中参考或修改</p>
<p><code>||</code>之后的<code>archive</code>表示图标，可以去<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ffontawesome.io%2Ficons%2F" target="_blank" rel="noopener">Font Awesome</a>中查看或修改，Next主题所有的图标都来自Font Awesome。</p>
<hr>
<h4 id="3、Next主题样式设置"><a href="#3、Next主题样式设置" class="headerlink" title="3、Next主题样式设置"></a>3、Next主题样式设置</h4><p>我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 <strong>主题配置文件</strong> 找到<code>Scheme Settings</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4、侧栏设置"><a href="#4、侧栏设置" class="headerlink" title="4、侧栏设置"></a>4、侧栏设置</h4><p>打开 <strong>主题配置文件</strong> 找到<code>sidebar</code>字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line"># Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  position: left        &#x2F;&#x2F;靠左放置</span><br><span class="line">  #position: right      &#x2F;&#x2F;靠右放置</span><br><span class="line"># Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效）</span><br><span class="line">  #display: post        &#x2F;&#x2F;默认行为，在文章页面（拥有目录列表）时显示</span><br><span class="line">  display: always       &#x2F;&#x2F;在所有页面中都显示</span><br><span class="line">  #display: hide        &#x2F;&#x2F;在所有页面中都隐藏（可以手动展开）</span><br><span class="line">  #display: remove      &#x2F;&#x2F;完全移除</span><br><span class="line">  offset: 12            &#x2F;&#x2F;文章间距（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  b2t: false            &#x2F;&#x2F;返回顶部按钮（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  scrollpercent: true   &#x2F;&#x2F;返回顶部按钮的百分比</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5、头像设置"><a href="#5、头像设置" class="headerlink" title="5、头像设置"></a>5、头像设置</h4><p>打开 <strong>主题配置文件</strong> 找到<code>Sidebar Avatar</code>字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar: &#x2F;images&#x2F;header.jpg</span><br></pre></td></tr></table></figure>

<p>这是头像的路径，只需把你的头像命名为<code>header.jpg</code>（随便命名）放入<code>themes/next/source/images</code>中，将<code>avatar</code>的路径名改成你的头像名就OK啦！</p>
<hr>
<h4 id="6、设置RSS"><a href="#6、设置RSS" class="headerlink" title="6、设置RSS"></a>6、设置RSS</h4><p>1、先安装 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fhexojs%2Fhexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>2、打开 <strong>站点配置文件</strong> 找到<code>Extensions</code>在下面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># RSS订阅</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: &#39; &#39;</span><br></pre></td></tr></table></figure>

<p>3、打开 <strong>主题配置文件</strong> 找到<code>rss</code>，设置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rss: &#x2F;atom.xml</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7、添加分类模块"><a href="#7、添加分类模块" class="headerlink" title="7、添加分类模块"></a>7、添加分类模块</h4><p>1、新建一个分类页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>categorcies/index.md</code>，打开<code>index.md</code>文件将title设置为<code>title: 分类</code><br>3、打开 <strong>主题配置文件</strong> 找到<code>menu</code>，将categorcies取消注释<br>4、把文章归入分类只需在文章的顶部标题下方添加<code>categories</code>字段，即可自动创建分类名并加入对应的分类中<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类测试文章标题</span><br><span class="line">categories: 分类名</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8、添加标签模块"><a href="#8、添加标签模块" class="headerlink" title="8、添加标签模块"></a>8、添加标签模块</h4><p>1、新建一个标签页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>tags/index.md</code>，打开<code>index.md</code>文件将title设置为<code>title: 标签</code><br>3、打开 <strong>主题配置文件</strong> 找到<code>menu</code>，将tags取消注释<br>4、把文章添加标签只需在文章的顶部标题下方添加<code>tags</code>字段，即可自动创建标签名并归入对应的标签中<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签测试文章标题</span><br><span class="line">tags: </span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9、添加关于模块"><a href="#9、添加关于模块" class="headerlink" title="9、添加关于模块"></a>9、添加关于模块</h4><p>1、新建一个关于页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>about/index.md</code>，打开<code>index.md</code>文件即可编辑关于你的信息，可以随便编辑。<br>3、打开 <strong>主题配置文件</strong> 找到<code>menu</code>，将about取消注释</p>
<hr>
<h4 id="10、添加搜索功能"><a href="#10、添加搜索功能" class="headerlink" title="10、添加搜索功能"></a>10、添加搜索功能</h4><p>1、安装 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fflashlab%2Fhexo-generator-search" target="_blank" rel="noopener">hexo-generator-searchdb</a> 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>2、打开 <strong>站点配置文件</strong> 找到<code>Extensions</code>在下面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>3、打开 <strong>主题配置文件</strong> 找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code></p>
<hr>
<h4 id="11、添加阅读全文按钮"><a href="#11、添加阅读全文按钮" class="headerlink" title="11、添加阅读全文按钮"></a>11、添加阅读全文按钮</h4><p>因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>其后面的部分就不会显示了，只能点击阅读全文才能看</p>
<hr>
<h4 id="12、修改文章内链接文本样式"><a href="#12、修改文章内链接文本样式" class="headerlink" title="12、修改文章内链接文本样式"></a>12、修改文章内链接文本样式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4120931-9cd87c2cc2d0c78f.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/360/format/webp" alt="img"></p>
<p>效果图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;components&#x2F;post&#x2F;post.styl</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-body p a &#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p>
<hr>
<h4 id="13、设置网站缩略图标"><a href="#13、设置网站缩略图标" class="headerlink" title="13、设置网站缩略图标"></a>13、设置网站缩略图标</h4><blockquote>
<p>从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行。</p>
</blockquote>
<p>我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在<code>themes/next/source/images</code>里，然后打开 <strong>主题配置文件</strong> 找到<code>favicon</code>，将<code>small、medium、apple_touch_icon</code>三个字段的值都设置成<code>/images/图片名.jpg</code>就可以了，其他字段都注释掉。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4120931-61a0cc555a25548e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/344/format/webp" alt="img"></p>
<hr>
<h4 id="14、设置文章字体的颜色、大小"><a href="#14、设置文章字体的颜色、大小" class="headerlink" title="14、设置文章字体的颜色、大小"></a>14、设置文章字体的颜色、大小</h4><p><img src="http://upload-images.jianshu.io/upload_images/4120931-e471abbb2b1f459f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/477/format/webp" alt="img"></p>
<p>效果图</p>
<p>如果想设置某一句的颜色或大小，只需用html语法写出来就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接下来就是见证奇迹的时刻</span><br><span class="line">&lt;font color&#x3D;&quot;#FF0000&quot;&gt; 我可以设置这一句的颜色哈哈 &lt;&#x2F;font&gt; </span><br><span class="line">&lt;font size&#x3D;6&gt; 我还可以设置这一句的大小嘻嘻 &lt;&#x2F;font&gt; </span><br><span class="line">&lt;font size&#x3D;5 color&#x3D;&quot;#FF0000&quot;&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="15、设置文字居中"><a href="#15、设置文字居中" class="headerlink" title="15、设置文字居中"></a>15、设置文字居中</h4><p>设置方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;这一行需要居中&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：简书中此方法无效</p>
</blockquote>
<hr>
<h4 id="16、添加评论系统"><a href="#16、添加评论系统" class="headerlink" title="16、添加评论系统"></a>16、添加评论系统</h4>]]></content>
      <categories>
        <category>mysoft</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo图片的那些事</title>
    <url>/2020/09/08/hexo%E5%9B%BE%E7%89%87%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="截图图片保存"><a href="#截图图片保存" class="headerlink" title="截图图片保存"></a>截图图片保存</h3><p>1、图片会莫名的丢失（文件的位置变了或者图片不见了）</p>
<p>2、在使用QQ或者各种截图工具，需要先保存到本地，然后在粘贴过来(截图工具默认图片是保存在缓存里的)</p>
<p>  为了解决这个问题，上网找了很多方法，个人比较喜欢的一种解决方式，现记录下来，一来做个记录；二来希望能够帮助和我一样碰到这个问题的朋友。</p>
<a id="more"></a>

<ul>
<li>第一步：文件—&gt;偏好设置（preference）<br><img src="https://img-blog.csdnimg.cn/20200419191321606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM0Mjg0MQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>第二步：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200419191338972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM0Mjg0MQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p> 经过上面设置以后：</p>
<p>1、文档中图片的地址：使用相对路径</p>
<p>2、在粘贴图片的时候，会自动在文档的当前目录下生成一个“文件名.assets”文件夹，里面会复制一份要粘贴的图片</p>
<p>3、在移动或复制文件的时候，连同assets一起复制，这样就不会出现图片显现不出来的问题。</p>
<h4 id="下载插件（根据md图片的相对路径，给出html中图片的绝对路径。）"><a href="#下载插件（根据md图片的相对路径，给出html中图片的绝对路径。）" class="headerlink" title="下载插件（根据md图片的相对路径，给出html中图片的绝对路径。）"></a>下载插件（根据md图片的相对路径，给出html中图片的绝对路径。）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install https:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></span><br></pre></td></tr></table></figure>

<p>注意：图片路径需去掉文件夹的名字，只需要文件名.png</p>
<p><img src="/2020/09/08/hexo%E5%9B%BE%E7%89%87%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210326154205261.png" alt="image-20210326154205261"></p>
<p><img src="/2020/09/08/hexo%E5%9B%BE%E7%89%87%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210326154405220.png" alt="image-20210326154405220"></p>
<h3 id="图片转成https"><a href="#图片转成https" class="headerlink" title="图片转成https"></a>图片转成https</h3><p>在线生成图片路径</p>
<p><a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p>
<h3 id="文章添加视频和-gif"><a href="#文章添加视频和-gif" class="headerlink" title="文章添加视频和 gif"></a>文章添加视频和 gif</h3><p>添加视频代码:(长宽可以自己定义)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">100</span> <span class="attr">width</span>=<span class="string">100</span> <span class="attr">src</span>=<span class="string">"视频地址"</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>添加 gif 代码:(长宽可以自己定义)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">100</span> <span class="attr">width</span>=<span class="string">100</span> <span class="attr">src</span>=<span class="string">"gif 图片地址"</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>mysoft</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>&#39;./icons/index&#39;</title>
    <url>/2021/03/01/icons-index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>introduction</title>
    <url>/2020/07/09/introduction/</url>
    <content><![CDATA[<h6 id><a href="#" class="headerlink" title></a></h6><h5 id="一个入门两年的小前端，日常总结和感悟，目的就是方便自己，方便他人。"><a href="#一个入门两年的小前端，日常总结和感悟，目的就是方便自己，方便他人。" class="headerlink" title="一个入门两年的小前端，日常总结和感悟，目的就是方便自己，方便他人。"></a>一个入门两年的小前端，日常总结和感悟，目的就是方便自己，方便他人。</h5><h5 id="这个博客将会记录我的前端生涯中，不管是鸡毛蒜皮，还是令人头秃的bug和自己记不住的知识点和方法。"><a href="#这个博客将会记录我的前端生涯中，不管是鸡毛蒜皮，还是令人头秃的bug和自己记不住的知识点和方法。" class="headerlink" title="这个博客将会记录我的前端生涯中，不管是鸡毛蒜皮，还是令人头秃的bug和自己记不住的知识点和方法。"></a>这个博客将会记录我的前端生涯中，不管是鸡毛蒜皮，还是令人头秃的bug和自己记不住的知识点和方法。</h5><h5 id="做一行，爱一行，菜鸟也会有飞起的那天，加油鸭！！！"><a href="#做一行，爱一行，菜鸟也会有飞起的那天，加油鸭！！！" class="headerlink" title="做一行，爱一行，菜鸟也会有飞起的那天，加油鸭！！！"></a>做一行，爱一行，菜鸟也会有飞起的那天，加油鸭！！！</h5>]]></content>
      <categories>
        <category>introduction</category>
      </categories>
      <tags>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>ipAndDNS</title>
    <url>/2020/07/22/ipAndDNS/</url>
    <content><![CDATA[<h3 id="怎么查找ip地址"><a href="#怎么查找ip地址" class="headerlink" title="怎么查找ip地址"></a>怎么查找ip地址</h3><p>方式一  电脑输入cmd，再输入ipconfig</p>
<p>方式二  本地连接的网络–属性–IPv4 地址 </p>
<a id="more"></a>

<h3 id="设置自动获取DNS服务器地址"><a href="#设置自动获取DNS服务器地址" class="headerlink" title="设置自动获取DNS服务器地址"></a>设置自动获取DNS服务器地址</h3><p>![clipboard (20)](ipAndDNS.assets/clipboard (20).png)</p>
<p>![clipboard (21)](ipAndDNS.assets/clipboard (21).png)</p>
<p>![clipboard (22)](ipAndDNS.assets/clipboard (22).png)</p>
<p>![clipboard (23)](ipAndDNS.assets/clipboard (23).png)</p>
<p>![clipboard (24)](ipAndDNS.assets/clipboard (24).png)</p>
]]></content>
      <categories>
        <category>ip</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>jsbridge</title>
    <url>/2020/07/22/jsbridge/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>h5 与原生 app 的交互，本质上说，就是两种调用：</p>
<ol>
<li>app 调用 h5 的代码</li>
<li>h5 调用 app 的代码</li>
</ol>
<a id="more"></a>

<p><strong>1. app 调用 h5 的代码</strong></p>
<p>因为 app 是宿主，可以直接访问 h5，所以这种调用比较简单，就是在 h5 中曝露一些全局对象（包括方法），然后在原生 app 中调用这些对</p>
<p><img src="https://img2018.cnblogs.com/blog/1661048/201908/1661048-20190805104711293-168785251.jpg" alt="img"></p>
<p><strong>javascript</strong></p>
<p><code>window.sdk = {</code></p>
<p><code>``double = value =&gt; value * 2,</code></p>
<p><code>``triple = value =&gt; value * 3,</code></p>
<p><code>};</code></p>
<p><strong>android：</strong></p>
<p><code>webview.evaluateJavascript(``&#39;window.sdk.double(10)&#39;``, ``new</code> <code>ValueCallback&lt;String&gt;() {</code></p>
<p><code>``@Override</code></p>
<p><code>``public</code> <code>void onReceiveValue(String s) {</code></p>
<p><code>``// 20</code></p>
<p><code>``}</code></p>
<p><code>});</code></p>
<p><strong>ios：</strong></p>
<p><code>NSString *func = @``&quot;window.sdk.double(10)&quot;``;</code></p>
<p><code>NSString *str = [webview stringByEvaluatingJavaScriptFromString:func]; ``// 20</code></p>
<p><strong>2. h5 调用 app 的代码</strong></p>
<p>因为 h5 不能直接访问宿主 app，所以这种调用就相对复杂一点。</p>
<p>这种调用常用有两种方式：</p>
<ol>
<li>由app向h5注入一个全局js对象，然后在h5直接访问这个对象</li>
<li>由h5发起一个自定义协议请求，app拦截这个请求后，再由app调用 h5 中的回调函数</li>
</ol>
<p><strong>2.1 由 app 向 h5 注入一个全局 js 对象</strong></p>
<p>这种方式沟通机制简单，比较好理解，并且对于 h5 来说，没有新的东西，所以是比较推荐的一种方式。但这种方式可能存在安全隐患，详细查看 你不知道的 Android WebView 使用漏洞。</p>
<p><img src="https://img2018.cnblogs.com/blog/1661048/201908/1661048-20190805105140875-2098346635.jpg" alt="img"></p>
<p><strong>android</strong></p>
<p><code>webview.addJavascriptInterface(``new</code> <code>Object() {</code></p>
<p><code>``@JavascriptInterface</code></p>
<p><code>``public</code> <code>int double(value) {</code></p>
<p><code>``return</code> <code>value * 2;</code></p>
<p><code>``}</code></p>
<p><code></code> </p>
<p><code>``@JavascriptInterface</code></p>
<p><code>``public</code> <code>int triple(value) {</code></p>
<p><code>``return</code> <code>value * 3;</code></p>
<p><code>``}</code></p>
<p><code>}, ``&quot;appSdk&quot;``);</code></p>
<hr>
<p><strong>ios</strong></p>
<p><code>NSString *scripts = @``&quot;window.appSdk = {double: value =&gt; value * 2, triple: value =&gt; value * 3}&quot;``;</code></p>
<p><code>[webview stringByEvaluatingJavaScriptFromString:scripts];</code></p>
<p><strong>javascript</strong></p>
<p><strong>window.appSdk.double(10); // 20</strong></p>
<hr>
<h3 id="JS-Bridge"><a href="#JS-Bridge" class="headerlink" title="JS Bridge"></a>JS Bridge</h3><h4 id="什么是JS-Bridge"><a href="#什么是JS-Bridge" class="headerlink" title="什么是JS Bridge"></a>什么是JS Bridge</h4><p>在移动开发中为了加快开发进度(0.0)很多页面会用H5来开发，这样一来可以快速完成节约，二来APP内嵌WebView可以较少APP更新频率。因此，成本现在大多数公司的首选，但是部分功能JavaScript的权限受到严格限制，比如拍照，读写权限，获取GPS等等，这些native功能，这时候我们需要去委托原生去实现，原生实现后再告知js。这个时候就需要一个中间桥梁，于是就有了<strong>WebViewJavascriptBridge</strong>，简称 <strong>JS bridge</strong>。</p>
<h4 id="重点叙述在vue中如何调用"><a href="#重点叙述在vue中如何调用" class="headerlink" title="重点叙述在vue中如何调用"></a>重点叙述在vue中如何调用</h4><ul>
<li>创建 src/config/bridge.js 文件，用于封装 WebViewJavascriptBridge</li>
<li>将以下代码拷贝到 bridge.js 文件中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line"><span class="built_in">window</span>.isAndroid = u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>; <span class="comment">//android终端 </span></span><br><span class="line"><span class="built_in">window</span>.isIOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(WebViewJavascriptBridge);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">'WebViewJavascriptBridgeReady'</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(WebViewJavascriptBridge)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.isIOS) &#123;</span><br><span class="line">    <span class="comment">// old ios method</span></span><br><span class="line">    <span class="comment">//setTimeout(function () &#123;</span></span><br><span class="line">    <span class="comment">//    if (window.WVJBCallbacks) &#123;</span></span><br><span class="line">    <span class="comment">//        return window.WVJBCallbacks.push(callback);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//&#125;, 500)</span></span><br><span class="line">    <span class="comment">//window.WVJBCallbacks = [callback];</span></span><br><span class="line">    <span class="comment">//var WVJBIframe = document.createElement('iframe');</span></span><br><span class="line">    <span class="comment">//WVJBIframe.style.display = 'none';</span></span><br><span class="line">    <span class="comment">//WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__';</span></span><br><span class="line">    <span class="comment">//document.documentElement.appendChild(WVJBIframe);</span></span><br><span class="line">    <span class="comment">//setTimeout(function () &#123;</span></span><br><span class="line">    <span class="comment">//    document.documentElement.removeChild(WVJBIframe)</span></span><br><span class="line">    <span class="comment">//&#125;, 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// new ios method</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WKWebViewJavascriptBridge) &#123; <span class="keyword">return</span> callback(WKWebViewJavascriptBridge); &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WKWVJBCallbacks) &#123; <span class="keyword">return</span> <span class="built_in">window</span>.WKWVJBCallbacks.push(callback); &#125;</span><br><span class="line">    <span class="built_in">window</span>.WKWVJBCallbacks = [callback];</span><br><span class="line">    <span class="built_in">window</span>.webkit.messageHandlers.iOS_Native_InjectJavascript.postMessage(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.isIOS) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.init(<span class="function"><span class="keyword">function</span> (<span class="params">message, responseCallback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">        responseCallback(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  callhandler(name, data, callback) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.callHandler(name, data, callback)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  registerhandler(name, callback) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.registerHandler(name, <span class="function"><span class="keyword">function</span> (<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">        callback(data, responseCallback)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 main.js 中引入该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Bridge from &#39;.&#x2F;config&#x2F;bridge.js&#39;</span><br><span class="line">Vue.prototype.$bridge &#x3D; Bridge</span><br></pre></td></tr></table></figure>

<p>在需要调用客户端方法的组件中（ObjC Echo是VUE端调用APP端的方法名）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; params是向app端传的参数</span><br><span class="line">&#x2F;&#x2F; iOS端</span><br><span class="line">this.$bridge.callhandler(&#39;ObjC Echo&#39;, params, (data) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理返回数据</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Android端</span><br><span class="line">JSAndroid.requestPaySupportWithPayWay(params);</span><br></pre></td></tr></table></figure>

<p>当app端需要调用 js 函数时,在mounted钩子中事先注册约定好的函数即可（JS Echo是APP端调用VUE端方法名称，博主没用过）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; iOS端</span><br><span class="line">this.$bridge.registerhandler(&#39;JS Echo&#39;, (data, responseCallback) &#x3D;&gt; &#123;</span><br><span class="line">  alert(&#39;JS Echo called with:&#39;, data)</span><br><span class="line">  responseCallback(data)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Android端</span><br><span class="line">window[&#39;JS Echo&#39;] &#x3D; (data, responseCallback) &#x3D;&gt; &#123;</span><br><span class="line">   alert(&#39;JS Echo called with:&#39;, data)</span><br><span class="line">   responseCallback(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="html中如何使用封装"><a href="#html中如何使用封装" class="headerlink" title="html中如何使用封装"></a>html中如何使用封装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var u &#x3D; navigator.userAgent;</span><br><span class="line">window.isAndroid &#x3D; u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Adr&#39;) &gt; -1; &#x2F;&#x2F;android终端 </span><br><span class="line">window.isIOS &#x3D; !!u.match(&#x2F;\(i[^;]+;( U;)? CPU.+Mac OS X&#x2F;); &#x2F;&#x2F;ios终端 </span><br><span class="line">window.jsbridge &#x3D; function (callback) &#123;</span><br><span class="line">    if (window.WebViewJavascriptBridge) &#123;</span><br><span class="line">        return callback(WebViewJavascriptBridge);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        document.addEventListener(</span><br><span class="line">            &#39;WebViewJavascriptBridgeReady&#39;,</span><br><span class="line">            function () &#123;</span><br><span class="line">                callback(WebViewJavascriptBridge)</span><br><span class="line">            &#125;,</span><br><span class="line">            false</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    if (window.isIOS) &#123;</span><br><span class="line">        &#x2F;&#x2F; old ios method</span><br><span class="line">        &#x2F;&#x2F;setTimeout(function () &#123;</span><br><span class="line">        &#x2F;&#x2F;    if (window.WVJBCallbacks) &#123;</span><br><span class="line">        &#x2F;&#x2F;        return window.WVJBCallbacks.push(callback);</span><br><span class="line">        &#x2F;&#x2F;    &#125;</span><br><span class="line">        &#x2F;&#x2F;&#125;, 500)</span><br><span class="line">        &#x2F;&#x2F;window.WVJBCallbacks &#x3D; [callback];</span><br><span class="line">        &#x2F;&#x2F;var WVJBIframe &#x3D; document.createElement(&#39;iframe&#39;);</span><br><span class="line">        &#x2F;&#x2F;WVJBIframe.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">        &#x2F;&#x2F;WVJBIframe.src &#x3D; &#39;wvjbscheme:&#x2F;&#x2F;__BRIDGE_LOADED__&#39;;</span><br><span class="line">        &#x2F;&#x2F;document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">        &#x2F;&#x2F;setTimeout(function () &#123;</span><br><span class="line">        &#x2F;&#x2F;    document.documentElement.removeChild(WVJBIframe)</span><br><span class="line">        &#x2F;&#x2F;&#125;, 0)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; new ios method</span><br><span class="line">        if (window.WKWebViewJavascriptBridge) &#123; return callback(WKWebViewJavascriptBridge); &#125;</span><br><span class="line">        if (window.WKWVJBCallbacks) &#123; return window.WKWVJBCallbacks.push(callback); &#125;</span><br><span class="line">        window.WKWVJBCallbacks &#x3D; [callback];</span><br><span class="line">        window.webkit.messageHandlers.iOS_Native_InjectJavascript.postMessage(null)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!window.isIOS) &#123;</span><br><span class="line">    jsbridge(function (bridge) &#123;</span><br><span class="line">        bridge.init(function (message, responseCallback) &#123;</span><br><span class="line">            var data &#x3D; &#123;&#125;;</span><br><span class="line">            responseCallback(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;option对象&#125;</span><br><span class="line"> * method: 调用的方法</span><br><span class="line"> * data: 传递的参数</span><br><span class="line"> * callback: 回掉方法</span><br><span class="line"> * @return &#123;[type]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">function bridgeCallHandler(option) &#123;</span><br><span class="line">    &#x2F;&#x2F; alert(option.method)</span><br><span class="line">    jsbridge(function (bridge) &#123;</span><br><span class="line">        bridge.callHandler(</span><br><span class="line">            option.method,</span><br><span class="line">            option.data || &#123;&#125;,</span><br><span class="line">            function (responseData) &#123;</span><br><span class="line">                if (option.callback) &#123;</span><br><span class="line">                    option.callback(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">window.callNativePage &#x3D; function (option) &#123;</span><br><span class="line">    bridgeCallHandler(&#123;</span><br><span class="line">        method: &#39;callNativePage&#39;,</span><br><span class="line">        data: option.data,</span><br><span class="line">        callback: function (responseData) &#123;</span><br><span class="line">            if (option.callback) &#123;</span><br><span class="line">                option.callback(responseData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">js调用app</span><br><span class="line">callNativePage(&#123;</span><br><span class="line">    data: &#123; msg : &#39;test send msg&#39; &#125;,</span><br><span class="line">    callback:function(responseData)&#123;</span><br><span class="line">        console.log(&#39;来源于app的反馈信息&#39;,responseData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;app调js</span><br><span class="line">window.bridgeRegisterHandler &#x3D; function (option) &#123;</span><br><span class="line">    &#x2F;&#x2F; alert(option.method);</span><br><span class="line">    jsbridge(function (bridge) &#123;</span><br><span class="line">        bridge.registerHandler(</span><br><span class="line">            option.method,</span><br><span class="line">            function (data, responseCallback) &#123;</span><br><span class="line">                if (option.callback) &#123;</span><br><span class="line">                    option.callback(data);</span><br><span class="line">                &#125;</span><br><span class="line">                responseCallback(option.data || &#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">window.bridgeRegisterHandler(&#123;</span><br><span class="line">    method:&quot;提供给app调用的方法名&quot;,</span><br><span class="line">    callback:function(data)&#123;</span><br><span class="line">        &#x2F;&#x2F; data : app传递给前端的data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参考链接</p>
<p><a href="https://www.cnblogs.com/tu-front-end/p/11301685.html" target="_blank" rel="noopener">jsbridge</a></p>
<p><a href="https://blog.csdn.net/daipianpian/article/details/90714502" target="_blank" rel="noopener">vue项目使用WebViewJavascriptBridge</a></p>
<p><a href="https://www.jianshu.com/p/2fa0b6cdca17" target="_blank" rel="noopener">H5调用封装</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jsbridge</tag>
      </tags>
  </entry>
  <entry>
    <title>js之BigNumber.js</title>
    <url>/2020/09/15/js%E4%B9%8BBigNumber-js/</url>
    <content><![CDATA[<p>vue使用BigNumber.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save bignumber.js</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var BigNumber &#x3D; require(&#39;bignumber.js&#39;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 转为 bignumber</span><br><span class="line">const x&#x3D; new BigNumber(&#39;123456789.123456789&#39;);</span><br><span class="line">&#x2F;&#x2F; 转为 普通数字</span><br><span class="line">x.toNumber()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 格式化(小数点)</span><br><span class="line">x.toFormat()    &#x2F;&#x2F; &#39;123,456,789.123456789&#39;</span><br><span class="line">x.toFormat(3)   &#x2F;&#x2F; &#39;123,456,789.123&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算</span><br><span class="line">x.plus(0.1)  &#x2F;&#x2F; 加法</span><br><span class="line">x.minus(0.1)  &#x2F;&#x2F; 减法</span><br><span class="line">x.times(0.1)  &#x2F;&#x2F; 乘法</span><br><span class="line">x.div(0.1)  &#x2F;&#x2F; 除法</span><br><span class="line">x.mod(3)  &#x2F;&#x2F; 取模&#x2F;取余</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比较大小</span><br><span class="line">x.eq(y) &#x2F;&#x2F; isEqualTo 的简写，是否相等</span><br><span class="line">x.gt(y) &#x2F;&#x2F; isGreaterThan 的简写，是否大于</span><br><span class="line">x.gte(y) &#x2F;&#x2F; isGreaterThanOrEqualTo 的简写，是否大于等于</span><br><span class="line">x.lt(y) &#x2F;&#x2F; isLessThan 的简写，是否小于</span><br><span class="line">x.lte(y) &#x2F;&#x2F; isLessThanOrEqualTo 的简写，是否小于等于</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取非，改变数字的正负号</span><br><span class="line">x.negated()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>精度计算</tag>
      </tags>
  </entry>
  <entry>
    <title>js之84个常用的JS代码片段</title>
    <url>/2021/03/15/js%E4%B9%8B84%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84JS%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="1、all-important"><a href="#1、all-important" class="headerlink" title="*1、all * (important)"></a>*<em>1、all *</em> (important)</h2><p>如果数组所有元素满足函数条件，则返回true。调用时，如果省略第二个参数，则默认传递布尔值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const all &#x3D; (arr, fn &#x3D; Boolean) &#x3D;&gt; arr.every(fn);</span><br><span class="line"></span><br><span class="line">all([4, 2, 3], x &#x3D;&gt; x &gt; 1); &#x2F;&#x2F; true</span><br><span class="line">all([1, 2, 3]); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2、allEqual-important"><a href="#2、allEqual-important" class="headerlink" title="2、allEqual (important)"></a><strong>2、allEqual</strong> (important)</h2><p>判断数组中的元素是否都相等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const allEqual &#x3D; arr &#x3D;&gt; arr.every(val &#x3D;&gt; val &#x3D;&#x3D;&#x3D; arr[0]);</span><br><span class="line"></span><br><span class="line">allEqual([1, 2, 3, 4, 5, 6]); &#x2F;&#x2F; false</span><br><span class="line">allEqual([1, 1, 1, 1]); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="3、approximatelyEqual"><a href="#3、approximatelyEqual" class="headerlink" title="3、approximatelyEqual"></a><strong>3、approximatelyEqual</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const approximatelyEqual &#x3D; (v1, v2, epsilon &#x3D; 0.001) &#x3D;&gt; Math.abs(v1 - v2) &lt; epsilon;</span><br><span class="line"></span><br><span class="line">approximatelyEqual(Math.PI &#x2F; 2.0, 1.5708); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="4、arrayToCSV"><a href="#4、arrayToCSV" class="headerlink" title="4、arrayToCSV"></a><strong>4、arrayToCSV</strong></h2><p>此段代码将没有逗号或双引号的元素转换成带有逗号分隔符的字符串即CSV格式识别的形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arrayToCSV &#x3D; (arr, delimiter &#x3D; &#39;,&#39;) &#x3D;&gt;</span><br><span class="line">  arr.map(v &#x3D;&gt; v.map(x &#x3D;&gt; &#96;&quot;$&#123;x&#125;&quot;&#96;).join(delimiter)).join(&#39;\n&#39;);</span><br><span class="line">  </span><br><span class="line">arrayToCSV([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]); &#x2F;&#x2F; &#39;&quot;a&quot;,&quot;b&quot;\n&quot;c&quot;,&quot;d&quot;&#39;</span><br><span class="line">arrayToCSV([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]], &#39;;&#39;); &#x2F;&#x2F; &#39;&quot;a&quot;;&quot;b&quot;\n&quot;c&quot;;&quot;d&quot;&#39;</span><br></pre></td></tr></table></figure>

<h2 id="5、arrayToHtmlList"><a href="#5、arrayToHtmlList" class="headerlink" title="5、arrayToHtmlList"></a><strong>5、arrayToHtmlList</strong></h2><p>此段代码将数组元素转换成<li>标记，并将此元素添加至给定的ID元素标记内。</li></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arrayToHtmlList &#x3D; (arr, listID) &#x3D;&gt;</span><br><span class="line">  (el &#x3D;&gt; (</span><br><span class="line">    (el &#x3D; document.querySelector(&#39;#&#39; + listID)),</span><br><span class="line">    (el.innerHTML +&#x3D; arr.map(item &#x3D;&gt; &#96;&lt;li&gt;$&#123;item&#125;&lt;&#x2F;li&gt;&#96;).join(&#39;&#39;))</span><br><span class="line">  ))();</span><br><span class="line">  </span><br><span class="line">arrayToHtmlList([&#39;item 1&#39;, &#39;item 2&#39;], &#39;myListID&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="6、attempt"><a href="#6、attempt" class="headerlink" title="6、attempt"></a><strong>6、attempt</strong></h2><p>此段代码执行一个函数，将剩余的参数传回函数当参数，返回相应的结果，并能捕获异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const attempt &#x3D; (fn, ...args) &#x3D;&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return fn(...args);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    return e instanceof Error ? e : new Error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var elements &#x3D; attempt(function(selector) &#123;</span><br><span class="line">  return document.querySelectorAll(selector);</span><br><span class="line">&#125;, &#39;&gt;_&gt;&#39;);</span><br><span class="line">if (elements instanceof Error) elements &#x3D; [];</span><br><span class="line">&#x2F;&#x2F; elements &#x3D; []</span><br></pre></td></tr></table></figure>

<h2 id="7、average-important"><a href="#7、average-important" class="headerlink" title="7、average (important)"></a><strong>7、average</strong> (important)</h2><p>此段代码返回两个或多个数的平均数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const average &#x3D; (...nums) &#x3D;&gt; nums.reduce((acc, val) &#x3D;&gt; acc + val, 0) &#x2F; nums.length;</span><br><span class="line">average(...[1, 2, 3]); &#x2F;&#x2F; 2</span><br><span class="line">average(1, 2, 3); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h2 id="8、averageBy-important"><a href="#8、averageBy-important" class="headerlink" title="8、averageBy (important)"></a><strong>8、averageBy</strong> (important)</h2><p>求对象数组的属性之和，一个 map()函数和 reduce()函数结合的例子，此函数先通过 map() 函数将对象转换成数组，然后在调用reduce()函数进行累加，然后根据数组长度返回平均值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const averageBy &#x3D; (arr, fn) &#x3D;&gt;</span><br><span class="line">  arr.map(typeof fn &#x3D;&#x3D;&#x3D; &#39;function&#39; ? fn : val &#x3D;&gt; val[fn]).reduce((acc, val) &#x3D;&gt; acc + val, 0) &#x2F;</span><br><span class="line">  arr.length;</span><br><span class="line">  </span><br><span class="line">averageBy([&#123; n: 4 &#125;, &#123; n: 2 &#125;, &#123; n: 8 &#125;, &#123; n: 6 &#125;], o &#x3D;&gt; o.n); &#x2F;&#x2F; 5</span><br><span class="line">averageBy([&#123; n: 4 &#125;, &#123; n: 2 &#125;, &#123; n: 8 &#125;, &#123; n: 6 &#125;], &#39;n&#39;); &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>

<h2 id="9、bifurcate"><a href="#9、bifurcate" class="headerlink" title="9、bifurcate"></a><strong>9、bifurcate</strong></h2><p>此函数包含两个参数，类型都为数组，依据第二个参数的真假条件，将一个参数的数组进行分组，条件为真的放入第一个数组，其它的放入第二个数组。这里运用了Array.prototype.reduce() 和 Array.prototype.push() 相结合的形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const bifurcate &#x3D; (arr, filter) &#x3D;&gt;</span><br><span class="line">  arr.reduce((acc, val, i) &#x3D;&gt; (acc[filter[i] ? 0 : 1].push(val), acc), [[], []]);</span><br><span class="line">bifurcate([&#39;beep&#39;, &#39;boop&#39;, &#39;foo&#39;, &#39;bar&#39;], [true, true, false, true]);</span><br><span class="line">&#x2F;&#x2F; [ [&#39;beep&#39;, &#39;boop&#39;, &#39;bar&#39;], [&#39;foo&#39;] ]</span><br></pre></td></tr></table></figure>

<h2 id="10、bifurcateBy-important"><a href="#10、bifurcateBy-important" class="headerlink" title="10、bifurcateBy (important)"></a><strong>10、bifurcateBy</strong> (important)</h2><p>此段代码将数组按照指定的函数逻辑进行分组，满足函数条件的逻辑为真，放入第一个数组中，其它不满足的放入第二个数组 。</p>
<p>这里运用了Array.prototype.reduce() 和 Array.prototype.push() 相结合的形式，基于函数过滤逻辑，通过 Array.prototype.push() 函数将其添加到数组中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const bifurcateBy &#x3D; (arr, fn) &#x3D;&gt;</span><br><span class="line">  arr.reduce((acc, val, i) &#x3D;&gt; (acc[fn(val, i) ? 0 : 1].push(val), acc), [[], []]);</span><br><span class="line">  </span><br><span class="line">bifurcateBy([&#39;beep&#39;, &#39;boop&#39;, &#39;foo&#39;, &#39;bar&#39;], x &#x3D;&gt; x[0] &#x3D;&#x3D;&#x3D; &#39;b&#39;);</span><br><span class="line">&#x2F;&#x2F; [ [&#39;beep&#39;, &#39;boop&#39;, &#39;bar&#39;], [&#39;foo&#39;] ]</span><br></pre></td></tr></table></figure>

<h2 id="11、bottomVisible-important"><a href="#11、bottomVisible-important" class="headerlink" title="11、bottomVisible (important)"></a><strong>11、bottomVisible (important)</strong></h2><p>用于检测页面是否滚动到页面底部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const bottomVisible &#x3D; () &#x3D;&gt;</span><br><span class="line">  document.documentElement.clientHeight + window.scrollY &gt;&#x3D;</span><br><span class="line">  (document.documentElement.scrollHeight || document.documentElement.clientHeight);</span><br><span class="line"></span><br><span class="line">bottomVisible(); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="12、byteSize"><a href="#12、byteSize" class="headerlink" title="12、byteSize"></a><strong>12、byteSize</strong></h2><p>此代码返回字符串的字节长度。这里用到了Blob对象，Blob（Binary Large Object）对象代表了一段二进制数据，提供了一系列操作接口。其他操作二进制数据的API（比如File对象），都是建立在Blob对象基础上的，继承了它的属性和方法。生成Blob对象有两种方法：一种是使用Blob构造函数，另一种是对现有的Blob对象使用slice方法切出一部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const byteSize &#x3D; str &#x3D;&gt; new Blob([str]).size;</span><br><span class="line"></span><br><span class="line">byteSize(&#39;😀&#39;); &#x2F;&#x2F; 4</span><br><span class="line">byteSize(&#39;Hello World&#39;); &#x2F;&#x2F; 11</span><br></pre></td></tr></table></figure>

<h2 id="13、capitalize-important"><a href="#13、capitalize-important" class="headerlink" title="13、capitalize (important)"></a><strong>13、capitalize</strong> (important)</h2><p>将字符串的首字母转成大写,这里主要运用到了ES6的展开语法在数组中的运用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const capitalize &#x3D; ([first, ...rest]) &#x3D;&gt;</span><br><span class="line">  first.toUpperCase() + rest.join(&#39;&#39;);</span><br><span class="line">  </span><br><span class="line">capitalize(&#39;fooBar&#39;); &#x2F;&#x2F; &#39;FooBar&#39;</span><br><span class="line">capitalize(&#39;fooBar&#39;, true); &#x2F;&#x2F; &#39;FooBar&#39;</span><br></pre></td></tr></table></figure>

<h2 id="14、capitalizeEveryWord-important"><a href="#14、capitalizeEveryWord-important" class="headerlink" title="14、capitalizeEveryWord (important)"></a><strong>14、capitalizeEveryWord</strong> (important)</h2><p>将一个句子中每个单词首字母转换成大写字母，这里中要运用了正则表达式进行替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const capitalizeEveryWord &#x3D; str &#x3D;&gt; str.replace(&#x2F;\b[a-z]&#x2F;g, char &#x3D;&gt; char.toUpperCase());</span><br><span class="line"></span><br><span class="line">capitalizeEveryWord(&#39;hello world!&#39;); &#x2F;&#x2F; &#39;Hello World!&#39;</span><br></pre></td></tr></table></figure>

<h2 id="15、castArray-important"><a href="#15、castArray-important" class="headerlink" title="15、castArray (important)"></a><strong>15、castArray</strong> (important)</h2><p>此段代码将非数值的值转换成数组对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const castArray &#x3D; val &#x3D;&gt; (Array.isArray(val) ? val : [val]);</span><br><span class="line"></span><br><span class="line">castArray(&#39;foo&#39;); &#x2F;&#x2F; [&#39;foo&#39;]</span><br><span class="line">castArray([1]); &#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure>

<h2 id="16、compact"><a href="#16、compact" class="headerlink" title="16、compact"></a><strong>16、compact</strong></h2><p>将数组中移除值为 false 的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const compact &#x3D; arr &#x3D;&gt; arr.filter(Boolean);</span><br><span class="line"></span><br><span class="line">compact([0, 1, false, 2, &#39;&#39;, 3, &#39;a&#39;, &#39;e&#39; * 23, NaN, &#39;s&#39;, 34]);</span><br><span class="line">&#x2F;&#x2F; [ 1, 2, 3, &#39;a&#39;, &#39;s&#39;, 34 ]</span><br></pre></td></tr></table></figure>

<h2 id="17、countOccurrences-important"><a href="#17、countOccurrences-important" class="headerlink" title="17、countOccurrences (important)"></a><strong>17、countOccurrences (important)</strong></h2><p>统计数组中某个值出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const countOccurrences &#x3D; (arr, val) &#x3D;&gt; arr.reduce((a, v) &#x3D;&gt; (v &#x3D;&#x3D;&#x3D; val ? a + 1 : a), 0);</span><br><span class="line">countOccurrences([1, 1, 2, 1, 2, 3], 1); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<h2 id="18、Create-Directory"><a href="#18、Create-Directory" class="headerlink" title="18、Create Directory"></a><strong>18、Create Directory</strong></h2><p>此代码段使用 existSync() 检查目录是否存在，然后使用 mkdirSync() 创建目录（如果不存在）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const createDirIfNotExists &#x3D; dir &#x3D;&gt; (!fs.existsSync(dir) ? fs.mkdirSync(dir) : undefined);</span><br><span class="line">createDirIfNotExists(&#39;test&#39;);</span><br><span class="line">&#x2F;&#x2F; creates the directory &#39;test&#39;, if it doesn&#39;t exist</span><br></pre></td></tr></table></figure>

<h2 id="19、currentURL"><a href="#19、currentURL" class="headerlink" title="19、currentURL"></a><strong>19、currentURL</strong></h2><p>返回当前访问的 URL 地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const currentURL &#x3D; () &#x3D;&gt; window.location.href;</span><br><span class="line"></span><br><span class="line">currentURL(); &#x2F;&#x2F; &#39;https:&#x2F;&#x2F;medium.com&#x2F;@fatosmorina&#39;</span><br></pre></td></tr></table></figure>

<h2 id="20、dayOfYear-important"><a href="#20、dayOfYear-important" class="headerlink" title="20、dayOfYear (important)"></a><strong>20、dayOfYear</strong> (important)</h2><p>返回当前是今年的第几天</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dayOfYear &#x3D; date &#x3D;&gt;</span><br><span class="line">  Math.floor((date - new Date(date.getFullYear(), 0, 0)) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24);</span><br><span class="line"></span><br><span class="line">dayOfYear(new Date()); &#x2F;&#x2F; 272</span><br></pre></td></tr></table></figure>

<h2 id="21、decapitalize-important"><a href="#21、decapitalize-important" class="headerlink" title="21、decapitalize (important)"></a><strong>21、decapitalize (important)</strong></h2><p>将字符串的首字母转换成小写字母。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const decapitalize &#x3D; ([first, ...rest]) &#x3D;&gt;</span><br><span class="line">  first.toLowerCase() + rest.join(&#39;&#39;)</span><br><span class="line"></span><br><span class="line">decapitalize(&#39;FooBar&#39;); &#x2F;&#x2F; &#39;fooBar&#39;</span><br></pre></td></tr></table></figure>

<h2 id="22、deepFlatten-important"><a href="#22、deepFlatten-important" class="headerlink" title="22、deepFlatten (important)"></a><strong>22、deepFlatten</strong> (important)</h2><p>通过递归的形式，将多维数组展平成一维数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const deepFlatten &#x3D; arr &#x3D;&gt; [].concat(...arr.map(v &#x3D;&gt; (Array.isArray(v) ? deepFlatten(v) : v)));</span><br><span class="line"></span><br><span class="line">deepFlatten([1, [2], [[3], 4], 5]); &#x2F;&#x2F; [1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<h2 id="23、default-important"><a href="#23、default-important" class="headerlink" title="23、default (important)"></a>23、default (important)</h2><p>去重对象的属性，如果对象中含有重复的属性，以前面的为准。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const defaults &#x3D; (obj, ...defs) &#x3D;&gt; Object.assign(&#123;&#125;, obj, ...defs.reverse(), obj);</span><br><span class="line"></span><br><span class="line">defaults(&#123; a: 1 &#125;, &#123; b: 2 &#125;, &#123; b: 6 &#125;, &#123; a: 3 &#125;); &#x2F;&#x2F; &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure>

<h1 id="24、defer"><a href="#24、defer" class="headerlink" title="24、defer"></a><strong>24、defer</strong></h1><p>延迟函数的调用，即异步调用函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const defer &#x3D; (fn, ...args) &#x3D;&gt; setTimeout(fn, 1, ...args);</span><br><span class="line"></span><br><span class="line">defer(console.log, &#39;a&#39;), console.log(&#39;b&#39;);</span><br><span class="line">&#x2F;&#x2F; logs &#39;b&#39; then &#39;a&#39;</span><br></pre></td></tr></table></figure>

<h1 id="25、degreesToRads"><a href="#25、degreesToRads" class="headerlink" title="25、degreesToRads"></a><strong>25、degreesToRads</strong></h1><p>此段代码将标准的度数，转换成弧度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const degreesToRads &#x3D; deg &#x3D;&gt; (deg * Math.PI) &#x2F; 180.0;</span><br><span class="line"></span><br><span class="line">degreesToRads(90.0); &#x2F;&#x2F; ~1.5708</span><br></pre></td></tr></table></figure>

<h1 id="26、difference-important"><a href="#26、difference-important" class="headerlink" title="26、difference (important)"></a><strong>26、difference</strong> (important)</h1><p>此段代码查找两个给定数组的差异，查找出前者数组在后者数组中不存在元素。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const difference &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  const s &#x3D; new Set(b);</span><br><span class="line">  return a.filter(x &#x3D;&gt; !s.has(x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">difference([1, 2, 3], [1, 2, 4]); &#x2F;&#x2F; [3]</span><br></pre></td></tr></table></figure>

<h1 id="27、differenceBy-important"><a href="#27、differenceBy-important" class="headerlink" title="27、differenceBy (important)"></a><strong>27、differenceBy</strong> (important)</h1><p>数组对象，通过给定的函数来处理需要对比差异的数组，查找出前者数组在后者数组中不存在元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const differenceBy &#x3D; (a, b, fn) &#x3D;&gt; &#123;</span><br><span class="line">  const s &#x3D; new Set(b.map(fn));</span><br><span class="line">  return a.filter(x &#x3D;&gt; !s.has(fn(x)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); &#x2F;&#x2F; [1.2]</span><br><span class="line">differenceBy([&#123; x: 2 &#125;, &#123; x: 1 &#125;], [&#123; x: 1 &#125;], v &#x3D;&gt; v.x); &#x2F;&#x2F; [ &#123; x: 2 &#125; ]</span><br></pre></td></tr></table></figure>

<h1 id="28、differenceWith-important"><a href="#28、differenceWith-important" class="headerlink" title="28、differenceWith (important)"></a><strong>28、differenceWith</strong> (important)</h1><p>此段代码按照给定函数逻辑筛选需要对比差异的数组，查找出前者数组在后者数组中不存在元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const differenceWith &#x3D; (arr, val, comp) &#x3D;&gt; arr.filter(a &#x3D;&gt; val.findIndex(b &#x3D;&gt; comp(a, b)) &#x3D;&#x3D;&#x3D; -1);</span><br><span class="line"></span><br><span class="line">differenceWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0], (a, b) &#x3D;&gt; Math.round(a) &#x3D;&#x3D;&#x3D; Math.round(b));</span><br><span class="line">&#x2F;&#x2F; [1, 1.2]</span><br></pre></td></tr></table></figure>

<h1 id="29、digitize"><a href="#29、digitize" class="headerlink" title="29、digitize"></a><strong>29、digitize</strong></h1><p>将输入的数字拆分成单个数字组成的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const digitize &#x3D; n &#x3D;&gt; [...&#96;$&#123;n&#125;&#96;].map(i &#x3D;&gt; parseInt(i));</span><br><span class="line"></span><br><span class="line">digitize(431); &#x2F;&#x2F; [4, 3, 1]</span><br></pre></td></tr></table></figure>

<h1 id="30、distance"><a href="#30、distance" class="headerlink" title="30、distance"></a><strong>30、distance</strong></h1><p>计算两点之间的距离</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const distance &#x3D; (x0, y0, x1, y1) &#x3D;&gt; Math.hypot(x1 - x0, y1 - y0);</span><br><span class="line"></span><br><span class="line">distance(1, 1, 2, 3); &#x2F;&#x2F; 2.23606797749979</span><br></pre></td></tr></table></figure>

<h1 id="31、drop-important"><a href="#31、drop-important" class="headerlink" title="31、drop (important)"></a><strong>31、drop</strong> (important)</h1><p>此段代码将给定的数组从左边开始删除 n 个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const drop &#x3D; (arr, n &#x3D; 1) &#x3D;&gt; arr.slice(n);</span><br><span class="line"></span><br><span class="line">drop([1, 2, 3]); &#x2F;&#x2F; [2,3]</span><br><span class="line">drop([1, 2, 3], 2); &#x2F;&#x2F; [3]</span><br><span class="line">drop([1, 2, 3], 42); &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<h1 id="32、dropRight"><a href="#32、dropRight" class="headerlink" title="32、dropRight"></a><strong>32、dropRight</strong></h1><p>此段代码将给定的数组从右边开始删除 n 个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dropRight &#x3D; (arr, n &#x3D; 1) &#x3D;&gt; arr.slice(0, -n);</span><br><span class="line"></span><br><span class="line">dropRight([1, 2, 3]); &#x2F;&#x2F; [1,2]</span><br><span class="line">dropRight([1, 2, 3], 2); &#x2F;&#x2F; [1]</span><br><span class="line">dropRight([1, 2, 3], 42); &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<h1 id="33、dropRightWhile"><a href="#33、dropRightWhile" class="headerlink" title="33、dropRightWhile"></a><strong>33、dropRightWhile</strong></h1><p>此段代码将给定的数组按照给定的函数条件从右开始删除，直到当前元素满足函数条件为True时，停止删除，并返回数组剩余元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dropRightWhile &#x3D; (arr, func) &#x3D;&gt; &#123;</span><br><span class="line">  while (arr.length &gt; 0 &amp;&amp; !func(arr[arr.length - 1])) arr &#x3D; arr.slice(0, -1);</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dropRightWhile([1, 2, 3, 4], n &#x3D;&gt; n &lt; 3); &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure>

<h1 id="34、dropWhile-important"><a href="#34、dropWhile-important" class="headerlink" title="34、dropWhile (important)"></a><strong>34、dropWhile</strong> (important)</h1><p>按照给的的函数条件筛选数组，不满足函数条件的将从数组中移除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dropWhile &#x3D; (arr, func) &#x3D;&gt; &#123;</span><br><span class="line">  while (arr.length &gt; 0 &amp;&amp; !func(arr[0])) arr &#x3D; arr.slice(1);</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dropWhile([1, 2, 3, 4], n &#x3D;&gt; n &gt;&#x3D; 3); &#x2F;&#x2F; [3,4]</span><br></pre></td></tr></table></figure>

<h1 id="35、elementContains"><a href="#35、elementContains" class="headerlink" title="35、elementContains"></a><strong>35、elementContains</strong></h1><p>接收两个DOM元素对象参数，判断后者是否是前者的子元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const elementContains &#x3D; (parent, child) &#x3D;&gt; parent !&#x3D;&#x3D; child &amp;&amp; parent.contains(child);</span><br><span class="line"></span><br><span class="line">elementContains(document.querySelector(&#39;head&#39;), document.querySelector(&#39;title&#39;)); &#x2F;&#x2F; true</span><br><span class="line">elementContains(document.querySelector(&#39;body&#39;), document.querySelector(&#39;body&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="36、filterNonUnique-important"><a href="#36、filterNonUnique-important" class="headerlink" title="36、filterNonUnique (important)"></a><strong>36、filterNonUnique</strong> (important)</h1><p>移除数组中重复的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const filterNonUnique &#x3D; arr &#x3D;&gt; [ …new Set(arr)];</span><br><span class="line">filterNonUnique([1, 2, 2, 3, 4, 4, 5]); </span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h1 id="37、findKey-important"><a href="#37、findKey-important" class="headerlink" title="37、findKey (important)"></a><strong>37、findKey</strong> (important)</h1><p>按照给定的函数条件，查找第一个满足条件对象的键值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const findKey &#x3D; (obj, fn) &#x3D;&gt; Object.keys(obj).find(key &#x3D;&gt; fn(obj[key], key, obj));</span><br><span class="line"></span><br><span class="line">findKey(</span><br><span class="line">  &#123;</span><br><span class="line">    barney: &#123; age: 36, active: true &#125;,</span><br><span class="line">    fred: &#123; age: 40, active: false &#125;,</span><br><span class="line">    pebbles: &#123; age: 1, active: true &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  o &#x3D;&gt; o[&#39;active&#39;]</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; &#39;barney&#39;</span><br></pre></td></tr></table></figure>

<h1 id="38、findLast-important"><a href="#38、findLast-important" class="headerlink" title="38、findLast (important)"></a><strong>38、findLast</strong> (important)</h1><p>按照给定的函数条件筛选数组，将最后一个满足条件的元素进行删除。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const findLast &#x3D; (arr, fn) &#x3D;&gt; arr.filter(fn).pop();</span><br><span class="line"></span><br><span class="line">findLast([1, 2, 3, 4], n &#x3D;&gt; n % 2 &#x3D;&#x3D;&#x3D; 1); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<h1 id="39、flatten-important"><a href="#39、flatten-important" class="headerlink" title="39、flatten (important)"></a><strong>39、flatten</strong> (important)</h1><p>按照指定数组的深度，将嵌套数组进行展平。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flatten &#x3D; (arr, depth &#x3D; 1) &#x3D;&gt;</span><br><span class="line">  arr.reduce((a, v) &#x3D;&gt; a.concat(depth &gt; 1 &amp;&amp; Array.isArray(v) ? flatten(v, depth - 1) : v), []);</span><br><span class="line"></span><br><span class="line">flatten([1, [2], 3, 4]); &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line">flatten([1, [2, [3, [4, 5], 6], 7], 8], 2); &#x2F;&#x2F; [1, 2, 3, [4, 5], 6, 7, 8]</span><br></pre></td></tr></table></figure>

<h1 id="40、forEachRight"><a href="#40、forEachRight" class="headerlink" title="40、forEachRight"></a><strong>40、forEachRight</strong></h1><p>按照给定的函数条件，从数组的右边往左依次进行执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const forEachRight &#x3D; (arr, callback) &#x3D;&gt;</span><br><span class="line">  arr</span><br><span class="line">    .slice(0)</span><br><span class="line">    .reverse()</span><br><span class="line">    .forEach(callback);</span><br><span class="line">    </span><br><span class="line">forEachRight([1, 2, 3, 4], val &#x3D;&gt; console.log(val)); &#x2F;&#x2F; &#39;4&#39;, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;</span><br></pre></td></tr></table></figure>

<h1 id="41、forOwn"><a href="#41、forOwn" class="headerlink" title="41、forOwn"></a><strong>41、forOwn</strong></h1><p>此段代码按照给定的函数条件，支持三个参数作为输入（值、键、对象本身），进行迭代对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const forOwn &#x3D; (obj, fn) &#x3D;&gt; Object.keys(obj).forEach(key &#x3D;&gt; fn(obj[key], key, obj));</span><br><span class="line">forOwn(&#123; foo: &#39;bar&#39;, a: 1 &#125;, v &#x3D;&gt; console.log(v));</span><br><span class="line">&#x2F;&#x2F; &#39;bar&#39;, 1</span><br></pre></td></tr></table></figure>

<h1 id="42、functionName"><a href="#42、functionName" class="headerlink" title="42、functionName"></a><strong>42、functionName</strong></h1><p>此段代码输出函数的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const functionName &#x3D; fn &#x3D;&gt; (console.debug(fn.name), fn);</span><br><span class="line"></span><br><span class="line">functionName(Math.max); &#x2F;&#x2F; max (logged in debug channel of console)</span><br></pre></td></tr></table></figure>

<h1 id="43、getColonTimeFromDate"><a href="#43、getColonTimeFromDate" class="headerlink" title="43、getColonTimeFromDate"></a><strong>43、getColonTimeFromDate</strong></h1><p>此段代码从Date对象里获取当前时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getColonTimeFromDate &#x3D; date &#x3D;&gt; date.toTimeString().slice(0, 8);</span><br><span class="line">getColonTimeFromDate(new Date()); &#x2F;&#x2F; &quot;08:38:00&quot;</span><br></pre></td></tr></table></figure>

<h1 id="44、getDaysDiffBetweenDates-important"><a href="#44、getDaysDiffBetweenDates-important" class="headerlink" title="44、getDaysDiffBetweenDates (important)"></a><strong>44、getDaysDiffBetweenDates</strong> (important)</h1><p>此段代码返回两个日期之间相差多少天。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getDaysDiffBetweenDates &#x3D; (dateInitial, dateFinal) &#x3D;&gt;</span><br><span class="line">  (dateFinal - dateInitial) &#x2F; (1000 * 3600 * 24);</span><br><span class="line">  </span><br><span class="line">getDaysDiffBetweenDates(new Date(&#39;2019-01-13&#39;), new Date(&#39;2019-01-15&#39;)); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h1 id="45、getStyle"><a href="#45、getStyle" class="headerlink" title="45、getStyle"></a><strong>45、getStyle</strong></h1><p>此代码返回DOM元素节点对应的属性值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getStyle &#x3D; (el, ruleName) &#x3D;&gt; getComputedStyle(el)[ruleName];</span><br><span class="line"></span><br><span class="line">getStyle(document.querySelector(&#39;p&#39;), &#39;font-size&#39;); &#x2F;&#x2F; &#39;16px&#39;</span><br></pre></td></tr></table></figure>

<h1 id="46、getType-important"><a href="#46、getType-important" class="headerlink" title="46、getType (important)"></a><strong>46、getType</strong> (important)</h1><p>此段代码的主要功能就是返回数据的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getType &#x3D; v &#x3D;&gt;</span><br><span class="line">  v &#x3D;&#x3D;&#x3D; undefined ? &#39;undefined&#39; : v &#x3D;&#x3D;&#x3D; null ? &#39;null&#39; : v.constructor.name.toLowerCase();</span><br><span class="line">  </span><br><span class="line">getType(new Set([1, 2, 3])); &#x2F;&#x2F; &#39;set&#39;</span><br></pre></td></tr></table></figure>

<h1 id="47、hasClass"><a href="#47、hasClass" class="headerlink" title="47、hasClass"></a><strong>47、hasClass</strong></h1><p>此段代码返回DOM元素是否包含指定的Class样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hasClass &#x3D; (el, className) &#x3D;&gt; el.classList.contains(className);</span><br><span class="line">hasClass(document.querySelector(&#39;p.special&#39;), &#39;special&#39;); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="48、head"><a href="#48、head" class="headerlink" title="48、head"></a><strong>48、head</strong></h1><p>此段代码输出数组的第一个元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const head &#x3D; arr &#x3D;&gt; arr[0];</span><br><span class="line"></span><br><span class="line">head([1, 2, 3]); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<h1 id="49、hide"><a href="#49、hide" class="headerlink" title="49、hide"></a><strong>49、hide</strong></h1><p>此段代码隐藏指定的DOM元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hide &#x3D; (...el) &#x3D;&gt; [...el].forEach(e &#x3D;&gt; (e.style.display &#x3D; &#39;none&#39;));</span><br><span class="line"></span><br><span class="line">hide(document.querySelectorAll(&#39;img&#39;)); &#x2F;&#x2F; Hides all &lt;img&gt; elements on the page</span><br></pre></td></tr></table></figure>

<h1 id="50、httpsRedirect"><a href="#50、httpsRedirect" class="headerlink" title="50、httpsRedirect"></a><strong>50、httpsRedirect</strong></h1><p>此段代码的功能就是将http网址重定向https网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const httpsRedirect &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  if (location.protocol !&#x3D;&#x3D; &#39;https:&#39;) location.replace(&#39;https:&#x2F;&#x2F;&#39; + location.href.split(&#39;&#x2F;&#x2F;&#39;)[1]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">httpsRedirect(); </span><br><span class="line">&#x2F;&#x2F; If you are on http:&#x2F;&#x2F;mydomain.com, you are redirected to https:&#x2F;&#x2F;mydomain.com</span><br></pre></td></tr></table></figure>

<h1 id="51、indexOfAll-important"><a href="#51、indexOfAll-important" class="headerlink" title="51、indexOfAll (important)"></a><strong>51、indexOfAll</strong> (important)</h1><p>此代码可以返回数组中某个值对应的所有索引值，如果不包含该值，则返回一个空数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const indexOfAll &#x3D; (arr, val) &#x3D;&gt; arr.reduce((acc, el, i) &#x3D;&gt; (el &#x3D;&#x3D;&#x3D; val ? [...acc, i] : acc), []);</span><br><span class="line"></span><br><span class="line">indexOfAll([1, 2, 3, 1, 2, 3], 1); &#x2F;&#x2F; [0,3]</span><br><span class="line">indexOfAll([1, 2, 3], 4); &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<h1 id="52、initial-important"><a href="#52、initial-important" class="headerlink" title="52、initial (important)"></a><strong>52、initial</strong> (important)</h1><p>此段代码返回数组中除最后一个元素的所有元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const initial &#x3D; arr &#x3D;&gt; arr.slice(0, -1);</span><br><span class="line"></span><br><span class="line">initial([1, 2, 3]); &#x2F;&#x2F; [1,2]const initial &#x3D; arr &#x3D;&gt; arr.slice(0, -1);</span><br><span class="line">initial([1, 2, 3]); &#x2F;&#x2F; [1,2]</span><br></pre></td></tr></table></figure>

<h1 id="53、insertAfter"><a href="#53、insertAfter" class="headerlink" title="53、insertAfter"></a><strong>53、insertAfter</strong></h1><p>此段代码的功能主要是在给定的DOM节点后插入新的节点内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const insertAfter &#x3D; (el, htmlString) &#x3D;&gt; el.insertAdjacentHTML(&#39;afterend&#39;, htmlString);</span><br><span class="line"></span><br><span class="line">insertAfter(document.getElementById(&#39;myId&#39;), &#39;&lt;p&gt;after&lt;&#x2F;p&gt;&#39;); &#x2F;&#x2F; &lt;div id&#x3D;&quot;myId&quot;&gt;...&lt;&#x2F;div&gt; &lt;p&gt;after&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h1 id="54、insertBefore"><a href="#54、insertBefore" class="headerlink" title="54、insertBefore"></a><strong>54、insertBefore</strong></h1><p>此段代码的功能主要是在给定的DOM节点前插入新的节点内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const insertBefore &#x3D; (el, htmlString) &#x3D;&gt; el.insertAdjacentHTML(&#39;beforebegin&#39;, htmlString);</span><br><span class="line"></span><br><span class="line">insertBefore(document.getElementById(&#39;myId&#39;), &#39;&lt;p&gt;before&lt;&#x2F;p&gt;&#39;); &#x2F;&#x2F; &lt;p&gt;before&lt;&#x2F;p&gt; &lt;div id&#x3D;&quot;myId&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="55、intersection-important"><a href="#55、intersection-important" class="headerlink" title="55、intersection (important)"></a><strong>55、intersection</strong> (important)</h1><p>此段代码返回两个数组元素之间的交集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const intersection &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  const s &#x3D; new Set(b);</span><br><span class="line">  return a.filter(x &#x3D;&gt; s.has(x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">intersection([1, 2, 3], [4, 3, 2]); &#x2F;&#x2F; [2, 3]</span><br></pre></td></tr></table></figure>

<h1 id="56、intersectionBy-important"><a href="#56、intersectionBy-important" class="headerlink" title="56、intersectionBy (important)"></a><strong>56、intersectionBy</strong> (important)</h1><p>按照给定的函数处理需要对比的数组元素，然后根据处理后的数组，找出交集，最后从第一个数组中将对应的元素输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const intersectionBy &#x3D; (a, b, fn) &#x3D;&gt; &#123;</span><br><span class="line">  const s &#x3D; new Set(b.map(fn));</span><br><span class="line">  return a.filter(x &#x3D;&gt; s.has(fn(x)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); &#x2F;&#x2F; [2.1]</span><br></pre></td></tr></table></figure>

<h1 id="57、intersectionBy"><a href="#57、intersectionBy" class="headerlink" title="57、intersectionBy"></a><strong>57、intersectionBy</strong></h1><p>按照给定的函数对比两个数组的差异，然后找出交集，最后从第一个数组中将对应的元素输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const intersectionWith &#x3D; (a, b, comp) &#x3D;&gt; a.filter(x &#x3D;&gt; b.findIndex(y &#x3D;&gt; comp(x, y)) !&#x3D;&#x3D; -1);</span><br><span class="line"></span><br><span class="line">intersectionWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) &#x3D;&gt; Math.round(a) &#x3D;&#x3D;&#x3D; Math.round(b)); &#x2F;&#x2F; [1.5, 3, 0]</span><br></pre></td></tr></table></figure>

<h1 id="58、is"><a href="#58、is" class="headerlink" title="58、is"></a><strong>58、is</strong></h1><p>此段代码用于判断数据是否为指定的数据类型，如果是则返回true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const is &#x3D; (type, val) &#x3D;&gt; ![, null].includes(val) &amp;&amp; val.constructor &#x3D;&#x3D;&#x3D; type;</span><br><span class="line"></span><br><span class="line">is(Array, [1]); &#x2F;&#x2F; true</span><br><span class="line">is(ArrayBuffer, new ArrayBuffer()); &#x2F;&#x2F; true</span><br><span class="line">is(Map, new Map()); &#x2F;&#x2F; true</span><br><span class="line">is(RegExp, &#x2F;.&#x2F;g); &#x2F;&#x2F; true</span><br><span class="line">is(Set, new Set()); &#x2F;&#x2F; true</span><br><span class="line">is(WeakMap, new WeakMap()); &#x2F;&#x2F; true</span><br><span class="line">is(WeakSet, new WeakSet()); &#x2F;&#x2F; true</span><br><span class="line">is(String, &#39;&#39;); &#x2F;&#x2F; true</span><br><span class="line">is(String, new String(&#39;&#39;)); &#x2F;&#x2F; true</span><br><span class="line">is(Number, 1); &#x2F;&#x2F; true</span><br><span class="line">is(Number, new Number(1)); &#x2F;&#x2F; true</span><br><span class="line">is(Boolean, true); &#x2F;&#x2F; true</span><br><span class="line">is(Boolean, new Boolean(true)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="59、isAfterDate-important"><a href="#59、isAfterDate-important" class="headerlink" title="59、isAfterDate (important)"></a><strong>59、isAfterDate</strong> (important)</h1><p>接收两个日期类型的参数，判断前者的日期是否晚于后者的日期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isAfterDate &#x3D; (dateA, dateB) &#x3D;&gt; dateA &gt; dateB;</span><br><span class="line"></span><br><span class="line">isAfterDate(new Date(2010, 10, 21), new Date(2010, 10, 20)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="60、isAnagram"><a href="#60、isAnagram" class="headerlink" title="60、isAnagram"></a><strong>60、isAnagram</strong></h1><p>用于检测两个单词是否相似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isAnagram &#x3D; (str1, str2) &#x3D;&gt; &#123;</span><br><span class="line">  const normalize &#x3D; str &#x3D;&gt;</span><br><span class="line">    str</span><br><span class="line">      .toLowerCase()</span><br><span class="line">      .replace(&#x2F;[^a-z0-9]&#x2F;gi, &#39;&#39;)</span><br><span class="line">      .split(&#39;&#39;)</span><br><span class="line">      .sort()</span><br><span class="line">      .join(&#39;&#39;);</span><br><span class="line">  return normalize(str1) &#x3D;&#x3D;&#x3D; normalize(str2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">isAnagram(&#39;iceman&#39;, &#39;cinema&#39;); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="61、isArrayLike"><a href="#61、isArrayLike" class="headerlink" title="61、isArrayLike"></a><strong>61、isArrayLike</strong></h1><p>此段代码用于检测对象是否为类数组对象,是否可迭代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isArrayLike &#x3D; obj &#x3D;&gt; obj !&#x3D; null &amp;&amp; typeof obj[Symbol.iterator] &#x3D;&#x3D;&#x3D; &#39;function&#39;;</span><br><span class="line"></span><br><span class="line">isArrayLike(document.querySelectorAll(&#39;.className&#39;)); &#x2F;&#x2F; true</span><br><span class="line">isArrayLike(&#39;abc&#39;); &#x2F;&#x2F; true</span><br><span class="line">isArrayLike(null); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="62、isBeforeDate"><a href="#62、isBeforeDate" class="headerlink" title="62、isBeforeDate"></a><strong>62、isBeforeDate</strong></h1><p>接收两个日期类型的参数，判断前者的日期是否早于后者的日期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isBeforeDate &#x3D; (dateA, dateB) &#x3D;&gt; dateA &lt; dateB;</span><br><span class="line"></span><br><span class="line">isBeforeDate(new Date(2010, 10, 20), new Date(2010, 10, 21)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="63、isBoolean"><a href="#63、isBoolean" class="headerlink" title="63、isBoolean"></a><strong>63、isBoolean</strong></h1><p>此段代码用于检查参数是否为布尔类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isBoolean &#x3D; val &#x3D;&gt; typeof val &#x3D;&#x3D;&#x3D; &#39;boolean&#39;;</span><br><span class="line">isBoolean(null); &#x2F;&#x2F; false</span><br><span class="line">isBoolean(false); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="64、getColonTimeFromDate"><a href="#64、getColonTimeFromDate" class="headerlink" title="64、getColonTimeFromDate"></a><strong>64、getColonTimeFromDate</strong></h1><p>用于判断程序运行环境是否在浏览器，这有助于避免在node环境运行前端模块时出错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isBrowser &#x3D; () &#x3D;&gt; ![typeof window, typeof document].includes(&#39;undefined&#39;);</span><br><span class="line"></span><br><span class="line">isBrowser(); &#x2F;&#x2F; true (browser)</span><br><span class="line">isBrowser(); &#x2F;&#x2F; false (Node)</span><br></pre></td></tr></table></figure>

<h1 id="65、isBrowserTabFocused"><a href="#65、isBrowserTabFocused" class="headerlink" title="65、isBrowserTabFocused"></a><strong>65、isBrowserTabFocused</strong></h1><p>用于判断当前页面是否处于活动状态（显示状态）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isBrowserTabFocused &#x3D; () &#x3D;&gt; !document.hidden;</span><br><span class="line">isBrowserTabFocused(); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="66、isLowerCase"><a href="#66、isLowerCase" class="headerlink" title="66、isLowerCase"></a><strong>66、isLowerCase</strong></h1><p>用于判断当前字符串是否都为小写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isLowerCase &#x3D; str &#x3D;&gt; str &#x3D;&#x3D;&#x3D; str.toLowerCase();</span><br><span class="line"></span><br><span class="line">isLowerCase(&#39;abc&#39;); &#x2F;&#x2F; true</span><br><span class="line">isLowerCase(&#39;a3@$&#39;); &#x2F;&#x2F; true</span><br><span class="line">isLowerCase(&#39;Ab4&#39;); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="67、isNil"><a href="#67、isNil" class="headerlink" title="67、isNil"></a><strong>67、isNil</strong></h1><p>用于判断当前变量的值是否为 null 或 undefined 类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isNil &#x3D; val &#x3D;&gt; val &#x3D;&#x3D;&#x3D; undefined || val &#x3D;&#x3D;&#x3D; null;</span><br><span class="line"></span><br><span class="line">isNil(null); &#x2F;&#x2F; true</span><br><span class="line">isNil(undefined); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="68、isNull"><a href="#68、isNull" class="headerlink" title="68、isNull"></a><strong>68、isNull</strong></h1><p>用于判断当前变量的值是否为 null 类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isNull &#x3D; val &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null;</span><br><span class="line"></span><br><span class="line">isNull(null); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="69、isNumber"><a href="#69、isNumber" class="headerlink" title="69、isNumber"></a><strong>69、isNumber</strong></h1><p>用于检查当前的值是否为数字类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isNumber(n) &#123;</span><br><span class="line">    return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNumber(&#39;1&#39;); &#x2F;&#x2F; false</span><br><span class="line">isNumber(1); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="70、isObject"><a href="#70、isObject" class="headerlink" title="70、isObject"></a><strong>70、isObject</strong></h1><p>用于判断参数的值是否是对象，这里运用了Object 构造函数创建一个对象包装器，如果是对象类型，将会原值返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isObject &#x3D; obj &#x3D;&gt; obj &#x3D;&#x3D;&#x3D; Object(obj);</span><br><span class="line"></span><br><span class="line">isObject([1, 2, 3, 4]); &#x2F;&#x2F; true</span><br><span class="line">isObject([]); &#x2F;&#x2F; true</span><br><span class="line">isObject([&#39;Hello!&#39;]); &#x2F;&#x2F; true</span><br><span class="line">isObject(&#123; a: 1 &#125;); &#x2F;&#x2F; true</span><br><span class="line">isObject(&#123;&#125;); &#x2F;&#x2F; true</span><br><span class="line">isObject(true); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="71、isObjectLike"><a href="#71、isObjectLike" class="headerlink" title="71、isObjectLike"></a><strong>71、isObjectLike</strong></h1><p>用于检查参数的值是否为null以及类型是否为对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isObjectLike &#x3D; val &#x3D;&gt; val !&#x3D;&#x3D; null &amp;&amp; typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39;;</span><br><span class="line"></span><br><span class="line">isObjectLike(&#123;&#125;); &#x2F;&#x2F; true</span><br><span class="line">isObjectLike([1, 2, 3]); &#x2F;&#x2F; true</span><br><span class="line">isObjectLike(x &#x3D;&gt; x); &#x2F;&#x2F; false</span><br><span class="line">isObjectLike(null); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="72、isPlainObject"><a href="#72、isPlainObject" class="headerlink" title="72、isPlainObject"></a><strong>72、isPlainObject</strong></h1><p>此代码段检查参数的值是否是由Object构造函数创建的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isPlainObject &#x3D; val &#x3D;&gt; !!val &amp;&amp; typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; val.constructor &#x3D;&#x3D;&#x3D; Object;</span><br><span class="line"></span><br><span class="line">isPlainObject(&#123; a: 1 &#125;); &#x2F;&#x2F; true</span><br><span class="line">isPlainObject(new Map()); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="73、isPromiseLike"><a href="#73、isPromiseLike" class="headerlink" title="73、isPromiseLike"></a><strong>73、isPromiseLike</strong></h1><p>用于检查当前的对象是否类似Promise函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onst isPromiseLike &#x3D; obj &#x3D;&gt;</span><br><span class="line">  obj !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">  (typeof obj &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof obj &#x3D;&#x3D;&#x3D; &#39;function&#39;) &amp;&amp;</span><br><span class="line">  typeof obj.then &#x3D;&#x3D;&#x3D; &#39;function&#39;;</span><br><span class="line">  </span><br><span class="line">isPromiseLike(&#123;</span><br><span class="line">  then: function() &#123;</span><br><span class="line">    return &#39;&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;); &#x2F;&#x2F; true</span><br><span class="line">isPromiseLike(null); &#x2F;&#x2F; false</span><br><span class="line">isPromiseLike(&#123;&#125;); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="74、isSameDate-important"><a href="#74、isSameDate-important" class="headerlink" title="74、isSameDate (important)"></a><strong>74、isSameDate</strong> (important)</h1><p>用于判断给定的两个日期是否是同一天。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isSameDate &#x3D; (dateA, dateB) &#x3D;&gt; dateA.toISOString() &#x3D;&#x3D;&#x3D; dateB.toISOString();</span><br><span class="line"></span><br><span class="line">isSameDate(new Date(2010, 10, 20), new Date(2010, 10, 20)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="75、isString"><a href="#75、isString" class="headerlink" title="75、isString"></a><strong>75、isString</strong></h1><p>用于检查当前的值是否为字符串类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isString &#x3D; val &#x3D;&gt; typeof val &#x3D;&#x3D;&#x3D; &#39;string&#39;;</span><br><span class="line"></span><br><span class="line">isString(&#39;10&#39;); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="76、isSymbol"><a href="#76、isSymbol" class="headerlink" title="76、isSymbol"></a><strong>76、isSymbol</strong></h1><p>用于判断参数的值是否是 Symbol 类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isSymbol &#x3D; val &#x3D;&gt; typeof val &#x3D;&#x3D;&#x3D; &#39;symbol&#39;;</span><br><span class="line"></span><br><span class="line">isSymbol(Symbol(&#39;x&#39;)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="77、isUndefined"><a href="#77、isUndefined" class="headerlink" title="77、isUndefined"></a><strong>77、isUndefined</strong></h1><p>用于判断参数的类型是否是 Undefined 类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isUndefined &#x3D; val &#x3D;&gt; val &#x3D;&#x3D;&#x3D; undefined;</span><br><span class="line"></span><br><span class="line">isUndefined(undefined); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="78、isUpperCase"><a href="#78、isUpperCase" class="headerlink" title="78、isUpperCase"></a><strong>78、isUpperCase</strong></h1><p>用于判断当前字符串的字母是否都为大写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isUpperCase &#x3D; str &#x3D;&gt; str &#x3D;&#x3D;&#x3D; str.toUpperCase();</span><br><span class="line"></span><br><span class="line">isUpperCase(&#39;ABC&#39;); &#x2F;&#x2F; true</span><br><span class="line">isLowerCase(&#39;A3@$&#39;); &#x2F;&#x2F; true</span><br><span class="line">isLowerCase(&#39;aB4&#39;); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="79、isValidJSON"><a href="#79、isValidJSON" class="headerlink" title="79、isValidJSON"></a><strong>79、isValidJSON</strong></h1><p>用于判断给定的字符串是否是 JSON 字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isValidJSON &#x3D; str &#x3D;&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    JSON.parse(str);</span><br><span class="line">    return true;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">isValidJSON(&#39;&#123;&quot;name&quot;:&quot;Adam&quot;,&quot;age&quot;:20&#125;&#39;); &#x2F;&#x2F; true</span><br><span class="line">isValidJSON(&#39;&#123;&quot;name&quot;:&quot;Adam&quot;,age:&quot;20&quot;&#125;&#39;); &#x2F;&#x2F; false</span><br><span class="line">isValidJSON(null); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h1 id="80、last"><a href="#80、last" class="headerlink" title="80、last"></a><strong>80、last</strong></h1><p>此函数功能返回数组的最后一个元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const last &#x3D; arr &#x3D;&gt; arr[arr.length - 1];</span><br><span class="line"></span><br><span class="line">last([1, 2, 3]); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<h1 id="81、matches"><a href="#81、matches" class="headerlink" title="81、matches"></a><strong>81、matches</strong></h1><p>此函数功能用于比较两个对象，以确定第一个对象是否包含与第二个对象相同的属性与值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const matches &#x3D; (obj, source) &#x3D;&gt;</span><br><span class="line">  Object.keys(source).every(key &#x3D;&gt; obj.hasOwnProperty(key) &amp;&amp; obj[key] &#x3D;&#x3D;&#x3D; source[key]);</span><br><span class="line">  </span><br><span class="line">matches(&#123; age: 25, hair: &#39;long&#39;, beard: true &#125;, &#123; hair: &#39;long&#39;, beard: true &#125;); &#x2F;&#x2F; true</span><br><span class="line">matches(&#123; hair: &#39;long&#39;, beard: true &#125;, &#123; age: 25, hair: &#39;long&#39;, beard: true &#125;); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="82、maxDate"><a href="#82、maxDate" class="headerlink" title="82、maxDate"></a><strong>82、maxDate</strong></h1><p>此代码段查找日期数组中最大的日期进行输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const maxDate &#x3D; (...dates) &#x3D;&gt; new Date(Math.max.apply(null, ...dates));</span><br><span class="line"></span><br><span class="line">const array &#x3D; [</span><br><span class="line">  new Date(2017, 4, 13),</span><br><span class="line">  new Date(2018, 2, 12),</span><br><span class="line">  new Date(2016, 0, 10),</span><br><span class="line">  new Date(2016, 0, 9)</span><br><span class="line">];</span><br><span class="line">maxDate(array); &#x2F;&#x2F; 2018-03-11T22:00:00.000Z</span><br></pre></td></tr></table></figure>

<h1 id="83、maxN"><a href="#83、maxN" class="headerlink" title="83、maxN"></a><strong>83、maxN</strong></h1><p>此段代码输出数组中前 n 位最大的数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const maxN &#x3D; (arr, n &#x3D; 1) &#x3D;&gt; [...arr].sort((a, b) &#x3D;&gt; b - a).slice(0, n);</span><br><span class="line"></span><br><span class="line">maxN([1, 2, 3]); &#x2F;&#x2F; [3]</span><br><span class="line">maxN([1, 2, 3], 2); &#x2F;&#x2F; [3,2]</span><br></pre></td></tr></table></figure>

<h1 id="84、minDate"><a href="#84、minDate" class="headerlink" title="84、minDate"></a><strong>84、minDate</strong></h1><p>此代码段查找日期数组中最早的日期进行输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const minDate &#x3D; (...dates) &#x3D;&gt; new Date(Math.min.apply(null, ...dates));</span><br><span class="line"></span><br><span class="line">const array &#x3D; [</span><br><span class="line">  new Date(2017, 4, 13),</span><br><span class="line">  new Date(2018, 2, 12),</span><br><span class="line">  new Date(2016, 0, 10),</span><br><span class="line">  new Date(2016, 0, 9)</span><br><span class="line">];</span><br><span class="line">minDate(array); &#x2F;&#x2F; 2016-01-08T22:00:00.000Z</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
        <tag>代码片段</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>js之Math</title>
    <url>/2020/09/23/js%E4%B9%8BMath/</url>
    <content><![CDATA[<h2 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h2><a id="more"></a>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_abs.asp" target="_blank" rel="noopener">abs(x)</a></td>
<td align="left">返回数的绝对值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_acos.asp" target="_blank" rel="noopener">acos(x)</a></td>
<td align="left">返回数的反余弦值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_asin.asp" target="_blank" rel="noopener">asin(x)</a></td>
<td align="left">返回数的反正弦值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_atan.asp" target="_blank" rel="noopener">atan(x)</a></td>
<td align="left">以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_atan2.asp" target="_blank" rel="noopener">atan2(y,x)</a></td>
<td align="left">返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_ceil.asp" target="_blank" rel="noopener">ceil(x)</a></td>
<td align="left">对数进行上舍入。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_cos.asp" target="_blank" rel="noopener">cos(x)</a></td>
<td align="left">返回数的余弦。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_exp.asp" target="_blank" rel="noopener">exp(x)</a></td>
<td align="left">返回 e 的指数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_floor.asp" target="_blank" rel="noopener">floor(x)</a></td>
<td align="left">对数进行下舍入。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_log.asp" target="_blank" rel="noopener">log(x)</a></td>
<td align="left">返回数的自然对数（底为e）。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_max.asp" target="_blank" rel="noopener">max(x,y)</a></td>
<td align="left">返回 x 和 y 中的最高值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_min.asp" target="_blank" rel="noopener">min(x,y)</a></td>
<td align="left">返回 x 和 y 中的最低值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_pow.asp" target="_blank" rel="noopener">pow(x,y)</a></td>
<td align="left">返回 x 的 y 次幂。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_random.asp" target="_blank" rel="noopener">random()</a></td>
<td align="left">返回 0 ~ 1 之间的随机数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_round.asp" target="_blank" rel="noopener">round(x)</a></td>
<td align="left">把数四舍五入为最接近的整数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_sin.asp" target="_blank" rel="noopener">sin(x)</a></td>
<td align="left">返回数的正弦。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_sqrt.asp" target="_blank" rel="noopener">sqrt(x)</a></td>
<td align="left">返回数的平方根。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_tan.asp" target="_blank" rel="noopener">tan(x)</a></td>
<td align="left">返回角的正切。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_tosource_math.asp" target="_blank" rel="noopener">toSource()</a></td>
<td align="left">返回该对象的源代码。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_valueof_math.asp" target="_blank" rel="noopener">valueOf()</a></td>
<td align="left">返回 Math 对象的原始值。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>js之call和apply</title>
    <url>/2020/09/14/js%E4%B9%8Bcall%E5%92%8Capply/</url>
    <content><![CDATA[<h3 id="是做啥的"><a href="#是做啥的" class="headerlink" title="是做啥的"></a>是做啥的</h3><p>call()、apply()、bind()是用来改变this的指向的。</p>
<h3 id="call和apply的区别和用法"><a href="#call和apply的区别和用法" class="headerlink" title="call和apply的区别和用法"></a>call和apply的区别和用法</h3><h4 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h4><p>obj.call(thisObj, arg1, arg2, …);<br>obj.apply(thisObj, [arg1, arg2, …]);<br>call和apply作用都是把obj绑定到thisObj的作用，即改变this的指向，然而唯一的区别就是apply传递的参数必须得是数组的形式传递，而call则直接连续参数传递</p>
<a id="more"></a>

<h4 id="call和apply在什么地方可以用到呢？"><a href="#call和apply在什么地方可以用到呢？" class="headerlink" title="call和apply在什么地方可以用到呢？"></a>call和apply在什么地方可以用到呢？</h4><p>当一个对象需要调用另外一个对象里面的方法的时候就可以用到call和apply，call和Apply可以理解成是继承另外一个对象的方法，以下代码举例：</p>
<p>首先，我们先建立两个对象，obj1和obj2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var name &#x3D; &quot;全局中的name&quot;;</span><br><span class="line">    var obj1 &#x3D; &#123;</span><br><span class="line">        name:&quot;obj1中的name&quot;,</span><br><span class="line">        func1:function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        func2:function (a,b) &#123;</span><br><span class="line">            console.log(a+b);</span><br><span class="line">            return a+b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">	name:&quot;obj2中的name&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.func1.call(this);&#x2F;&#x2F;输出：全局中的name</span><br><span class="line">obj1.func1.apply(this);&#x2F;&#x2F;输出：全局中的name</span><br><span class="line"></span><br><span class="line">obj1.func1.call(obj2); &#x2F;&#x2F;输出：obj2中的name</span><br><span class="line">obj1.func1.apply(obj2);&#x2F;&#x2F;输出：obj2中的name</span><br><span class="line"></span><br><span class="line">obj1.func2.call(obj2,1,2);&#x2F;&#x2F;输出：3</span><br><span class="line">obj1.func2.apply(obj2,[1,2]);&#x2F;&#x2F;输出：3</span><br></pre></td></tr></table></figure>



<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>一个叫喵喵的猫喜欢吃鱼，一个叫汪汪的小狗喜欢啃骨头，用代码实现如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var cat = &#123;</span><br><span class="line">  name:"喵喵",</span><br><span class="line">  eatFish:function(param1,param2)&#123;</span><br><span class="line">    console.log("吃鱼");</span><br><span class="line">	console.log("this的指向=&gt;");</span><br><span class="line">	console.log(this);</span><br><span class="line">	console.log(param1,param2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog = &#123;</span><br><span class="line">	name:"汪汪",</span><br><span class="line">	eatBone:function(param1,param2)&#123;</span><br><span class="line">		console.log("啃骨头");</span><br><span class="line">		console.log("this的指向=&gt;");</span><br><span class="line">		console.log(this);</span><br><span class="line">		console.log(param1,param2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一天，小狗汪汪和喵喵共进午餐的时候，汪汪说自己想尝尝小鱼干的味道，但是因为有刺，喵喵就想了个办法，说自己先吃，完了喂给汪汪</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//第一种，用call方法</span><br><span class="line">cat.eatFish.call(dog,"旺财-13岁","call");</span><br><span class="line"></span><br><span class="line">//第二种，用apply方法，参数不一样</span><br><span class="line">cat.eatFish.apply(dog,["旺财-13岁","apply"]);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180517112432197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNzYwOTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>这样，汪汪就吃到了美味的鱼干。可是汪汪每吨都想来点小鱼干，喵喵还要工作去捉老鼠，所以它们又想了一个办法，喵喵把吃鱼的方法教给汪汪。这样，每次汪汪就可以自己吃小鱼干了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var eatFishFun = cat.eatFish.bind(dog,"旺财-13岁","bind"); //返回的是方法</span><br><span class="line">eatFishFun();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180517112744838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNzYwOTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>bind()方法在这里再多说一下，bind的时候传的参数会预先传给返回的方法，调用方法时就不用再传参数了。</p>
<p>撇开上面的例子，看看一个特殊情况：</p>
<p>如果call()和apply()的第一个参数是null或者undefined，那么this的指向就是全局变量，在浏览器里就是window对象。</p>
<p><img src="https://img-blog.csdn.net/2018051715053339?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNzYwOTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>apply</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">89</span>,<span class="number">46</span>]</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(arr)<span class="comment">//89</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title>js之loadshJs</title>
    <url>/2020/10/09/js%E4%B9%8BloadshJs/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Lodash是一个著名的javascript原生库，不需要引入其他第三方依赖。是一个意在提高开发者效率,提高JS原生方法性能的JS库。简单的说就是，很多方法lodash已经帮你写好了，直接调用就行，不用自己费尽心思去写了，而且可以统一方法的一致性。Lodash使用了一个简单的 _ 符号，就像Jquery的 $ 一样，十分简洁。<br> 类似的还有Underscore.js和Lazy.js</p>
<h4 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h4><p>chrome 43往上<br> Firefox 38往上<br> IE 6-11<br> MS Edge<br> Safari 5往上<br> （几乎涵盖现在市面上可以见到的大部分浏览器）</p>
<h4 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h4><a id="more"></a>

<h5 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h5><script src="lodash.js"></script> 直接下载下来引入，或者使用cdn

<h6 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i -g npm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm i --save lodash</span></span><br></pre></td></tr></table></figure>

<p>先全局安装，在单独安装到项目中</p>
<h6 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h6><p><code>var _ = require(&#39;lodash&#39;);</code></p>
<h4 id="为什么使用lodash"><a href="#为什么使用lodash" class="headerlink" title="为什么使用lodash"></a>为什么使用lodash</h4><p>通过使用数组，数字，对象，字符串等方法，Lodash使JavaScript变得更简单。</p>
<h4 id="常用lodash函数"><a href="#常用lodash函数" class="headerlink" title="常用lodash函数"></a>常用lodash函数</h4><p>（参考版本lodash v4.16.1）</p>
<h5 id="1、N次循环"><a href="#1、N次循环" class="headerlink" title="1、N次循环"></a>1、N次循环</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- javascript -------'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//js原生的循环方法</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(i);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- lodash -------'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//ladash的times方法</span></span></span><br><span class="line"><span class="actionscript">    _.times(<span class="number">5</span>,<span class="function"><span class="keyword">function</span><span class="params">(a)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(a);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>for</code>语句是执行循环的不二选择，但在上面代码的使用场景下，<code>_.times()</code>的解决方式更加简洁和易于理解。</p>
<h5 id="2、深层查找属性值"><a href="#2、深层查找属性值" class="headerlink" title="2、深层查找属性值"></a>2、深层查找属性值</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ownerArr = [&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"owner"</span>: <span class="string">"Colin"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog1"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog2"</span>&#125;]</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line"><span class="actionscript">        <span class="string">"owner"</span>: <span class="string">"John"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog3"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog4"</span>&#125;]</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> jsMap = ownerArr.map(<span class="function"><span class="keyword">function</span> <span class="params">(owner)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> owner.pets[<span class="number">0</span>].name;</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- jsMap -------'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(jsMap);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> lodashMap = _.map(ownerArr, <span class="string">'pets[0].name'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'------- lodashMap -------'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(lodashMap);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Lodash中的<code>_.map</code>方法和JavaScript中原生的数组方法非常的像，但它还是有非常有用的升级。 你可以通过一个字符串而不是回调函数来浏览深度嵌套的对象属性。</p>
<h5 id="3、深克隆对象"><a href="#3、深克隆对象" class="headerlink" title="3、深克隆对象"></a>3、深克隆对象</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objA = &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="string">"name"</span>: <span class="string">"戈德斯文"</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objB = _.cloneDeep(objA);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objB);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA === objB);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>深度克隆JavaScript对象是困难的，并且也没有什么简单的解决方案。你可以使用原生的解决方案:<code>JSON.parse(JSON.stringify(objectToClone))</code> 进行深度克隆。但是，这种方案仅在对象内部没有方法的时候才可行。</p>
<h5 id="4、在指定范围内获取一个随机值"><a href="#4、在指定范围内获取一个随机值" class="headerlink" title="4、在指定范围内获取一个随机值"></a>4、在指定范围内获取一个随机值</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getRandomNumber</span><span class="params">(min, max)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(getRandomNumber(<span class="number">15</span>, <span class="number">20</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.random(<span class="number">15</span>, <span class="number">20</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Lodash中的 <code>_.random</code> 方法要比上面的原生方法更强大与灵活。你可以只传入一个参数作为最大值， 你也可以指定返回的结果为浮点数<code>_.random(15,20,true)</code></p>
<h5 id="5、扩展对象"><a href="#5、扩展对象" class="headerlink" title="5、扩展对象"></a>5、扩展对象</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;    <span class="comment">//判断被扩展的对象有没有某个属性，</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>[i] = obj[i];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"戈德斯文"</span>, <span class="string">"car"</span>: <span class="string">"宝马"</span>&#125;;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> objB = &#123;<span class="string">"name"</span>: <span class="string">"柴硕"</span>, <span class="string">"loveEat"</span>: <span class="literal">true</span>&#125;;</span></span><br><span class="line"></span><br><span class="line">    objA.extend(objB);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(objA); </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.assign(objA, objB));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>_.assign</code> 方法也可以接收多个参数对象进行扩展，都是往后面的对象上合并</p>
<h5 id="6、从列表中随机的选择列表项"><a href="#6、从列表中随机的选择列表项" class="headerlink" title="6、从列表中随机的选择列表项"></a>6、从列表中随机的选择列表项</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> smartTeam = [<span class="string">"戈德斯文"</span>, <span class="string">"杨海月"</span>, <span class="string">"柴硕"</span>, <span class="string">"师贝贝"</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">randomSmarter</span><span class="params">(smartTeam)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * smartTeam.length);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> smartTeam[index];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(randomSmarter(smartTeam));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Lodash</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.sample(smartTeam));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.sampleSize(smartTeam,<span class="number">2</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外，你也可以指定随机返回元素的个数<code>_.sampleSize(smartTeam,n)</code>，n为需要返回的元素个数</p>
<h5 id="7、判断对象中是否含有某元素"><a href="#7、判断对象中是否含有某元素" class="headerlink" title="7、判断对象中是否含有某元素"></a>7、判断对象中是否含有某元素</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> smartPerson = &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="string">'name'</span>: <span class="string">'戈德斯文'</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">'gender'</span>: <span class="string">'male'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        smartTeam = [<span class="string">"戈德斯文"</span>, <span class="string">"杨海月"</span>, <span class="string">"柴硕"</span>, <span class="string">"师贝贝"</span>];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartPerson, <span class="string">'戈德斯文'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartTeam, <span class="string">'杨海月'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.includes(smartTeam, <span class="string">'杨海月'</span>,<span class="number">2</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>_.includes()</code>第一个参数是需要查询的对象，第二个参数是需要查询的元素，第三个参数是开始查询的下标</p>
<h5 id="8、遍历循环"><a href="#8、遍历循环" class="headerlink" title="8、遍历循环"></a>8、遍历循环</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    _([<span class="number">1</span>, <span class="number">2</span>]).forEach(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(value);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    _.forEach([<span class="number">1</span>, <span class="number">3</span>] , <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(key,value);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两种方法都会分别输出‘1’和‘2’，不仅是数组，对象也可以，数组的是后<code>key</code>是元素的下标，当传入的是对象的时候，<code>key</code>是属性，<code>value</code>是值</p>
<h5 id="9、遍历循环执行某个方法"><a href="#9、遍历循环执行某个方法" class="headerlink" title="9、遍历循环执行某个方法"></a>9、遍历循环执行某个方法</h5><p><code>_.map()</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(n)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> n * n;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map([<span class="number">4</span>, <span class="number">8</span>], square));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [16, 64]</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map(&#123; <span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">8</span> &#125;, square));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [16, 64] (iteration order is not guaranteed)</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> users = [</span></span><br><span class="line"><span class="actionscript">        &#123; <span class="string">'user'</span>: <span class="string">'barney'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">        &#123; <span class="string">'user'</span>: <span class="string">'fred'</span> &#125;</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// The `_.property` iteratee shorthand.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.map(users, <span class="string">'user'</span>));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; ['barney', 'fred']</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="10、检验值是否为空"><a href="#10、检验值是否为空" class="headerlink" title="10、检验值是否为空"></a>10、检验值是否为空</h5><p><code>_.isEmpty()</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    _.isEmpty(<span class="literal">null</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    _.isEmpty(<span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line">    _.isEmpty(1);</span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; true</span></span></span><br><span class="line"></span><br><span class="line">    _.isEmpty([1, 2, 3]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; false</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    _.isEmpty(&#123; <span class="string">'a'</span>: <span class="number">1</span> &#125;);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; false</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="11、查找属性"><a href="#11、查找属性" class="headerlink" title="11、查找属性"></a>11、查找属性</h5><p><code>_.find()</code>、<code>_.filter()</code>、<code>_.reject()</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> users = [</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'barney'</span>, <span class="string">'age'</span>: <span class="number">36</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'fred'</span>, <span class="string">'age'</span>: <span class="number">40</span>, <span class="string">'active'</span>: <span class="literal">false</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;<span class="string">'user'</span>: <span class="string">'pebbles'</span>, <span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> o.age &lt; <span class="number">40</span>;</span></span><br><span class="line">    &#125;));</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, &#123;<span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, &#123;<span class="string">'age'</span>: <span class="number">1</span>, <span class="string">'active'</span>: <span class="literal">true</span>&#125;));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, [<span class="string">'active'</span>, <span class="literal">false</span>]));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, [<span class="string">'active'</span>, <span class="literal">false</span>]));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.find(users, <span class="string">'active'</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.filter(users, <span class="string">'active'</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>_.find()</code>第一个返回真值的第一个元素。<br> <code>_.filter()</code>返回真值的所有元素的数组。<br> <code>_.reject()</code>是<code>_.filter</code>的反向方法，不返回真值的（集合）元素</p>
<h5 id="12、数组去重"><a href="#12、数组去重" class="headerlink" title="12、数组去重"></a>12、数组去重</h5><p><code>_.uniq(array)</code>创建一个去重后的array数组副本。</p>
<p>参数<br> <code>array (Array)</code>: 要检查的数组。</p>
<p>返回新的去重后的数组</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr1 = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr2 = _.uniq(arr1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">unique</span><span class="params">(arr)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> newArr = [];</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></span><br><span class="line">            if(newArr.indexOf(arr[i]) == -1)&#123;</span><br><span class="line">                newArr.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> newArr;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr1);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr2);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(unique(arr1));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>_.uniqBy(array,[iteratee=_.identity])</code>这个方法类似 <code>_.uniq</code>，除了它接受一个 <code>iteratee</code>（迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 调用时会传入一个参数：(value)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.uniqBy([<span class="number">2.1</span>, <span class="number">1.2</span>, <span class="number">2.3</span>], <span class="built_in">Math</span>.floor));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [2.1, 1.2]</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(_.uniqBy([&#123; <span class="string">'x'</span>: <span class="number">1</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">2</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">1</span> &#125;], <span class="string">'x'</span>));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// =&gt; [&#123; 'x': 1 &#125;, &#123; 'x': 2 &#125;]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Math.floor</code>只是向下取整，去重，并没有改变原有的数组，所以还是2.1和1.2，不是2和1。</p>
<h5 id="13、模板插入"><a href="#13、模板插入" class="headerlink" title="13、模板插入"></a>13、模板插入</h5><p><code>_.template([string=&#39;&#39;], [options={}])</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> data = [&#123;name: <span class="string">'戈德斯文'</span>&#125;, &#123;name: <span class="string">'柴硕'</span>&#125;, &#123;name: <span class="string">'杨海月'</span>&#125;];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> t = _.template($(<span class="string">"#tpl"</span>).html());</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#container"</span>).html(t(data));</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    &lt;% _.each(obj,<span class="function"><span class="keyword">function</span><span class="params">(e,i)</span></span>&#123; %&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">e.name</span> %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span> %&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，这个<code>&lt;script&gt;</code>标签的<code>type</code>是<code>text/template</code>，类似于react的JSX的写法，就是js和html可以混写，用<code>&lt;% %&gt;</code>括起来的就是js代码，可以执行，直接写的就是html的标签，并且有类似MVC框架的的数据绑定，在<code>&lt;%= %&gt;</code>中可以调用到数据呈现（纯属个人见解，不知道理解的对不对）</p>
]]></content>
  </entry>
  <entry>
    <title>js之今天是星期几</title>
    <url>/2020/09/09/js%E4%B9%8B%E4%BB%8A%E5%A4%A9%E6%98%AF%E6%98%9F%E6%9C%9F%E5%87%A0/</url>
    <content><![CDATA[<h4 id="初学"><a href="#初学" class="headerlink" title="初学"></a>初学</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    if (date &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        string +&#x3D; &quot;日&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        string +&#x3D; &quot;一&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">        string +&#x3D; &quot;二&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 3) &#123;</span><br><span class="line">        string +&#x3D; &quot;三&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        string +&#x3D; &quot;四&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 5) &#123;</span><br><span class="line">        string +&#x3D; &quot;五&quot;;</span><br><span class="line">    &#125; else if (date &#x3D;&#x3D;&#x3D; 6) &#123;</span><br><span class="line">        string +&#x3D; &quot;六&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    switch (date) &#123;</span><br><span class="line">        case 0 :</span><br><span class="line">            string +&#x3D; &quot;日&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 1 :</span><br><span class="line">            string +&#x3D; &quot;一&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 2 :</span><br><span class="line">            string +&#x3D; &quot;二&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 3 :</span><br><span class="line">            string +&#x3D; &quot;三&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 4 :</span><br><span class="line">            string +&#x3D; &quot;四&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 5 :</span><br><span class="line">            string +&#x3D; &quot;五&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 6 :</span><br><span class="line">            string +&#x3D; &quot;六&quot;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    &#x2F;&#x2F; 使用数组</span><br><span class="line">    let dateArr &#x3D; [ 天 , 一 , 二 , 三 , 四 , 五 , 六 ];</span><br><span class="line">    return string + dateArr[date]</span><br><span class="line">&#125;</span><br><span class="line">console.log(returnWeekday())</span><br><span class="line"></span><br><span class="line">倘若我们的每个 case 是不规律的字符串呢？那我们使用对象，每个 case 为一个 key</span><br><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    &#x2F;&#x2F; 使用对象</span><br><span class="line">    dateObj &#x3D; &#123; </span><br><span class="line">        0:  天 , </span><br><span class="line">        1: &quot;一&quot;, </span><br><span class="line">        2: &quot;二&quot;, </span><br><span class="line">        3: &quot;三&quot;, </span><br><span class="line">        4: &quot;四&quot;, </span><br><span class="line">        5: &quot;五&quot;, </span><br><span class="line">        6: &quot;六&quot;, </span><br><span class="line">    &#125;;</span><br><span class="line">    return string + dateObj[date]</span><br><span class="line">&#125;</span><br><span class="line">console.log(returnWeekday())</span><br><span class="line"></span><br><span class="line">使用 charAt 字符方法</span><br><span class="line">&#x2F;&#x2F; charAt 定位方法</span><br><span class="line">function returnWeekday()&#123;</span><br><span class="line">    return &quot;今天是星期&quot; + &quot;日一二三四五六&quot;.charAt(new Date().getDay());</span><br><span class="line">&#125;</span><br><span class="line">console.log(returnWeekday())</span><br></pre></td></tr></table></figure>



<h3 id="需求变动-区分工作日和休息日"><a href="#需求变动-区分工作日和休息日" class="headerlink" title="需求变动(区分工作日和休息日)"></a>需求变动(区分工作日和休息日)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnWeekday()&#123;</span><br><span class="line">    let string &#x3D; &quot;今天是星期&quot;;</span><br><span class="line">    let date &#x3D; new Date().getDay();</span><br><span class="line">    &#x2F;&#x2F; 使用对象</span><br><span class="line">    dateObj &#x3D; &#123; </span><br><span class="line">        0: [&#39;天&#39;,&#39;休&#39;], </span><br><span class="line">        1: [&quot;一&quot;,&#39;工&#39;], </span><br><span class="line">        2: [&quot;二&quot;,&#39;工&#39;], </span><br><span class="line">        3: [&quot;三&quot;,&#39;工&#39;], </span><br><span class="line">        4: [&quot;四&quot;,&#39;工&#39;], </span><br><span class="line">        5: [&quot;五&quot;,&#39;工&#39;], </span><br><span class="line">        6: [&quot;六&quot;,&#39;休&#39;], </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 类型，这里也可以对应相关方法</span><br><span class="line">    dayType &#x3D; &#123;</span><br><span class="line">        &#39;休&#39;: function()&#123;</span><br><span class="line">            &#x2F;&#x2F; some code</span><br><span class="line">            console.log(&#39;为休息日&#39;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;工&#39;: function()&#123;</span><br><span class="line">            &#x2F;&#x2F; some code</span><br><span class="line">            console.log(&#39;为工作日&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let returnData &#x3D; &#123;</span><br><span class="line">         string  : string + dateObj[date][0],</span><br><span class="line">         method  : dayType[dateObj[date][1]]</span><br><span class="line">    &#125;</span><br><span class="line">    return returnData</span><br><span class="line">&#125;;</span><br><span class="line">console.log(returnWeekday().method.call(this))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>星期</tag>
      </tags>
  </entry>
  <entry>
    <title>js之冷门好用方法合集</title>
    <url>/2021/03/17/js%E4%B9%8B%E5%86%B7%E9%97%A8%E5%A5%BD%E7%94%A8%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="获取一个月有多少天-important"><a href="#获取一个月有多少天-important" class="headerlink" title="获取一个月有多少天 (important)"></a>获取一个月有多少天 (important)</h2><p>今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据</p>
<p><code>new Date(year, month, date, hrs, min, sec)</code>，<code>new Date</code> 可以接受这些参数创建一个时间对象 其中当我们把 <code>date</code> 设置为 <code>0</code> 的时候，可以直接通过 <code>getDate()</code> 获取到最后一天的日期然后得到我们要的最后一天</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Date(2019, 12, 0).getDate(); &#x2F;&#x2F; 31</span><br><span class="line">new Date(2018, 2, 0).getDate(); &#x2F;&#x2F; 28</span><br><span class="line">&#x2F;&#x2F; 根据这个我们可以得到一个方法</span><br><span class="line">function getMonthLength(month) &#123;</span><br><span class="line">  const date &#x3D; new Date(month);</span><br><span class="line">  const year &#x3D; date.getFullYear();</span><br><span class="line">  &#x2F;&#x2F; 月份是从 0 开始计算的</span><br><span class="line">  const _month &#x3D; date.getMonth() + 1;</span><br><span class="line">  return new Date(year, _month, 0).getDate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="关于函数的-length-属性-important"><a href="#关于函数的-length-属性-important" class="headerlink" title="关于函数的 length 属性 (important)"></a>关于函数的 length 属性 (important)</h2><p>360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(() &#x3D;&gt; 1).length &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F; 输出什么</span><br></pre></td></tr></table></figure>

<p>我所理解的拥有 <code>length</code> 的对象一般都是数组或者类数组对象，或者定义了 <code>length</code> 属性的对象，所以我回答说这个应该是 <code>false</code> 吧，后来面试告诉我函数是有 <code>length</code> 属性的，函数的 <code>length</code> 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 <code>arguments</code>，而 <code>arguments</code> 也是一个类数组对象所以他是有 <code>length</code> 属性的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; so</span><br><span class="line">(() &#x3D;&gt; 1).length &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F; 输出 true</span><br><span class="line">(a &#x3D;&gt; a).length; &#x2F;&#x2F; 输出 1</span><br></pre></td></tr></table></figure>

<h2 id="数组中字符串键值的处理"><a href="#数组中字符串键值的处理" class="headerlink" title="数组中字符串键值的处理"></a>数组中字符串键值的处理</h2><p>在 JavaScript 中数组是通过数字进行索引，但是有趣的是他们也是对象，所以也可以包含<code>字符串</code> 键值和属性，但是这些不会被计算在数组的长度（length）内</p>
<p>如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当做数字索引来处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [];</span><br><span class="line">arr[0] &#x3D; 1;</span><br><span class="line">arr[&#39;1&#39;] &#x3D; &#39;嘿嘿&#39;;</span><br><span class="line">arr[&#39;cym&#39;] &#x3D; &#39;cym&#39;;</span><br><span class="line">console.log(arr); &#x2F;&#x2F; [1, &#39;嘿嘿&#39;, cym: &#39;cym&#39;]</span><br><span class="line">console.log(arr.length); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h2 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h2><p><code>undefined</code> 是一个内置标志符，它的值为 <code>undefined</code>（除非被重新定义过），通过<code>void</code> 运算符即可得到该值</p>
<p>在 <code>void</code> 之后的语句或表达式都将返回 <code>undefined</code>。<code>void</code> 并不会改变表达式的结果，只是让表达式不返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void true; &#x2F;&#x2F; undefined</span><br><span class="line">void 0; &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p><code>void</code> 运算符在其他地方也可以派上用场，比如不让表达式返回任何结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该函数不需要有任何返回结果</span><br><span class="line">function doSomething(sign) &#123;</span><br><span class="line">  if (!sign) &#123;</span><br><span class="line">    return void setTimeout(doSomething, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 或许你经常向下面一样这么写</span><br><span class="line">function doSomething(sign) &#123;</span><br><span class="line">  if (!sign) &#123;</span><br><span class="line">    setTimeout(doSomething, 100);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于-JSON-stringify"><a href="#关于-JSON-stringify" class="headerlink" title="关于 JSON.stringify"></a>关于 JSON.stringify</h2><p><code>JSON.stringify</code> 和 <code>toString()</code> 效果基本相同，只不过序列化的结果总是字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON.stringify(42); &#x2F;&#x2F; &quot;42&quot;</span><br><span class="line">JSON.stringify(&#39;42&#39;); &#x2F;&#x2F; &quot;&quot;42&quot;&quot;（含有双引号的字符串）</span><br><span class="line">JSON.stringify(null); &#x2F;&#x2F; &quot;null&quot;</span><br><span class="line">JSON.stringify(true); &#x2F;&#x2F; &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h3 id="不安全的-JSON-值"><a href="#不安全的-JSON-值" class="headerlink" title="不安全的 JSON 值"></a>不安全的 JSON 值</h3><p>所有安全的 <code>JSON</code> 值都可以使用 <code>JSON.stringify</code> 序列化，不安全的 <code>JSON</code> 值有：<code>undefined</code>、<code>function</code>、<code>symbol</code> 和 <code>循环引用</code>。<code>JSON.stringify</code></p>
<p>在对象中遇到这些不安全的 <code>JSON</code> 值的时候会自动将其忽略，在数组中遇到则会返回<code>null</code>，以保证数组成员位置不变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON.stringify(undefined); &#x2F;&#x2F; null</span><br><span class="line">JSON.stringify(function () &#123;&#125;); &#x2F;&#x2F; null</span><br><span class="line">JSON.stringify([1, undefined, 2, function () &#123;&#125;, 3]); &#x2F;&#x2F; &quot;1, null, 2, null, 3&quot;</span><br><span class="line">JSON.stringify(&#123; a: 2, b: function () &#123;&#125; &#125;); &#x2F;&#x2F; &quot;&#123;&quot;a&quot;:2&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON 方法"></a>toJSON 方法</h3><p>如果对象中定义了 <code>toJSON</code> 方法，那么在 <code>JSON</code> 序列化的时候优先调用该方法，主要是为了处理循环引用的时候，我们让其返回一个合理的值</p>
<p>也就是说 <code>toJSON</code> 方法应该返回一个能够被字符串安全化的 <code>JSON</code> 值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const o &#x3D; &#123;</span><br><span class="line">  a: &#39;cym&#39;,</span><br><span class="line">  toJSON() &#123;</span><br><span class="line">    return &#123; c: &#39;b&#39; &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JSON.stringify(o); &#x2F;&#x2F; &#123;&quot;c&quot;:&quot;b&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON-stringify-的第二个参数-important"><a href="#JSON-stringify-的第二个参数-important" class="headerlink" title="JSON.stringify 的第二个参数 (important)"></a>JSON.stringify 的第二个参数 (important)</h3><p>我们可以向 <code>JSON.stringify</code> 中传递一个可选参数 <code>replacer</code>，他可以书数组也可以书函数，用来指定对象序列化的时候哪些属性应该被处理，哪些应该被排除，和 <code>toJSON</code> 很像</p>
<ol>
<li>当 <code>replacer</code> 是一个数组时，那么他必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外的属性就会被忽略</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  a: 42,</span><br><span class="line">  b: 30,</span><br><span class="line">  c: 100,</span><br><span class="line">&#125;;</span><br><span class="line">JSON.stringify(obj, [&#39;a&#39;, &#39;c&#39;]); &#x2F;&#x2F; &#123;&quot;a&quot;:42,&quot;c&quot;:100&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当 <code>replacer</code> 是一个函数时，他会对对象本身调用一次，然后在对对象中的每个属性各调用一次。每次传递两个参数（对象的键和值）。如果要忽略某个键就返回<code>undecided</code>，否则就返回指定的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  a: 42,</span><br><span class="line">  b: 30,</span><br><span class="line">  c: 100,</span><br><span class="line">&#125;;</span><br><span class="line">JSON.stringify(obj, (k, v) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 注意：第一次 k 是 undefined，v 是原对象</span><br><span class="line">  if (k !&#x3D;&#x3D; &#39;c&#39;) return v;</span><br><span class="line">&#125;); &#x2F;&#x2F; &quot;&#123;&quot;a&quot;:42,&quot;b&quot;:30&#125;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><p>我们都知道一个字符串转换为数字，可以使用 <code>+ &quot;12&quot;</code> 转换为数字 12，也可以使用 <code>-</code>，这样的 <code>+、-</code> 是一元运算符，这样将数字转换为字符串的方法属于显示转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&#96; 运算符还有反转符号位的功能，当然不能把一元操作符连在一起写，不然会变成 &#96;--&#96;，当做递减运算符号来计算了，我们可以理解为 &#96;-&#96; 运算符出在单数次数会转符号位，出现双次数会抵消反转，比如说 &#96;1 - - 1 &#x3D;&#x3D;&#x3D; 2</span><br><span class="line"># 这是 js 代码哦，不是 python</span><br><span class="line">1 + - + - + - 1   # 0</span><br><span class="line">1 - - 1           # 2</span><br><span class="line">1 - - - 1         # 0</span><br></pre></td></tr></table></figure>

<h2 id="字位反转操作符"><a href="#字位反转操作符" class="headerlink" title="字位反转操作符 ~"></a>字位反转操作符 ~</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#96; 返回 2 的补码，&#96;~x&#96; 大致等同于 &#96;-(x+1)</span><br><span class="line">~42; &#x2F;&#x2F; -(42+1) &#x3D;&#x3D;&#x3D;&gt; -43</span><br></pre></td></tr></table></figure>

<p>在 <code>-(x+1)</code> 中唯一能够得到 0（或者严格来说时候 -0）的 x 值是 -1，也就是说 ~ 和一些数字在一起会返回一个假值 0，其他情况下则返回真值</p>
<p>-1 是一个 <code>哨位值</code>，哨位值是那些在各个类型中被赋予了特殊含义的值。在 C 语言中 -1 代表函数执行失败，大于等于 0 的值代表函数执行成功</p>
<p>比如在 JavaScript 中字符串的 indexOf 方法也遵循这一惯例，该方法在字符串中搜索指定的字符串，如果找到就返回该子字符串所在的位置，否则返回 -1</p>
<h3 id="的用途-和-indexOf的联用-important"><a href="#的用途-和-indexOf的联用-important" class="headerlink" title="~ 的用途 (~ 和 indexOf的联用) (important)"></a>~ 的用途 (<code>~</code> 和 <code>indexOf</code>的联用) (important)</h3><p>我们知道在 JavaScript 中假值有：<code>undefined、null、false、+0、-0、NaN、&#39;&#39;</code>，其他都为真值，所以负数也是真值，那么我们就可以拿着 <code>~</code> 和 <code>indexOf</code> 一起检结果强制类型转换为 真/假 值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str &#x3D; &#39;hello world&#39;;</span><br><span class="line">~str.indexOf(&#39;lo&#39;); &#x2F;&#x2F; -4，真值</span><br><span class="line">if (~str.indexOf(&#39;lo&#39;)) &#123;</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">  &#x2F;&#x2F; 找到匹配</span><br><span class="line">&#125;</span><br><span class="line">~str.indexOf(&#39;ol&#39;); &#x2F;&#x2F; 0，假值</span><br><span class="line">!~str.indexOf(&#39;ol&#39;); &#x2F;&#x2F; true</span><br><span class="line">if (!~str.indexOf(&#39;ol&#39;)) &#123;</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">  &#x2F;&#x2F; 没有找到匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>~ 要比 <code>&gt;=0</code> 和 <code>== -1</code> 更简洁</p>
<h3 id="字位截除"><a href="#字位截除" class="headerlink" title="字位截除"></a>字位截除</h3><p>我们经常使用 <code>~~</code> 来截取数字值的小数部分，以为这是和 Math.floor 效果是一样的，实际上并非如此</p>
<p><code>~~</code> 中第一个 ~ 执行 ToInt32 并反转字位，然后第二个在进行一次字位反转，就是将所有的字位反转回原值，最后得到的结果仍是 ToInt32 的结果</p>
<p><code>~~</code> 只适用于 32 位的数字，更重要的是他对负数的处理与 Math.floor 不同，所以使用时要多加注意</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.floor(1.9); &#x2F;&#x2F; 1</span><br><span class="line">~~1.9; &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 操作负数</span><br><span class="line">Math.floor(-1.9); &#x2F;&#x2F; -2</span><br><span class="line">~~-1.9; &#x2F;&#x2F; -1</span><br><span class="line">~~x&#96; 能将值截除为一个 32 位的整数，&#96;x | 0&#96; 也可以，而且看起来更简洁哦，不过出于对运算符优先级的考虑，我们更倾向于使用 &#96;~~x</span><br><span class="line">~~1.9; &#x2F;&#x2F; 1</span><br><span class="line">1.9 | 0; &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">~~-1.9; &#x2F;&#x2F; -1</span><br><span class="line">-1.9 | 0; &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure>

<h2 id="给定一组-url-实现并发请求"><a href="#给定一组-url-实现并发请求" class="headerlink" title="给定一组 url 实现并发请求"></a>给定一组 url 实现并发请求</h2><p>原题是这样的：给定一组 url，利用 js 的异步实现并发请求，并按顺序输出结果</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>首先我们可以想到的是利用 <code>Promise.all</code> 来实现，代码实现如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const urls &#x3D; [&#39;.&#x2F;1.json&#39;, &#39;.&#x2F;2.json&#39;, &#39;.&#x2F;3.json&#39;];</span><br><span class="line">function getData(url) &#123;</span><br><span class="line">  &#x2F;&#x2F; 返回一个 Promise 利用 Promise.all 接受</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.responseType &#x3D; &#39;json&#39;;</span><br><span class="line">    xhr.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          resolve(xhr.response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&#39;GET&#39;, url, true);</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function getMultiData(urls) &#123;</span><br><span class="line">  &#x2F;&#x2F; Promise.all 接受一个包含 promise 的数组，如果不是 promise 数组会被转成 promise</span><br><span class="line">  Promise.all(urls.map(url &#x3D;&gt; getData(url))).then(results &#x3D;&gt; &#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不用-Promise"><a href="#不用-Promise" class="headerlink" title="不用 Promise"></a>不用 Promise</h3><p>原题是不用 <code>Promise</code> 来实现，我们可以写一个方法，加个回调函数，等数据全部回来之后，触发回调函数传入得到的数据，那么数据全部回来的就是我们要考虑的核心问题，我们可以用个数组或者对象，然后判断一下数组的 length 和传入的 url 的长度是否一样来做判断</p>
<h4 id="使用对象做映射"><a href="#使用对象做映射" class="headerlink" title="使用对象做映射"></a>使用对象做映射</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const urls &#x3D; [&#39;.&#x2F;1.json&#39;, &#39;.&#x2F;2.json&#39;, &#39;.&#x2F;3.json&#39;];</span><br><span class="line">function getAllDate(urls, cd) &#123;</span><br><span class="line">  const result &#x3D; &#123;&#125;;</span><br><span class="line">  function getData(url, idx) &#123;</span><br><span class="line">    const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.responseType &#x3D; &#39;json&#39;;</span><br><span class="line">    xhr.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          result[idx] &#x3D; xhr.response;</span><br><span class="line">          &#x2F;&#x2F; 如果两者 length 相等说明都请求完成了</span><br><span class="line">          if (Object.keys(result).length &#x3D;&#x3D;&#x3D; urls.length) &#123;</span><br><span class="line">            &#x2F;&#x2F; 给对象添加length属性，方便转换数组</span><br><span class="line">            result.length &#x3D; urls.length;</span><br><span class="line">            cd &amp;&amp; cd(Array.from(result));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 触发函数执行</span><br><span class="line">  urls.forEach((url, idx) &#x3D;&gt; getData(url, idx));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">getAllDate(urls, data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="使用数组实现"><a href="#使用数组实现" class="headerlink" title="使用数组实现"></a>使用数组实现</h4><p>和上面的基本思路差不多，不过这次换成了数组，也可以给个信号量来做判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getGroupData(urls, cb) &#123;</span><br><span class="line">  const results &#x3D; [];</span><br><span class="line">  let count &#x3D; 0;</span><br><span class="line">  const getData &#x3D; url &#x3D;&gt; &#123;</span><br><span class="line">    const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.responseType &#x3D; &#39;json&#39;;</span><br><span class="line">    xhr.onreadystatechange &#x3D; _ &#x3D;&gt; &#123;</span><br><span class="line">      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          results.push(xhr.response);</span><br><span class="line">          if (++count &#x3D;&#x3D;&#x3D; urls.length) &#123;</span><br><span class="line">            cb &amp;&amp; cb(results);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&#39;GET&#39;, url, true);</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;;</span><br><span class="line">  urls.forEach(url &#x3D;&gt; getData(url));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getGroupData(urls, data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h2><p>原题：如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为 true?</p>
<p>这个问题考查的数据类型转换，<code>==</code> 类型转换有个基本规则</p>
<ul>
<li><code>NaN</code> 与任何值都不相等，包括自己本身</li>
<li><code>undefined</code> 与 <code>null</code> 相等(==)，其他都不等</li>
<li>对象与字符串类型做比较，会把对象转换成字符串然后做比较</li>
<li>其他类型比较都要转换成 <code>数字</code> 做比较</li>
</ul>
<p>那么这个问题我们重写 <code>toString</code> 或者 <code>valueOf</code> 方法就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; &#123;</span><br><span class="line">  val: 1,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.val++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">if (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;</span><br><span class="line">  console.log(&#39;ok&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方法实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i &#x3D; 1;</span><br><span class="line">Object.defineProperty(window, &#39;a&#39;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;</span><br><span class="line">  console.log(&#39;OK&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展一下-为什么是-true-important"><a href="#拓展一下-为什么是-true-important" class="headerlink" title="拓展一下 [] == ![] 为什么是 true (important)"></a>拓展一下 [] == ![] 为什么是 true (important)</h3><p>上面隐式类型转换规则中提到，其他类型比较都要转换成数字做比较，这个就是对应那条规则的</p>
<ul>
<li>首先 <code>[].toString()</code> 会得到一个 <code>&#39;&#39;</code> 字符串</li>
<li><code>![]</code> 得到一个布尔值 <code>false</code></li>
<li><code>&#39;&#39;</code> 与 <code>false</code> 比较肯定要转换成数字比较</li>
<li>那么 <code>&#39;&#39;</code> 转换则为 <code>0</code>， <code>false</code> 转换也是 <code>0</code></li>
<li>所以这道题就是 <code>true</code></li>
</ul>
<h2 id="1-toString-的问题"><a href="#1-toString-的问题" class="headerlink" title="1..toString 的问题"></a>1..toString 的问题</h2><p>有时候我们看到别人的代码中会写到数字调其他类型的方法的时候会写成 <code>1..toString()</code>这样的写法</p>
<p>因为直接用整数型数字调方法就会报错，但是如果是一个浮点数的话就不会报错了</p>
<p>因为可能在 <code>.</code> 上面存在争议，一个数字后面加点，解释器他不知道你这是小数还是要调取方法，所以就跑异常了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.toString()     &#x2F;&#x2F; Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">1..toString()    &#x2F;&#x2F; &#39;1&#39;</span><br><span class="line">1.2.toString()   &#x2F;&#x2F; &#39;1.2&#39;</span><br></pre></td></tr></table></figure>

<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><h3 id="对象增加迭代器"><a href="#对象增加迭代器" class="headerlink" title="对象增加迭代器"></a>对象增加迭代器</h3><p>类数组对象的特征：必须有长度、索引、能够被迭代，否则这个对象不可以使用 <code>...</code> 语法转数组，我们可以使用 Array.from 转，当然我们也可以给对象添加一个迭代器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  0: 1,</span><br><span class="line">  1: 2,</span><br><span class="line">  2: 3,</span><br><span class="line">  3: 4,</span><br><span class="line">  length: 4,</span><br><span class="line">  [Symbol.iterator]() &#123;</span><br><span class="line">    let idx &#x3D; 0</span><br><span class="line">    return &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: obj[idx],</span><br><span class="line">          done: idx++ &gt;&#x3D; obj.length,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 此时对象就被添加了迭代器</span><br><span class="line">[...obj]  &#x2F;&#x2F; 1 2 3 4</span><br><span class="line">for (const val of obj) &#123;</span><br><span class="line">  console.log(val)  &#x2F;&#x2F; 1 2 3 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的问题可以字节使用生成器来实现，生成器返回一个迭代器，迭代器有 next 方法，调用 next 方法可以返回 value 和 done</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  0: 1,</span><br><span class="line">  1: 2,</span><br><span class="line">  2: 3,</span><br><span class="line">  3: 4,</span><br><span class="line">  length: 4,</span><br><span class="line">  [Symbol.iterator]: function* () &#123;</span><br><span class="line">    let idx &#x3D; 0</span><br><span class="line">    while (idx !&#x3D;&#x3D; this.length) &#123;</span><br><span class="line">      yield this[idx++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现一个字符串的迭代器"><a href="#实现一个字符串的迭代器" class="headerlink" title="实现一个字符串的迭代器"></a>实现一个字符串的迭代器</h3><p>实现一个字符串的迭代器：传入一组字符串并返回单个字符的范例。一旦更新的字符串，输出也跟着替换掉旧的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function generator(str) &#123;</span><br><span class="line">  let idx &#x3D; 0;</span><br><span class="line">  return &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        value: str[idx],</span><br><span class="line">        done: idx++ &gt;&#x3D; str.length,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 测试</span><br><span class="line">const str &#x3D; &#39;as&#39;;</span><br><span class="line">let gen &#x3D; generator(str);</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">gen &#x3D; generator(&#39;str&#39;);</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">console.log(gen.next());</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;a&#39;, done: false &#125;</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;s&#39;, done: false &#125;</span><br><span class="line">&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br><span class="line">&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;s&#39;, done: false &#125;</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;t&#39;, done: false &#125;</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;r&#39;, done: false &#125;</span><br><span class="line">&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单模拟-co"><a href="#简单模拟-co" class="headerlink" title="简单模拟 co"></a>简单模拟 co</h3><p>模拟一下 co 的实现</p>
<p>首先来看一则例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const &#123; promisify &#125; &#x3D; require(&#39;util&#39;);</span><br><span class="line">const readFile &#x3D; promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">function* read() &#123;</span><br><span class="line">  const name &#x3D; yield readFile(path.resolve(__dirname, &#39;name.txt&#39;), &#39;utf8&#39;);</span><br><span class="line">  const age &#x3D; yield readFile(path.resolve(__dirname, name), &#39;utf8&#39;);</span><br><span class="line">  return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const it &#x3D; read();</span><br><span class="line"></span><br><span class="line">let &#123; value, done &#125; &#x3D; it.next();</span><br><span class="line">value.then(data &#x3D;&gt; &#123;</span><br><span class="line">  let &#123; value, done &#125; &#x3D; it.next(data);</span><br><span class="line">  &#x2F;&#x2F; console.log(data, &#39;???&#39;)</span><br><span class="line">  value.then(data &#x3D;&gt; &#123;</span><br><span class="line">    let &#123; value, done &#125; &#x3D; it.next(data);</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 co 库可以很容易解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const co &#x3D; require(&#39;co&#39;);</span><br><span class="line">&#x2F;&#x2F; co 接受一个生成器</span><br><span class="line">co(read()).then(data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 那模拟一下</span><br><span class="line">function _co(it) &#123;</span><br><span class="line">  &#x2F;&#x2F; 首先返回一个 promise</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 因为可以传值的原因，不可以直接使用循环实现，需要使用 递归</span><br><span class="line">    function next(data) &#123;</span><br><span class="line">      const &#123; value, done &#125; &#x3D; it.next(data);</span><br><span class="line">      if (done) return resolve(value);</span><br><span class="line">      &#x2F;&#x2F; 保证值是一个 promise</span><br><span class="line">      Promise.resolve(value).then(data &#x3D;&gt; &#123;</span><br><span class="line">        next(data);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="菲波那切数列"><a href="#菲波那切数列" class="headerlink" title="菲波那切数列"></a>菲波那切数列</h2><ul>
<li>今天新东方的面试还提到了菲波那切数列，其实这个东西蛮很有趣，简单介绍一下</li>
<li>1、1、2、3、5、8、13、21、34 ….</li>
<li>这道题有个规律，第一项加上第二项永远等于第三项：1 + 1 = 2；1 + 2 = 3；2 + 3 = 5；3 + 5 = 8 ….</li>
<li>要求是传入第几项，得到该值，根据这个规律来实现一下</li>
</ul>
<h3 id="简单写法"><a href="#简单写法" class="headerlink" title="简单写法"></a>简单写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fibonacci(n) &#123;</span><br><span class="line">  &#x2F;&#x2F; 第一项和第二项都返回1</span><br><span class="line">  if (n &#x3D;&#x3D;&#x3D; 1 || n &#x3D;&#x3D;&#x3D; 2) return 1;</span><br><span class="line">  &#x2F;&#x2F; 我们只要返回 n - 1（n的前一项）与 n - 2（n的前两项）的和便是我们要的值</span><br><span class="line">  return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化版本-important"><a href="#优化版本-important" class="headerlink" title="优化版本 (important)"></a>优化版本 (important)</h3><p>上面的写法，求 20 次以内的总和运行会很快，50 次以上特别慢，100 次 以上可能就爆栈了，所以我们需要优化写法，缓存每次计算后的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function feibo(n, sum1 &#x3D; 1, sum2 &#x3D; 1) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D;&#x3D; 1 || n &#x3D;&#x3D;&#x3D; 2) return sum2;</span><br><span class="line">  return feibo(n - 1, sum2, sum1 + sum2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法缓存了，每次计算后的值，执行效率会很高，100 次以上也会秒返回结果，这个也叫作尾递归优化</p>
<h2 id="观察者与发布订阅"><a href="#观察者与发布订阅" class="headerlink" title="观察者与发布订阅"></a>观察者与发布订阅</h2><blockquote>
<p>一直以来，我以为发布订阅和观察者是一个思路，一次偶然的机会我发现他们是两种不同的设计思路</p>
</blockquote>
<p>虽然他们都是<code>实现了对象的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得倒通知，然后自动更新</code>。但是他们之间是有一定区别的。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式会有 <code>观察者</code> 与 <code>被观察者(观察目标)</code> 两个对象存在，观察者可以有多个，观察目标可以添加多个观察者，可以通知观察者。观察者模式是面向与目标和观察者编程的，耦合目标和观察者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 被观察者</span><br><span class="line">class Subject &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs &#x3D; [];</span><br><span class="line">  &#125;</span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    this.subs.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  notify(...args) &#123;</span><br><span class="line">    this.subs.forEach(ob &#x3D;&gt; ob.update(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 观察者</span><br><span class="line">class Observer &#123;</span><br><span class="line">  update(...args) &#123;</span><br><span class="line">    console.log(&#39;Observer -&gt; update -&gt; args&#39;, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">const o1 &#x3D; new Observer();</span><br><span class="line">const o2 &#x3D; new Observer();</span><br><span class="line">const o3 &#x3D; new Observer();</span><br><span class="line">const o5 &#x3D; new Observer();</span><br><span class="line">const sub &#x3D; new Subject();</span><br><span class="line">&#x2F;&#x2F; 添加观察者</span><br><span class="line">sub.add(o1);</span><br><span class="line">sub.add(o2);</span><br><span class="line">sub.add(o3);</span><br><span class="line">&#x2F;&#x2F; 通知观察者</span><br><span class="line">sub.notify(&#39;嘿嘿嘿&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>发布订阅模式会有一个调度中心的概念。是面向调度中心编程的，对发布者与订阅者解耦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PubSub &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.handlers &#x3D; &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  subscribe(type, fn) &#123;</span><br><span class="line">    if (!this.handlers[type]) &#123;</span><br><span class="line">      this.handlers[type] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line">    this.handlers[type].push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  publish(type, ...args) &#123;</span><br><span class="line">    if (!this.handlers[type]) return;</span><br><span class="line">    this.handlers[type].forEach(fn &#x3D;&gt; fn(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ps &#x3D; new PubSub();</span><br><span class="line"></span><br><span class="line">ps.subscribe(&#39;a&#39;, console.log);</span><br><span class="line">ps.subscribe(&#39;a&#39;, console.log);</span><br><span class="line">ps.subscribe(&#39;a&#39;, console.log);</span><br><span class="line">ps.subscribe(&#39;a&#39;, console.log);</span><br><span class="line">ps.publish(&#39;a&#39;, &#39;hello world&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="字符串转-txt-文件（blob）"><a href="#字符串转-txt-文件（blob）" class="headerlink" title="字符串转 txt 文件（blob）"></a>字符串转 txt 文件（blob）</h2><p>有个要求：纯前端实现，不可以使用 <code>nodejs</code></p>
<p>实现原理也很简单，就像我们平时下载一个本地文件一样，可以动态的创建一个可以下载的 <code>a</code> 标签，给它设置 <code>download</code> 属性，然后把下载的内容转 <code>blob</code> 创建下载链接下载即可</p>
<p>具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function exportTxt(text, filename) &#123;</span><br><span class="line">  const eleLink &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">  eleLink.download &#x3D; filename;</span><br><span class="line">  eleLink.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">  &#x2F;&#x2F; 将内容转为 blob</span><br><span class="line">  const blob &#x3D; new Blob([text]);</span><br><span class="line">  eleLink.href &#x3D; URL.createObjectURL(blob);</span><br><span class="line">  document.body.appendChild(eleLink);</span><br><span class="line">  eleLink.click();</span><br><span class="line">  document.body.removeChild(eleLink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="奇偶数判断"><a href="#奇偶数判断" class="headerlink" title="奇偶数判断"></a>奇偶数判断</h2><p>可能会遇到一个做奇偶数判断的方法吧，反正我遇到了，一句话搞定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isEven &#x3D; num &#x3D;&gt; num % 2 &#x3D;&#x3D;&#x3D; 0;</span><br></pre></td></tr></table></figure>

<h2 id="格式化金钱-important"><a href="#格式化金钱-important" class="headerlink" title="格式化金钱 (important)"></a>格式化金钱 (important)</h2><p>项目中我们经常会遇到金钱格式化需求，或者说数字格式化一下，方便阅读（数字比较大的情况下）</p>
<p>比如说 <code>999999999</code>，直接阅读很不直观，格式化后 <code>999,999,999</code></p>
<p>通常我们会使用正则来处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function formatPrice(price) &#123;</span><br><span class="line">  return String(price).replace(&#x2F;\B(?&#x3D;(\d&#123;3&#125;)+(?!\d))&#x2F;g, &#39;,&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以不使用正则然后优雅的处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function formatPrice(price) &#123;</span><br><span class="line">  return String(price)</span><br><span class="line">    .split(&#39;&#39;)</span><br><span class="line">    .reverse()</span><br><span class="line">    .reduce((prev, next, index) &#x3D;&gt; &#123;</span><br><span class="line">      return (index % 3 ? next : next + &#39;,&#39;) + prev;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是两种提到的比较常用的方案，但是 js 还有个比较牛逼的 API 可以直接实现这个需求哦，它就是 <code>toLocaleString</code>，我们可以直接数字调用这个方法就可以实现，金额的格式化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(999999999).toLocaleString(); &#x2F;&#x2F; 999,999,999</span><br><span class="line">&#x2F;&#x2F; 当然还可以更秀一点</span><br><span class="line">const options &#x3D; &#123;</span><br><span class="line">  style: &#39;currency&#39;,</span><br><span class="line">  currency: &#39;CNY&#39;,</span><br><span class="line">&#125;;</span><br><span class="line">(123456).toLocaleString(&#39;zh-CN&#39;, options); &#x2F;&#x2F; ¥123,456.00</span><br></pre></td></tr></table></figure>

<p><code>toLocaleString</code> 可以接收两个可选参数：<code>locales</code> 和 <code>options</code>，而且这个 api 在各大浏览器通用不存在兼容问题并且这个 <code>api</code> 不止存在 Number 的原型上，Array、Object、Date 原型上都有这个 api，并且格式化出来的值可以根据我们传入的参数出现各种结果</p>
<p>参数及用法可以参考 MDN</p>
<h2 id="深度冻结对象"><a href="#深度冻结对象" class="headerlink" title="深度冻结对象"></a>深度冻结对象</h2><p>在 vue 项目开发中，有些不变的常量，我们不想 vue 为他做双向绑定，以减少一些性能上消耗，我们可以把使用 <code>Object.freeze</code> 将对象冻结，此时 vue 将不会对这个对象进行冻结，但是这个冻结只是冻结对象第一层，所以遇到对象层级比较深的话，我们可以写个深度冻结的 api，来对常量对象做一些冻结优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const deepFreeze &#x3D; o &#x3D;&gt; &#123;</span><br><span class="line">  const propNames &#x3D; Object.getOwnPropertyNames(o);</span><br><span class="line">  propNames.forEach(name &#x3D;&gt; &#123;</span><br><span class="line">    const prop &#x3D; o[name];</span><br><span class="line">    if (typeof prop &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; prop !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      deepFreeze(prop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return Object.freeze(o);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="脱敏处理-手机号身份证号之类的信息脱敏带-号-important"><a href="#脱敏处理-手机号身份证号之类的信息脱敏带-号-important" class="headerlink" title="脱敏处理 (手机号身份证号之类的信息脱敏带*号)(important)"></a>脱敏处理 (手机号身份证号之类的信息脱敏带*号)(important)</h2><p>在一些涉及到用户隐私情况下，可能会遇到对用户的手机号身份证号之类的信息脱敏，但是这个脱敏数据的规则是根据用户信息要脱敏字段动态的生成的，此时我们动态拼接正则来实现一个动态脱敏规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const encryptReg &#x3D; (before &#x3D; 3, after &#x3D; 4) &#x3D;&gt; &#123;</span><br><span class="line">  return new RegExp(&#39;(\\d&#123;&#39; + before + &#39;&#125;)\\d*(\\d&#123;&#39; + after + &#39;&#125;)&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 使用：&#39;13456789876&#39;.replace(encryptReg(), &#39;$1****$2&#39;) -&gt; &quot;134****9876&quot;</span><br></pre></td></tr></table></figure>

<h2 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h2><p>对于树结构的遍历一般有深度优先和广度优先</p>
<p>广度优先和深度优先的概念很简单，区别如下：</p>
<ul>
<li>深度优先，访问完一颗子树再去访问后面的子树，而访问子树的时候，先访问根再访问根的子树，称为先序遍历；先访问子树再访问根，称为后序遍历。</li>
<li>广度优先，即访问树结构的第 n+1 层前必须先访问完第 n 层</li>
</ul>
<ol>
<li>深度优先</li>
</ol>
<p>先序遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const treeForEach &#x3D; (tree, func) &#x3D;&gt; &#123;</span><br><span class="line">  tree.forEach(data &#x3D;&gt; &#123;</span><br><span class="line">    func(data);</span><br><span class="line">    data.children &amp;&amp; treeForEach(data.children, func);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后序遍历，只需要调换一下节点遍历和子树遍历的顺序即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const treeForEach &#x3D; (tree, func) &#x3D;&gt; &#123;</span><br><span class="line">  tree.forEach(data &#x3D;&gt; &#123;</span><br><span class="line">    data.children &amp;&amp; treeForEach(data.children, func);</span><br><span class="line">    func(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>广度优先</li>
</ol>
<p>广度优先的思路是，维护一个队列，队列的初始值为树结构根节点组成的列表，重复执行以下步骤直到队列为空。取出队列中的第一个元素，进行访问相关操作，然后将其后代元素（如果有）全部追加到队列最后。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const treeForEach &#x3D; (tree, func) &#x3D;&gt; &#123;</span><br><span class="line">  let node,</span><br><span class="line">    list &#x3D; [...tree];</span><br><span class="line">  while ((node &#x3D; list.shift())) &#123;</span><br><span class="line">    func(node);</span><br><span class="line">    node.children &amp;&amp; list.push(...node.children);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组分组"><a href="#数组分组" class="headerlink" title="数组分组"></a>数组分组</h2><p>开发移动端的时候，遇到一个首页菜单改版的需求，首页菜单根据权限控制显隐，而菜单每页展示八个小菜单，超过八个做 swipe 滑动切换，当时项目用了 vant 做的 UI 框架，菜单那模块就选择了他的轮播插件，菜单做成了一个扁平化的 list 配置，首先根据权限过滤出所有有权限的菜单项，然后每八个一分组，处理成一个二维数据来遍历菜单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arrayGroupBySize &#x3D; (arr, size &#x3D; 2) &#x3D;&gt; &#123;</span><br><span class="line">  const result &#x3D; [];</span><br><span class="line">  for (let i &#x3D; 0, len &#x3D; arr.length; i &lt; len; i +&#x3D; size) &#123;</span><br><span class="line">    result.push(arr.slice(i, i + size));</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="下划线与驼峰-important"><a href="#下划线与驼峰-important" class="headerlink" title="下划线与驼峰(important)"></a>下划线与驼峰(important)</h2><p>做一些数据持久化的工作的时候经常会出现下划线命名和驼峰命名的转化，因为在前端处理中规范是驼峰命名，而像 mysql 之类的规范是下划线命名，所以在处理后返回给前端的数据需要转换为驼峰命名，而对数据库的读写需要下划线命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">驼峰</span><br><span class="line">const toHump &#x3D; name &#x3D;&gt; &#123;</span><br><span class="line">  return name.replace(&#x2F;\_(\w)&#x2F;g, function (all, letter) &#123;</span><br><span class="line">    return letter.toUpperCase();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">toHump(&#39;_chose_hello&#39;) &#x2F;&#x2F; ChoseHello</span><br><span class="line"></span><br><span class="line">下划线</span><br><span class="line">const toLine &#x3D; name &#x3D;&gt; &#123;</span><br><span class="line">  return name.replace(&#x2F;([A-Z])&#x2F;g, &#39;_$1&#39;).toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line">toLine(&#39;ChoseHello&#39;)  _chose_hello</span><br></pre></td></tr></table></figure>

<h2 id="校验时间格式-important"><a href="#校验时间格式-important" class="headerlink" title="校验时间格式(important)"></a>校验时间格式(important)</h2><p>业务中遇到一个校验一下传入时间格式是否为一个时间格式，下面的方法可以完美校验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isDate &#x3D; str &#x3D;&gt; &#123;</span><br><span class="line">  return typeof str !&#x3D;&#x3D; &#39;number&#39; &amp;&amp; str !&#x3D;&#x3D; null &amp;&amp; new Date(str) !&#x3D;&#x3D; &#39;Invalid Date&#39;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>持续记录中…</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js之图片懒加载</title>
    <url>/2021/02/01/js%E4%B9%8B%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>参考链接 </p>
<p><a href="https://mp.weixin.qq.com/s/wsaB9pT75msm9usT9i3Xig" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wsaB9pT75msm9usT9i3Xig</a></p>
<p>window.innerHeight和document.documentElement.clientHeight区别(window.innerHeight和clentWidth同理)</p>
<p><strong>1.window.innerHeight属于BOM（浏览器对象模型），而document.documentElement.clientHeight则属于文档对象模型</strong></p>
<p><strong>2.window.innerHeight获取的高度包含横向滚动条，而document.documentElement.clientHeight不包含横向滚动条</strong></p>
<h2 id="基于原生-js-实现图片懒加载"><a href="#基于原生-js-实现图片懒加载" class="headerlink" title="基于原生 js 实现图片懒加载"></a>基于原生 js 实现图片懒加载</h2><h4 id="document-documentElement-clientHeight"><a href="#document-documentElement-clientHeight" class="headerlink" title="document.documentElement.clientHeight"></a>document.documentElement.clientHeight</h4><p>获取屏幕可视区域的高度。</p>
<h4 id="element-offsetTop"><a href="#element-offsetTop" class="headerlink" title="element.offsetTop"></a>element.offsetTop</h4><p>获取元素相对于文档顶部的高度。</p>
<h4 id="document-documentElement-scrollTop"><a href="#document-documentElement-scrollTop" class="headerlink" title="document.documentElement.scrollTop"></a>document.documentElement.scrollTop</h4><p>获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离。</p>
<a id="more"></a>

<p>通过上面三个 API，我们获得了三个值：可视区域的高度、元素相对于其父元素容器顶部的距离、浏览器窗口顶部与容器元素顶部的距离也就是滚动条滚动的高度。</p>
<p>虽然这几个<code>API</code>很简单，但是单纯的去说还是有点抽象，这里我们还是用图来展示一下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-af1ab0c5f34e468e8647135c1f9f51e4_720w.jpg" alt="img"></p>
<p>看完上面这张图片，我想你已经明白了：如果满足<code>offsetTop-scrollTop&lt;clientHeight</code>，则图片进入了可视区内，我们就去请求进入可视区域的图片。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>基于上面的分析，我们很容易就可以写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;基于原生 js 实现图片懒加载&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        img &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 300px;</span><br><span class="line">            margin-bottom: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;.&#x2F;img&#x2F;1.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;.&#x2F;img&#x2F;2.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;.&#x2F;img&#x2F;3.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;.&#x2F;img&#x2F;4.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;.&#x2F;img&#x2F;5.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;.&#x2F;img&#x2F;6.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;.&#x2F;img&#x2F;7.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;.&#x2F;img&#x2F;8.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        var imgs &#x3D; document.querySelectorAll(&#39;img&#39;);</span><br><span class="line">        &#x2F;&#x2F;offsetTop是元素与offsetParent的距离，循环获取直到页面顶部</span><br><span class="line">        function getRealTop(e) &#123;</span><br><span class="line">            var realTop &#x3D; e.offsetTop;</span><br><span class="line">            while(e &#x3D; e.offsetParent) &#123;</span><br><span class="line">                realTop +&#x3D; e.offsetTop;</span><br><span class="line">            &#125;</span><br><span class="line">            return realTop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function lazyLoad(imgs) &#123;</span><br><span class="line">            var H &#x3D; document.documentElement.clientHeight;&#x2F;&#x2F;获取可视区域高度</span><br><span class="line">            var S &#x3D; document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">            for (var i &#x3D; 0; i &lt; imgs.length; i++) &#123;</span><br><span class="line">                if (H + S &gt; getRealTop(imgs[i])) &#123;</span><br><span class="line">                    imgs[i].src &#x3D; imgs[i].getAttribute(&#39;data-src&#39;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window.onload &#x3D; window.onscroll &#x3D; function () &#123; &#x2F;&#x2F;onscroll()在滚动条滚动的时候触发</span><br><span class="line">            lazyLoad(imgs);</span><br><span class="line">        &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>但上面的代码如果你在<code>lazyLoad</code>中打印，你会发现滚动条上下滚动时，<code>lazyLoad</code>会被频繁调用，造成很大的性能损失，这里我们可以给事件加上节流<code>throttle</code></p>
</blockquote>
<h2 id="基于-getBoundingClientRect-实现图片懒加载"><a href="#基于-getBoundingClientRect-实现图片懒加载" class="headerlink" title="基于 getBoundingClientRect()实现图片懒加载"></a>基于 getBoundingClientRect()实现图片懒加载</h2><p>先来了解一下这个<code>API</code>吧：</p>
<p><code>getBoundingClientRect()</code>用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。<code>getBoundingClientRect()</code>是<code>DOM</code>元素到浏览器可视范围的距离（不包含页面看不见的部分）。</p>
<p>该函数返回一个<code>rectObject</code>对象，该对象有 6 个属性：<code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>,<code>width</code>, <code>height</code>；这里的<code>top</code>、<code>left</code>和<code>css</code>中的理解很相似，<code>width</code>、<code>height</code>是元素自身的宽高，但是<code>right</code>，<code>bottom</code>和<code>css</code>中的理解有点不一样。<code>right</code>是指元素右边界距窗口最左边的距离，<code>bottom</code>是指元素下边界距窗口最上面的距离。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/LNrWl4n5XIIK2zJ2Sib4NcyG27o0KmtgwLlWQAyRI4Y2vy2Du4JDDmrmNvD8eJMvgvv8lFCfgtkx8R8JgZ7piabA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>通过这个 API，我们就很容易获取<code>img</code>元素相对于视口的顶点位置<code>rectObject.top</code>，只要这个值小于浏览器的高度<code>window.innerHeight</code>就说明进入可视区域：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isInSight(el)&#123;</span><br><span class="line">  const bound &#x3D; el.getBoundingClientRect();</span><br><span class="line">  const clientHeight &#x3D; window.innerHeight;</span><br><span class="line">  return bound.top &lt;&#x3D; clientHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里结合第一种实现方式，做下改造，就得到了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loadImg(el)&#123;</span><br><span class="line"> if(!el.src)&#123;</span><br><span class="line">   const source &#x3D; el.getAttribute(&#39;data-src&#39;);;</span><br><span class="line">   el.src &#x3D; source;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">function checkImgs()&#123;</span><br><span class="line">  const imgs &#x3D; document.querySelectorAll(&#39;img&#39;);</span><br><span class="line">  Array.from(imgs).forEach(el &#x3D;&gt;&#123;</span><br><span class="line">    if (isInSight(el))&#123;</span><br><span class="line">      loadImg(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">  checkImgs();</span><br><span class="line">&#125;</span><br><span class="line">document.onscroll &#x3D; function () &#123;</span><br><span class="line">  checkImgs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基于-IntersectionObserver-实现图片懒加载"><a href="#基于-IntersectionObserver-实现图片懒加载" class="headerlink" title="基于 IntersectionObserver 实现图片懒加载"></a>基于 IntersectionObserver 实现图片懒加载</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>我们在平时的开发中，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/LNrWl4n5XIIK2zJ2Sib4NcyG27o0KmtgwqVrRibSL2Qphibt4wUmg4O50icQ1zyw9tCDEqaA3zCtAxEwaujs2ttSJw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p>上图的绿色方块不断滚动，顶部会提示它的可见性。</p>
<p>传统的实现方法是，监听到<code>scroll</code>事件后，调用目标元素（绿色方块）的<code>getBoundingClientRect()</code>方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于<code>scroll</code>事件密集发生，计算量很大，容易造成性能问题。</p>
<p>目前有一个新的 <code>IntersectionObserver API</code>，可以自动”观察”元素是否可见，<code>Chrome 51+</code>已经支持。由于可见（<code>visible</code>）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做<code>交叉观察器</code>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>它的用法也非常简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var io &#x3D; new IntersectionObserver(callback, option);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>IntersectionObserver</code>是浏览器原生提供的构造函数，接受两个参数：<code>callback</code>是可见性变化时的回调函数，<code>option</code>是配置对象（该参数可选）。</p>
<p>构造函数的返回值是一个观察器实例。实例的<code>observe</code>方法可以指定观察哪个 <code>DOM</code> 节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开始观察</span><br><span class="line">io.observe(document.getElementById(&#39;container&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 停止观察</span><br><span class="line">io.unobserve(element);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关闭观察器</span><br><span class="line">io.disconnect();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>observe</code>的参数是一个 <code>DOM</code> 节点对象。</p>
<p>如果要观察多个节点，就要多次调用这个方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io.observe(elementA);</span><br><span class="line">io.observe(elementB);</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>看完相关的<code>API</code>，下面就让我们基于<code>IntersectionObserver</code>来实现图片懒加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const imgs &#x3D; document.querySelectorAll(&#39;img&#39;) &#x2F;&#x2F;获取所有待观察的目标元素</span><br><span class="line">var options &#x3D; &#123;&#125;</span><br><span class="line">function lazyLoad(target) &#123;</span><br><span class="line">  const observer &#x3D; new IntersectionObserver((entries, observer) &#x3D;&gt; &#123;</span><br><span class="line">    entries.forEach(entrie &#x3D;&gt; &#123;</span><br><span class="line">      if (entrie.isIntersecting) &#123;</span><br><span class="line">        const img &#x3D; entrie.target;</span><br><span class="line">        const src &#x3D; img.getAttribute(&#39;data-src&#39;);</span><br><span class="line">        img.setAttribute(&#39;src&#39;, src)</span><br><span class="line">        observer.unobserve(img); &#x2F;&#x2F; 停止监听已开始加载的图片</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, options);</span><br><span class="line">  observer.observe(target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imgs.forEach(lazyLoad)</span><br></pre></td></tr></table></figure>



<h2 id="img-loading-lazy"><a href="#img-loading-lazy" class="headerlink" title="img.loading=lazy"></a>img.loading=lazy</h2><p>最后这种相对就简单很多了，它是 <code>Chrome</code> 自带的原生 <code>lazyload</code> 属性。我们先来看下他在各大浏览器的支持程度：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/LNrWl4n5XIIK2zJ2Sib4NcyG27o0KmtgwYtRjlRFEmic0tcibqgmiak9CzMTKtYNMKcZT6P4E6hfkRPKpjFg9Z5G0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>“</p>
<p>其实支持程度还不是特别好，我们你的应用对于浏览器兼容性要求比较高的话，建议还是先观望一波～</p>
</blockquote>
<p>它的使用也非常简单，如标题所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;example.jpg&quot; loading&#x3D;&quot;lazy&quot; alt&#x3D;&quot;zhangxinxu&quot; width&#x3D;&quot;250&quot; height&#x3D;&quot;150&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>图片懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title>js之实现图片等比缩放</title>
    <url>/2021/02/01/js%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%AD%89%E6%AF%94%E7%BC%A9%E6%94%BE/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在容器等高或者等宽的时候，实现图片不变形</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>图片的高和宽都超限了，这时要算一下哪个超的多，按超多的缩放比例等比计算宽和高。</p>
<p>高超限，宽未超限，按高的缩放等比计算。</p>
<p>宽超限，高未超退，按宽的缩放等比计算。</p>
<p>高宽均未超限，返回原始宽和高。</p>
<a id="more"></a>

<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="获取原始图片宽高"><a href="#获取原始图片宽高" class="headerlink" title="获取原始图片宽高"></a>获取原始图片宽高</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getNaturalSize (Domlement) &#123;</span><br><span class="line"> var natureSize &#x3D; &#123;&#125;;</span><br><span class="line"> if(window.naturalWidth &amp;&amp; window.naturalHeight) &#123;</span><br><span class="line">     natureSize.width &#x3D; Domlement.naturalWidth;</span><br><span class="line">     natureSizeheight &#x3D; Domlement.naturalHeight;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     var img &#x3D; new Image();</span><br><span class="line">     img.src &#x3D; DomElement.src;</span><br><span class="line">     natureSize.width &#x3D; img.width;</span><br><span class="line">     natureSize.height &#x3D; img.height;</span><br><span class="line"> &#125;</span><br><span class="line"> return natureSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var natural &#x3D; getNaturalSize (document.getElementById(&#39;img&#39;)),</span><br><span class="line"> natureWidth &#x3D; natural.width,</span><br><span class="line"> natureHeight &#x3D; natural.height;</span><br></pre></td></tr></table></figure>

<h4 id="获取图片需展示的宽度"><a href="#获取图片需展示的宽度" class="headerlink" title="获取图片需展示的宽度"></a>获取图片需展示的宽度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function scale(maxW, maxH, orgW, orgH) &#123;</span><br><span class="line">    if (orgW &lt; maxW &amp;&amp; orgH &lt; maxH) &#123;</span><br><span class="line">        return &#123; w: orgW, h: orgH &#125;</span><br><span class="line">    &#125; else if (orgW &gt; maxW &amp;&amp; orgH &gt; maxH) &#123;</span><br><span class="line">        var sw &#x3D; orgW &#x2F; maxW, sh &#x3D; orgH &#x2F; maxH;</span><br><span class="line">        if (sw &gt; sh) &#123;</span><br><span class="line">            return &#123; w: maxW, h: maxH &#x2F; sw &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123; w: maxW &#x2F; sh, h: maxH &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (orgW &gt; maxW) &#123;</span><br><span class="line">        var sw &#x3D; orgW &#x2F; maxW;</span><br><span class="line">        return &#123; w: maxW, h: orgH &#x2F; sw &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var sh &#x3D; orgH &#x2F; maxH;</span><br><span class="line">        return &#123; w: orgW&#x2F;sh, h: maxH &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var resimg &#x3D; scale(300, 999999, natureWidth, natureHeight);</span><br><span class="line">image.style.width &#x3D; resimg.w + &#39;px&#39;;</span><br><span class="line">image.style.height &#x3D; resimg.h + &#39;px&#39;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>图片等比缩放</tag>
      </tags>
  </entry>
  <entry>
    <title>js之对象的方法合集</title>
    <url>/2020/09/25/js%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="Object构造方法"><a href="#Object构造方法" class="headerlink" title="Object构造方法"></a><code>Object</code>构造方法</h2><ul>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener"><code>Object.assign()</code></a></p>
<p>将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener"><code>Object.create()</code></a></p>
<p>用指定的原型对象和属性创建一个新对象。</p>
<a id="more"></a>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty()</code></a></p>
<p>将给定描述符描述的命名属性添加到对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener"><code>Object.defineProperties()</code></a></p>
<p>将给定描述符描述的命名属性添加到对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener"><code>Object.entries()</code></a></p>
<p>返回一个包含<code>[key, value]</code>给定对象<strong>自己的</strong>可枚举字符串属性的所有对的数组。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener"><code>Object.freeze()</code></a></p>
<p>冻结对象。其他代码无法删除或更改其属性。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries" target="_blank" rel="noopener"><code>Object.fromEntries()</code></a></p>
<p>从可迭代的<code>[key, value]</code>对中返回一个新对象。（这是的反向 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener"><code>Object.entries</code></a>）。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptor()</code></a></p>
<p>返回对象的命名属性的属性描述符。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptors()</code></a></p>
<p>返回一个包含对象自身所有属性描述符的对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" target="_blank" rel="noopener"><code>Object.getOwnPropertyNames()</code></a></p>
<p>返回一个数组，其中包含给定对象<strong>自己</strong>的所有可枚举和不可枚举属性的名称。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="noopener"><code>Object.getOwnPropertySymbols()</code></a></p>
<p>返回直接在给定对象上找到的所有符号属性的数组。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener"><code>Object.getPrototypeOf()</code></a></p>
<p>返回<code>prototype</code>指定对象的。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener"><code>Object.is()</code></a></p>
<p>比较两个值是否相同。求所有<code>NaN</code>值（不同于“抽象相等比较”和“严格相等比较”）。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible" target="_blank" rel="noopener"><code>Object.isExtensible()</code></a></p>
<p>确定是否允许扩展对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen" target="_blank" rel="noopener"><code>Object.isFrozen()</code></a></p>
<p>确定对象是否冻结。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed" target="_blank" rel="noopener"><code>Object.isSealed()</code></a></p>
<p>确定对象是否密封。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener"><code>Object.keys()</code></a></p>
<p>返回一个数组，其中包含给定对象<strong>自己</strong>的所有可枚举字符串属性的名称。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="noopener"><code>Object.preventExtensions()</code></a></p>
<p>防止对象的任何扩展。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener"><code>Object.seal()</code></a></p>
<p>防止其他代码删除对象的属性。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf()</code></a></p>
<p>设置对象的原型（其内部<code>[[Prototype]]</code>属性）。</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank" rel="noopener"><code>Object.values()</code></a></p>
<p>返回一个数组，该数组包含与给定对象<strong>自己的所有</strong>可枚举字符串属性相对应的值。</p>
</li>
</ul>
<h2 id="Object实例和Object原型对象"><a href="#Object实例和Object原型对象" class="headerlink" title="Object实例和Object原型对象"></a><code>Object</code>实例和<code>Object</code>原型对象</h2><p>JavaScript中的所有对象均来自<code>Object</code>。所有对象都继承自的方法和属性<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="noopener"><code>Object.prototype</code></a>，尽管它们可能会被覆盖。</p>
<p>例如，其他构造函数的原型将覆盖<code>constructor</code>属性并提供自己的<code>toString()</code>方法。对<code>Object</code>原型对象的更改将传播到所有对象，除非经受这些更改的属性和方法在原型链中进一步被覆盖。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener"><code>Object.prototype.constructor</code></a></p>
<p>指定创建对象原型的函数。</p>
</li>
</ul>
<h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><p>typeof只能判断区分基本类型，number、string、boolean、undefined和object,function；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof 0;  &#x2F;&#x2F;number;</span><br><span class="line">typeof true;  &#x2F;&#x2F;boolean;</span><br><span class="line">typeof undefined;  &#x2F;&#x2F;undefined;</span><br><span class="line">typeof &quot;hello world&quot;   &#x2F;&#x2F;string;</span><br><span class="line">typeof function()&#123;&#125;;   &#x2F;&#x2F;function;</span><br><span class="line"></span><br><span class="line">typeof null; &#x2F;&#x2F;object</span><br><span class="line">typeof &#123;&#125;;  &#x2F;&#x2F;object;</span><br><span class="line">typeof []; &#x2F;&#x2F;object</span><br></pre></td></tr></table></figure>

<p>从上例我们可以看出， typeof 判断对象和数组都返回object,因此它无法区分对象和数组。</p>
<h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a&#x3D;&#123;&#125;;</span><br><span class="line">a instanceof Object  &#x2F;&#x2F;true</span><br><span class="line">a intanceof Array     &#x2F;&#x2F;false</span><br><span class="line">var b&#x3D;[];</span><br><span class="line">b instanceof Array  &#x2F;&#x2F;true</span><br><span class="line">b instanceof  Object &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>因为数组属于object中的一种，所以数组instanceof object,也是true.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c&#x3D;&#39;abc&#39;;</span><br><span class="line">c instanceof String; &#x2F;&#x2F;false</span><br><span class="line">var d&#x3D;new String();</span><br><span class="line">d instanceof String  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>instanceof不能区分基本类型string和boolean,除非是字符串对象和布尔对象。如上例所示。</p>
<h4 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o&#x3D;&#123;&#125;;</span><br><span class="line">o.constructor&#x3D;&#x3D;Object  &#x2F;&#x2F;true</span><br><span class="line">var arr&#x3D;[];</span><br><span class="line">arr.constructor&#x3D;&#x3D;Array  &#x2F;&#x2F;true</span><br><span class="line">arr.constructor&#x3D;&#x3D;Object &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>可以看出constructor可以区分Array和Object。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var n&#x3D;true;</span><br><span class="line">n.constructor&#x3D;&#x3D;Boolean  &#x2F;&#x2F;true</span><br><span class="line">var num&#x3D;1;</span><br><span class="line">num.constructor&#x3D;&#x3D;Number  &#x2F;&#x2F;true</span><br><span class="line">var str&#x3D;&#39;hello world&#39;;</span><br><span class="line">str.constructor&#x3D;&#x3D;String     &#x2F;&#x2F;true</span><br><span class="line">var num&#x3D;new Number();</span><br><span class="line">num.constructor&#x3D;&#x3D;Number  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>不过要注意，constructor属性是可以被修改的，会导致检测出的结果不正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">function Student()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">Student.prototype &#x3D; new Person();</span><br><span class="line">var John &#x3D; new Student();</span><br><span class="line">console.log(John.constructor&#x3D;&#x3D;Student); &#x2F;&#x2F; false</span><br><span class="line">console.log(John.constructor&#x3D;&#x3D;Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h5 id="除了undefined和null，其他类型的变量均能使用constructor判断出类型"><a href="#除了undefined和null，其他类型的变量均能使用constructor判断出类型" class="headerlink" title="除了undefined和null，其他类型的变量均能使用constructor判断出类型."></a>除了undefined和null，其他类型的变量均能使用constructor判断出类型.</h5><h4 id="4-Object-prototype-toString-call-———最好用"><a href="#4-Object-prototype-toString-call-———最好用" class="headerlink" title="4.Object.prototype.toString.call()  ———最好用"></a>4.Object.prototype.toString.call()  ———最好用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(123)</span><br><span class="line">&#x2F;&#x2F;&quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#39;str&#39;)</span><br><span class="line">&#x2F;&#x2F;&quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)</span><br><span class="line">&#x2F;&#x2F;&quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)</span><br><span class="line">&#x2F;&#x2F;&quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([])</span><br><span class="line">&#x2F;&#x2F;&quot;[object Array]&quot;</span><br></pre></td></tr></table></figure>

<p>封装一个判断数组和对象的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function typeObj(obj)&#123;</span><br><span class="line">      var type&#x3D;Object.prototype.toString.call(obj);</span><br><span class="line">      if(type&#x3D;&#x3D;&#39;[object Array]&#39;)&#123;</span><br><span class="line">        return &#39;Array&#39;;</span><br><span class="line">      &#125;elseif(type&#x3D;&#x3D;&#39;[object  Object]&#39;)&#123;</span><br><span class="line">        return &#39;Object&#39;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        return &quot;obj is not object or array&quot;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>对象的方法</tag>
      </tags>
  </entry>
  <entry>
    <title>js之快速理解i闭包</title>
    <url>/2020/09/29/js%E4%B9%8B%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3i%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 累加器</span><br><span class="line">function counter() &#123;</span><br><span class="line">  &#x2F;&#x2F; 秒数</span><br><span class="line">  let second &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  function doCounter() &#123;</span><br><span class="line">    &#x2F;&#x2F; 到达10秒后停止</span><br><span class="line">    if (second &#x3D;&#x3D;&#x3D; 10) &#123;</span><br><span class="line">      clearInterval(recordSecond);</span><br><span class="line">      console.log(&#39;计时结束!&#39;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    second +&#x3D; 1;</span><br><span class="line">    console.log(&#96;$&#123;second&#125;秒&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return doCounter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 得到累加器</span><br><span class="line">const doCounterFn &#x3D; counter();</span><br><span class="line"></span><br><span class="line">const recordSecond &#x3D; setInterval(function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 调用累加器</span><br><span class="line">  doCounterFn();</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>大概意思就是嵌套函数的外部函数如果返回的是一个函数（内部函数），变量和作用域会被保存，所以可以实现变量累加</p>
<blockquote>
<p>提一个概念，当我们将函数调用的返回值赋值给一个变量时，如果调用的这个函数返回的是一个函数，那么变量得到的则是对这个<strong>返回函数</strong>的引用（返回函数的内存地址），当一个函数存在被引用的关系，垃圾回收机制则不会回收它所占的内存，也就是保留该函数的整个执行上下文占用的内存（变量对象，作用域链等）。而因为返回的这个函数同时又是某个函数的内部函数，产生了作用域嵌套，形成了闭包，返回函数的作用域链上包括了外部函数的作用域，也就是返回函数中可以访问外部函数中定义的变量。</p>
</blockquote>
<p>参考链接：<a href="https://juejin.im/post/6877512572178808845" target="_blank" rel="noopener">https://juejin.im/post/6877512572178808845</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>js之构造函数原型实例</title>
    <url>/2020/09/25/js%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>首先用构造函数（一会解释什么叫做构造函数）的方法创建一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name=<span class="string">'123'</span>&#125;   <span class="comment">//ƒ ()&#123;this.name='123'&#125;</span></span><br><span class="line"><span class="keyword">var</span> a1=<span class="keyword">new</span> M()  <span class="comment">//M &#123;name: "123"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.name)  <span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数：</strong>现在M就是构造函数，因为他被new过了！–在js中，只要是被new过的函数都被成为构造函数。</p>
<p><strong>实例对象：</strong>现在a1就叫做实例，因为他是被new出来的！–在js中，只要是被new出来的对象都叫做实例对象。也叫实例。</p>
<p><strong>原型对象：</strong>现在M.prototype就是原型对象，构造函数函数被创建出来的时候，天生就带一个prototype属性，而这个属性里面的东西就叫原型对象。</p>
 <a id="more"></a>

<p><strong><em>\</em>他们之间的关系就如同下图：**</strong>我们暂时只看绿色框中的内容</p>
<p><img src="https://img-blog.csdnimg.cn/20190624230114432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDEwNTQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>从图中可得知4种关系：</p>
<p>1、构造函数（例子中的M）new出来的东西就叫实例，或者叫实例对象</p>
<p>2、构造函数（例子中的M）的prototype属性就叫原型对象</p>
<p>3、原型对象（M.prototype）中的constructor其实就等于构造函数，可以打印一下  M.prototype.constructor===M //true</p>
<p>   这样我们就知道构造函数和原型对象的关系了吧，就是一个闭环。</p>
<p>4、实例（例子中的a1）的_  _proto__属性其实就是把他new出来的那个构造函数的prototype</p>
<p>   可以打印 a1._ <em>proto_</em>===M.prototype //true</p>
<p>接下来我们看图的另一半</p>
<p><img src="https://img-blog.csdnimg.cn/20190625102904387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDEwNTQ0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>一个被new出来的实例，通过本身的<strong>proto</strong>属性找到他的原型对象，然后再通过他的原型对象的<strong>proto</strong>找到他的原型对象，一直找，递归访问<strong>proto</strong>最终到头，并且值是null，这个过程从头到结束就叫<strong>原型链</strong></p>
<p>构造函数的contructor属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分别以字面量和构造函数的方式创建</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;</span><br><span class="line">o.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span></span><br><span class="line">o.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line">a.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span></span><br><span class="line">a.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line">a.constructor === <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>)</span><br><span class="line">n.constructor === <span class="built_in">Number</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>构造函数</tag>
        <tag>原型对象</tag>
        <tag>实例对象</tag>
      </tags>
  </entry>
  <entry>
    <title>js之深拷贝和浅拷贝方法合集</title>
    <url>/2020/10/20/js%E4%B9%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="js中的堆和栈"><a href="#js中的堆和栈" class="headerlink" title="js中的堆和栈"></a><a href="https://www.cnblogs.com/cherishnow/p/10901586.html" target="_blank" rel="noopener">js中的堆和栈</a></h2><h3 id="一-栈和堆"><a href="#一-栈和堆" class="headerlink" title="一.栈和堆"></a>一.栈和堆</h3><p>栈(stack)：栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。（基本类型：String，Number，Boolean，Null，Undefined）<br>堆(heap)：动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。（引用类型：Function，Array，Object）</p>
<h3 id="二-区别"><a href="#二-区别" class="headerlink" title="二.区别"></a>二.区别</h3><p>栈：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。<br>优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可以共享；<br>缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。<br>堆：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(参数传递)。创建对象是为了反复利用，这个对象将被保存到运行时数据区。</p>
<a id="more"></a>

<h3 id="三-栈和堆的溢出"><a href="#三-栈和堆的溢出" class="headerlink" title="三.栈和堆的溢出"></a>三.栈和堆的溢出</h3><p>栈：可以递归调用方法，这样随着栈深度的增加，JVM维持着一条长长的方法调用轨迹，知道内存不够分配，产生栈溢出。<br>堆：循环创建对象，通俗点就是不断的new 一个对象。</p>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>JS中的数据类型有两种，分别是基本数据类型和引用数据类型，前者存放在栈中，我们可以通过值的形式去访问；后者则是存放在堆和栈中，我们不能直接操作对象的堆内存空间，只能按照引用进行访问，即只能访问栈中的“地址”，这个地址指向存储在堆中的对象。</p>
<h4 id="自定义函数-–浅拷贝"><a href="#自定义函数-–浅拷贝" class="headerlink" title="自定义函数 –浅拷贝"></a>自定义函数 –浅拷贝</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj&#x3D;&#123;</span><br><span class="line">        name:&#39;zs&#39;,</span><br><span class="line">        age:18,</span><br><span class="line">        friends:[&#39;Kate&#39;,&#39;Bob&#39;,&#39;Mike&#39;],</span><br><span class="line">        hobby:&#123;</span><br><span class="line">            hobby1:&#39;codes&#39;,</span><br><span class="line">            hobby2:&#39;piano&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function copy(obj1)&#123;</span><br><span class="line">        var obj2&#x3D;&#123;&#125;;</span><br><span class="line">        for(var key in obj1)&#123;</span><br><span class="line">            obj2[key]&#x3D;obj1[key]</span><br><span class="line">        &#125;</span><br><span class="line">        return obj2;</span><br><span class="line">    &#125;</span><br><span class="line">    var result&#x3D;copy(obj);   </span><br><span class="line">    console.log(result.friends);&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br></pre></td></tr></table></figure>

<p>以上代码可以将obj的值完全拷贝给obj2，看起来确实没有问题，但是一旦修改了原始对象或者拷贝对象的引用类型的属性值，另一个对象的属性值也会发生相应的改变，很明显这并不是我们想要的。那么为什么修改基本类型的属性值并没有产生影响呢？那就要从浅拷贝原理说起了，其实浅拷贝只是拷贝一层，对于基本数据类型来说，拷贝的是值，而深层次对象级别的则是拷贝引用，也就是平常说的地址。既然拷贝的对象与原始对象指向的地址相同，那么二者便会相互影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.friends.push(&#39;Cherry&#39;);</span><br><span class="line"></span><br><span class="line">console.log(result.friends);&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;, &quot;Cherry&quot;]</span><br><span class="line"></span><br><span class="line">obj.name&#x3D;&#39;Rose&#39;;</span><br><span class="line"></span><br><span class="line">console.log(result.name);&#x2F;&#x2F;zs</span><br></pre></td></tr></table></figure>



<h4 id="es6的扩展运算符（…）–浅拷贝"><a href="#es6的扩展运算符（…）–浅拷贝" class="headerlink" title="es6的扩展运算符（…）–浅拷贝"></a>es6的扩展运算符（…）–浅拷贝</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let newObj &#x3D; &#123;...obj&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Object-assign-obj-–浅拷贝"><a href="#Object-assign-obj-–浅拷贝" class="headerlink" title="Object.assign(obj) –浅拷贝"></a>Object.assign(obj) –浅拷贝</h4><p>ES6中对象新增了一个assign方法，可以迅速实现<strong>浅拷贝</strong>，这里演示一下。当然这个方法也存在着引用拷贝互相影响的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj3&#x3D;Object.assign(obj);</span><br><span class="line"></span><br><span class="line">console.log(obj3.friends)&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br></pre></td></tr></table></figure>

<p>在拷贝完成后，我们希望两个对象之间互不影响，也就是说改变任一对象的属性，另一个对象都不会发生改变。那么怎样实现深拷贝呢？这里介绍两种方法，一种是通过JSON来实现，另一种是运用递归来解决。</p>
<h4 id="JSON-stringify-–深拷贝"><a href="#JSON-stringify-–深拷贝" class="headerlink" title="JSON.stringify –深拷贝"></a>JSON.stringify –深拷贝</h4><p>借用JSON的属性可以先用<code>JSON.stringify</code>把对象转成字符串，再用<code>JSON.parse</code>把字符串转成新的对象。当我们改变原始对象的属性值时，拷贝对象的属性并不会发生变化，但是这种方法存在一个弊端，我们无法拷贝原始对象的函数，因为函数是无法转成字符串的。于是，我们就可以考虑用递归的方法来解决问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepCopy(obj1)&#123;</span><br><span class="line">        var copyObj&#x3D;JSON.parse(JSON.stringify(obj1));</span><br><span class="line">        return copyObj;</span><br><span class="line">    &#125;</span><br><span class="line">    var result&#x3D;deepCopy(obj)</span><br><span class="line">    console.log(result.friends);&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br><span class="line">    obj.friends.push(&#39;Cherry&#39;);</span><br><span class="line">    console.log(result.friends);&#x2F;&#x2F; [&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br><span class="line">    console.log(obj.friends);&#x2F;&#x2F;[&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;, &quot;Cherry&quot;]</span><br></pre></td></tr></table></figure>



<h4 id="递归-–深拷贝"><a href="#递归-–深拷贝" class="headerlink" title="递归 –深拷贝"></a>递归 –深拷贝</h4><p>终极办法：递归。因为我们无法确定原始对象里面的嵌套层数，因此可以借助递归的方法，再次调用拷贝函数，直到最深层数据为基本类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj&#x3D;&#123;</span><br><span class="line">        name:&#39;zs&#39;,</span><br><span class="line">        age:18,</span><br><span class="line">        friends:[&#39;Kate&#39;,&#39;Bob&#39;,&#39;Mike&#39;],</span><br><span class="line">        hobby:&#123;</span><br><span class="line">            hobby1:&#39;codes&#39;,</span><br><span class="line">            hobby2:&#39;piano&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    function deepCopy(origin,target)&#123;</span><br><span class="line">        &#x2F;&#x2F;目标值先置为空</span><br><span class="line">        var target&#x3D;null;</span><br><span class="line">        &#x2F;&#x2F;判断原始对象的数据类型</span><br><span class="line">        if(typeof origin&#x3D;&#x3D;&#x3D;&#39;object&#39;&amp;&amp;origin!&#x3D;&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;判断拷贝的是数组还是对象</span><br><span class="line">            target&#x3D;origin instanceof Array?[]:&#123;&#125;;</span><br><span class="line">            for(var key in origin)&#123;</span><br><span class="line">                &#x2F;&#x2F;递归拷贝</span><br><span class="line">                target[key]&#x3D;deepCopy(origin[key],target[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;基本类型直接赋值</span><br><span class="line">            target&#x3D;origin;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">    var newObj&#x3D;&#123;&#125;;</span><br><span class="line">    var result&#x3D;deepCopy(obj,newObj);</span><br><span class="line">    console.log(result);</span><br><span class="line">    obj.friends.push(&#39;Cherry&#39;);</span><br><span class="line">    console.log(result.friends);&#x2F;&#x2F; [&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;]</span><br><span class="line">    console.log(obj.friends)&#x2F;&#x2F; [&quot;Kate&quot;, &quot;Bob&quot;, &quot;Mike&quot;, &quot;Cherry&quot;]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>深拷贝浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>js之防抖和节流</title>
    <url>/2020/09/29/js%E4%B9%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</span><br></pre></td></tr></table></figure>

<p>举个例子：<br> 当鼠标移动到一个div上时，div的内容一直在更新，如果不用防抖处理，效果如下图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">       let count &#x3D; 0;</span><br><span class="line">       function myEvent()&#123;</span><br><span class="line">           mydiv.innerText &#x3D; count++;</span><br><span class="line">       &#125;</span><br><span class="line">       mydiv.addEventListener(&#39;mouseover&#39;, function(event)&#123;</span><br><span class="line">           myEvent();</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><img src="https://user-gold-cdn.xitu.io/2020/3/3/1709ebe109bc00dd?imageslim" alt="img"></p>
<p>使用了防抖后的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(fn,delay) &#123;</span><br><span class="line">           let timeout &#x3D; null;</span><br><span class="line">           return function () &#123;</span><br><span class="line">               if(timeout)&#123;</span><br><span class="line">                   clearTimeout(timeout);</span><br><span class="line">               &#125;</span><br><span class="line">               timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                   fn.apply(this, arguments);</span><br><span class="line">               &#125;,delay);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">       let count &#x3D; 0;</span><br><span class="line">       function myEvent()&#123;</span><br><span class="line">           mydiv.innerText &#x3D; count++;</span><br><span class="line">       &#125;        </span><br><span class="line">       mydiv.addEventListener(&#39;mouseover&#39;, debounce(myEvent,2000));</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2020/3/3/1709ec48bfa90688?imageslim" alt="img"></p>
<p>代码实现原理：<br> 函数防抖的关键在于，在一个动作发生一定时间后，才执行指定事件；如果n秒内高频事件再次被触发，则重新计算时间；</p>
<p>在document中鼠标移动的时候，会在mouseover最后触发的2s后执行回调函数myEvent；如果我们一直在浏览器中移动鼠标（比如10s），会发现会在10 + 2s后才会执行myEvent函数（因为clearTimeout(timeout)），这个就是函数防抖。</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。稀释事件执行频率。</p>
<p><strong>定时器的实现方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function throttle(fn, delay) &#123;</span><br><span class="line">                let hasRun &#x3D; false;</span><br><span class="line">                return function () &#123;</span><br><span class="line">                    if (hasRun) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hasRun &#x3D; true;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        hasRun &#x3D; false;</span><br><span class="line">                        fn.apply(this, arguments);</span><br><span class="line">                    &#125;, delay);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">        let count &#x3D; 0;</span><br><span class="line">        function myEvent()&#123;</span><br><span class="line">            mydiv.innerText &#x3D; count++;</span><br><span class="line">        &#125;        </span><br><span class="line">        mydiv.addEventListener(&#39;mouseover&#39;, throttle(myEvent,2000));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/3/1709fc48220bf21d?imageslim" alt="img"></p>
<p><strong>时间戳的实现方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var count &#x3D; 0;</span><br><span class="line">function myEvent() &#123;</span><br><span class="line">    div.innerText &#x3D; count++;</span><br><span class="line">&#125;</span><br><span class="line">div.onmouseover &#x3D; throttle(myEvent,2000);</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    let pre &#x3D; 0;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        let now &#x3D; new Date().getTime();</span><br><span class="line">        if (now - pre &gt; wait) &#123;</span><br><span class="line">            pre &#x3D; now;</span><br><span class="line">            func.apply(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码实现原理：每隔n秒执行一次回调函数。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>防抖：<br> 1、search搜索联想，用户在不断输入值时，用防抖来节约请求资源；<br> 2、window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次；<br> 3、防止重复提交；<br> 节流：<br> 1、鼠标不断的点击触发，mousedown（单位时间内只触发一次）；<br> 2、监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断；</p>
<p>链接：<a href="https://juejin.im/post/6844904080540729357" target="_blank" rel="noopener">https://juejin.im/post/6844904080540729357</a></p>
]]></content>
  </entry>
  <entry>
    <title>js作用域</title>
    <url>/2020/07/30/js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="js作用域"><a href="#js作用域" class="headerlink" title="js作用域"></a>js作用域</h3><p>![clipboard (2)](js作用域.assets/clipboard (2)-1599547611289.png)</p>
<a id="more"></a>

<p>![clipboard (3)](js作用域.assets/clipboard (3).png)</p>
<p>![clipboard (4)](js作用域.assets/clipboard (4).png)</p>
<p>![clipboard (5)](js作用域.assets/clipboard (5).png)</p>
<p>![clipboard (6)](js作用域.assets/clipboard (6).png)</p>
<p>![clipboard (7)](js作用域.assets/clipboard (7).png)</p>
<p>![clipboard (8)](js作用域.assets/clipboard (8)-1599547718223.png)</p>
<p>![clipboard (9)](js作用域.assets/clipboard (9).png)</p>
]]></content>
      <categories>
        <category>js作用域</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组方法-reduce</title>
    <url>/2020/08/25/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95-reduce/</url>
    <content><![CDATA[<h1 id="JS数组reduce-方法详解及高级技巧"><a href="#JS数组reduce-方法详解及高级技巧" class="headerlink" title="JS数组reduce()方法详解及高级技巧"></a>JS数组reduce()方法详解及高级技巧</h1><h4 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">arr</span><span class="selector-class">.reduce</span>(<span class="selector-tag">callback</span>,<span class="selector-attr">[initialValue]</span>)</span><br></pre></td></tr></table></figure>

<p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>.reduce(function(prev, currentValue, currentIndex, arr), initialValue)</span><br><span class="line"></span><br><span class="line">prev:表示上一次执行方法所返回的值，或者initialValue。（如果initialValue没有设置，则取<span class="built_in">array</span>中的第一个元素）</span><br><span class="line">currentValue:当前循环的<span class="built_in">array</span>的元素值</span><br><span class="line">currentIndex:当前循环的<span class="built_in">array</span>的元素值所对应的下标</span><br><span class="line">arr:表示当前所遍历的函数</span><br><span class="line">    </span><br><span class="line">initialValue:为prev指定一个初始值，可不写，则取<span class="built_in">array</span>的第一个元素</span><br></pre></td></tr></table></figure>



<h4 id="2、实例解析-initialValue-参数"><a href="#2、实例解析-initialValue-参数" class="headerlink" title="2、实例解析 initialValue 参数"></a>2、实例解析 initialValue 参数</h4><p>先看第一个例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果：<br> 1 2 1<br> 3 3 2<br> 6 4 3<br> [1, 2, 3, 4] 10</p>
</blockquote>
<p>这里可以看出，上面的例子index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。</p>
<p>再看第二个例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;，<span class="number">0</span>) <span class="comment">//注意这里设置了初始值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr, sum);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果：<br> 0 1 0<br> 1 2 1<br> 3 3 2<br> 6 4 3<br> [1, 2, 3, 4] 10</p>
</blockquote>
<p>这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。</p>
<p>结论：<code>如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。</code></p>
<p>注意：如果这个数组为空，运用reduce是什么情况？</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//报错，"TypeError: Reduce of empty array with no initial value"</span></span><br></pre></td></tr></table></figure>

<p>但是要是我们设置了初始值就不会报错，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, index);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;，<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [] 0</span></span><br></pre></td></tr></table></figure>

<p><strong>所以一般来说我们提供初始值通常更安全</strong></p>
<h4 id="3、initialValue-类型不同的区别"><a href="#3、initialValue-类型不同的区别" class="headerlink" title="3、initialValue 类型不同的区别"></a>3、initialValue 类型不同的区别</h4><p><strong>初始值为数值：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class="line">const sum &#x3D; arr.reduce(function (prev, current) &#123;</span><br><span class="line">	return prev+current</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(sum) &#x2F;&#x2F;55</span><br></pre></td></tr></table></figure>

<p>reduce根据函数传进来的初始值，不断回调叠加最终算出数组的和</p>
<p><strong>初始值为对象：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class="line">const sum &#x3D; arr.reduce(function (prev, current) &#123;</span><br><span class="line">    prev.count &#x3D; prev.count+current</span><br><span class="line">    return prev</span><br><span class="line">&#125;, &#123;count: 0&#125;)</span><br><span class="line">console.log(sum) &#x2F;&#x2F;&#123;count: 55&#125;</span><br></pre></td></tr></table></figure>

<p>如果初始值为对象的话，返回的也是一个对象</p>
<p><strong>初始值为数组：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str &#x3D; &#39;hello&#39;</span><br><span class="line">const newstr &#x3D; str.split(&#39;&#39;).reduce(function (prev, current) &#123;</span><br><span class="line">    const obj &#x3D; &#123;&#125;;</span><br><span class="line">    obj[current] &#x3D; current;</span><br><span class="line">    prev.push(obj)</span><br><span class="line">    return prev;</span><br><span class="line">&#125;, [])</span><br><span class="line">console.log(newstr)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    h: &#39;h&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    e: &#39;e&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    l: &#39;l&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    l: &#39;l&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    o: &#39;o&#39;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>如果初始值为数组，则返回的也是数组</p>
<h4 id="4、reduce的简单用法"><a href="#4、reduce的简单用法" class="headerlink" title="4、reduce的简单用法"></a>4、reduce的简单用法</h4><p>当然最简单的就是我们常用的数组求和，求乘积了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x+y)</span><br><span class="line"><span class="keyword">var</span> mul = arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x*y)</span><br><span class="line"><span class="built_in">console</span>.log( sum ); <span class="comment">//求和，10</span></span><br><span class="line"><span class="built_in">console</span>.log( mul ); <span class="comment">//求乘积，24</span></span><br></pre></td></tr></table></figure>



<p>计算数组最大值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(prev,cur);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="4、reduce的高级用法"><a href="#4、reduce的高级用法" class="headerlink" title="4、reduce的高级用法"></a>4、reduce的高级用法</h4><p>（1）计算数组中每个元素出现的次数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Bruce'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nameNum = names.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cur <span class="keyword">in</span> pre)&#123;</span><br><span class="line">    pre[cur]++</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    pre[cur] = <span class="number">1</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre</span><br><span class="line">&#125;,&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(nameNum); <span class="comment">//&#123;Alice: 2, Bob: 1, Tiff: 1, Bruce: 1&#125;</span></span><br></pre></td></tr></table></figure>



<p>（2）数组去重</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">方法一</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur,index,curarr</span>) </span>&#123;</span><br><span class="line">    prev.indexOf(cur) === <span class="number">-1</span> &amp;&amp; prev.push(cur);</span><br><span class="line">    <span class="comment">//这里表示prev第一次去设置的init值[]，当满足当前的新数组没有cur（当前元素）时才执行push</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;,[]);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pre.includes(cur))&#123;</span><br><span class="line">      <span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>（3）将二维数组转化为一维</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>



<p>（3）将多维数组转化为一维</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]]</span><br><span class="line"><span class="keyword">const</span> newArr = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>pre.concat(<span class="built_in">Array</span>.isArray(cur)?newArr(cur):cur),[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr(arr)); <span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>



<p>（4）对象里的属性求和</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'math'</span>,</span><br><span class="line">        score: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'chinese'</span>,</span><br><span class="line">        score: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        subject: <span class="string">'english'</span>,</span><br><span class="line">        score: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cur.score + prev;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">//60</span></span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://www.jianshu.com/p/e375ba1cfc47" target="_blank" rel="noopener">https://www.jianshu.com/p/e375ba1cfc47</a></p>
<p>参考链接：<a href="https://blog.csdn.net/hope93/article/details/86528183" target="_blank" rel="noopener">https://blog.csdn.net/hope93/article/details/86528183</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>reduce</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组方法</title>
    <url>/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="15种关于JavaScript的数组方法"><a href="#15种关于JavaScript的数组方法" class="headerlink" title="15种关于JavaScript的数组方法"></a>15种关于JavaScript的数组方法</h3><ul>
<li><p>some（）</p>
</li>
<li><p>reduce（）</p>
</li>
<li><p>Every（）</p>
</li>
<li><p>map（）</p>
</li>
<li><p>flat（）</p>
</li>
<li><p>filter（）</p>
<a id="more"></a>
</li>
<li><p>forEach（）</p>
</li>
<li><p>findIndex（）</p>
</li>
<li><p>indexOf（）</p>
</li>
<li><p>find（）</p>
</li>
<li><p>sort（）</p>
</li>
<li><p>concat（）</p>
</li>
<li><p>fill（）</p>
</li>
<li><p>includes（）</p>
</li>
<li><p>reverse（）</p>
</li>
<li><p>flatMap（）</p>
</li>
</ul>
<p>注意，大多数情况下，我们将简化作为参数传递的函数。</p>
<p>// Instead of using this waymyAwesomeArray.some(test =&gt; {  if (test === “d”) {    return test  }})</p>
<p>// We’ll use the shorter onemyAwesomeArray.some(test =&gt; test === “d”)</p>
<p>1、some()</p>
<p>此方法为参数传递的函数测试数组。如果有一个元素与测试元素匹配，则返回true，否则返回false。</p>
<p>译者注： some() 不会对空数组进行检测；some() 不会改变原始数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.some(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;d&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : true</span><br></pre></td></tr></table></figure>



<p>2、reduce（）</p>
<p>此方法接收一个函数作为累加器。它为数组中的每个元素依次执行回调函数，不包括数组中被删除或者从未被赋值的元素。函数应用于累加器，数组中的每个值最后只返回一个值。</p>
<p>译者注：reduce() 方法接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.reduce((total, value) &#x3D;&gt; total * value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 * 2 * 3 * 4 * 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output &#x3D; 120</span><br></pre></td></tr></table></figure>



<p>3、Every（）</p>
<p>此方法是对数组中每项运行给定函数，如果数组的每个元素都与测试匹配，则返回true，反之则返回false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.every(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;d&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : false</span><br><span class="line"></span><br><span class="line">const myAwesomeArray2 &#x3D; [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">myAwesomeArray2.every(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : true</span><br></pre></td></tr></table></figure>



<p>4、map（）</p>
<p>该方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。它按照原始数组元素顺序依次处理元素。</p>
<p>译者注：map() 不会对空数组进行检测；map() 不会改变原始数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [5, 4, 3, 2, 1]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.map(x &#x3D;&gt; x * x)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;--&gt; Output : 25                  </span><br><span class="line"></span><br><span class="line">             16                  </span><br><span class="line"></span><br><span class="line">             9                  </span><br><span class="line"></span><br><span class="line">             4                  </span><br><span class="line"></span><br><span class="line">             1</span><br><span class="line"></span><br><span class="line">let selected_values &#x3D; [ &#39;1&#39;, &#39;5&#39;, &#39;8&#39; ]</span><br><span class="line"></span><br><span class="line">selected_values &#x3D; selected_values.map(Number) &#x2F;&#x2F; [ 1, 5, 8 ]</span><br><span class="line"></span><br><span class="line">selected_values &#x3D; selected_values.map(Boolean) &#x2F;&#x2F;[true, true, true]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在数组中删除某个对象里的某个属性值</span><br><span class="line">如 list &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        China:&#123;name:‘张三’,age:‘10’&#125;,</span><br><span class="line">        English:&#123;name:‘Tony’,age:‘20’&#125;,</span><br><span class="line">        Spanish:&#123;name:‘Someone’,age:‘12’&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">list.map(item&#x3D;&gt;&#123;</span><br><span class="line">	delete item.English</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>(除了将所有值都强制转换为整数，还可以通过简单地更改map函数的参数将数组中的所有值强制转换为布尔值。)</p>
<p>5、flat（）</p>
<p>此方法创建一个新数组，其中包含子数组上的holden元素，并将其平整到新数组中。请注意，此方法只能进行一个级别的深度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [[1, 2], [3, 4], 5]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.flat()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const myAwesomeArray &#x3D; [[1, 2], [3, 4], 5,[7,[9,10]]]</span><br><span class="line">myAwesomeArray.flat(Infinity)</span><br><span class="line">&#x2F;&#x2F;无限内循环</span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>



<p>6、filter（）</p>
<p>该方法接收一个函数作为参数。并返回一个新数组，该数组包含该数组的所有元素，作为参数传递的过滤函数对其返回true。</p>
<p>译者注：filter（）方法是对数据中的元素进行过滤，也就是说是不能修改原数组中的数据，只能读取原数组中的数据，callback需要返回布尔值；为true的时候，对应的元素留下来；为false的时候，对应的元素过滤掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [  &#123; id: 1, name: &quot;john&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,  &#123; id: 4, name: &quot;Mass&quot; &#125;,]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.filter(element &#x3D;&gt; element.name &#x3D;&#x3D;&#x3D; &quot;Mass&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : 0:&#123;id: 3, name: &quot;Mass&quot;&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                   1:&#123;id: 4, name: &quot;Mass&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>7、forEach（）</p>
<p>此方法用于调用数组的每个元素。并将元素传递给回调函数。</p>
<p>译者注: forEach() 对于空数组是不会执行回调函数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [  &#123; id: 1, name: &quot;john&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.forEach(element &#x3D;&gt; console.log(element.name))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : john                  </span><br><span class="line"></span><br><span class="line">                     Ali                  </span><br><span class="line">                     Mass</span><br></pre></td></tr></table></figure>



<p>8、 findIndex（）</p>
<p>此方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。它为数组中的每个元素都调用一次函数执行，当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1</p>
<p>译者注：findIndex() 对于空数组，函数是不会执行的， findIndex() 并没有改变数组的原始值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [  &#123; id: 1, name: &quot;john&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.findIndex(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : 2</span><br><span class="line"></span><br><span class="line">myAwesomeArray.findIndex(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 7)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : -1</span><br></pre></td></tr></table></figure>



<p>9、 find（）</p>
<p>此方法返回通过测试（函数内判断）的数组的第一个元素的值。find() 方法为数组中的每个元素都调用一次函数执行：当数组中的元素在测试条件时回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。</p>
<p>译者注: find() 对于空数组，函数是不会执行的；find() 并没有改变数组的原始值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [  &#123; id: 1, name: &quot;john&quot; &#125;,  &#123; id: 2, name: &quot;Ali&quot; &#125;,  &#123; id: 3, name: &quot;Mass&quot; &#125;,] </span><br><span class="line"></span><br><span class="line">myAwesomeArray.find(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 3) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : &#123;id: 3, name: &quot;Mass&quot;&#125; </span><br><span class="line"></span><br><span class="line">myAwesomeArray.find(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 7) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : undefined</span><br></pre></td></tr></table></figure>



<p>10、 sort（）</p>
<p>此方法接收一个函数作为参数。它对数组的元素进行排序并返回它。也可以使用含有参数的sort()方法进行排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [5, 4, 3, 2, 1]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sort from smallest to largest</span><br><span class="line"></span><br><span class="line">myAwesomeArray.sort((a, b) &#x3D;&gt; a - b)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  -------&gt; Output : [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Sort from largest to smallest</span><br><span class="line"></span><br><span class="line">myAwesomeArray.sort((a, b) &#x3D;&gt; b - a)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>



<p>11、 concat（）</p>
<p>此方法用于连接两个或多个数组/值，它不会改变现有的数组。而仅仅返回被连接数组的一个新数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const myAwesomeArray2 &#x3D; [10, 20, 30, 40, 50]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.concat(myAwesomeArray2)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]</span><br></pre></td></tr></table></figure>



<p>12、 fill（）</p>
<p>此方法的作用是使用一个固定值来替换数组中的元素。该固定值可以是字母、数字、字符串、数组等等。它还有两个可选参数，表示填充起来的开始位置（默认为0）与结束位置（默认为array.length）。</p>
<p>译者注：fill() 方法用于将一个固定值替换数组的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The first argument (0) is the value</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; he second argument (1) is the starting index</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The third argument (3) is the ending index</span><br><span class="line"></span><br><span class="line">myAwesomeArray.fill(0, 1, 3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [1, 0, 0, 4, 5]</span><br></pre></td></tr></table></figure>



<p>13、 includes（）</p>
<p>此方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。</p>
<p>译者注：includes() 方法区分大小写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.includes(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : true</span><br><span class="line"></span><br><span class="line">myAwesomeArray.includes(8)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(fruit) &#123;</span><br><span class="line">  &#x2F;&#x2F; 条件提取到数组中</span><br><span class="line">  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];</span><br><span class="line"></span><br><span class="line">  if (redFruits.includes(fruit)) &#123;</span><br><span class="line">    console.log(&#39;red&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>14、 reverse（）</p>
<p>此方法用于颠倒数组中元素的顺序。第一个元素成为最后一个，最后一个元素将成为第一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.reverse()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------&gt; Output : [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span><br></pre></td></tr></table></figure>



<p>15、 flatMap（）</p>
<p>该方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。它在一个函数中结合了flat（）和map（）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myAwesomeArray &#x3D; [[1], [2], [3], [4], [5]]</span><br><span class="line"></span><br><span class="line">myAwesomeArray.flatMap(arr &#x3D;&gt; arr * 10)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [10, 20, 30, 40, 50]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;With .flat() and .map()</span><br><span class="line"></span><br><span class="line">myAwesomeArray.flat().map(arr &#x3D;&gt; arr * 10)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------&gt; Output : [10, 20, 30, 40, 50]</span><br></pre></td></tr></table></figure>



<p>16、 indexOf（）()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fruits &#x3D; [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">var a &#x3D; fruits.indexOf(&quot;Apple&quot;);</span><br><span class="line">结果输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">indexOf是传入一个值.找到了返回索引,没有找到返回-1</span><br><span class="line">findIndex是传入一个测试条件,也就是函数,找到了返回索引,没有找到返回-1.</span><br></pre></td></tr></table></figure>



<p>实例</p>
<p>迭代一个空数组</p>
<p>JavaScript 中直接创建的数组是松散的，以至于会有很多坑。试着用数组的构造方法创建一个数组，你就会瞬间明白了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; new Array(4);[undefined, undefined, undefined, undefined]&#x2F;&#x2F; 谷歌浏览器中是 [empty x 4]</span><br></pre></td></tr></table></figure>

<p>你会发现，通过一个松散的数组去循环调用一些转换是非常难的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; new Array(4);arr.map((elem, index) &#x3D;&gt; index);[undefined, undefined, undefined, undefined]</span><br></pre></td></tr></table></figure>

<p>想要解决这个问题，你可以使用在创建新数组的时候使用 <em>Array.apply</em>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; Array.apply(null, new Array(4));arr.map((elem, index) &#x3D;&gt; index);[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>



<p>Javascript多维数组扁平化</p>
<p>下面是将多位数组转化为单一数组的三种不同方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</span><br></pre></td></tr></table></figure>

<p>期望结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>解决方案1：使用concat()和apply()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newArr &#x3D; [].concat.apply([], arr);&#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>解决方案2：使用reduce()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newArr &#x3D; arr.reduce(function(prev, curr) &#123;  return prev.concat(curr);&#125;);&#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>解决方案3：使用 ES6 的展开运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newArr &#x3D; [].concat(...arr);console.log(newArr);&#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>解决方案4：使用Array.proptotype.flat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newArr &#x3D; arr.flat()</span><br></pre></td></tr></table></figure>



<h2 id="2-给方法传一个空参数"><a href="#2-给方法传一个空参数" class="headerlink" title="2. 给方法传一个空参数"></a>2. 给方法传一个空参数</h2><p>如果你想调用一个方法，并不填其中的一个参数时，JavaScript 就会报错。</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method(&#39;parameter1&#39;, , &#39;parameter3&#39;); &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token ,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>一个我们常用的解决方法是传递 null 或 undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method(&#39;parameter1&#39;, null, &#39;parameter3&#39;) &#x2F;&#x2F; or</span><br><span class="line">method(&#39;parameter1&#39;, undefined, &#39;parameter3&#39;);</span><br></pre></td></tr></table></figure>

<p>根据 ES6 中对扩展运算符的介绍，有一个更简洁的方法可以将空参数传递给一个方法。正如上面所提到的，数组是松散的，所以给它传空值是可以的，我们正是用到了这个优点。</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method(...[&#39;parameter1&#39;, , &#39;parameter3&#39;]); &#x2F;&#x2F; 代码执行了...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3. 数组去重"></a>3. 数组去重</h2><p>我一直不明白为什么数组不提供一个内置函数可以让我们方便的取到去重以后的值。扩展运算符帮到了我们，使用扩展运算符配合 Set可以生成一个不重复的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [...new Set([1, 2, 3, 3])];&#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>





<p>判断一个数组中是否有相同的</p>
<p>1，普通数组</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/e9dd2688ece34b1ba81d391336c5e0a1/db3151266e069a56a9ba36f665d74f8.png" alt="img"></p>
<p>对象数组</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/136023e12af0401f9b684274c3bbc546/clipboard.png" alt="img"></p>
<p>去重方法</p>
<p>普通数组</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/20373a06171a4ac7bcfe9ea9f0852ba1/clipboard.png" alt="img"></p>
<p>对象数组</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/e50bd5cace6a4f0c9543035efd8a0a1e/clipboard.png" alt="img"></p>
<p>举例</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/c5aa3be1f55f4308a73d94fedf91ec0b/7a5080667b91dd81a3e75ad1c0ff8dc.png" alt="img"></p>
<p>二维数组方法</p>
<p><img src="/2020/07/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/9a4d248972f74ac184f5ee7787a651d7/5e1f34890adcd7abba1b3fc9c0f0503.jpg" alt="img"></p>
<p>var arr=[[1,2,3,4],[5,6,7,8],[‘A’,’B’,’C’,’D’]]</p>
<p>console.log(arr[0].map((n,i)=&gt;arr.reduce((t,c)=&gt;t.concat(c[i]),[])))</p>
<p>二维数组翻转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">翻转二维数组</span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//逆时针旋转 90 度</span></span><br><span class="line">    <span class="comment">//列 = 行</span></span><br><span class="line">    <span class="comment">//行 = n - 1 - 列(j);  n表示总行数</span></span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">var</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> k = len - <span class="number">1</span> -j;</span><br><span class="line">            <span class="keyword">if</span>(!temp[k])&#123;</span><br><span class="line">                temp[k] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            temp[k][i] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> rotate180 = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//逆时针旋转 180 度</span></span><br><span class="line">    <span class="comment">//行 = h - 1 - 行(i);  h表示总行数</span></span><br><span class="line">    <span class="comment">//列 = n - 1 - 列(j);  n表示总列数</span></span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">var</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> k = len - <span class="number">1</span> - i;</span><br><span class="line">            <span class="keyword">if</span>(!temp[k])&#123;</span><br><span class="line">                temp[k] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            temp[k][len<span class="number">-1</span>-j] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> rotate270 = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//逆时针旋转 270 度</span></span><br><span class="line">    <span class="comment">//行 = 列</span></span><br><span class="line">    <span class="comment">//列 = n - 1 - 行(i);  n表示总列数</span></span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">var</span> len = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> k = len - <span class="number">1</span> - i;</span><br><span class="line">            <span class="keyword">if</span>(!temp[j])&#123;</span><br><span class="line">                temp[j] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            temp[j][k] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组方法之sort</title>
    <url>/2020/09/30/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E4%B9%8Bsort/</url>
    <content><![CDATA[<p><strong>总之：return -1 和return b-a是降序</strong></p>
<p><strong>总之：return 1 和return a-b是升序</strong></p>
<p><strong><code>sort()</code></strong> 方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串<strong><code>Unicode</code></strong>码点。<br>语法：arrayObject.sort(sortby)；参数sortby可选。规定排序顺序。必须是函数。<br>注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<a id="more"></a>

<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：<br>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p>
<p>例1：我们将创建一个数组，并按字母顺序进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; new Array(6)</span><br><span class="line">arr[0] &#x3D; &quot;George&quot;</span><br><span class="line">arr[1] &#x3D; &quot;John&quot;</span><br><span class="line">arr[2] &#x3D; &quot;Thomas&quot;</span><br><span class="line">arr[3] &#x3D; &quot;James&quot;</span><br><span class="line">arr[4] &#x3D; &quot;Adrew&quot;</span><br><span class="line">arr[5] &#x3D; &quot;Martin&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br &#x2F;&gt;&quot;)</span><br><span class="line">document.write(arr.sort())</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">George,John,Thomas,James,Adrew,Martin</span><br><span class="line">Adrew,George,James,John,Martin,Thomas</span><br></pre></td></tr></table></figure>

<p>例2：我们将创建一个数组，并按字母顺序进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; new Array(6)</span><br><span class="line">arr[0] &#x3D; &quot;10&quot;</span><br><span class="line">arr[1] &#x3D; &quot;5&quot;</span><br><span class="line">arr[2] &#x3D; &quot;40&quot;</span><br><span class="line">arr[3] &#x3D; &quot;25&quot;</span><br><span class="line">arr[4] &#x3D; &quot;1000&quot;</span><br><span class="line">arr[5] &#x3D; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br &#x2F;&gt;&quot;)</span><br><span class="line">document.write(arr.sort())</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10,5,40,25,1000,1</span><br><span class="line">1,10,1000,25,40,5</span><br></pre></td></tr></table></figure>

<p>请注意，上面的代码没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">function sortNumber(a,b)</span><br><span class="line">&#123;</span><br><span class="line">return a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; new Array(6)</span><br><span class="line">arr[0] &#x3D; &quot;10&quot;</span><br><span class="line">arr[1] &#x3D; &quot;5&quot;</span><br><span class="line">arr[2] &#x3D; &quot;40&quot;</span><br><span class="line">arr[3] &#x3D; &quot;25&quot;</span><br><span class="line">arr[4] &#x3D; &quot;1000&quot;</span><br><span class="line">arr[5] &#x3D; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br &#x2F;&gt;&quot;)</span><br><span class="line">document.write(arr.sort(sortNumber))</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10,5,40,25,1000,1</span><br><span class="line">1,5,10,25,40,1000</span><br></pre></td></tr></table></figure>

<h3 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h3><p>这里可以看出，如果安装升序排列，那么方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sortNumber(a,b)&#123;</span><br><span class="line">    return a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是按照降序排列则为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sortNumber(a,b)&#123;</span><br><span class="line">    return b - a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组对象中的某个属性值进行排序"><a href="#数组对象中的某个属性值进行排序" class="headerlink" title="数组对象中的某个属性值进行排序"></a>数组对象中的某个属性值进行排序</h3><p><code>sort</code>方法接收一个函数作为参数，这里嵌套一层函数用来接收对象属性名，其他部分代码与正常使用<code>sort</code>方法相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [</span><br><span class="line">    &#123;name:&#39;zopp&#39;,age:0&#125;,</span><br><span class="line">    &#123;name:&#39;gpp&#39;,age:18&#125;,</span><br><span class="line">    &#123;name:&#39;yjj&#39;,age:8&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function compare(property)&#123;</span><br><span class="line">    return function(a,b)&#123;</span><br><span class="line">        var value1 &#x3D; a[property];</span><br><span class="line">        var value2 &#x3D; b[property];</span><br><span class="line">        return value1 - value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var compare &#x3D; function (prop) &#123;</span><br><span class="line">  return function (obj1, obj2) &#123;</span><br><span class="line">      var val1 &#x3D; obj1[prop];</span><br><span class="line">      var val2 &#x3D; obj2[prop];</span><br><span class="line">      if (!isNaN(Number(val1)) &amp;&amp; !isNaN(Number(val2))) &#123;</span><br><span class="line">          val1 &#x3D; Number(val1);</span><br><span class="line">          val2 &#x3D; Number(val2);</span><br><span class="line">      &#125;</span><br><span class="line">      if (val1 &lt; val2) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">      &#125; else if (val1 &gt; val2) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.sort(compare(&#39;age&#39;)))</span><br></pre></td></tr></table></figure>

<p>结果如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/595142/201705/595142-20170515085841119-1950402124.png" alt="img"></p>
<h3 id="根据参数不同，来确定是升序排列，还是降序排序"><a href="#根据参数不同，来确定是升序排列，还是降序排序" class="headerlink" title="根据参数不同，来确定是升序排列，还是降序排序"></a>根据参数不同，来确定是升序排列，还是降序排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sortBy: function(attr,rev)&#123;</span><br><span class="line">    &#x2F;&#x2F;第二个参数没有传递 默认升序排列</span><br><span class="line">    if(rev &#x3D;&#x3D;  undefined)&#123;</span><br><span class="line">        rev &#x3D; 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        rev &#x3D; (rev) ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return function(a,b)&#123;</span><br><span class="line">        a &#x3D; a[attr];</span><br><span class="line">        b &#x3D; b[attr];</span><br><span class="line">        if(a &lt; b)&#123;</span><br><span class="line">            return rev * -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a &gt; b)&#123;</span><br><span class="line">            return rev * 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newArray.sort(sortBy(&#39;number&#39;,false))</span><br></pre></td></tr></table></figure>

<h3 id="某个属性值相同时，根据另一个属性排序"><a href="#某个属性值相同时，根据另一个属性排序" class="headerlink" title="某个属性值相同时，根据另一个属性排序"></a>某个属性值相同时，根据另一个属性排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D; [ </span><br><span class="line">    &#123; &#39;sortNo&#39;: 2, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 1, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 5, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 6, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 7, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 3, &#39;sortNo2&#39;: 4&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 3, &#39;sortNo2&#39;: 2&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 3, &#39;sortNo2&#39;: 1&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 3, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 8, &#39;sortNo2&#39;: 3&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 4, &#39;sortNo2&#39;: 1&#125;,</span><br><span class="line">    &#123; &#39;sortNo&#39;: 4, &#39;sortNo2&#39;: 2&#125;</span><br><span class="line">];</span><br><span class="line">arr.sort(function(a, b)&#123;</span><br><span class="line">    if (a.sortNo &#x3D;&#x3D;&#x3D; b.sortNo) &#123;</span><br><span class="line">            return b.sortNo2 - a.sortNo2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            return a.sortNo - b.sortNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>js方法（一）</title>
    <url>/2020/07/23/js%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="获取服务器时间"><a href="#获取服务器时间" class="headerlink" title="获取服务器时间"></a>获取服务器时间</h3><a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、依赖jQuery</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServerDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>($.ajax(&#123; <span class="attr">async</span>: <span class="literal">false</span> &#125;).getResponseHeader(<span class="string">"Date"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>、原生</span><br><span class="line">（同步）</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServerDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> <span class="built_in">window</span>.XMLHttpRequest();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// ie</span></span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveObject(<span class="string">"Microsoft"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, <span class="string">"/"</span>, <span class="literal">false</span>)<span class="comment">//false不可变</span></span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">var</span> date = xhr.getResponseHeader(<span class="string">"Date"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">&#125;</span><br><span class="line">（异步）</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServerDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> <span class="built_in">window</span>.XMLHttpRequest();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// ie</span></span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveObject(<span class="string">"Microsoft"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, <span class="string">"/"</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> time, date;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">2</span>) &#123;</span><br><span class="line">      time = xhr.getResponseHeader(<span class="string">"Date"</span>);</span><br><span class="line">      date = <span class="keyword">new</span> <span class="built_in">Date</span>(time);</span><br><span class="line">      <span class="built_in">console</span>.log(date);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="userAgent"><a href="#userAgent" class="headerlink" title="userAgent"></a>userAgent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">userAgent属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。</span><br><span class="line"></span><br><span class="line">一般来讲，它是在 navigator.appCodeName 的值之后加上斜线和 navigator.appVersion 的值构成的。</span><br><span class="line"></span><br><span class="line">例如：Mozilla / <span class="number">4.0</span>(compatible; MSIE <span class="number">6.0</span>; Windows NT <span class="number">5.2</span>; SV1; .NET CLR <span class="number">1.1</span><span class="number">.4322</span>) 。</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;浏览器："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.appName + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">浏览器：Netscape</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;浏览器版本："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.appVersion + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">浏览器版本：<span class="number">5.0</span>(Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit / <span class="number">537.36</span>(KHTML, like Gecko) Chrome / <span class="number">77.0</span><span class="number">.3865</span><span class="number">.120</span> Safari / <span class="number">537.36</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;代码："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.appCodeName + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">代码：Mozilla</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;平台："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.platform + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">平台：Win32</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;Cookies 启用："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.cookieEnabled + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">Cookies 启用：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;p&gt;浏览器的用户代理报头："</span>)</span><br><span class="line"><span class="built_in">document</span>.write(navigator.userAgent + <span class="string">"&lt;/p&gt;"</span>)</span><br><span class="line">浏览器的用户代理报头：Mozilla / <span class="number">5.0</span>(Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit / <span class="number">537.36</span>(KHTML, like Gecko) Chrome / <span class="number">77.0</span><span class="number">.3865</span><span class="number">.120</span> Safari / <span class="number">537.36</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b_version = navigator.appVersion</span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">parseFloat</span>(b_version)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"浏览器版本："</span> + version)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、通过判断浏览器的userAgent，用正则来判断是否是ios和Android客户端。代码如下：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、检查是否是移动端（Mobile）、ipad、iphone、微信、QQ等：</span><br><span class="line"></span><br><span class="line">使用方法：</span><br><span class="line"></span><br><span class="line">检测浏览器语言：</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、判断iPhone | iPad | iPod | iOS | Android客户端：</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、判断pc还是移动端：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line"><span class="keyword">var</span> isAndroid = u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>; <span class="comment">//android终端</span></span><br><span class="line"><span class="keyword">var</span> isiOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端</span></span><br></pre></td></tr></table></figure>

<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deepClone: function (obj) &#123;</span><br><span class="line">    var _obj &#x3D; JSON.stringify(obj),</span><br><span class="line">    objClone &#x3D; JSON.parse(_obj);</span><br><span class="line">    return objClone</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="获取url参数"><a href="#获取url参数" class="headerlink" title="获取url参数"></a>获取url参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getUrlParam = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = location.search;</span><br><span class="line">    <span class="keyword">var</span> theRequest = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">"?"</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = url.substr(<span class="number">1</span>);</span><br><span class="line">        strs = str.split(<span class="string">"&amp;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            theRequest[strs[i].split(<span class="string">"="</span>)[<span class="number">0</span>]] = strs[i].split(<span class="string">"="</span>)[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> theRequest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="encodeURI-和encodeURIComponent-decodeURI-和decodeURIComponent"><a href="#encodeURI-和encodeURIComponent-decodeURI-和decodeURIComponent" class="headerlink" title="encodeURI()和encodeURIComponent()  decodeURI()和decodeURIComponent()"></a>encodeURI()和encodeURIComponent()  decodeURI()和decodeURIComponent()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其中encodeURI()主要用于整个URI(例如，http:&#x2F;&#x2F;www.jxbh.cn&#x2F;illegal value.htm)，而encode-URIComponent()主要用于对URI中的某一段(例如前面URI中的illegal value．htm)进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。来看下面的例子：</span><br><span class="line">var uri&#x3D;&quot;http:&#x2F;&#x2F;www.jxbh.cn&#x2F;illegal value.htm#start&quot;;</span><br><span class="line">&#x2F;&#x2F;”http: &#x2F;&#x2F;www.jxbh.cn&#x2F;illegal%20value .htm#s tart”</span><br><span class="line">alert(encodeURI (uri)):</span><br><span class="line">&#x2F;&#x2F;”http% 3A%2F%2Fwww.jxbh.cn%2 Fillegal%2 0value. htm%23 start”</span><br><span class="line">alert( encodaURIComponent (uri));</span><br><span class="line">使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()的原因所在。一般来说,我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多,因为在实践中更常见的是对查询字符串参数而不是对基础URL进行编码.</span><br><span class="line">经我的观测，很多网站的cookie在进行编码的时候，是encodeURIComponent格式的，所以应该使用decodeURIComponent()进行解码</span><br></pre></td></tr></table></figure>





<h3 id="True与False"><a href="#True与False" class="headerlink" title="True与False"></a>True与False</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">以下是Truthy (真值)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> ([])</span><br><span class="line"><span class="keyword">if</span> (<span class="number">42</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"foo"</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-42</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-3.14</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">Infinity</span>)</span><br><span class="line"><span class="keyword">if</span> (-<span class="literal">Infinity</span>)</span><br><span class="line">  </span><br><span class="line">以下是falsy  值</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NaN</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">""</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">``</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all)</span><br></pre></td></tr></table></figure>

<h3 id="ios下时间格式问题"><a href="#ios下时间格式问题" class="headerlink" title="ios下时间格式问题"></a>ios下时间格式问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2016-08-09 00:00:00'</span>).getTime（） <span class="comment">//拿到的值是NaN</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2016-08-09'</span>).getTime（） <span class="comment">//正常</span></span><br><span class="line">原因：ios下不支持<span class="string">'-'</span>格式的时间可以支持<span class="string">'/'</span></span><br><span class="line">解决方案：改成<span class="string">'yy/mm/dd'</span></span><br></pre></td></tr></table></figure>



<h3 id="打印周几"><a href="#打印周几" class="headerlink" title="打印周几"></a>打印周几</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> week=[<span class="string">'星期日'</span>,<span class="string">'星期一'</span>,<span class="string">'星期二'</span>,<span class="string">'星期三'</span>,<span class="string">'星期四'</span>,<span class="string">'星期五'</span>,<span class="string">'星期六'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">document</span>.write(week[date.getDay()])</span><br></pre></td></tr></table></figure>



<h3 id="js-判断当前时间是否处于某个时间段内"><a href="#js-判断当前时间是否处于某个时间段内" class="headerlink" title="js 判断当前时间是否处于某个时间段内"></a>js 判断当前时间是否处于某个时间段内</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isDuringDate: function (beginDateStr, endDateStr) &#123;</span><br><span class="line">    var curDate &#x3D; new Date(),</span><br><span class="line">    beginDate &#x3D; new Date(beginDateStr),</span><br><span class="line">    endDate &#x3D; new Date(endDateStr);</span><br><span class="line">    if (curDate &gt;&#x3D; beginDate &amp;&amp; curDate &lt;&#x3D; endDate) &#123;</span><br><span class="line">    	return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">isDuringDate(&#39;2018&#x2F;09&#x2F;17&#39;, &#39;2030&#x2F;09&#x2F;17&#39;)</span><br></pre></td></tr></table></figure>





<h3 id="当前时间加半个小时"><a href="#当前时间加半个小时" class="headerlink" title="当前时间加半个小时"></a>当前时间加半个小时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">当前时间加上半个小时一个小时等</span><br><span class="line">getHourDate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    date.setTime(date.getTime() + <span class="number">0.5</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">var</span> FullYear = date.getFullYear();</span><br><span class="line">    <span class="keyword">var</span> month = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> dd = date.getDate();</span><br><span class="line">    <span class="keyword">var</span> hh = date.getHours();</span><br><span class="line">    <span class="keyword">var</span> mm = date.getMinutes();</span><br><span class="line">    <span class="keyword">return</span> FullYear + <span class="string">"-"</span> + month + <span class="string">"-"</span> + dd + <span class="string">" "</span> + hh + <span class="string">":"</span> + mm + <span class="string">":00"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="当前时间与目标时间倒计时到达"><a href="#当前时间与目标时间倒计时到达" class="headerlink" title="当前时间与目标时间倒计时到达"></a>当前时间与目标时间倒计时到达</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">countTime: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前时间  </span></span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> now = date.getTime();</span><br><span class="line">    <span class="comment">//设置截止时间  </span></span><br><span class="line">    <span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.endDate.replace(<span class="regexp">/-/g</span>, <span class="string">'/'</span>));</span><br><span class="line">    <span class="keyword">var</span> end = endDate.getTime();</span><br><span class="line">    <span class="comment">//时间差</span></span><br><span class="line">    <span class="keyword">var</span> leftTime = <span class="keyword">this</span>.leftTime = end - now;</span><br><span class="line">    <span class="comment">//定义变量 d,h,m,s保存倒计时的时间  </span></span><br><span class="line">    <span class="keyword">var</span> d, h, m, s;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.leftTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        d = <span class="built_in">Math</span>.floor(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span><br><span class="line">        h = <span class="built_in">Math</span>.floor(leftTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> % <span class="number">24</span>);</span><br><span class="line">        m = <span class="built_in">Math</span>.floor(leftTime / <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">        s = <span class="built_in">Math</span>.floor(leftTime / <span class="number">1000</span> % <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">this</span>.leftStr = d + <span class="string">"天"</span> + h + <span class="string">"时"</span> + m + <span class="string">"分"</span> + s + <span class="string">"秒"</span></span><br><span class="line">        setTimeout(<span class="keyword">this</span>.countTime, <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.isCanPay = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="将当前时间转化为-2018-12-12-12-00-00"><a href="#将当前时间转化为-2018-12-12-12-00-00" class="headerlink" title="将当前时间转化为 2018-12-12 12:00:00"></a>将当前时间转化为 2018-12-12 12:00:00</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> formatDateTime = <span class="function"><span class="keyword">function</span> (<span class="params">date</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = date.getFullYear();</span><br><span class="line">    <span class="keyword">var</span> m = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">    m = m &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + m) : m;</span><br><span class="line">    <span class="keyword">var</span> d = date.getDate();</span><br><span class="line">    d = d &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + d) : d;</span><br><span class="line">    <span class="keyword">var</span> h = date.getHours();</span><br><span class="line">    h = h &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + h) : h;</span><br><span class="line">    <span class="keyword">var</span> minute = date.getMinutes();</span><br><span class="line">    minute = minute &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + minute) : minute;</span><br><span class="line">    <span class="keyword">var</span> second = date.getSeconds();</span><br><span class="line">    second = second &lt; <span class="number">10</span> ? (<span class="string">'0'</span> + second) : second;</span><br><span class="line">    <span class="keyword">return</span> y + <span class="string">'-'</span> + m + <span class="string">'-'</span> + d + <span class="string">' '</span> + h + <span class="string">':'</span> + minute + <span class="string">':'</span> + second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="判断当前日期是否离开"><a href="#判断当前日期是否离开" class="headerlink" title="判断当前日期是否离开"></a>判断当前日期是否<strong>离开</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">departTimeHandle: <span class="function"><span class="keyword">function</span> (<span class="params">departTime</span>) </span>&#123;</span><br><span class="line">    diff = <span class="keyword">new</span> <span class="built_in">Date</span>(departTime.replace(<span class="regexp">/\-/g</span>, <span class="string">"/"</span>)).getTime() - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        alert(<span class="string">'未出发'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'已离开'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="计算两个时间的分钟差"><a href="#计算两个时间的分钟差" class="headerlink" title="计算两个时间的分钟差"></a>计算两个时间的分钟差</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeDifference</span>(<span class="params">time1, time2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//截取字符串，得到日期部分"2009-12-02",用split把字符串分隔成数组</span></span><br><span class="line">    <span class="keyword">var</span> begin1 = time1.substr(<span class="number">0</span>, <span class="number">10</span>).split(<span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">var</span> end1 = time2.substr(<span class="number">0</span>, <span class="number">10</span>).split(<span class="string">"-"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将拆分的数组重新组合，并实例成化新的日期对象</span></span><br><span class="line">    <span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(begin1[<span class="number">1</span>] + - + begin1[<span class="number">2</span>] + - + begin1[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(end1[<span class="number">1</span>] + - + end1[<span class="number">2</span>] + - + end1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到两个日期之间的差值m，以分钟为单位</span></span><br><span class="line">    <span class="comment">//Math.abs(date2-date1)计算出以毫秒为单位的差值</span></span><br><span class="line">    <span class="comment">//Math.abs(date2-date1)/1000得到以秒为单位的差值</span></span><br><span class="line">    <span class="comment">//Math.abs(date2-date1)/1000/60得到以分钟为单位的差值</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.abs(date2 - date1) / <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小时数和分钟数相加得到总的分钟数</span></span><br><span class="line">    <span class="comment">//time1.substr(11,2)截取字符串得到时间的小时数</span></span><br><span class="line">    <span class="comment">//parseInt(time1.substr(11,2))*60把小时数转化成为分钟</span></span><br><span class="line">    <span class="keyword">var</span> min1 = <span class="built_in">parseInt</span>(time1.substr(<span class="number">11</span>, <span class="number">2</span>)) * <span class="number">60</span> + <span class="built_in">parseInt</span>(time1.substr(<span class="number">14</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">var</span> min2 = <span class="built_in">parseInt</span>(time2.substr(<span class="number">11</span>, <span class="number">2</span>)) * <span class="number">60</span> + <span class="built_in">parseInt</span>(time2.substr(<span class="number">14</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个分钟数相减得到时间部分的差值，以分钟为单位</span></span><br><span class="line">    <span class="keyword">var</span> n = min2 - min1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将日期和时间两个部分计算出来的差值相加，即得到两个时间相减后的分钟数</span></span><br><span class="line">    <span class="keyword">var</span> minutes = m + n;</span><br><span class="line">    <span class="built_in">document</span>.writeln(minutes);</span><br><span class="line">&#125;</span><br><span class="line">TimeDifference(<span class="string">"2019-08-12 15:21:00"</span>, <span class="string">"2019-08-21 10:18:34"</span>);</span><br></pre></td></tr></table></figure>



<p>计算两个时间相隔几天几个小时几分钟几秒几毫秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var  dt1 &#x3D;  &quot;2009-11-5 10:30:01:69&quot;  ;</span><br><span class="line">     var  dt2 &#x3D;  &quot;2009-11-8 9:20:02&quot;</span><br><span class="line">     function  getHoursDiff(dt1,dt2) &#123;</span><br><span class="line">         if ( typeof (dt1)&#x3D;&#x3D; &quot;string&quot; ) &#123;</span><br><span class="line">             dt1&#x3D; new  Date(dt1.replace(&#x2F;-&#x2F;, &#39;&#x2F;&#39; ));</span><br><span class="line">             dt2&#x3D; new  Date(dt2.replace(&#x2F;-&#x2F;, &#39;&#x2F;&#39; ));</span><br><span class="line">         &#125;</span><br><span class="line">         var  res&#x3D;dt2.getTime()-dt1.getTime();</span><br><span class="line">         if (isNaN(res))</span><br><span class="line">             throw  Error( &quot;invalid dates arguments&quot; );</span><br><span class="line"></span><br><span class="line">        var ss &#x3D; 1000;</span><br><span class="line">        var mi &#x3D; ss * 60;</span><br><span class="line">        var hh &#x3D; mi * 60;</span><br><span class="line">        var dd &#x3D; hh * 24;</span><br><span class="line"> </span><br><span class="line">        var day &#x3D; parseInt(res &#x2F; dd);</span><br><span class="line">        var hour &#x3D; parseInt((res&#x2F;hh-day*24));</span><br><span class="line">        var minute &#x3D; parseInt((res&#x2F;mi-day*24*60-hour*60));</span><br><span class="line">        var second &#x3D; parseInt((res&#x2F;ss-day*24*60*60-hour*60*60 -minute*60));</span><br><span class="line">        var milliSecond &#x3D; parseInt((res-day*dd-hour*hh -minute*mi - second*ss));</span><br><span class="line"></span><br><span class="line">        if (day &gt; 0) &#123;</span><br><span class="line">            return parseInt(day) + &quot;天&quot; + hour + &quot;小时&quot; + minute + &quot;分钟&quot; + second +&quot;秒&quot;+ milliSecond +&quot;毫秒&quot;;</span><br><span class="line">        &#125; else if (hour &gt; 0) &#123;</span><br><span class="line">            return hour + &quot;小时&quot; + minute + &quot;分钟&quot;;</span><br><span class="line">        &#125; else if (minute &gt; 0) &#123;</span><br><span class="line">            return minute + &quot;分钟&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0 + &quot;分钟&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">var  re&#x3D;getHoursDiff(dt1,dt2);</span><br></pre></td></tr></table></figure>



<h3 id="距离当前日期多少天后的日期"><a href="#距离当前日期多少天后的日期" class="headerlink" title="距离当前日期多少天后的日期"></a>距离当前日期多少天后的日期</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetDateStr</span>(<span class="params">AddDayCount</span>) </span>&#123;   </span><br><span class="line">      <span class="keyword">var</span> dd = <span class="keyword">new</span> <span class="built_in">Date</span>();  </span><br><span class="line">      dd.setDate(dd.getDate()+AddDayCount);<span class="comment">//获取AddDayCount天后的日期</span></span><br><span class="line">      <span class="keyword">var</span> y = dd.getFullYear();   </span><br><span class="line">      <span class="keyword">var</span> m = (dd.getMonth()+<span class="number">1</span>)&lt;<span class="number">10</span>?<span class="string">"0"</span>+(dd.getMonth()+<span class="number">1</span>):(dd.getMonth()+<span class="number">1</span>);<span class="comment">//获取当前月份的日期，不足10补0</span></span><br><span class="line">      <span class="keyword">var</span> d = dd.getDate()&lt;<span class="number">10</span>?<span class="string">"0"</span>+dd.getDate():dd.getDate();<span class="comment">//获取当前几号，不足10补0</span></span><br><span class="line">      <span class="keyword">return</span> y+<span class="string">"-"</span>+m+<span class="string">"-"</span>+d;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Date-1556121600000-’和‘-Date-1528953453022-0800-’日期格式处理"><a href="#Date-1556121600000-’和‘-Date-1528953453022-0800-’日期格式处理" class="headerlink" title="/Date(1556121600000)/’和‘/Date(1528953453022+0800)/’日期格式处理"></a>/Date(1556121600000)/’和‘/Date(1528953453022+0800)/’日期格式处理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handelTime</span>(<span class="params">strTime</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">parseInt</span>(strTime.replace(<span class="string">"/Date("</span>, <span class="string">""</span>).replace(<span class="string">")/"</span>, <span class="string">""</span>), <span class="number">10</span>));</span><br><span class="line">       <span class="keyword">return</span> obj.toLocaleDateString();</span><br><span class="line">&#125;</span><br><span class="line">handelTime(<span class="string">'\/Date(1556121600000)\/'</span>)</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">dt</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> year = dt.getFullYear(); </span><br><span class="line">  <span class="keyword">var</span> month = dt.getMonth() + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">var</span> date = dt.getDate(); </span><br><span class="line">  <span class="keyword">var</span> hour = dt.getHours(); </span><br><span class="line">  <span class="keyword">var</span> minute = dt.getMinutes(); </span><br><span class="line">  <span class="keyword">var</span> second = dt.getSeconds(); </span><br><span class="line">  <span class="keyword">return</span> year + <span class="string">"-"</span> + month + <span class="string">"-"</span> + date + <span class="string">" "</span> + hour + <span class="string">":"</span> + minute + <span class="string">":"</span> + second; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">time</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">var</span> t= time.slice(<span class="number">6</span>, <span class="number">19</span>) </span><br><span class="line">	<span class="keyword">var</span> NewDtime = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">parseInt</span>(t)); </span><br><span class="line">	<span class="keyword">return</span> formatDate(NewDtime); </span><br><span class="line">&#125; </span><br><span class="line">Test(<span class="string">"/Date(1528953453022+0800)/"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="验证码60s"><a href="#验证码60s" class="headerlink" title="验证码60s"></a>验证码60s</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getCountDown(time=<span class="number">60</span>) &#123; <span class="comment">//验证码一分钟倒计时</span></span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">parseInt</span>(time);</span><br><span class="line">  <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      sendMg: <span class="string">"获取验证码"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    time: <span class="built_in">parseInt</span>(time) - <span class="number">1</span>,</span><br><span class="line">    sendMg: <span class="string">"剩余"</span> + time + <span class="string">"S"</span></span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(<span class="keyword">this</span>.getCountDown, <span class="number">1000</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="距离当天24点前倒计时"><a href="#距离当天24点前倒计时" class="headerlink" title="距离当天24点前倒计时"></a>距离当天24点前倒计时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCountDown: <span class="function"><span class="keyword">function</span> (<span class="params">endTime=<span class="string">'2020-07-29 00:00:00'</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();<span class="comment">//现在时间（时间戳）</span></span><br><span class="line">    <span class="keyword">var</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>(endTime).getTime();<span class="comment">//结束时间（时间戳）</span></span><br><span class="line">    <span class="keyword">var</span> intDiff = (endTime - nowTime) / <span class="number">1000</span>;<span class="comment">//距离结束的毫秒数</span></span><br><span class="line">    <span class="keyword">var</span> day = <span class="number">0</span>,</span><br><span class="line">      hour = <span class="number">24</span>,</span><br><span class="line">      minute = <span class="number">60</span>,</span><br><span class="line">      second = <span class="number">60</span>;<span class="comment">//时间默认值</span></span><br><span class="line">    <span class="keyword">if</span> (intDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      day = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line">      hour = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span>)) - (day * <span class="number">24</span>);</span><br><span class="line">      minute = <span class="built_in">Math</span>.floor(intDiff / <span class="number">60</span>) - (day * <span class="number">24</span> * <span class="number">60</span>) - (hour * <span class="number">60</span>);</span><br><span class="line">      second = <span class="built_in">Math</span>.floor(intDiff) - (day * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) - (hour * <span class="number">60</span> * <span class="number">60</span>) - (minute * <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hour &lt;= <span class="number">9</span>) hour = <span class="string">'0'</span> + hour;</span><br><span class="line">    <span class="keyword">if</span> (minute &lt;= <span class="number">9</span>) minute = <span class="string">'0'</span> + minute;</span><br><span class="line">    <span class="keyword">if</span> (second &lt;= <span class="number">9</span>) second = <span class="string">'0'</span> + second;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      showTime: day + <span class="string">':'</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second</span><br><span class="line">    &#125;)</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.setCountDown, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h3 id="支付半小时倒计时"><a href="#支付半小时倒计时" class="headerlink" title="支付半小时倒计时"></a>支付半小时倒计时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCountDown: <span class="function"><span class="keyword">function</span> (<span class="params">Time = <span class="string">'2020-07-28 16:25:00'</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> setTime = <span class="number">0.5</span> * <span class="number">3600</span> * <span class="number">1000</span>;<span class="comment">//半个小时的毫秒数</span></span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();<span class="comment">//现在时间（时间戳）</span></span><br><span class="line">    <span class="keyword">var</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>().setTime(<span class="keyword">new</span> <span class="built_in">Date</span>(Time).getTime() + setTime);<span class="comment">//距离参数半个小时后的时间</span></span><br><span class="line">    <span class="keyword">var</span> intDiff = (endTime - nowTime) / <span class="number">1000</span>;<span class="comment">//毫秒数差</span></span><br><span class="line">    <span class="keyword">var</span> day = <span class="number">0</span>,</span><br><span class="line">      hour = <span class="number">24</span>,</span><br><span class="line">      minute = <span class="number">60</span>,</span><br><span class="line">      second = <span class="number">60</span>;<span class="comment">//时间默认值</span></span><br><span class="line">    <span class="keyword">if</span> (intDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      day = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line">      hour = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span>)) - (day * <span class="number">24</span>);</span><br><span class="line">      minute = <span class="built_in">Math</span>.floor(intDiff / <span class="number">60</span>) - (day * <span class="number">24</span> * <span class="number">60</span>) - (hour * <span class="number">60</span>);</span><br><span class="line">      second = <span class="built_in">Math</span>.floor(intDiff) - (day * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) - (hour * <span class="number">60</span> * <span class="number">60</span>) - (minute * <span class="number">60</span>);</span><br><span class="line">      <span class="keyword">if</span> (hour &lt;= <span class="number">9</span>) hour = <span class="string">'0'</span> + hour;</span><br><span class="line">      <span class="keyword">if</span> (minute &lt;= <span class="number">9</span>) minute = <span class="string">'0'</span> + minute;</span><br><span class="line">      <span class="keyword">if</span> (second &lt;= <span class="number">9</span>) second = <span class="string">'0'</span> + second;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        showTime: day + <span class="string">':'</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        showTime: <span class="string">'00:00:00'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.setCountDown, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h3 id="遍历值键对"><a href="#遍历值键对" class="headerlink" title="遍历值键对"></a>遍历值键对</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test: &#123;</span><br><span class="line">                <span class="string">"阿巴嘎旗"</span>: &#123;</span><br><span class="line">                    <span class="string">"hot"</span>: <span class="number">10851</span>,</span><br><span class="line">                    <span class="string">"priority"</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"match"</span>: <span class="string">"abgq|abagaqi"</span>,</span><br><span class="line">                    <span class="string">"stationCode"</span>: <span class="string">"abagaqi"</span>,</span><br><span class="line">                    <span class="string">"cityId"</span>: <span class="number">269</span>,</span><br><span class="line">                    <span class="string">"cityName"</span>: <span class="string">"锡林郭勒盟"</span>,</span><br><span class="line">                    <span class="string">"provinceId"</span>: <span class="number">19</span>,</span><br><span class="line">                    <span class="string">"provinceName"</span>: <span class="string">"内蒙古"</span>,</span><br><span class="line">                    <span class="string">"longitude"</span>: <span class="string">"0.000000"</span>,</span><br><span class="line">                    <span class="string">"latitude"</span>: <span class="string">"0.000000"</span>,</span><br><span class="line">                    <span class="string">"siteCode"</span>: <span class="string">""</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"阿尔山"</span>: &#123;</span><br><span class="line">                    <span class="string">"hot"</span>: <span class="number">311502</span>,</span><br><span class="line">                    <span class="string">"priority"</span>: <span class="number">10</span>,</span><br><span class="line">                    <span class="string">"match"</span>: <span class="string">"aes|aershan"</span>,</span><br><span class="line">                    <span class="string">"stationCode"</span>: <span class="string">"aershan"</span>,</span><br><span class="line">                    <span class="string">"cityId"</span>: <span class="number">270</span>,</span><br><span class="line">                    <span class="string">"cityName"</span>: <span class="string">"兴安盟"</span>,</span><br><span class="line">                    <span class="string">"provinceId"</span>: <span class="number">19</span>,</span><br><span class="line">                    <span class="string">"provinceName"</span>: <span class="string">"内蒙古"</span>,</span><br><span class="line">                    <span class="string">"longitude"</span>: <span class="string">"119.954934"</span>,</span><br><span class="line">                    <span class="string">"latitude"</span>: <span class="string">"47.177865"</span>,</span><br><span class="line">                    <span class="string">"siteCode"</span>: <span class="string">""</span></span><br><span class="line">                &#125;,</span><br><span class="line">&#125;</span><br><span class="line">遍历方法：</span><br><span class="line"><span class="keyword">var</span> allcities = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> test) &#123;</span><br><span class="line">    <span class="keyword">var</span> city = [];</span><br><span class="line">    city.push(test[prop].provinceId, prop, <span class="string">'0'</span>, test[prop].match, test[prop].stationCode);</span><br><span class="line">    allcities.push(city);</span><br><span class="line">    <span class="comment">// console.log(test[prop]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">判断对象是否为空</span><br><span class="line">evtValue = &#123;&#125;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(evtValue) == <span class="string">'&#123;&#125;'</span></span><br><span class="line"><span class="built_in">Object</span>.keys(evtValue).length == <span class="number">0</span></span><br><span class="line">取对象的属性和值</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'叶落森'</span>, <span class="string">'sex'</span>: <span class="string">'女'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">Object</span>.keys(obj); --可以获取key值</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="built_in">Object</span>.values(obj); --可以获取value值</span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// ['id','name','sex']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">//  ['1','叶落森','女']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">1</span>]);  <span class="comment">// 叶落森</span></span><br></pre></td></tr></table></figure>



<h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、window.location具有以下属性：</span><br><span class="line"></span><br><span class="line">1、window.location.href：取得当前地址栏中的完整URL，可以通过赋值改变当前地址栏中的URL；</span><br><span class="line"></span><br><span class="line">2、window.location.search 取得当前URL的参数部分，即“?”后面的部分（包括问号），可以通过赋值改变URL的参数部分；</span><br><span class="line"></span><br><span class="line">3、window.location.host：取得当前URL中的主机信息，包括端口号，可以通过赋值改变主机信息；</span><br><span class="line"></span><br><span class="line">4、window.location.port：取得当前URL中的端口号，可以通过赋值改变端口号；</span><br><span class="line"></span><br><span class="line">5、window.location.pathname：取得当前URL中的路径信息，即域名与参数之间的部分，可以通过赋值改变当前URL的路径；</span><br><span class="line"></span><br><span class="line">6、window.location.protocol：取得当前URL的协议部分，比如http:，https:等，可以通过赋值改变URL的协议部分；</span><br><span class="line"></span><br><span class="line">设置有以下方法：</span><br><span class="line"></span><br><span class="line">1、window.location.replace(url)：用传入的URL字符串替代当前的URL，该方法会将历史记录中的URL一并替换掉，也就是说，这个方法会覆盖之前的历史记录；</span><br><span class="line"></span><br><span class="line">2、window.location.reload()：重新加载当前URL，相当于刷新；</span><br><span class="line"></span><br><span class="line">3、window.location.assign(url)：加载传入的URL，该方法不会覆盖之前的历史记录；</span><br><span class="line"></span><br><span class="line">if(&quot;https:&quot; &#x3D;&#x3D; document.location.protocol </span><br><span class="line">     alert(&quot;HTTPS&quot;)</span><br><span class="line"> );</span><br><span class="line">document.location.protocol</span><br><span class="line">可设置或返回当前 URL 的协议</span><br></pre></td></tr></table></figure>



<h3 id="判断机型–iphoneX"><a href="#判断机型–iphoneX" class="headerlink" title="判断机型–iphoneX"></a>判断机型–iphoneX</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIphoneX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/iphone/gi</span>.test(navigator.userAgent) &amp;&amp; (screen.height == <span class="number">812</span> &amp;&amp; screen.width == <span class="number">375</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="js实现根据身份证号码识别-性别-年龄-生日"><a href="#js实现根据身份证号码识别-性别-年龄-生日" class="headerlink" title="js实现根据身份证号码识别 性别 年龄 生日"></a>js实现根据身份证号码识别 性别 年龄 生日</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discriCard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取输入身份证号码 </span></span><br><span class="line">    <span class="keyword">var</span> UUserCard = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//获取出生日期 </span></span><br><span class="line">    UUserCard.substring(<span class="number">6</span>, <span class="number">10</span>) + <span class="string">"-"</span> + UUserCard.substring(<span class="number">10</span>, <span class="number">12</span>) + <span class="string">"-"</span> + UUserCard.substring(<span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//获取性别 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(UUserCard.substr(<span class="number">16</span>, <span class="number">1</span>)) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        alert(<span class="string">"男"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"女"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取年龄 </span></span><br><span class="line">    <span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> month = myDate.getMonth() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> day = myDate.getDate();</span><br><span class="line">    <span class="keyword">var</span> age = myDate.getFullYear() - UUserCard.substring(<span class="number">6</span>, <span class="number">10</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (UUserCard.substring(<span class="number">10</span>, <span class="number">12</span>) &lt; month || UUserCard.substring(<span class="number">10</span>, <span class="number">12</span>) == month &amp;&amp; UUserCard.substring(<span class="number">12</span>, <span class="number">14</span>) &lt;= day) &#123;</span><br><span class="line">        age++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//年龄 age </span></span><br><span class="line">    alert(age)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="验证身份证有木有18周岁"><a href="#验证身份证有木有18周岁" class="headerlink" title="验证身份证有木有18周岁"></a>验证身份证有木有18周岁</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> strBirthday = num.substr(<span class="number">6</span>, <span class="number">4</span>) + <span class="string">"/"</span> + num.substr(<span class="number">10</span>, <span class="number">2</span>) + <span class="string">"/"</span> + num.substr(<span class="number">12</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> birthDate = <span class="keyword">new</span> <span class="built_in">Date</span>(strBirthday);</span><br><span class="line"><span class="keyword">var</span> nowDateTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> age = nowDateTime.getFullYear() - birthDate.getFullYear();</span><br><span class="line"><span class="keyword">if</span> (nowDateTime.getMonth() &lt; birthDate.getMonth() || (nowDateTime.getMonth() == birthDate.getMonth() &amp;&amp; nowDateTime.getDate() &lt; birthDate.getDate())) &#123;</span><br><span class="line">    age--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="身份证是否合法"><a href="#身份证是否合法" class="headerlink" title="身份证是否合法"></a>身份证是否合法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">验证身份证号方法</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdentityCodeValid = <span class="function">(<span class="params">code</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> city=&#123;<span class="number">11</span>:<span class="string">"北京"</span>,<span class="number">12</span>:<span class="string">"天津"</span>,<span class="number">13</span>:<span class="string">"河北"</span>,<span class="number">14</span>:<span class="string">"山西"</span>,<span class="number">15</span>:<span class="string">"内蒙古"</span>,<span class="number">21</span>:<span class="string">"辽宁"</span>,<span class="number">22</span>:<span class="string">"吉林"</span>,<span class="number">23</span>:<span class="string">"黑龙江 "</span>,<span class="number">31</span>:<span class="string">"上海"</span>,<span class="number">32</span>:<span class="string">"江苏"</span>,<span class="number">33</span>:<span class="string">"浙江"</span>,<span class="number">34</span>:<span class="string">"安徽"</span>,<span class="number">35</span>:<span class="string">"福建"</span>,<span class="number">36</span>:<span class="string">"江西"</span>,<span class="number">37</span>:<span class="string">"山东"</span>,<span class="number">41</span>:<span class="string">"河南"</span>,<span class="number">42</span>:<span class="string">"湖北 "</span>,<span class="number">43</span>:<span class="string">"湖南"</span>,<span class="number">44</span>:<span class="string">"广东"</span>,<span class="number">45</span>:<span class="string">"广西"</span>,<span class="number">46</span>:<span class="string">"海南"</span>,<span class="number">50</span>:<span class="string">"重庆"</span>,<span class="number">51</span>:<span class="string">"四川"</span>,<span class="number">52</span>:<span class="string">"贵州"</span>,<span class="number">53</span>:<span class="string">"云南"</span>,<span class="number">54</span>:<span class="string">"西藏 "</span>,<span class="number">61</span>:<span class="string">"陕西"</span>,<span class="number">62</span>:<span class="string">"甘肃"</span>,<span class="number">63</span>:<span class="string">"青海"</span>,<span class="number">64</span>:<span class="string">"宁夏"</span>,<span class="number">65</span>:<span class="string">"新疆"</span>,<span class="number">71</span>:<span class="string">"台湾"</span>,<span class="number">81</span>:<span class="string">"香港"</span>,<span class="number">82</span>:<span class="string">"澳门"</span>,<span class="number">91</span>:<span class="string">"国外 "</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> tip = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> pass= <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//验证身份证格式（6个地区编码，8位出生日期，3位顺序号，1位校验位）</span></span><br><span class="line">    <span class="keyword">if</span>(!code || !<span class="regexp">/^\d&#123;6&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)$/i</span>.test(code))&#123;</span><br><span class="line">        tip = <span class="string">"身份证号格式错误"</span>;</span><br><span class="line">        pass = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(!city[code.substr(<span class="number">0</span>,<span class="number">2</span>)])&#123;</span><br><span class="line">        tip = <span class="string">"地址编码错误"</span>;</span><br><span class="line">        pass = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//18位身份证需要验证最后一位校验位</span></span><br><span class="line">        <span class="keyword">if</span>(code.length == <span class="number">18</span>)&#123;</span><br><span class="line">            code = code.split(<span class="string">''</span>);</span><br><span class="line">            <span class="comment">//∑(ai×Wi)(mod 11)</span></span><br><span class="line">            <span class="comment">//加权因子</span></span><br><span class="line">            <span class="keyword">var</span> factor = [ <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span> ];</span><br><span class="line">            <span class="comment">//校验位</span></span><br><span class="line">            <span class="keyword">var</span> parity = [ <span class="number">1</span>, <span class="number">0</span>, <span class="string">'X'</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span> ];</span><br><span class="line">            <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> ai = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> wi = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ai = code[i];</span><br><span class="line">                wi = factor[i];</span><br><span class="line">                sum += ai * wi;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> last = parity[sum % <span class="number">11</span>];</span><br><span class="line">            <span class="keyword">if</span>(parity[sum % <span class="number">11</span>] != code[<span class="number">17</span>])&#123;</span><br><span class="line">                tip = <span class="string">"校验位错误"</span>;</span><br><span class="line">                pass =<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(code.length == <span class="number">15</span>)&#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="img标签的onerror事件"><a href="#img标签的onerror事件" class="headerlink" title="img标签的onerror事件"></a>img标签的onerror事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>循环里的图片直接引用原生事件</span><br><span class="line">&lt; div v-<span class="keyword">for</span>= <span class="string">"(item,index) in imgSrcList"</span> &gt;</span><br><span class="line">    &lt;p&gt; item.test &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img :src="'/i</span>travel/itravel/assets/images/common/<span class="string">'+item.test+'</span>.png<span class="string">'" onerror="javascript:this.src='</span>/itravel/itravel/assets/images/ticket/child-desc.png<span class="string">';" /&gt;</span></span><br><span class="line"><span class="string">&lt;div/ &gt;</span></span><br><span class="line"><span class="string">2.只有一个路径</span></span><br><span class="line"><span class="string">    &lt;div class="pic" &gt;</span></span><br><span class="line"><span class="string">        &lt;img v-bind: src="item.productInfo.images[0].url" v-on: error="imgError(item)" /&gt;</span></span><br><span class="line"><span class="string">    &lt;div/ &gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">imgError: function (item) &#123;</span></span><br><span class="line"><span class="string">    item.productInfo.images[0].url = '</span>http:<span class="comment">//t.cn/RmxJlMa'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递归优化</span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    return n * factorial(n - 1) &#x2F;&#x2F; 重点在尾部调用返回</span><br><span class="line">&#125;</span><br><span class="line">之后</span><br><span class="line">console.log(factorial(5)) &#x2F;&#x2F; 120</span><br><span class="line">function factorial(n, total &#x3D; 1) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">    return factorial(n - 1, total * n); &#x2F;&#x2F; 重点在尾部调用返回</span><br><span class="line">&#125;</span><br><span class="line">console.log(factorial(5)) &#x2F;&#x2F; 120</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务器时间</tag>
      </tags>
  </entry>
  <entry>
    <title>js方法（三）</title>
    <url>/2020/07/30/js%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>1.邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isEmail &#x3D; (s) &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$&#x2F;.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.手机号码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isMobile &#x3D; (s) &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;^1[0-9]&#123;10&#125;$&#x2F;.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>3.电话号码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isPhone &#x3D; (s) &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$&#x2F;.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.是否url地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isURL &#x3D; (s) &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;^http[s]?:\&#x2F;\&#x2F;.*&#x2F;.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.是否字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isString &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;String&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.是否数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isNumber &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Number&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.是否boolean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isBoolean &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Boolean&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.是否函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isFunction &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Function&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.是否为null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isNull &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Null&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.是否undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isUndefined &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Undefined&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11.是否对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isObj &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Object&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12.是否数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isArray &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Array&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.是否时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isDate &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Date&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14.是否正则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isRegExp &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;RegExp&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15.是否错误对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isError &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Error&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>16.是否Symbol函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isSymbol &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Symbol&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>17.是否Promise对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isPromise &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Promise&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>18.是否Set对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isSet &#x3D; (o) &#x3D;&gt; &#123;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Set&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>19.是否是微信浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const ua &#x3D; navigator.userAgent.toLowerCase();</span><br><span class="line">export const isWeiXin &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return ua.match(&#x2F;microMessenger&#x2F;i) &#x3D;&#x3D; &#39;micromessenger&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>20.是否是移动端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isDeviceMobile &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;android|webos|iphone|ipod|balckberry&#x2F;i.test(ua)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>21.是否是QQ浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isQQBrowser &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return !!ua.match(&#x2F;mqqbrowser|qzone|qqbrowser|qbwebviewtype&#x2F;i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22.是否是爬虫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isSpider &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return &#x2F;adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sogou orion spider&#x2F;.test(ua)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>23.是否ios</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isIos &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    var u &#x3D; navigator.userAgent;</span><br><span class="line">    if (u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1) &#123;  &#x2F;&#x2F;安卓手机</span><br><span class="line">        return false</span><br><span class="line">    &#125; else if (u.indexOf(&#39;iPhone&#39;) &gt; -1) &#123;&#x2F;&#x2F;苹果手机</span><br><span class="line">        return true</span><br><span class="line">    &#125; else if (u.indexOf(&#39;iPad&#39;) &gt; -1) &#123;&#x2F;&#x2F;iPad</span><br><span class="line">        return false</span><br><span class="line">    &#125; else if (u.indexOf(&#39;Windows Phone&#39;) &gt; -1) &#123;&#x2F;&#x2F;winphone手机</span><br><span class="line">        return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>24.是否为PC端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isPC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    var userAgentInfo &#x3D; navigator.userAgent;</span><br><span class="line">    var Agents &#x3D; [&quot;Android&quot;, &quot;iPhone&quot;,</span><br><span class="line">        &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,</span><br><span class="line">        &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class="line">    var flag &#x3D; true;</span><br><span class="line">    for (var v &#x3D; 0; v &lt; Agents.length; v++) &#123;</span><br><span class="line">        if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;</span><br><span class="line">            flag &#x3D; false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>25.去除html标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const removeHtmltag &#x3D; (str) &#x3D;&gt; &#123;</span><br><span class="line">    return str.replace(&#x2F;&lt;[^&gt;]+&gt;&#x2F;g, &#39;&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>26.获取url参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const getQueryString &#x3D; (name) &#x3D;&gt; &#123;</span><br><span class="line">    const reg &#x3D; new RegExp(&#39;(^|&amp;)&#39; + name + &#39;&#x3D;([^&amp;]*)(&amp;|$)&#39;, &#39;i&#39;);</span><br><span class="line">    const search &#x3D; window.location.search.split(&#39;?&#39;)[1] || &#39;&#39;;</span><br><span class="line">    const r &#x3D; search.match(reg) || [];</span><br><span class="line">    return r[2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>27.动态引入js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const injectScript &#x3D; (src) &#x3D;&gt; &#123;</span><br><span class="line">    const s &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    s.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line">    s.async &#x3D; true;</span><br><span class="line">    s.src &#x3D; src;</span><br><span class="line">    const t &#x3D; document.getElementsByTagName(&#39;script&#39;)[0];</span><br><span class="line">    t.parentNode.insertBefore(s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28.根据url地址下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const download &#x3D; (url) &#x3D;&gt; &#123;</span><br><span class="line">    var isChrome &#x3D; navigator.userAgent.toLowerCase().indexOf(&#39;chrome&#39;) &gt; -1;</span><br><span class="line">    var isSafari &#x3D; navigator.userAgent.toLowerCase().indexOf(&#39;safari&#39;) &gt; -1;</span><br><span class="line">    if (isChrome || isSafari) &#123;</span><br><span class="line">        var link &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">        link.href &#x3D; url;</span><br><span class="line">        if (link.download !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">            var fileName &#x3D; url.substring(url.lastIndexOf(&#39;&#x2F;&#39;) + 1, url.length);</span><br><span class="line">            link.download &#x3D; fileName;</span><br><span class="line">        &#125;</span><br><span class="line">        if (document.createEvent) &#123;</span><br><span class="line">            var e &#x3D; document.createEvent(&#39;MouseEvents&#39;);</span><br><span class="line">            e.initEvent(&#39;click&#39;, true, true);</span><br><span class="line">            link.dispatchEvent(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (url.indexOf(&#39;?&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">        url +&#x3D; &#39;?download&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    window.open(url, &#39;_self&#39;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>29.el是否包含某个class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const hasClass &#x3D; (el, className) &#x3D;&gt; &#123;</span><br><span class="line">    let reg &#x3D; new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;)</span><br><span class="line">    return reg.test(el.className)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>30.el添加某个class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const addClass &#x3D; (el, className) &#x3D;&gt; &#123;</span><br><span class="line">    if (hasClass(el, className)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let newClass &#x3D; el.className.split(&#39; &#39;)</span><br><span class="line">    newClass.push(className)</span><br><span class="line">    el.className &#x3D; newClass.join(&#39; &#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>31.el去除某个class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const removeClass &#x3D; (el, className) &#x3D;&gt; &#123;</span><br><span class="line">    if (!hasClass(el, className)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let reg &#x3D; new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;, &#39;g&#39;)</span><br><span class="line">    el.className &#x3D; el.className.replace(reg, &#39; &#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32.获取滚动的坐标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const getScrollPosition &#x3D; (el &#x3D; window) &#x3D;&gt; (&#123;</span><br><span class="line">    x: el.pageXOffset !&#x3D;&#x3D; undefined ? el.pageXOffset : el.scrollLeft,</span><br><span class="line">    y: el.pageYOffset !&#x3D;&#x3D; undefined ? el.pageYOffset : el.scrollTop</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>33.滚动到顶部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const scrollToTop &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const c &#x3D; document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">    if (c &gt; 0) &#123;</span><br><span class="line">        window.requestAnimationFrame(scrollToTop);</span><br><span class="line">        window.scrollTo(0, c - c &#x2F; 8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>34.el是否在视口范围内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const elementIsVisibleInViewport &#x3D; (el, partiallyVisible &#x3D; false) &#x3D;&gt; &#123;</span><br><span class="line">    const &#123; top, left, bottom, right &#125; &#x3D; el.getBoundingClientRect();</span><br><span class="line">    const &#123; innerHeight, innerWidth &#125; &#x3D; window;</span><br><span class="line">    return partiallyVisible</span><br><span class="line">        ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;</span><br><span class="line">        ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth))</span><br><span class="line">        : top &gt;&#x3D; 0 &amp;&amp; left &gt;&#x3D; 0 &amp;&amp; bottom &lt;&#x3D; innerHeight &amp;&amp; right &lt;&#x3D; innerWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>35.洗牌算法随机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const shuffle &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    var result &#x3D; [],</span><br><span class="line">        random;</span><br><span class="line">    while (arr.length &gt; 0) &#123;</span><br><span class="line">        random &#x3D; Math.floor(Math.random() * arr.length);</span><br><span class="line">        result.push(arr[random])</span><br><span class="line">        arr.splice(random, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>36.劫持粘贴板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const copyTextToClipboard &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">    var textArea &#x3D; document.createElement(&quot;textarea&quot;);</span><br><span class="line">    textArea.style.background &#x3D; &#39;transparent&#39;;</span><br><span class="line">    textArea.value &#x3D; value;</span><br><span class="line">    document.body.appendChild(textArea);</span><br><span class="line">    textArea.select();</span><br><span class="line">    try &#123;</span><br><span class="line">        var successful &#x3D; document.execCommand(&#39;copy&#39;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.log(&#39;Oops, unable to copy&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    document.body.removeChild(textArea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>37.判断类型集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const checkStr &#x3D; (str, type) &#x3D;&gt; &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;phone&#39;:   &#x2F;&#x2F;手机号码</span><br><span class="line">            return &#x2F;^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$&#x2F;.test(str);</span><br><span class="line">        case &#39;tel&#39;:     &#x2F;&#x2F;座机</span><br><span class="line">            return &#x2F;^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$&#x2F;.test(str);</span><br><span class="line">        case &#39;card&#39;:    &#x2F;&#x2F;身份证</span><br><span class="line">            return &#x2F;(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)&#x2F;.test(str);</span><br><span class="line">        case &#39;pwd&#39;:     &#x2F;&#x2F;密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线</span><br><span class="line">            return &#x2F;^[a-zA-Z]\w&#123;5,17&#125;$&#x2F;.test(str)</span><br><span class="line">        case &#39;postal&#39;:  &#x2F;&#x2F;邮政编码</span><br><span class="line">            return &#x2F;[1-9]\d&#123;5&#125;(?!\d)&#x2F;.test(str);</span><br><span class="line">        case &#39;QQ&#39;:      &#x2F;&#x2F;QQ号</span><br><span class="line">            return &#x2F;^[1-9][0-9]&#123;4,9&#125;$&#x2F;.test(str);</span><br><span class="line">        case &#39;email&#39;:   &#x2F;&#x2F;邮箱</span><br><span class="line">            return &#x2F;^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$&#x2F;.test(str);</span><br><span class="line">        case &#39;money&#39;:   &#x2F;&#x2F;金额(小数点2位)</span><br><span class="line">            return &#x2F;^\d*(?:\.\d&#123;0,2&#125;)?$&#x2F;.test(str);</span><br><span class="line">        case &#39;URL&#39;:     &#x2F;&#x2F;网址</span><br><span class="line">            return &#x2F;(http|ftp|https):\&#x2F;\&#x2F;[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^&#x3D;%&amp;:&#x2F;~\+#]*[\w\-\@?^&#x3D;%&amp;&#x2F;~\+#])?&#x2F;.test(str)</span><br><span class="line">        case &#39;IP&#39;:      &#x2F;&#x2F;IP</span><br><span class="line">            return &#x2F;((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))&#x2F;.test(str);</span><br><span class="line">        case &#39;date&#39;:    &#x2F;&#x2F;日期时间</span><br><span class="line">            return &#x2F;^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$&#x2F;.test(str) || &#x2F;^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$&#x2F;.test(str)</span><br><span class="line">        case &#39;number&#39;:  &#x2F;&#x2F;数字</span><br><span class="line">            return &#x2F;^[0-9]$&#x2F;.test(str);</span><br><span class="line">        case &#39;english&#39;: &#x2F;&#x2F;英文</span><br><span class="line">            return &#x2F;^[a-zA-Z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;chinese&#39;: &#x2F;&#x2F;中文</span><br><span class="line">            return &#x2F;^[\\u4E00-\\u9FA5]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;lower&#39;:   &#x2F;&#x2F;小写</span><br><span class="line">            return &#x2F;^[a-z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;upper&#39;:   &#x2F;&#x2F;大写</span><br><span class="line">            return &#x2F;^[A-Z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;HTML&#39;:    &#x2F;&#x2F;HTML标记</span><br><span class="line">            return &#x2F;&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;&#x2F;.test(str);</span><br><span class="line">        default:</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>38.严格的身份证校验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isCardID &#x3D; (sId) &#x3D;&gt; &#123;</span><br><span class="line">    if (!&#x2F;(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)&#x2F;.test(sId)) &#123;</span><br><span class="line">        console.log(&#39;你输入的身份证长度或格式错误&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;身份证城市</span><br><span class="line">    var aCity &#x3D; &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125;;</span><br><span class="line">    if (!aCity[parseInt(sId.substr(0, 2))]) &#123;</span><br><span class="line">        console.log(&#39;你的身份证地区非法&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 出生日期验证</span><br><span class="line">    var sBirthday &#x3D; (sId.substr(6, 4) + &quot;-&quot; + Number(sId.substr(10, 2)) + &quot;-&quot; + Number(sId.substr(12, 2))).replace(&#x2F;-&#x2F;g, &quot;&#x2F;&quot;),</span><br><span class="line">        d &#x3D; new Date(sBirthday)</span><br><span class="line">    if (sBirthday !&#x3D; (d.getFullYear() + &quot;&#x2F;&quot; + (d.getMonth() + 1) + &quot;&#x2F;&quot; + d.getDate())) &#123;</span><br><span class="line">        console.log(&#39;身份证上的出生日期非法&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 身份证号码校验</span><br><span class="line">    var sum &#x3D; 0,</span><br><span class="line">        weights &#x3D; [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],</span><br><span class="line">        codes &#x3D; &quot;10X98765432&quot;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; sId.length - 1; i++) &#123;</span><br><span class="line">        sum +&#x3D; sId[i] * weights[i];</span><br><span class="line">    &#125;</span><br><span class="line">    var last &#x3D; codes[sum % 11]; &#x2F;&#x2F;计算出来的最后一位身份证号码</span><br><span class="line">    if (sId[sId.length - 1] !&#x3D; last) &#123;</span><br><span class="line">        console.log(&#39;你输入的身份证号非法&#39;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>39.随机数范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const random &#x3D; (min, max) &#x3D;&gt; &#123;</span><br><span class="line">    if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return Math.floor(min + Math.random() * ((max + 1) - min))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>40.将阿拉伯数字翻译成中文的大写数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const numberToChinese &#x3D; (num) &#x3D;&gt; &#123;</span><br><span class="line">    var AA &#x3D; new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;);</span><br><span class="line">    var BB &#x3D; new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;);</span><br><span class="line">    var a &#x3D; (&quot;&quot; + num).replace(&#x2F;(^0*)&#x2F;g, &quot;&quot;).split(&quot;.&quot;),</span><br><span class="line">        k &#x3D; 0,</span><br><span class="line">        re &#x3D; &quot;&quot;;</span><br><span class="line">    for (var i &#x3D; a[0].length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        switch (k) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                re &#x3D; BB[7] + re;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                if (!new RegExp(&quot;0&#123;4&#125;&#x2F;&#x2F;d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;)</span><br><span class="line">                    .test(a[0]))</span><br><span class="line">                    re &#x3D; BB[4] + re;</span><br><span class="line">                break;</span><br><span class="line">            case 8:</span><br><span class="line">                re &#x3D; BB[5] + re;</span><br><span class="line">                BB[7] &#x3D; BB[5];</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k % 4 &#x3D;&#x3D; 2 &amp;&amp; a[0].charAt(i + 2) !&#x3D; 0 &amp;&amp; a[0].charAt(i + 1) &#x3D;&#x3D; 0)</span><br><span class="line">            re &#x3D; AA[0] + re;</span><br><span class="line">        if (a[0].charAt(i) !&#x3D; 0)</span><br><span class="line">            re &#x3D; AA[a[0].charAt(i)] + BB[k % 4] + re;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (a.length &gt; 1) &#x2F;&#x2F; 加上小数部分(如果有小数部分)</span><br><span class="line">    &#123;</span><br><span class="line">        re +&#x3D; BB[6];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; a[1].length; i++)</span><br><span class="line">            re +&#x3D; AA[a[1].charAt(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    if (re &#x3D;&#x3D; &#39;一十&#39;)</span><br><span class="line">        re &#x3D; &quot;十&quot;;</span><br><span class="line">    if (re.match(&#x2F;^一&#x2F;) &amp;&amp; re.length &#x3D;&#x3D; 3)</span><br><span class="line">        re &#x3D; re.replace(&quot;一&quot;, &quot;&quot;);</span><br><span class="line">    return re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>41.将数字转换为大写金额</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const changeToChinese &#x3D; (Num) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;判断如果传递进来的不是字符的话转换为字符</span><br><span class="line">    if (typeof Num &#x3D;&#x3D; &quot;number&quot;) &#123;</span><br><span class="line">        Num &#x3D; new String(Num);</span><br><span class="line">    &#125;;</span><br><span class="line">    Num &#x3D; Num.replace(&#x2F;,&#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换tomoney()中的“,”</span><br><span class="line">    Num &#x3D; Num.replace(&#x2F; &#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换tomoney()中的空格</span><br><span class="line">    Num &#x3D; Num.replace(&#x2F;￥&#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换掉可能出现的￥字符</span><br><span class="line">    if (isNaN(Num)) &#123; &#x2F;&#x2F;验证输入的字符是否为数字</span><br><span class="line">        &#x2F;&#x2F;alert(&quot;请检查小写金额是否正确&quot;);</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;字符处理完毕后开始转换，采用前后两部分分别转换</span><br><span class="line">    var part &#x3D; String(Num).split(&quot;.&quot;);</span><br><span class="line">    var newchar &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;小数点前进行转化</span><br><span class="line">    for (var i &#x3D; part[0].length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        if (part[0].length &gt; 10) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">            &#x2F;&#x2F;若数量超过拾亿单位，提示</span><br><span class="line">        &#125;</span><br><span class="line">        var tmpnewchar &#x3D; &quot;&quot;</span><br><span class="line">        var perchar &#x3D; part[0].charAt(i);</span><br><span class="line">        switch (perchar) &#123;</span><br><span class="line">            case &quot;0&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;零&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;1&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;壹&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;2&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;贰&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;3&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;叁&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;4&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;肆&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;5&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;伍&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;6&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;陆&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;7&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;柒&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;8&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;捌&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;9&quot;:</span><br><span class="line">                tmpnewchar &#x3D; &quot;玖&quot; + tmpnewchar;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (part[0].length - i - 1) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                tmpnewchar &#x3D; tmpnewchar + &quot;元&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;佰&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;仟&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                tmpnewchar &#x3D; tmpnewchar + &quot;万&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;佰&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;仟&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 8:</span><br><span class="line">                tmpnewchar &#x3D; tmpnewchar + &quot;亿&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 9:</span><br><span class="line">                tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        var newchar &#x3D; tmpnewchar + newchar;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;小数点之后进行转化</span><br><span class="line">    if (Num.indexOf(&quot;.&quot;) !&#x3D; -1) &#123;</span><br><span class="line">        if (part[1].length &gt; 2) &#123;</span><br><span class="line">            &#x2F;&#x2F; alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;);</span><br><span class="line">            part[1] &#x3D; part[1].substr(0, 2)</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 0; i &lt; part[1].length; i++) &#123;</span><br><span class="line">            tmpnewchar &#x3D; &quot;&quot;</span><br><span class="line">            perchar &#x3D; part[1].charAt(i)</span><br><span class="line">            switch (perchar) &#123;</span><br><span class="line">                case &quot;0&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;零&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;1&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;壹&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;2&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;贰&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;3&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;叁&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;4&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;肆&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;5&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;伍&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;6&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;陆&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;7&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;柒&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;8&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;捌&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;9&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;玖&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &#x3D;&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;角&quot;;</span><br><span class="line">            if (i &#x3D;&#x3D; 1) tmpnewchar &#x3D; tmpnewchar + &quot;分&quot;;</span><br><span class="line">            newchar &#x3D; newchar + tmpnewchar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;替换所有无用汉字</span><br><span class="line">    while (newchar.search(&quot;零零&quot;) !&#x3D; -1)</span><br><span class="line">        newchar &#x3D; newchar.replace(&quot;零零&quot;, &quot;零&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零亿&quot;, &quot;亿&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;亿万&quot;, &quot;亿&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零万&quot;, &quot;万&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零元&quot;, &quot;元&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零角&quot;, &quot;&quot;);</span><br><span class="line">    newchar &#x3D; newchar.replace(&quot;零分&quot;, &quot;&quot;);</span><br><span class="line">    if (newchar.charAt(newchar.length - 1) &#x3D;&#x3D; &quot;元&quot;) &#123;</span><br><span class="line">        newchar &#x3D; newchar + &quot;整&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return newchar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>42.判断一个元素是否在数组中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const contains &#x3D; (arr, val) &#x3D;&gt; &#123;</span><br><span class="line">    return arr.indexOf(val) !&#x3D; -1 ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>43.数组排序，<code>{type} 1：从小到大 2：从大到小 3：随机</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const sort &#x3D; (arr, type &#x3D; 1) &#x3D;&gt; &#123;</span><br><span class="line">    return arr.sort((a, b) &#x3D;&gt; &#123;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                return a - b;</span><br><span class="line">            case 2:</span><br><span class="line">                return b - a;</span><br><span class="line">            case 3:</span><br><span class="line">                return Math.random() - 0.5;</span><br><span class="line">            default:</span><br><span class="line">                return arr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>44.去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const unique &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    if (Array.hasOwnProperty(&#39;from&#39;)) &#123;</span><br><span class="line">        return Array.from(new Set(arr));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var n &#x3D; &#123;&#125;, r &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (!n[arr[i]]) &#123;</span><br><span class="line">                n[arr[i]] &#x3D; true;</span><br><span class="line">                r.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>45.求两个集合的并集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const union &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">    var newArr &#x3D; a.concat(b);</span><br><span class="line">    return this.unique(newArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>46.求两个集合的交集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const intersect &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    a &#x3D; this.unique(a);</span><br><span class="line">    return this.map(a, function (o) &#123;</span><br><span class="line">        return _this.contains(b, o) ? o : null;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>47.删除其中一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const remove &#x3D; (arr, ele) &#x3D;&gt; &#123;</span><br><span class="line">    var index &#x3D; arr.indexOf(ele);</span><br><span class="line">    if (index &gt; -1) &#123;</span><br><span class="line">        arr.splice(index, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>48.将类数组转换为数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const formArray &#x3D; (ary) &#x3D;&gt; &#123;</span><br><span class="line">    var arr &#x3D; [];</span><br><span class="line">    if (Array.isArray(ary)) &#123;</span><br><span class="line">        arr &#x3D; ary;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        arr &#x3D; Array.prototype.slice.call(ary);</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>49.最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const max &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    return Math.max.apply(null, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>50.最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const min &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    return Math.min.apply(null, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>51.求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const sum &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    return arr.reduce((pre, cur) &#x3D;&gt; &#123;</span><br><span class="line">        return pre + cur</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>52.平均值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const average &#x3D; (arr) &#x3D;&gt; &#123;</span><br><span class="line">    return this.sum(arr) &#x2F; arr.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>53.去除空格,<code>type: 1-所有空格 2-前后空格 3-前空格 4-后空格</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const trim &#x3D; (str, type) &#x3D;&gt; &#123;</span><br><span class="line">    type &#x3D; type || 1</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            return str.replace(&#x2F;\s+&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 2:</span><br><span class="line">            return str.replace(&#x2F;(^\s*)|(\s*$)&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 3:</span><br><span class="line">            return str.replace(&#x2F;(^\s*)&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 4:</span><br><span class="line">            return str.replace(&#x2F;(\s*$)&#x2F;g, &quot;&quot;);</span><br><span class="line">        default:</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>54.字符转换，<code>type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const changeCase &#x3D; (str, type) &#x3D;&gt; &#123;</span><br><span class="line">    type &#x3D; type || 4</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            return str.replace(&#x2F;\b\w+\b&#x2F;g, function (word) &#123;</span><br><span class="line">                return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        case 2:</span><br><span class="line">            return str.replace(&#x2F;\b\w+\b&#x2F;g, function (word) &#123;</span><br><span class="line">                return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();</span><br><span class="line">            &#125;);</span><br><span class="line">        case 3:</span><br><span class="line">            return str.split(&#39;&#39;).map(function (word) &#123;</span><br><span class="line">                if (&#x2F;[a-z]&#x2F;.test(word)) &#123;</span><br><span class="line">                    return word.toUpperCase();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return word.toLowerCase()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).join(&#39;&#39;)</span><br><span class="line">        case 4:</span><br><span class="line">            return str.toUpperCase();</span><br><span class="line">        case 5:</span><br><span class="line">            return str.toLowerCase();</span><br><span class="line">        default:</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>55.检测密码强度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const checkPwd &#x3D; (str) &#x3D;&gt; &#123;</span><br><span class="line">    var Lv &#x3D; 0;</span><br><span class="line">    if (str.length &lt; 6) &#123;</span><br><span class="line">        return Lv</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[0-9]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[a-z]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[A-Z]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[\.|-|_]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    return Lv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>56.函数节流器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const debouncer &#x3D; (fn, time, interval &#x3D; 200) &#x3D;&gt; &#123;</span><br><span class="line">    if (time - (window.debounceTimestamp || 0) &gt; interval) &#123;</span><br><span class="line">        fn &amp;&amp; fn();</span><br><span class="line">        window.debounceTimestamp &#x3D; time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>57.在字符串中插入新字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const insertStr &#x3D; (soure, index, newStr) &#x3D;&gt; &#123;</span><br><span class="line">    var str &#x3D; soure.slice(0, index) + newStr + soure.slice(index);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>58.判断两个对象是否键值相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const isObjectEqual &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">    var aProps &#x3D; Object.getOwnPropertyNames(a);</span><br><span class="line">    var bProps &#x3D; Object.getOwnPropertyNames(b);</span><br><span class="line"></span><br><span class="line">    if (aProps.length !&#x3D;&#x3D; bProps.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; aProps.length; i++) &#123;</span><br><span class="line">        var propName &#x3D; aProps[i];</span><br><span class="line"></span><br><span class="line">        if (a[propName] !&#x3D;&#x3D; b[propName]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>59.16进制颜色转RGBRGBA字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const colorToRGB &#x3D; (val, opa) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    var pattern &#x3D; &#x2F;^(#?)[a-fA-F0-9]&#123;6&#125;$&#x2F;; &#x2F;&#x2F;16进制颜色值校验规则</span><br><span class="line">    var isOpa &#x3D; typeof opa &#x3D;&#x3D; &#39;number&#39;; &#x2F;&#x2F;判断是否有设置不透明度</span><br><span class="line"></span><br><span class="line">    if (!pattern.test(val)) &#123; &#x2F;&#x2F;如果值不符合规则返回空字符</span><br><span class="line">        return &#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var v &#x3D; val.replace(&#x2F;#&#x2F;, &#39;&#39;); &#x2F;&#x2F;如果有#号先去除#号</span><br><span class="line">    var rgbArr &#x3D; [];</span><br><span class="line">    var rgbStr &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        var item &#x3D; v.substring(i * 2, i * 2 + 2);</span><br><span class="line">        var num &#x3D; parseInt(item, 16);</span><br><span class="line">        rgbArr.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rgbStr &#x3D; rgbArr.join();</span><br><span class="line">    rgbStr &#x3D; &#39;rgb&#39; + (isOpa ? &#39;a&#39; : &#39;&#39;) + &#39;(&#39; + rgbStr + (isOpa ? &#39;,&#39; + opa : &#39;&#39;) + &#39;)&#39;;</span><br><span class="line">    return rgbStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>60.追加url参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const appendQuery &#x3D; (url, key, value) &#x3D;&gt; &#123;</span><br><span class="line">    var options &#x3D; key;</span><br><span class="line">    if (typeof options &#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">        options &#x3D; &#123;&#125;;</span><br><span class="line">        options[key] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    options &#x3D; $.param(options);</span><br><span class="line">    if (url.includes(&#39;?&#39;)) &#123;</span><br><span class="line">        url +&#x3D; &#39;&amp;&#39; + options</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        url +&#x3D; &#39;?&#39; + options</span><br><span class="line">    &#125;</span><br><span class="line">    return url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="61">
<li>禁止网页复制粘贴</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const html &#x3D; document.querySelector(&#39;html&#39;)</span><br><span class="line"> html.oncopy &#x3D; () &#x3D;&gt; false</span><br><span class="line"> html.onpaste &#x3D; () &#x3D;&gt; false</span><br></pre></td></tr></table></figure>

<ol start="62">
<li>input框限制只能输入中文</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const input &#x3D; document.querySelector(&#39;input[type&#x3D;&quot;text&quot;]&#39;)</span><br><span class="line"> const clearText &#x3D; target &#x3D;&gt; &#123;</span><br><span class="line">     const &#123;</span><br><span class="line">         value</span><br><span class="line">     &#125; &#x3D; target</span><br><span class="line">     target.value &#x3D; value.replace(&#x2F;[^\u4e00-\u9fa5]&#x2F;g, &#39;&#39;)</span><br><span class="line"> &#125;</span><br><span class="line"> input.onfocus &#x3D; (&#123;target&#125;) &#x3D;&gt; &#123;</span><br><span class="line">     clearText(target)</span><br><span class="line"> &#125;</span><br><span class="line"> input.onkeyup &#x3D; (&#123;target&#125;) &#x3D;&gt; &#123;</span><br><span class="line">     clearText(target)</span><br><span class="line"> &#125;</span><br><span class="line"> input.onblur &#x3D; (&#123;target&#125;) &#x3D;&gt; &#123;</span><br><span class="line">     clearText(target)</span><br><span class="line"> &#125;</span><br><span class="line"> input.oninput &#x3D; (&#123;target&#125;) &#x3D;&gt; &#123;</span><br><span class="line">     clearText(target)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="63">
<li>计算目录树的深度</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tree &#x3D; &#123;</span><br><span class="line">  name: &#39;root&#39;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; name: &#39;叶子1-1&#39; &#125;,</span><br><span class="line">    &#123; name: &#39;叶子1-2&#39; &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#39;叶子2-1&#39;,</span><br><span class="line">      children: [&#123;</span><br><span class="line">        name: &#39;叶子3-1&#39;,</span><br><span class="line">        children: [&#123;</span><br><span class="line">          name: &#39;叶子4-1&#39;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDepth(tree) &#123;</span><br><span class="line">  let depth &#x3D; 0</span><br><span class="line"></span><br><span class="line">  if (tree) &#123;</span><br><span class="line">    let arr &#x3D; [tree]</span><br><span class="line">    let temp &#x3D; arr</span><br><span class="line">    while (temp.length) &#123;</span><br><span class="line">      arr &#x3D; temp</span><br><span class="line">      temp &#x3D; []</span><br><span class="line">      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i].children &amp;&amp; arr[i].children.length) &#123;</span><br><span class="line">          for (let j &#x3D; 0; j &lt; arr[i].children.length; j++) &#123;</span><br><span class="line">            temp.push(arr[i].children[j])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      depth++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return depth</span><br><span class="line">&#125;</span><br><span class="line">console.log(getDepth(tree)); &#x2F;&#x2F;输出4</span><br></pre></td></tr></table></figure>



<p>参考链接 <a href="https://mp.weixin.qq.com/s/a_hBJdIxnqrzcx28K56VXA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/a_hBJdIxnqrzcx28K56VXA</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>less</title>
    <url>/2020/07/27/less/</url>
    <content><![CDATA[<h3 id="less高级用法记录"><a href="#less高级用法记录" class="headerlink" title="less高级用法记录"></a>less高级用法记录</h3><ul>
<li><p>注意</p>
<p><img src="/2020/07/27/less/clipboard.png" alt="clipboard"></p>
</li>
</ul>
<a id="more"></a>

<p>![clipboard (1)](less.assets/clipboard (1).png)</p>
<ul>
<li>例如（变量的延迟加载，会加载作用域中最后一个变量的值）</li>
</ul>
<p>![clipboard (2)](less.assets/clipboard (2).png)</p>
<ul>
<li>普通混合（输出到css里）</li>
</ul>
<p>![clipboard (3)](less.assets/clipboard (3).png)</p>
<ul>
<li>不带参数的混合（不会输出到css里）</li>
</ul>
<p>![clipboard (4)](less.assets/clipboard (4).png)</p>
<ul>
<li>带有参数的混合</li>
</ul>
<p>![clipboard (5)](less.assets/clipboard (5).png)</p>
<ul>
<li>带有默认参数的混合</li>
</ul>
<p>![clipboard (6)](less.assets/clipboard (6).png)</p>
<ul>
<li>命名参数，指定参数给谁</li>
</ul>
<p>![clipboard (7)](less.assets/clipboard (7).png)</p>
<ul>
<li>@argruments(参数匹配时全部替换)</li>
</ul>
<p>![clipboard (10)](less.assets/clipboard (10).png)</p>
<ul>
<li>继承 （all继承所有.juzhong中的属性）</li>
</ul>
<p>![clipboard (11)](less.assets/clipboard (11).png)</p>
<ul>
<li>避免编译，让浏览器去编译，加上~“string”就可以=</li>
</ul>
<p>![clipboard (12)](less.assets/clipboard (12)-1599546053799.png)</p>
<ul>
<li><h5 id="混合的匹配模式"><a href="#混合的匹配模式" class="headerlink" title="混合的匹配模式"></a>混合的匹配模式</h5><p>就是通过混合的第一个字符串形参,来确定具体要执行哪一个同名混合</p>
</li>
<li><h5 id="通用的匹配模式"><a href="#通用的匹配模式" class="headerlink" title="通用的匹配模式"></a>通用的匹配模式</h5><p>无论同名的哪一个混合被匹配了, 都会先执行通用匹配模式中的代码<br>@_: 表示通用的匹配模式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>我赛季刚开始就港口建设控股<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>我赛季刚开始就港口建设控股<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>我赛季刚开始就港口建设控股<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box4"</span>&gt;</span>我赛季刚开始就港口建设控股<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="keyword">@_</span>, @width, @color) &#123;</span></span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-style: solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="selector-tag">Bottom</span>, <span class="keyword">@width</span>, @color) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-width</span>: <span class="keyword">@width</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-color</span>: <span class="keyword">@color</span> transparent transparent transparent;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="selector-tag">Left</span>, <span class="keyword">@width</span>, @color) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-width</span>: <span class="keyword">@width</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="keyword">@color</span> transparent transparent;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="selector-tag">Top</span>, <span class="keyword">@width</span>, @color) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-width</span>: <span class="keyword">@width</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="keyword">@color</span> transparent;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.triangle</span>(<span class="selector-tag">Right</span>, <span class="keyword">@width</span>, @color) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-width</span>: <span class="keyword">@width</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="keyword">@color</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.triangle</span>(<span class="selector-tag">Top</span>, 50<span class="selector-tag">px</span>, <span class="selector-tag">skyblue</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.triangle</span>(<span class="selector-tag">Bottom</span>, 50<span class="selector-tag">px</span>, <span class="selector-tag">skyblue</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.box3</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.triangle</span>(<span class="selector-tag">Left</span>, 50<span class="selector-tag">px</span>, <span class="selector-tag">skyblue</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.box4</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.triangle</span>(<span class="selector-tag">Right</span>, 50<span class="selector-tag">px</span>, <span class="selector-tag">skyblue</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title>js方法（二）</title>
    <url>/2020/07/30/js%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="js方法记录"><a href="#js方法记录" class="headerlink" title="js方法记录"></a>js方法记录</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="1-数组交集"><a href="#1-数组交集" class="headerlink" title="1.数组交集"></a>1.数组交集</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5 , 8 ,9],arr2 &#x3D; [5, 6, 7, 8, 9];</span><br><span class="line">const intersection &#x3D; arr1.filter(function (val) &#123; return arr2.indexOf(val) &gt; -1 &#125;)</span><br><span class="line">console.log(intersection) &#x2F;&#x2F;[5, 8, 9]</span><br><span class="line"></span><br><span class="line">const intersection &#x3D; (list, ...args) &#x3D;&gt; list.filter(item &#x3D;&gt; args.every(list &#x3D;&gt; list.includes(item)))</span><br><span class="line">console.log(intersection([2, 1], [2, 3])) &#x2F;&#x2F; [2]</span><br><span class="line">console.log(intersection([1, 2], [3, 4])) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>数组对象<br>数组对象目前仅针对value值为简单的Number，String，Boolan数据类型 文中JSON.stringif比较对象是简写方法，完整的对象比较请看技巧24.对象是否相等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">const arr2 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">const result &#x3D; arr2.filter(function (v) &#123;</span><br><span class="line">  return arr1.some(n &#x3D;&gt; JSON.stringify(n) &#x3D;&#x3D;&#x3D; JSON.stringify(v))</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result); &#x2F;&#x2F; [&#123; name: &#39;name1&#39;, id: 1 &#125;,&#123; name: &#39;name2&#39;, id: 2 &#125;,&#123; name: &#39;name3&#39;, id: 3 &#125;,&#123; name: &#39;name5&#39;, id: 5 &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="2-数组并集"><a href="#2-数组并集" class="headerlink" title="2.数组并集"></a>2.数组并集</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5, 8, 9]</span><br><span class="line">const arr2 &#x3D; [5, 6, 7, 8, 9];</span><br><span class="line">const result &#x3D; arr1.concat(arr2.filter(v &#x3D;&gt; !arr1.includes(v)))</span><br><span class="line">console.log(result) &#x2F;&#x2F;[1, 2, 3, 4, 5, 8, 9, 6, 7]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;];</span><br><span class="line">const arr2 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">let arr3 &#x3D; arr1.concat(arr2);</span><br><span class="line">let result &#x3D; [];</span><br><span class="line">let obj &#x3D; [];</span><br><span class="line">result &#x3D; arr3.reduce(function (prev, cur, index, arr) &#123;</span><br><span class="line">  obj[cur.id] ? &#39;&#39; : obj[cur.id] &#x3D; true &amp;&amp; prev.push(cur);</span><br><span class="line">  return prev;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(result); &#x2F;&#x2F;[&#123; name: &#39;name1&#39;, id: 1 &#125;,&#123; name: &#39;name2&#39;, id: 2 &#125;,&#123; name: &#39;name3&#39;, id: 3 &#125;,&#123; name: &#39;name4&#39;, id: 4 &#125;,&#123; name: &#39;name5&#39;, id: 5 &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="3-数组差集"><a href="#3-数组差集" class="headerlink" title="3.数组差集"></a>3.数组差集</h4><p>数组arr1相对于arr2所没有的<br>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5, 8, 9]</span><br><span class="line">const arr2 &#x3D; [5, 6, 7, 8, 9];</span><br><span class="line">const diff &#x3D; arr1.filter(item &#x3D;&gt; !new Set(arr2).has(item))</span><br><span class="line">console.log(diff) &#x2F;&#x2F;[ 1, 2, 3, 4 ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象数组</span><br><span class="line">let arr1 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;];</span><br><span class="line">let arr2 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">let result &#x3D; arr1.filter(function (v) &#123;</span><br><span class="line">  return arr2.every(n &#x3D;&gt; JSON.stringify(n) !&#x3D;&#x3D; JSON.stringify(v))</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result); &#x2F;&#x2F; [ &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125; ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-数组补集"><a href="#4-数组补集" class="headerlink" title="4.数组补集"></a>4.数组补集</h4><p>两个数组各自没有的集合<br>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5, 8, 9]</span><br><span class="line">const arr2 &#x3D; [5, 6, 7, 8, 9];</span><br><span class="line">const difference &#x3D; Array.from(new Set(arr1.concat(arr2).filter(v &#x3D;&gt; !new Set(arr1).has(v) || !new Set(arr2).has(v)))) </span><br><span class="line">console.log(difference) &#x2F;&#x2F;[ 1, 2, 3, 4, 6, 7 ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;];</span><br><span class="line">let arr2 &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line">let arr3 &#x3D; arr1.concat(arr2);</span><br><span class="line">let result &#x3D; arr3.filter(function (v) &#123;</span><br><span class="line">  return arr1.every(n &#x3D;&gt; JSON.stringify(n) !&#x3D;&#x3D; JSON.stringify(v)) || arr2.every(n &#x3D;&gt; JSON.stringify(n) !&#x3D;&#x3D; JSON.stringify(v))</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result); &#x2F;&#x2F; [&#123; name: &#39;name2&#39;, id: 2 &#125;,&#123; name: &#39;name3&#39;, id: 3 &#125;,&#123; name: &#39;name4&#39;, id: 4 &#125;,&#123; name: &#39;name5&#39;, id: 5 &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>总结一下，差集就是数组arr1相对于arr2所没有的集合，补集是两个数组各自没有的集合</p>
<h4 id="5-数组去重"><a href="#5-数组去重" class="headerlink" title="5.数组去重"></a>5.数组去重</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Array.from(new Set([1, 2, 3, 3, 4, 4]))) &#x2F;&#x2F;[1,2,3,4]</span><br><span class="line">console.log([...new Set([1, 2, 3, 3, 4, 4])]) &#x2F;&#x2F;[1,2,3,4]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name2&#39;, id: 2 &#125;, &#123; name: &#39;name3&#39;, id: 3 &#125;, &#123; name: &#39;name1&#39;, id: 1 &#125;, &#123; name: &#39;name4&#39;, id: 4 &#125;, &#123; name: &#39;name5&#39;, id: 5 &#125;];</span><br><span class="line"> const result &#x3D; [];</span><br><span class="line"> arr.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">    !result.some(v &#x3D;&gt; JSON.stringify(v) &#x3D;&#x3D;&#x3D; JSON.stringify(item)) &amp;&amp; result.push(item)</span><br><span class="line"> &#125;)</span><br><span class="line"> console.log(result) &#x2F;&#x2F;[&#123; name: &#39;name1&#39;, id: 1 &#125;,&#123; name: &#39;name2&#39;, id: 2 &#125;,&#123; name: &#39;name3&#39;, id: 3 &#125;,&#123; name: &#39;name4&#39;, id: 4 &#125;,&#123; name: &#39;name5&#39;, id: 5 &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="6-数组排序"><a href="#6-数组排序" class="headerlink" title="6.数组排序"></a>6.数组排序</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([1, 2, 3, 4].sort((a, b) &#x3D;&gt; a - b)); &#x2F;&#x2F; [1, 2,3,4] 升序</span><br><span class="line">console.log([1, 2, 3, 4].sort((a, b) &#x3D;&gt; b - a)); &#x2F;&#x2F; [4,3,2,1] 降序</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D; [&#123; name: &quot;Rom&quot;, age: 12 &#125;, &#123; name: &quot;Bob&quot;, age: 22 &#125;].sort((a, b) &#x3D;&gt; &#123; return a.age - b.age &#125;)&#x2F;&#x2F;升序</span><br><span class="line">const arr2 &#x3D; [&#123; name: &quot;Rom&quot;, age: 12 &#125;, &#123; name: &quot;Bob&quot;, age: 22 &#125;].sort((a, b) &#x3D;&gt; &#123; return -a.age + b.age &#125;)&#x2F;&#x2F;降序</span><br><span class="line">console.log(arr2) &#x2F;&#x2F; [&#123; name: &#39;Bob&#39;, age:22 &#125;, &#123; name: &#39;Rom&#39;, age: 12 &#125;]</span><br><span class="line">console.log(arr1) &#x2F;&#x2F; [ &#123; name: &#39;Rom&#39;, age: 12 &#125;, &#123; name: &#39;Bob&#39;, age: 22 &#125; ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>两个种类型数组都可以使用sort排序，sort是浏览器内置方法；<br>默认是升序排序，默认返回一个函数，有两个参数：<br>(a, b) =&gt; a - b 是升序；<br>(a, b) =&gt; b - a 是降序。</p>
<h4 id="7-最大值"><a href="#7-最大值" class="headerlink" title="7.最大值"></a>7.最大值</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.max(...[1, 2, 3, 4]) &#x2F;&#x2F;4</span><br><span class="line">Math.max.apply(this, [1, 2, 3, 4]) &#x2F;&#x2F;4</span><br><span class="line">[1, 2, 3, 4].reduce((prev, cur, curIndex, arr) &#x3D;&gt; &#123;</span><br><span class="line">   return Math.max(prev, cur);</span><br><span class="line">&#125;, 0) &#x2F;&#x2F;4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>取数组对象中id的最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&#123; id: 1, name: &#39;jack&#39; &#125;,&#123; id: 2, name: &#39;may&#39; &#125;,&#123; id: 3, name: &#39;shawn&#39; &#125;,&#123; id: 4, name: &#39;tony&#39; &#125;]</span><br><span class="line">const arr1 &#x3D; Math.max.apply(Math, arr.map(item &#x3D;&gt; &#123; return item.id &#125;))</span><br><span class="line">const arr2 &#x3D; arr.sort((a, b) &#x3D;&gt; &#123; return b.id - a.id &#125;)[0].id</span><br><span class="line">console.log(arr1) &#x2F;&#x2F; 4</span><br><span class="line">console.log(arr2) &#x2F;&#x2F; 4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="8-数组求和"><a href="#8-数组求和" class="headerlink" title="8.数组求和"></a>8.数组求和</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4].reduce(function (prev, cur) &#123;</span><br><span class="line">  return prev + cur;</span><br><span class="line">&#125;, 0) &#x2F;&#x2F;10 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sum &#x3D; [&#123;age:1&#125;,&#123;age:2&#125;].reduce(function (prev, cur) &#123;</span><br><span class="line">  return prev + cur.age;</span><br><span class="line">&#125;, 0) &#x2F;&#x2F;3</span><br><span class="line">console.log(sum)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="9-数组合并"><a href="#9-数组合并" class="headerlink" title="9.数组合并"></a>9.数组合并</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 &#x3D;[1, 2, 3, 4].concat([5, 6]) &#x2F;&#x2F;[1,2,3,4,5,6]</span><br><span class="line">const arr2 &#x3D;[...[1, 2, 3, 4],...[4, 5]] &#x2F;&#x2F;[1,2,3,4,5,6]</span><br><span class="line">const arrA &#x3D; [1, 2], arrB &#x3D; [3, 4]</span><br><span class="line">const arr3 &#x3D;[].concat.apply(arrA, arrB)&#x2F;&#x2F;arrA值为[1,2,3,4]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr4 &#x3D; [&#123; age: 1 &#125;].concat([&#123; age: 2 &#125;])</span><br><span class="line">const arr5 &#x3D; [...[&#123; age: 1 &#125;],...[&#123; age: 2 &#125;]]</span><br><span class="line">console.log(arr4) &#x2F;&#x2F;[ &#123; age: 1 &#125;, &#123; age: 2 &#125; ]</span><br><span class="line">console.log(arr5) &#x2F;&#x2F; [ &#123; age: 1 &#125;, &#123; age: 2 &#125; ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="10-数组是否包含值"><a href="#10-数组是否包含值" class="headerlink" title="10.数组是否包含值"></a>10.数组是否包含值</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([1, 2, 3].includes(4)) &#x2F;&#x2F;false</span><br><span class="line">console.log([1, 2, 3].indexOf(4)) &#x2F;&#x2F;-1 如果存在换回索引</span><br><span class="line">console.log([1, 2, 3].find((item) &#x3D;&gt; item &#x3D;&#x3D;&#x3D; 3)) &#x2F;&#x2F;3 如果数组中无值返回undefined</span><br><span class="line">console.log([1, 2, 3].findIndex((item) &#x3D;&gt; item &#x3D;&#x3D;&#x3D; 3)) &#x2F;&#x2F;2 如果数组中无值返回-1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag &#x3D; [&#123;age:1&#125;,&#123;age:2&#125;].some(v&#x3D;&gt;JSON.stringify(v)&#x3D;&#x3D;&#x3D;JSON.stringify(&#123;age:2&#125;))</span><br><span class="line">console.log(flag)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="11-数组每一项都满足"><a href="#11-数组每一项都满足" class="headerlink" title="11.数组每一项都满足"></a>11.数组每一项都满足</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].every(item &#x3D;&gt; &#123; return item &gt; 2 &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&#123; age: 3 &#125;, &#123; age: 4 &#125;, &#123; age: 5 &#125;]</span><br><span class="line">arr.every(item &#x3D;&gt; &#123; return item.age &gt; 2 &#125;) &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="12-数组有一项满足"><a href="#12-数组有一项满足" class="headerlink" title="12.数组有一项满足"></a>12.数组有一项满足</h4><p>普通数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].some(item &#x3D;&gt; &#123; return item &gt; 2 &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [&#123; age: 3 &#125;, &#123; age: 4 &#125;, &#123; age: 5 &#125;]</span><br><span class="line">arr.some(item &#x3D;&gt; &#123; return item.age &lt; 4 &#125;) &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="13-版本号排序"><a href="#13-版本号排序" class="headerlink" title="13.版本号排序"></a>13.版本号排序</h4><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sortNumber(a, b) &#123;</span><br><span class="line">  return a - b</span><br><span class="line">&#125;</span><br><span class="line">const b &#x3D; [1,2,3,7,5,6]</span><br><span class="line">const a &#x3D; [&quot;1.5&quot;, &quot;1.5&quot;, &quot;1.40&quot;, &quot;1.25&quot;, &quot;1.1000&quot;, &quot;1.1&quot;];</span><br><span class="line"></span><br><span class="line">console.log(a.sort(sortNumber)); &#x2F;&#x2F; [ 1, 2, 3, 5, 6, 7 ]</span><br><span class="line">console.log(b.sort(sortNumber)); &#x2F;&#x2F;[ &#39;1.1000&#39;, &#39;1.1&#39;, &#39;1.25&#39;, &#39;1.40&#39;, &#39;1.5&#39;, &#39;1.5&#39; ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可见sort排序对整数可以，类似版本号这个格式就不适用了，因为sort函数在比较字符串的时候，是比较字符串的Unicode进行排序的。</p>
<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;假定字符串的每节数都在5位以下</span><br><span class="line">&#x2F;&#x2F;去除数组空值||空格</span><br><span class="line">if (!Array.prototype.trim) &#123;</span><br><span class="line">  Array.prototype.trim &#x3D; function () &#123;</span><br><span class="line">    let arr &#x3D; []; this.forEach(function (e) &#123;</span><br><span class="line">      if (e.match(&#x2F;\S+&#x2F;)) arr.push(e);</span><br><span class="line">    &#125;)</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提取数字部分</span><br><span class="line">function toNum(a) &#123;</span><br><span class="line">  let d &#x3D; a.toString();</span><br><span class="line">  let c &#x3D; d.split(&#x2F;\D&#x2F;).trim();</span><br><span class="line">  let num_place &#x3D; [&quot;&quot;, &quot;0&quot;, &quot;00&quot;, &quot;000&quot;, &quot;0000&quot;], r &#x3D; num_place.reverse();</span><br><span class="line">  for (let i &#x3D; 0; i &lt; c.length; i++) &#123;</span><br><span class="line">    let len &#x3D; c[i].length;</span><br><span class="line">    c[i] &#x3D; r[len] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  let res &#x3D; c.join(&#39;&#39;);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提取字符</span><br><span class="line">function toChar(a) &#123;</span><br><span class="line">  let d &#x3D; a.toString();</span><br><span class="line">  let c &#x3D; d.split(&#x2F;\.|\d&#x2F;).join(&#39;&#39;);</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sortVersions(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let _a1 &#x3D; toNum(a), _b1 &#x3D; toNum(b);</span><br><span class="line">  if (_a1 !&#x3D;&#x3D; _b1) return _a1 - _b1;</span><br><span class="line">  else &#123;</span><br><span class="line">    _a2 &#x3D; toChar(a).charCodeAt(0).toString(16);</span><br><span class="line">    _b2 &#x3D; toChar(b).charCodeAt(0).toString(16);</span><br><span class="line">    return _a2 - _b2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr1 &#x3D; [&quot;10&quot;, &quot;5&quot;, &quot;40&quot;, &quot;25&quot;, &quot;1000&quot;, &quot;1&quot;];</span><br><span class="line">let arr2 &#x3D; [&quot;1.10&quot;, &quot;1.5&quot;, &quot;1.40&quot;, &quot;1.25&quot;, &quot;1.1000&quot;, &quot;1.1&quot;];</span><br><span class="line">let arr3 &#x3D; [&quot;1.10c&quot;, &quot;1.10b&quot;, &quot;1.10C&quot;, &quot;1.25&quot;, &quot;1.1000&quot;, &quot;1.10A&quot;];</span><br><span class="line">console.log(arr1.sort(sortVersions)) &#x2F;&#x2F;[ &#39;1&#39;, &#39;5&#39;, &#39;10&#39;, &#39;25&#39;, &#39;40&#39;, &#39;1000&#39; ]</span><br><span class="line">console.log(arr2.sort(sortVersions)) &#x2F;&#x2F;[ &#39;1.1&#39;, &#39;1.5&#39;, &#39;1.10&#39;, &#39;1.25&#39;, &#39;1.40&#39;, &#39;1.1000&#39; ]</span><br><span class="line">console.log(arr3.sort(sortVersions)) &#x2F;&#x2F; [ &#39;1.10A&#39;, &#39;1.10C&#39;, &#39;1.10b&#39;, &#39;1.10c&#39;, &#39;1.25&#39;, &#39;1.1000&#39; ]</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看出这个函数均兼容整数，非整数，字母；<br>字母排序是根据Unicode排序的，所以1.10b在1.10C的后面</p>
<h4 id="14-对象转数组"><a href="#14-对象转数组" class="headerlink" title="14. 对象转数组"></a>14. 对象转数组</h4><p>将数组的key和value转化成数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.keys(&#123; name: &#39;张三&#39;, age: 14 &#125;) &#x2F;&#x2F;[&#39;name&#39;,&#39;age&#39;]</span><br><span class="line">Object.values(&#123; name: &#39;张三&#39;, age: 14 &#125;) &#x2F;&#x2F;[&#39;张三&#39;,14]</span><br><span class="line">Object.entries(&#123; name: &#39;张三&#39;, age: 14 &#125;) &#x2F;&#x2F;[[name,&#39;张三&#39;],[age,14]]</span><br><span class="line">Object.fromEntries([name, &#39;张三&#39;], [age, 14]) &#x2F;&#x2F;ES10的api,Chrome不支持 , firebox输出&#123;name:&#39;张三&#39;,age:14&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="15-数组转对象"><a href="#15-数组转对象" class="headerlink" title="15.数组转对象"></a>15.数组转对象</h4><p>将数组的值转化为对象的value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arrName &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]</span><br><span class="line">const arrAge&#x3D;[&#39;20&#39;,&#39;30&#39;,&#39;40&#39;]</span><br><span class="line">const arrDec &#x3D; [&#39;描述1&#39;, &#39;描述2&#39;, &#39;描述3&#39;]</span><br><span class="line">const obj &#x3D; arrName.map((item,index)&#x3D;&gt;&#123;</span><br><span class="line">  return &#123; name: item, age: arrAge[index],dec:arrDec[index]&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(obj) &#x2F;&#x2F; [&#123; name: &#39;张三&#39;, age: &#39;20&#39;, dec: &#39;描述1&#39; &#125;,&#123; name: &#39;李四&#39;, age: &#39;30&#39;, dec: &#39;描述2&#39; &#125;,&#123; name: &#39;王五&#39;, age: &#39;40&#39;, dec: &#39;描述3&#39; &#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="16-数组解构"><a href="#16-数组解构" class="headerlink" title="16.数组解构"></a>16.数组解构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr&#x3D;[1,2]; &#x2F;&#x2F;后面一定要加分号，因为不加解释器会认为在读数组</span><br><span class="line">[arr[1], arr[0]] &#x3D; [arr[0], arr[1]]; &#x2F;&#x2F; [2,1]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="17-对象变量属性"><a href="#17-对象变量属性" class="headerlink" title="17.对象变量属性"></a>17.对象变量属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag &#x3D; true;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    a: 0,</span><br><span class="line">    [flag ? &quot;c&quot; : &quot;d&quot;]: 2</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; obj &#x3D;&gt; &#123; a: 0, c: 2 &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="18-对象多余属性删除"><a href="#18-对象多余属性删除" class="headerlink" title="18.对象多余属性删除"></a>18.对象多余属性删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; name, age, ...obj &#125; &#x3D; &#123; name: &#39;张三&#39;, age: 13, dec: &#39;描述1&#39;, info: &#39;信息&#39; &#125;</span><br><span class="line">console.log(name)  &#x2F;&#x2F; 张三</span><br><span class="line">console.log(age)  &#x2F;&#x2F; 13</span><br><span class="line">console.log(obj)  &#x2F;&#x2F; &#123;dec: &#39;描述1&#39;, info: &#39;信息&#39; &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="19-对象嵌套属性解构"><a href="#19-对象嵌套属性解构" class="headerlink" title="19.对象嵌套属性解构"></a>19.对象嵌套属性解构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; info:&#123; dec&#125; &#125; &#x3D; &#123; name: &#39;张三&#39;, age: 13, info:&#123;dec: &#39;描述1&#39;, info: &#39;信息&#39; &#125;&#125;</span><br><span class="line">console.log(dec) &#x2F;&#x2F; 描述1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="20-解构对象属性别名"><a href="#20-解构对象属性别名" class="headerlink" title="20.解构对象属性别名"></a>20.解构对象属性别名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; name:newName &#125; &#x3D; &#123; name: &#39;张三&#39;, age: 13 &#125;</span><br><span class="line">console.log(newName)  &#x2F;&#x2F; 张三</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="21-解构对象属性默认值"><a href="#21-解构对象属性默认值" class="headerlink" title="21.解构对象属性默认值"></a>21.解构对象属性默认值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; dec&#x3D;&#39;这是默认dec值&#39; &#125; &#x3D; &#123; name: &#39;张三&#39;, age: 13 &#125;</span><br><span class="line">console.log(dec) &#x2F;&#x2F;这是默认dec值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="22-拦截对象"><a href="#22-拦截对象" class="headerlink" title="22.拦截对象"></a>22.拦截对象</h4><p>利用Object.defineProperty拦截对象<br>无法拦截数组的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123; name: &#39;&#39;, age: &#39;&#39;, sex: &#39;&#39; &#125;,</span><br><span class="line">  defaultName &#x3D; [&quot;这是姓名默认值1&quot;, &quot;这是年龄默认值1&quot;, &quot;这是性别默认值1&quot;];</span><br><span class="line">Object.keys(obj).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123; &#x2F;&#x2F; 拦截整个object 对象，并通过get获取值，set设置值，vue 2.x的核心就是这个来监听</span><br><span class="line">    get() &#123;</span><br><span class="line">      return defaultName;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">      defaultName &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(obj.name); &#x2F;&#x2F; [ &#39;这是姓名默认值1&#39;, &#39;这是年龄默认值1&#39;, &#39;这是性别默认值1&#39; ]</span><br><span class="line">console.log(obj.age); &#x2F;&#x2F; [ &#39;这是姓名默认值1&#39;, &#39;这是年龄默认值1&#39;, &#39;这是性别默认值1&#39; ]</span><br><span class="line">console.log(obj.sex); &#x2F;&#x2F; [ &#39;这是姓名默认值1&#39;, &#39;这是年龄默认值1&#39;, &#39;这是性别默认值1&#39; ]</span><br><span class="line">obj.name &#x3D; &quot;这是改变值1&quot;;</span><br><span class="line">console.log(obj.name); &#x2F;&#x2F; 这是改变值1</span><br><span class="line">console.log(obj.age);  &#x2F;&#x2F; 这是改变值1</span><br><span class="line">console.log(obj.sex); &#x2F;&#x2F; 这是改变值1</span><br><span class="line"></span><br><span class="line">let objOne &#x3D; &#123;&#125;, defaultNameOne &#x3D; &quot;这是默认值2&quot;;</span><br><span class="line">Object.defineProperty(obj, &#39;name&#39;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return defaultNameOne;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(value) &#123;</span><br><span class="line">    defaultNameOne &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(objOne.name); &#x2F;&#x2F; undefined</span><br><span class="line">objOne.name &#x3D; &quot;这是改变值2&quot;;</span><br><span class="line">console.log(objOne.name); &#x2F;&#x2F; 这是改变值2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>利用proxy拦截对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123; name: &#39;&#39;, age: &#39;&#39;, sex: &#39;&#39; &#125;</span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  get(target, key, receiver) &#123;</span><br><span class="line">    console.log(&quot;get&quot;, key); </span><br><span class="line">    return Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value, receiver) &#123;</span><br><span class="line">    console.log(&quot;set&quot;, key, value); &#x2F;&#x2F; set name 李四  &#x2F;&#x2F; set age 24</span><br><span class="line">    return Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let proxy &#x3D; new Proxy(obj, handler);</span><br><span class="line">proxy.name &#x3D; &quot;李四&quot;;</span><br><span class="line">proxy.age &#x3D; 24;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>defineProterty和proxy的对比：<br>1.defineProterty是es5的标准,proxy是es6的标准;<br>2.proxy可以监听到数组索引赋值,改变数组长度的变化;<br>3.proxy是监听对象,不用深层遍历,defineProterty是监听属性;<br>4.利用defineProterty实现双向数据绑定(vue2.x采用的核心)</p>
<h4 id="23-对象深度拷贝"><a href="#23-对象深度拷贝" class="headerlink" title="23.对象深度拷贝"></a>23.对象深度拷贝</h4><p>JSON.stringify深度克隆对象;<br>1.无法对函数 、RegExp等特殊对象的克隆;<br>2.会抛弃对象的constructor,所有的构造函数会指向Object;<br>3.对象有循环引用,会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapTag &#x3D; &#39;[object Map]&#39;;</span><br><span class="line">const setTag &#x3D; &#39;[object Set]&#39;;</span><br><span class="line">const arrayTag &#x3D; &#39;[object Array]&#39;;</span><br><span class="line">const objectTag &#x3D; &#39;[object Object]&#39;;</span><br><span class="line">const argsTag &#x3D; &#39;[object Arguments]&#39;;</span><br><span class="line"></span><br><span class="line">const boolTag &#x3D; &#39;[object Boolean]&#39;;</span><br><span class="line">const dateTag &#x3D; &#39;[object Date]&#39;;</span><br><span class="line">const numberTag &#x3D; &#39;[object Number]&#39;;</span><br><span class="line">const stringTag &#x3D; &#39;[object String]&#39;;</span><br><span class="line">const symbolTag &#x3D; &#39;[object Symbol]&#39;;</span><br><span class="line">const errorTag &#x3D; &#39;[object Error]&#39;;</span><br><span class="line">const regexpTag &#x3D; &#39;[object RegExp]&#39;;</span><br><span class="line">const funcTag &#x3D; &#39;[object Function]&#39;;</span><br><span class="line"></span><br><span class="line">const deepTag &#x3D; [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function forEach(array, iteratee) &#123;</span><br><span class="line">  let index &#x3D; -1;</span><br><span class="line">  const length &#x3D; array.length;</span><br><span class="line">  while (++index &lt; length) &#123;</span><br><span class="line">    iteratee(array[index], index);</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isObject(target) &#123;</span><br><span class="line">  const type &#x3D; typeof target;</span><br><span class="line">  return target !&#x3D;&#x3D; null &amp;&amp; (type &#x3D;&#x3D;&#x3D; &#39;object&#39; || type &#x3D;&#x3D;&#x3D; &#39;function&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getType(target) &#123;</span><br><span class="line">  return Object.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getInit(target) &#123;</span><br><span class="line">  const Ctor &#x3D; target.constructor;</span><br><span class="line">  return new Ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneSymbol(targe) &#123;</span><br><span class="line">  return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneReg(targe) &#123;</span><br><span class="line">  const reFlags &#x3D; &#x2F;\w*$&#x2F;;</span><br><span class="line">  const result &#x3D; new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">  result.lastIndex &#x3D; targe.lastIndex;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneFunction(func) &#123;</span><br><span class="line">  const bodyReg &#x3D; &#x2F;(?&lt;&#x3D;&#123;)(.|\n)+(?&#x3D;&#125;)&#x2F;m;</span><br><span class="line">  const paramReg &#x3D; &#x2F;(?&lt;&#x3D;\().+(?&#x3D;\)\s+&#123;)&#x2F;;</span><br><span class="line">  const funcString &#x3D; func.toString();</span><br><span class="line">  if (func.prototype) &#123;</span><br><span class="line">    const param &#x3D; paramReg.exec(funcString);</span><br><span class="line">    const body &#x3D; bodyReg.exec(funcString);</span><br><span class="line">    if (body) &#123;</span><br><span class="line">      if (param) &#123;</span><br><span class="line">        const paramArr &#x3D; param[0].split(&#39;,&#39;);</span><br><span class="line">        return new Function(...paramArr, body[0]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return new Function(body[0]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return eval(funcString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneOtherType(targe, type) &#123;</span><br><span class="line">  const Ctor &#x3D; targe.constructor;</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case boolTag:</span><br><span class="line">    case numberTag:</span><br><span class="line">    case stringTag:</span><br><span class="line">    case errorTag:</span><br><span class="line">    case dateTag:</span><br><span class="line">      return new Ctor(targe);</span><br><span class="line">    case regexpTag:</span><br><span class="line">      return cloneReg(targe);</span><br><span class="line">    case symbolTag:</span><br><span class="line">      return cloneSymbol(targe);</span><br><span class="line">    case funcTag:</span><br><span class="line">      return cloneFunction(targe);</span><br><span class="line">    default:</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clone(target, map &#x3D; new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 克隆原始类型</span><br><span class="line">  if (!isObject(target)) &#123;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 初始化</span><br><span class="line">  const type &#x3D; getType(target);</span><br><span class="line">  let cloneTarget;</span><br><span class="line">  if (deepTag.includes(type)) &#123;</span><br><span class="line">    cloneTarget &#x3D; getInit(target, type);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return cloneOtherType(target, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 防止循环引用</span><br><span class="line">  if (map.get(target)) &#123;</span><br><span class="line">    return map.get(target);</span><br><span class="line">  &#125;</span><br><span class="line">  map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 克隆set</span><br><span class="line">  if (type &#x3D;&#x3D;&#x3D; setTag) &#123;</span><br><span class="line">    target.forEach(value &#x3D;&gt; &#123;</span><br><span class="line">      cloneTarget.add(clone(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 克隆map</span><br><span class="line">  if (type &#x3D;&#x3D;&#x3D; mapTag) &#123;</span><br><span class="line">    target.forEach((value, key) &#x3D;&gt; &#123;</span><br><span class="line">      cloneTarget.set(key, clone(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 克隆对象和数组</span><br><span class="line">  const keys &#x3D; type &#x3D;&#x3D;&#x3D; arrayTag ? undefined : Object.keys(target);</span><br><span class="line">  forEach(keys || target, (value, key) &#x3D;&gt; &#123;</span><br><span class="line">    if (keys) &#123;</span><br><span class="line">      key &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    cloneTarget[key] &#x3D; clone(target[key], map);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return cloneTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(clone(&#123;</span><br><span class="line">  name: &#39;张三&#39;, age: 23,</span><br><span class="line">  obj: &#123; name: &#39;李四&#39;, age: 46 &#125;,</span><br><span class="line">  arr: [1, 2, 3]</span><br><span class="line">&#125;)) &#x2F;&#x2F; &#123; name: &#39;张三&#39;, age: 23, obj: &#123; name: &#39;李四&#39;, age: 46 &#125;, arr: [ 1, 2, 3 ] &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对象深度克隆实际上就是要兼容Array，RegExp，Date，Function类型；<br>克隆函数可以用正则取出函数体和参数，再定义一个函数将取出来的值赋值进去<br>详细请戳对象深度拷贝</p>
<h4 id="24-对象是否相等"><a href="#24-对象是否相等" class="headerlink" title="24.对象是否相等"></a>24.对象是否相等</h4><p>如果用JSON.stringify转化属性顺序不同，也不相等；<br>而且不支持无法对函数 、RegExp等特殊对象的克隆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepCompare(x, y) &#123;</span><br><span class="line">  var i, l, leftChain, rightChain;</span><br><span class="line"></span><br><span class="line">  function compare2Objects(x, y) &#123;</span><br><span class="line">    var p;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; remember that NaN &#x3D;&#x3D;&#x3D; NaN returns false</span><br><span class="line">    &#x2F;&#x2F; and isNaN(undefined) returns true</span><br><span class="line">    if (isNaN(x) &amp;&amp; isNaN(y) &amp;&amp; typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39; &amp;&amp; typeof y &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Compare primitives and functions.     </span><br><span class="line">    &#x2F;&#x2F; Check if both arguments link to the same object.</span><br><span class="line">    &#x2F;&#x2F; Especially useful on the step where we compare prototypes</span><br><span class="line">    if (x &#x3D;&#x3D;&#x3D; y) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Works in case when functions are created in constructor.</span><br><span class="line">    &#x2F;&#x2F; Comparing dates is a common scenario. Another built-ins?</span><br><span class="line">    &#x2F;&#x2F; We can even handle functions passed across iframes</span><br><span class="line">    if ((typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof y &#x3D;&#x3D;&#x3D; &#39;function&#39;) ||</span><br><span class="line">      (x instanceof Date &amp;&amp; y instanceof Date) ||</span><br><span class="line">      (x instanceof RegExp &amp;&amp; y instanceof RegExp) ||</span><br><span class="line">      (x instanceof String &amp;&amp; y instanceof String) ||</span><br><span class="line">      (x instanceof Number &amp;&amp; y instanceof Number)) &#123;</span><br><span class="line">      return x.toString() &#x3D;&#x3D;&#x3D; y.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; At last checking prototypes as good as we can</span><br><span class="line">    if (!(x instanceof Object &amp;&amp; y instanceof Object)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (x.constructor !&#x3D;&#x3D; y.constructor) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (x.prototype !&#x3D;&#x3D; y.prototype) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check for infinitive linking loops</span><br><span class="line">    if (leftChain.indexOf(x) &gt; -1 || rightChain.indexOf(y) &gt; -1) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Quick checking of one object being a subset of another.</span><br><span class="line">    &#x2F;&#x2F; todo: cache the structure of arguments[0] for performance</span><br><span class="line">    for (p in y) &#123;</span><br><span class="line">      if (y.hasOwnProperty(p) !&#x3D;&#x3D; x.hasOwnProperty(p)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125; else if (typeof y[p] !&#x3D;&#x3D; typeof x[p]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (p in x) &#123;</span><br><span class="line">      if (y.hasOwnProperty(p) !&#x3D;&#x3D; x.hasOwnProperty(p)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125; else if (typeof y[p] !&#x3D;&#x3D; typeof x[p]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (typeof (x[p])) &#123;</span><br><span class="line">        case &#39;object&#39;:</span><br><span class="line">        case &#39;function&#39;:</span><br><span class="line"></span><br><span class="line">          leftChain.push(x);</span><br><span class="line">          rightChain.push(y);</span><br><span class="line"></span><br><span class="line">          if (!compare2Objects(x[p], y[p])) &#123;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          leftChain.pop();</span><br><span class="line">          rightChain.pop();</span><br><span class="line">          break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">          if (x[p] !&#x3D;&#x3D; y[p]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (arguments.length &lt; 1) &#123;</span><br><span class="line">    return true; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (i &#x3D; 1, l &#x3D; arguments.length; i &lt; l; i++) &#123;</span><br><span class="line"></span><br><span class="line">    leftChain &#x3D; []; &#x2F;&#x2F;Todo: this can be cached</span><br><span class="line">    rightChain &#x3D; [];</span><br><span class="line"></span><br><span class="line">    if (!compare2Objects(arguments[0], arguments[i])) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj1 &#x3D; &#123; </span><br><span class="line">  name: &#39;张三&#39;, age: 23, </span><br><span class="line">  obj: &#123; name: &#39;李四&#39;, age: 46 &#125;, </span><br><span class="line">  arr: [1, 2, 3],</span><br><span class="line">  date:new Date(23),</span><br><span class="line">  reg: new RegExp(&#39;abc&#39;),</span><br><span class="line">  fun: ()&#x3D;&gt;&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">const obj2 &#x3D; &#123; </span><br><span class="line">  name: &#39;张三&#39;, age: 23, </span><br><span class="line">  obj: &#123; name: &#39;李四&#39;, age: 46 &#125;, </span><br><span class="line">  arr: [1, 2, 3],</span><br><span class="line">  date: new Date(23),</span><br><span class="line">  reg: new RegExp(&#39;abc&#39;),</span><br><span class="line">  fun: ()&#x3D;&gt;&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">console.log(deepCompare(obj1,obj2)) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>判断对象是否相等，实际上就是要处理Array，Date，RegExp，Object，Function的特殊类型是否相等</p>
<h4 id="25-对象转化为字符串"><a href="#25-对象转化为字符串" class="headerlink" title="25.对象转化为字符串"></a>25.对象转化为字符串</h4><p>通过字符串+Object 的方式来转化对象为字符串(实际上是调用 .toString() 方法)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;the Math object:&#39; + Math.ceil(3.4)                &#x2F;&#x2F; &quot;the Math object:4&quot;</span><br><span class="line">&#39;the JSON object:&#39; + &#123;name:&#39;曹操&#39;&#125;              &#x2F;&#x2F; &quot;the JSON object:[object Object]&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>覆盖对象的toString和valueOf方法来自定义对象的类型转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2  * &#123; valueOf: ()&#x3D;&gt;&#39;4&#39; &#125;                &#x2F;&#x2F; 8</span><br><span class="line">&#39;J&#39; + &#123; toString: ()&#x3D;&gt;&#39;ava&#39; &#125;                &#x2F;&#x2F; &quot;Java&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当+用在连接字符串时，当一个对象既有toString方法又有valueOf方法时候，JS通过盲目使用valueOf方法来解决这种含糊;<br>对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39; + &#123;toString:()&#x3D;&gt;&#39;S&#39;,valueOf:()&#x3D;&gt;&#39;J&#39;&#125;  &#x2F;&#x2F;J</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><h4 id="26-函数隐式返回值"><a href="#26-函数隐式返回值" class="headerlink" title="26.函数隐式返回值"></a>26.函数隐式返回值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(()&#x3D;&gt;3)()  &#x2F;&#x2F;3</span><br><span class="line">(()&#x3D;&gt;(</span><br><span class="line">   3</span><br><span class="line">))()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>函数省略大括号，或者将大括号改成小括号可以确保代码以单个语句的形式进行求值</p>
<h4 id="27-函数自执行"><a href="#27-函数自执行" class="headerlink" title="27.函数自执行"></a>27.函数自执行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Func &#x3D; function() &#123;&#125;(); &#x2F;&#x2F; 常用</span><br><span class="line"></span><br><span class="line">(function() &#123;&#125;)(); &#x2F;&#x2F; 常用</span><br><span class="line">(function() &#123;&#125;()); &#x2F;&#x2F; 常用</span><br><span class="line">[function() &#123;&#125;()];</span><br><span class="line"></span><br><span class="line">new function() &#123;&#125;;</span><br><span class="line">new function() &#123;&#125;();</span><br><span class="line">void function() &#123;&#125;();</span><br><span class="line">typeof function() &#123;&#125;();</span><br><span class="line">delete function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">+ function() &#123;&#125;();</span><br><span class="line">- function() &#123;&#125;();</span><br><span class="line">~ function() &#123;&#125;();</span><br><span class="line">! function() &#123;&#125;();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="28-函数异步执行"><a href="#28-函数异步执行" class="headerlink" title="28.函数异步执行"></a>28.函数异步执行</h4><p>Promise</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.reject(&#39;这是第二个 reject 值&#39;).then((data)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;).catch(data&#x3D;&gt;&#123;</span><br><span class="line">  console.log(data) &#x2F;&#x2F;这是第二个 reject 值</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* gen(x) &#123;</span><br><span class="line">  const y &#x3D; yield x + 6;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; yield 如果用在另外一个表达式中,要放在()里面</span><br><span class="line">&#x2F;&#x2F; 像上面如果是在&#x3D;右边就不用加()</span><br><span class="line">function* genOne(x) &#123;</span><br><span class="line">  const y &#x3D; &#96;这是第一个 yield 执行:$&#123;yield x + 1&#125;&#96;;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const g &#x3D; gen(1);</span><br><span class="line">&#x2F;&#x2F;执行 Generator 会返回一个Object,而不是像普通函数返回return 后面的值</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: 7, done: false &#125;</span><br><span class="line">&#x2F;&#x2F;调用指针的 next 方法,会从函数的头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式或return语句暂停,也就是执行yield 这一行</span><br><span class="line">&#x2F;&#x2F; 执行完成会返回一个 Object,</span><br><span class="line">&#x2F;&#x2F; value 就是执行 yield 后面的值,done 表示函数是否执行完毕</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br><span class="line">&#x2F;&#x2F; 因为最后一行 return y 被执行完成,所以done 为 true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Async/Await</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getSomething() &#123;</span><br><span class="line">    return &quot;something&quot;;</span><br><span class="line">&#125;</span><br><span class="line">async function testAsync() &#123;</span><br><span class="line">    return Promise.resolve(&quot;hello async&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    const v1 &#x3D; await getSomething();</span><br><span class="line">    const v2 &#x3D; await testAsync();</span><br><span class="line">    console.log(v1, v2); &#x2F;&#x2F;something 和 hello async</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="29-字符串翻转"><a href="#29-字符串翻转" class="headerlink" title="29.字符串翻转"></a>29.字符串翻转</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function reverseStr(str &#x3D; &quot;&quot;) &#123;</span><br><span class="line">  return str.split(&quot;&quot;).reduceRight((t, v) &#x3D;&gt; t + v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const str &#x3D; &quot;reduce123&quot;;</span><br><span class="line">console.log(reverseStr(str)); &#x2F;&#x2F; &quot;321recuder&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="30-url参数序列化"><a href="#30-url参数序列化" class="headerlink" title="30.url参数序列化"></a>30.url参数序列化</h4><p>将对象序列化成url参数传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function stringifyUrl(search &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  return Object.entries(search).reduce(</span><br><span class="line">    (t, v) &#x3D;&gt; &#96;$&#123;t&#125;$&#123;v[0]&#125;&#x3D;$&#123;encodeURIComponent(v[1])&#125;&amp;&#96;,</span><br><span class="line">    Object.keys(search).length ? &quot;?&quot; : &quot;&quot;</span><br><span class="line">  ).replace(&#x2F;&amp;$&#x2F;, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(stringifyUrl(&#123; age: 27, name: &quot;YZW&quot; &#125;)); &#x2F;&#x2F; &quot;?age&#x3D;27&amp;name&#x3D;YZW&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="31-url参数反序列化"><a href="#31-url参数反序列化" class="headerlink" title="31.url参数反序列化"></a>31.url参数反序列化</h4><p>一般会通过location.search拿到路由传递的参数，并进行反序列化得到对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parseUrlSearch() &#123;</span><br><span class="line">  const search &#x3D; &#39;?age&#x3D;25&amp;name&#x3D;TYJ&#39;</span><br><span class="line">  return search.replace(&#x2F;(^\?)|(&amp;$)&#x2F;g, &quot;&quot;).split(&quot;&amp;&quot;).reduce((t, v) &#x3D;&gt; &#123;</span><br><span class="line">    const [key, val] &#x3D; v.split(&quot;&#x3D;&quot;);</span><br><span class="line">    t[key] &#x3D; decodeURIComponent(val);</span><br><span class="line">    return t;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(parseUrlSearch()); &#x2F;&#x2F; &#123; age: &quot;25&quot;, name: &quot;TYJ&quot; &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="32-转化为字符串"><a href="#32-转化为字符串" class="headerlink" title="32.转化为字符串"></a>32.转化为字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const val &#x3D; 1 + &quot;&quot;; &#x2F;&#x2F; 通过+ &#39;&#39;空字符串转化</span><br><span class="line">console.log(val); &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">console.log(typeof val); &#x2F;&#x2F; &quot;string&quot;</span><br><span class="line"></span><br><span class="line">const val1 &#x3D; String(1);</span><br><span class="line">console.log(val1); &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">console.log(typeof val1); &#x2F;&#x2F; &quot;string&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h4 id="33-数字千分位"><a href="#33-数字千分位" class="headerlink" title="33.数字千分位"></a>33.数字千分位</h4><p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function thousandNum(num &#x3D; 0) &#123;</span><br><span class="line">  const str &#x3D; (+num).toString().split(&quot;.&quot;);</span><br><span class="line">  const int &#x3D; nums &#x3D;&gt; nums.split(&quot;&quot;).reverse().reduceRight((t, v, i) &#x3D;&gt; t + (i % 3 ? v : &#96;$&#123;v&#125;,&#96;), &quot;&quot;).replace(&#x2F;^,|,$&#x2F;g, &quot;&quot;);</span><br><span class="line">  const dec &#x3D; nums &#x3D;&gt; nums.split(&quot;&quot;).reduce((t, v, i) &#x3D;&gt; t + ((i + 1) % 3 ? v : &#96;$&#123;v&#125;,&#96;), &quot;&quot;).replace(&#x2F;^,|,$&#x2F;g, &quot;&quot;);</span><br><span class="line">  return str.length &gt; 1 ? &#96;$&#123;int(str[0])&#125;.$&#123;dec(str[1])&#125;&#96; : int(str[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thousandNum(1234); &#x2F;&#x2F; &quot;1,234&quot;</span><br><span class="line">thousandNum(1234.00); &#x2F;&#x2F; &quot;1,234&quot;</span><br><span class="line">thousandNum(0.1234); &#x2F;&#x2F; &quot;0.123,4&quot;</span><br><span class="line">console.log(thousandNum(1234.5678)); &#x2F;&#x2F; &quot;1,234.567,8&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;1234567890&#39;.replace(&#x2F;\B(?&#x3D;(\d&#123;3&#125;)+(?!\d))&#x2F;g, &quot;,&quot;))</span><br><span class="line">console.log((1234567890).toLocaleString())</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="34-字符串转数字"><a href="#34-字符串转数字" class="headerlink" title="34.字符串转数字"></a>34.字符串转数字</h4><p>方法一<br>用*1来转化为数字,实际上是调用.valueOf方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;32&#39; * 1            &#x2F;&#x2F; 32</span><br><span class="line">&#39;ds&#39; * 1            &#x2F;&#x2F; NaN</span><br><span class="line">null * 1            &#x2F;&#x2F; 0</span><br><span class="line">undefined * 1    &#x2F;&#x2F; NaN</span><br><span class="line">1  * &#123; valueOf: ()&#x3D;&gt;&#39;3&#39; &#125;        &#x2F;&#x2F; 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ &#39;123&#39;            &#x2F;&#x2F; 123</span><br><span class="line">+ &#39;ds&#39;               &#x2F;&#x2F; NaN</span><br><span class="line">+ &#39;&#39;                    &#x2F;&#x2F; 0</span><br><span class="line">+ null              &#x2F;&#x2F; 0</span><br><span class="line">+ undefined    &#x2F;&#x2F; NaN</span><br><span class="line">+ &#123; valueOf: ()&#x3D;&gt;&#39;3&#39; &#125;    &#x2F;&#x2F; 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="35-判断小数是否相等"><a href="#35-判断小数是否相等" class="headerlink" title="35.判断小数是否相等"></a>35.判断小数是否相等</h4><p>肯定有人会说这还不简单，直接用’===’比较；<br>实际上0.1+0.2 !==0.3，因为计算机不能精确表示0.1， 0.2这样的浮点数，所以相加就不是0.3了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number.EPSILON&#x3D;(function()&#123;   &#x2F;&#x2F;解决兼容性问题</span><br><span class="line">    return Number.EPSILON?Number.EPSILON:Math.pow(2,-52);</span><br><span class="line">&#125;)();</span><br><span class="line">&#x2F;&#x2F;上面是一个自调用函数，当JS文件刚加载到内存中，就会去判断并返回一个结果</span><br><span class="line">function numbersequal(a,b)&#123; </span><br><span class="line">    return Math.abs(a-b)&lt;Number.EPSILON;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;接下来再判断   </span><br><span class="line">const a&#x3D;0.1+0.2, b&#x3D;0.3;</span><br><span class="line">console.log(numbersequal(a,b)); &#x2F;&#x2F;这里就为true了</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="36-双位运算符"><a href="#36-双位运算符" class="headerlink" title="36.双位运算符"></a>36.双位运算符</h4><p>双位运算符比Math.floor(),Math.ceil()速度快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~7.5                &#x2F;&#x2F; 7</span><br><span class="line">Math.ceil(7.5)       &#x2F;&#x2F; 8</span><br><span class="line">Math.floor(7.5)      &#x2F;&#x2F; 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~-7.5          &#x2F;&#x2F; -7</span><br><span class="line">Math.floor(-7.5)     &#x2F;&#x2F; -8</span><br><span class="line">Math.ceil(-7.5)      &#x2F;&#x2F; -7</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以负数时，双位运算符和Math.ceil结果一致，正数时和Math.floor结果一致</p>
<h4 id="37-取整和奇偶性判断"><a href="#37-取整和奇偶性判断" class="headerlink" title="37.取整和奇偶性判断"></a>37.取整和奇偶性判断</h4><p>取整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.3 | 0         &#x2F;&#x2F; 3</span><br><span class="line">-3.9 | 0        &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">parseInt(3.3)  &#x2F;&#x2F; 3</span><br><span class="line">parseInt(-3.3) &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 四舍五入取整</span><br><span class="line">Math.round(3.3) &#x2F;&#x2F; 3</span><br><span class="line">Math.round(-3.3) &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向上取整</span><br><span class="line">Math.ceil(3.3) &#x2F;&#x2F; 4</span><br><span class="line">Math.ceil(-3.3) &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向下取整</span><br><span class="line">Math.floor(3.3) &#x2F;&#x2F; 3</span><br><span class="line">Math.floor(-3.3) &#x2F;&#x2F; -4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>判断奇偶数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const num&#x3D;5;</span><br><span class="line">!!(num &amp; 1) &#x2F;&#x2F; true</span><br><span class="line">!!(num % 2) &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h4 id="38-判断数据类型"><a href="#38-判断数据类型" class="headerlink" title="38.判断数据类型"></a>38.判断数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dataTypeJudge(val, type) &#123;</span><br><span class="line">  const dataType &#x3D; Object.prototype.toString.call(val).replace(&#x2F;\[object (\w+)\]&#x2F;, &quot;$1&quot;).toLowerCase();</span><br><span class="line">  return type ? dataType &#x3D;&#x3D;&#x3D; type : dataType;</span><br><span class="line">&#125;</span><br><span class="line">console.log(dataTypeJudge(&quot;young&quot;)); &#x2F;&#x2F; &quot;string&quot;</span><br><span class="line">console.log(dataTypeJudge(20190214)); &#x2F;&#x2F; &quot;number&quot;</span><br><span class="line">console.log(dataTypeJudge(true)); &#x2F;&#x2F; &quot;boolean&quot;</span><br><span class="line">console.log(dataTypeJudge([], &quot;array&quot;)); &#x2F;&#x2F; true</span><br><span class="line">console.log(dataTypeJudge(&#123;&#125;, &quot;array&quot;)); &#x2F;&#x2F; false</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可判断类型：undefined、null、string、number、boolean、array、object、symbol、date、regexp、function、asyncfunction、arguments、set、map、weakset、weakmap</p>
<h4 id="39-使用Boolean过滤数组假值"><a href="#39-使用Boolean过滤数组假值" class="headerlink" title="39.使用Boolean过滤数组假值"></a>39.使用Boolean过滤数组假值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const compact &#x3D; arr &#x3D;&gt; arr.filter(Boolean)</span><br><span class="line">compact([0, 1, false, 2, &#39;&#39;, 3, &#39;a&#39;, &#39;e&#39; * 23, NaN, &#39;s&#39;, 34])  &#x2F;&#x2F;[ 1, 2, 3, &#39;a&#39;, &#39;s&#39;, 34 ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="40-短路运算"><a href="#40-短路运算" class="headerlink" title="40.短路运算"></a>40.短路运算</h4><p>||（或）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag &#x3D; false || true &#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F; 某个值为假时可以给默认值</span><br><span class="line">const arr &#x3D; false || []</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>&amp;&amp;（与）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flag1 &#x3D; false &amp;&amp; true &#x2F;&#x2F;false</span><br><span class="line">const flag2 &#x3D; true &amp;&amp; true &#x2F;&#x2F;true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="41-switch-简写"><a href="#41-switch-简写" class="headerlink" title="41.switch 简写"></a>41.switch 简写</h4><p>可以用对象替代switch，提高代码可读性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch(a) &#123;</span><br><span class="line">  case &#39;张三&#39;:</span><br><span class="line">    return &#39;age是12&#39;</span><br><span class="line">  case &#39;李四&#39;:</span><br><span class="line">    return &#39;age是120&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用对象替换后</span><br><span class="line">const obj &#x3D;&#123;</span><br><span class="line">  &#39;张三&#39;: &#39;age12&#39;,</span><br><span class="line">  &#39;李四&#39;: &#39;age120&#39;,</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj[&#39;张三&#39;])</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>源码地址 <a href="https://github.com/lanzhsh/react-vue-koa/tree/master/js/skill；" target="_blank" rel="noopener">https://github.com/lanzhsh/react-vue-koa/tree/master/js/skill；</a><br>原创码字不易，欢迎start！</p>
<h2 id="给一个函数-Bind-对象"><a href="#给一个函数-Bind-对象" class="headerlink" title="给一个函数 Bind 对象"></a>给一个函数 Bind 对象</h2><p>我们经常需要将一个对象绑定到一个方法的 this 上。在 JS 中，如果你想要调用一个函数并指定它的 this 时可以使用 bind 方法。</p>
<p>Bind 语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<p>参数</p>
<p>thisArg</p>
<p>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。</p>
<p>arg1, arg2, …</p>
<p>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</p>
<p>返回值</p>
<p>返回由指定的this值和初始化参数改造的原函数拷贝</p>
<a id="more"></a>

<h2 id="JS-中的实例"><a href="#JS-中的实例" class="headerlink" title="JS 中的实例"></a>JS 中的实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myCar &#x3D; &#123; brand: &#39;Ford&#39;, type: &#39;Sedan&#39;, color: &#39;Red&#39;&#125;;</span><br><span class="line">const getBrand &#x3D; function () &#123; console.log(this.brand);&#125;;</span><br><span class="line">const getType &#x3D; function () &#123; console.log(this.type);&#125;;</span><br><span class="line">const getColor &#x3D; function () &#123; console.log(this.color);&#125;;</span><br><span class="line">getBrand(); &#x2F;&#x2F; object not bind,undefined</span><br><span class="line">getBrand(myCar); &#x2F;&#x2F; object not bind,undefined</span><br><span class="line">getType.bind(myCar)(); &#x2F;&#x2F; Sedan</span><br><span class="line">let boundGetColor &#x3D; getColor.bind(myCar);boundGetColor(); &#x2F;&#x2F; Red</span><br></pre></td></tr></table></figure>

<h2 id="获取文件拓展名"><a href="#获取文件拓展名" class="headerlink" title="获取文件拓展名"></a>获取文件拓展名</h2><p>解决方法 1: 正则表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFileExtension1(filename) &#123;  return (&#x2F;[.]&#x2F;.exec(filename)) ? &#x2F;[^.]+$&#x2F;.exec(filename)[0] : undefined;&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法 2: String的split方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFileExtension2(filename) &#123;  return filename.split(&#39;.&#39;).pop();&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法 3: String的slice、lastIndexOf方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFileExtension3(filename) &#123;  return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2);&#125;</span><br><span class="line">console.log(getFileExtension3(&#39;&#39;));                            &#x2F;&#x2F; &#39;&#39;console.log(getFileExtension3(&#39;filename&#39;));                    &#x2F;&#x2F; &#39;&#39;console.log(getFileExtension3(&#39;filename.txt&#39;));                &#x2F;&#x2F; &#39;txt&#39;console.log(getFileExtension3(&#39;.hiddenfile&#39;));                 &#x2F;&#x2F; &#39;&#39;console.log(getFileExtension3(&#39;filename.with.many.dots.ext&#39;)); &#x2F;&#x2F; &#39;ext&#39;</span><br></pre></td></tr></table></figure>

<p><strong>*这是如何实现的呢?*</strong></p>
<p><strong>**</strong></p>
<ul>
<li>String.lastIndexOf() 方法返回指定值（本例中的’.’）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</li>
<li>对于’filename’和’.hiddenfile’，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。</li>
<li>String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为””。</li>
</ul>
<h2 id="预防unapply攻击"><a href="#预防unapply攻击" class="headerlink" title="预防unapply攻击"></a>预防unapply攻击</h2><p>重写内置对象的原型方法，外部代码可以通过重写代码达到暴漏和修改已绑定参数的函数。这在es5的方法下使用polyfill时是一个严重的安全问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bind polyfill 示例function bind(fn) &#123;  var prev &#x3D; Array.prototype.slice.call(arguments, 1);  return function bound() &#123;    var curr &#x3D; Array.prototype.slice.call(arguments, 0);    var args &#x3D; Array.prototype.concat.apply(prev, curr);    return fn.apply(null, args);  &#125;;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; unapply攻击function unapplyAttack() &#123;  var concat &#x3D; Array.prototype.concat;  Array.prototype.concat &#x3D; function replaceAll() &#123;    Array.prototype.concat &#x3D; concat; &#x2F;&#x2F; restore the correct version    var curr &#x3D; Array.prototype.slice.call(arguments, 0);    var result &#x3D; concat.apply([], curr);    return result;  &#125;;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数声明忽略了函数bind的prev参数，意味着调用unapplyAttack之后首次调用.concat将会抛出错误。</p>
<p>使用Object.freeze，可以使对象不可变，你可以防止任何内置对象原型方法被重写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function freezePrototypes() &#123;  if (typeof Object.freeze !&#x3D;&#x3D; &#39;function&#39;) &#123;    throw new Error(&#39;Missing Object.freeze&#39;);  &#125;  Object.freeze(Object.prototype);  Object.freeze(Array.prototype);  Object.freeze(Function.prototype);&#125;());</span><br></pre></td></tr></table></figure>

<p>点击这里，你可以阅读更多关于unapply攻击。</p>
<p>##给缓存设置过期时间</p>
<p>方案一（通用）：ES5扩展Storage<a href="https://www.cnblogs.com/ricolee/p/localstorage-expiretime.html#341252870" target="_blank" rel="noopener">#</a></p>
<p>思路很简单，存储的值加一个时间戳，下次取值时验证时间戳。</p>
<p>注意： localStorage只能存储字符，存入时将对象转为json字符串,读取时也要解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;localStorage 设置的值不能为对象,转为json字符串</span><br><span class="line">Storage.prototype.setExpire &#x3D; (key, value, expire) &#x3D; &gt;&#123;</span><br><span class="line">    let obj &#x3D; &#123;</span><br><span class="line">        data: value,</span><br><span class="line">        time: Date.now(),</span><br><span class="line">        expire: expire</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    localStorage.setItem(key, JSON.stringify(obj));</span><br><span class="line">&#125;</span><br><span class="line">Storage.prototype.getExpire &#x3D; key &#x3D; &gt;&#123;</span><br><span class="line">    let val &#x3D; localStorage.getItem(key);</span><br><span class="line">    if (!val) &#123;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">    val &#x3D; JSON.parse(val);</span><br><span class="line">    if (Date.now() - val.time &gt; val.expire) &#123;</span><br><span class="line">        localStorage.removeItem(key);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return val.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试一下：</p>
<p>Copy</p>
<p>localStorage.setExpire(‘userId’,’zhangsan’,5000);</p>
<p>window.setInterval(()=&gt;{  console.log(localStorage.getExpire(“userId”));},1000)</p>
<p>前5秒还是有值的，之后即为null</p>
<p>方案二：ES6扩展Storage<a href="https://www.cnblogs.com/ricolee/p/localstorage-expiretime.html#3576419538" target="_blank" rel="noopener">#</a></p>
<p>大体思路和方案一是一样的只不过是用了ES6的最新语法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Storage &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        this.props &#x3D; props || &#123;&#125;</span><br><span class="line">        this.source &#x3D; this.props.source || window.localStorage this.initRun();</span><br><span class="line">    &#125;</span><br><span class="line">    initRun() &#123;</span><br><span class="line">        &#x2F;*        </span><br><span class="line">        * set 存储方法</span><br><span class="line">        * @ param &#123;String&#125; key 键        </span><br><span class="line">        * @ param &#123;String&#125; value 值，存储的值可能是数组&#x2F;对象，不能直接存储，需要转换 JSON.stringify </span><br><span class="line">        * @ param &#123;String&#125; expired 过期时间，以分钟为单位        *&#x2F;</span><br><span class="line">        const reg &#x3D; new RegExp(&quot;__expires__&quot;);</span><br><span class="line">        let data &#x3D; this.source;</span><br><span class="line">        let list &#x3D; Object.keys(data);</span><br><span class="line">        if (list.length &gt; 0) &#123;</span><br><span class="line">            list.map((key, v) &#x3D; &gt;&#123;</span><br><span class="line">                if (!reg.test(key)) &#123;</span><br><span class="line">                    let now &#x3D; Date.now();</span><br><span class="line">                    let expires &#x3D; data[&#96;$ &#123;</span><br><span class="line">                        key</span><br><span class="line">                    &#125;</span><br><span class="line">                    __expires__&#96;] || Date.now + 1;</span><br><span class="line">                    if (now &gt;&#x3D; expires) &#123;</span><br><span class="line">                        this.remove(key);</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                return key;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    set(key, value, expired) &#123;</span><br><span class="line">        &#x2F;*	    </span><br><span class="line">        * set 存储方法	    </span><br><span class="line">        * @ param &#123;String&#125;     key 键	    </span><br><span class="line">        * @ param &#123;String&#125;     value 值，	    </span><br><span class="line">        * @ param &#123;String&#125;     expired 过期时间，以毫秒为单位，非必须</span><br><span class="line">        *&#x2F;</span><br><span class="line">        let source &#x3D; this.source;</span><br><span class="line">        source[key] &#x3D; JSON.stringify(value);</span><br><span class="line">        if (expired) &#123;</span><br><span class="line">            source[&#96;$ &#123;</span><br><span class="line">                key</span><br><span class="line">            &#125;</span><br><span class="line">            __expires__&#96;] &#x3D; Date.now() + expired</span><br><span class="line">        &#125;;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    get(key) &#123;</span><br><span class="line">        &#x2F;*        </span><br><span class="line">        * get 获取方法        </span><br><span class="line">        * @ param &#123;String&#125;     key 键        </span><br><span class="line">        * @ param &#123;String&#125;     expired 存储时为非必须字段，所以有可能取不到，默认为 Date.now+1        		*&#x2F;</span><br><span class="line">        const source &#x3D; this.source,</span><br><span class="line">        expired &#x3D; source[&#96;$ &#123;</span><br><span class="line">            key</span><br><span class="line">        &#125;</span><br><span class="line">        __expires__&#96;] || Date.now + 1;</span><br><span class="line">        const now &#x3D; Date.now();</span><br><span class="line">        if (now &gt;&#x3D; expired) &#123;</span><br><span class="line">            this.remove(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        const value &#x3D; source[key] ? JSON.parse(source[key]) : source[key];</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        const data &#x3D; this.source,</span><br><span class="line">        value &#x3D; data[key];</span><br><span class="line">        delete data[key];</span><br><span class="line">        delete data[&#96;$ &#123;</span><br><span class="line">            key</span><br><span class="line">        &#125;</span><br><span class="line">        __expires__&#96;];</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中set(),get(),remove()方法可以理解用来存、取、删, initRun()做什么用呢？过期的值只有取时才能知道是不是过期，不取一直存着。initRun()和constructor只是在初始化时实现清理，也不是一定即时。另外写一个定时器去清理貌似也不值当，所以觉得做到这样已经够用了。</p>
<p>使用如下代码进行测试一下,效果和方案一相同</p>
<p>var ls=new Storage();</p>
<p>ls.set(‘userId’,’zhangsan’,5000);</p>
<p>window.setInterval(()=&gt;{console.log(ls.get(“userId”));},1000)</p>
<h2 id="valueOf方法"><a href="#valueOf方法" class="headerlink" title="valueOf方法"></a>valueOf方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valueOf()方法的使用</span><br><span class="line"></span><br><span class="line">undefined和null没有valueOf()方法，使用会报错；</span><br><span class="line">布尔类型true和false会返回原值；</span><br><span class="line">字符串类型会返回原值；</span><br><span class="line">数字：</span><br><span class="line">如果是整数，需要用小括号将数字包起来再使用valueOf()方法，直接在数字后面跟.valueOf()会报错；</span><br><span class="line">如果是小数会返回原值；</span><br><span class="line">对象Object类型及自定义对象类型会返回原对象（注意花括号可能会被当作代码块的问题）；</span><br><span class="line">函数function类型返回原函数；</span><br><span class="line">数组Array类型返回原数组；</span><br><span class="line">Date对象类型返回数字（1970年1月1日00：00：00至现在的毫秒数）；</span><br><span class="line">正则表达式RegExp类型返回正则对象；</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h2><p><code>Symbol.toPrimitive</code> 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。</p>
<p>下面的例子展示了， <code>Symbol.toPrimitive</code> 属性是如何干扰一个对象转换为原始值时输出的结果的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(+obj1);     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj1&#125;</span>`</span>); <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 + <span class="string">""</span>); <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(+obj2);     <span class="comment">// 10      -- hint 参数值是 "number"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj2&#125;</span>`</span>); <span class="comment">// "hello" -- hint 参数值是 "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2 + <span class="string">""</span>); <span class="comment">// "true"  -- hint 参数值是 "default"</span></span><br></pre></td></tr></table></figure>

<h2 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h2><ol>
<li><p>单词不一样。</p>
<p>方法的英文是method，函数的英文是Function。</p>
</li>
<li><p>位置不一样。</p>
<p>写在外面（直接写在<code>&lt;script&gt;</code>标签里面的）的叫函数，比如这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   function abc()&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>写在类里面的叫方法，因为方法和某个实例或对象是绑定的。比如这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">   &#x2F;&#x2F;写在Person里面的叫方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><strong>高阶函数</strong></h2><p>接收函数作为参数或者返回函数的函数，都可成为高阶函数。所以常见的方法有：map,filter,bind,apply等。</p>
<h2 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h2><p><code>arguments</code>对象是所有（非箭头）函数中都可用的<strong>局部变量</strong></p>
<p>　　拥有四个属性（按照规范来说只有三个了—-caller）</p>
<ul>
<li>　　arguments.callee—指向<strong>当前执行</strong>的函数</li>
<li>　　agruments.caller—-指向调用<strong>当前函数的函数 （已移除）</strong></li>
<li>　　arguments.length—指向传递给<strong>当前函数</strong>的参数数量</li>
<li>　　arguments.arguments— 返回一个新的Array迭代器对象，该对象包含参数中每个索引的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func(...args)&#123;</span><br><span class="line">    return args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(1,2,3)   &#x2F;&#x2F; [1,2,3]</span><br><span class="line"></span><br><span class="line">&#x2F;* --------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">function func(a) &#123; </span><br><span class="line">  arguments[0] &#x3D; 99;   &#x2F;&#x2F; 更新了arguments[0] 同样更新了a</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">func(10); &#x2F;&#x2F; 99</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;use strict&quot; </span><br><span class="line">func(10); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">&#x2F;* --------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">function func(a) &#123; </span><br><span class="line">  a &#x3D; 99;              &#x2F;&#x2F; 更新了a 同样更新了arguments[0] </span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">func(10); &#x2F;&#x2F; 99</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot; </span><br><span class="line">func(10); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">&#x2F;* --------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">function func(a &#x3D; 55) &#123; </span><br><span class="line">  arguments[0] &#x3D; 99; &#x2F;&#x2F;  更新了arguments[0]不会更新a</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">func(10); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">&#x2F;* --------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">function func(a &#x3D; 55) &#123; </span><br><span class="line">  a &#x3D; 99; &#x2F;&#x2F; 更新了a不会更新arguments[0]</span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">func(10); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">不在严格模式下，arguments[0]改变，会使相对应的形参也发生改变，</span><br><span class="line">修改形参，arguments[0]也会相应被修改</span><br><span class="line">而在严格模式和有形参的情况下则不会被修改</span><br></pre></td></tr></table></figure>



<h2 id="按位或运算符可以这样写："><a href="#按位或运算符可以这样写：" class="headerlink" title="按位或运算符可以这样写："></a>按位或运算符可以这样写：</h2><p>如果希望将浮点数转换为整数，可以使用<code>Math.floor()</code>、<code>Math.ceil()</code>或<code>Math.round()</code>。但是还有一种更快的方法可以使用|(位或运算符)将浮点数截断为整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(23.9 | 0);  </span><br><span class="line">&#x2F;&#x2F; Result: 23</span><br><span class="line">console.log(-23.9 | 0);</span><br><span class="line">&#x2F;&#x2F; Result: -23</span><br><span class="line"></span><br><span class="line">console.log(1553&#x2F;10 | 0)  </span><br><span class="line">&#x2F;&#x2F; Result: 155</span><br><span class="line">console.log(1553&#x2F;100 | 0)  </span><br><span class="line">&#x2F;&#x2F; Result: 15</span><br><span class="line">console.log(1553&#x2F;1000 | 0)  </span><br><span class="line">&#x2F;&#x2F; Result: 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>mdIntro</title>
    <url>/2020/07/15/mdIntro/</url>
    <content><![CDATA[<p><strong>Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。</strong></p>
<h4 id="智能标点"><a href="#智能标点" class="headerlink" title="智能标点"></a>智能标点</h4><p>我认为「智能标点」是比较有趣的一点。它可以自动帮你将不是很美观的直引号 <code>&quot;</code> <code>&#39;</code> 转化为更美观的弯引号 <code>“</code> <code>‘</code> <code>’</code> <code>”</code>。具体内容你可以在官方的 <a href="http://support.typora.io/SmartyPants/" target="_blank" rel="noopener">这篇文档</a> 中查看。关于直弯引号在 macOS 上如何输入你也可以看 <a href="https://sspai.com/post/38342" target="_blank" rel="noopener">这篇文章</a>。</p>
<hr>
<a id="more"></a>

<h4 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h4><p>Typora 支持在拖动或 <code>Ctrl + V</code> 网络图片后自动将其保存到本地。你可以在 <code>文件 - 偏好设置 - 编辑器 - 图片插入</code> 中选择复制到哪个路径，什么情况下需要复制。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/717da653ad91e938c5f1f40555b9c057.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img">图片插入</p>
<p>这一功能保证了即使网络图片源失效了，你还有本地的备份可用。同时也能使你的文档文件夹更合理、完整。</p>
<hr>
<h4 id="打字机模式和专注模式"><a href="#打字机模式和专注模式" class="headerlink" title="打字机模式和专注模式"></a>打字机模式和专注模式</h4><p><strong>「打字机模式」</strong>使得你所编辑的那一行永远处于屏幕正中。</p>
<p><strong>「专注模式」</strong>使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。</p>
<p>你可以在 <code>视图 - 专注模式 / 打字机模式</code> 中勾选使用这两个模式。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/8b4e14ef732a23d4cc2a8fb1f8ec016c.gif" alt="img"></p>
<p>为了防止一些程序 bug 的发生（虽然在我使用下来感到是很少的）导致格式问题无法修改，Typora 保留了一个<strong>「源代码模式」</strong>。你可以通过 <code>视图 - 源代码模式</code> 或左下角的 <code>&lt;/&gt;</code> 按钮进入。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/bcda9c4e35725b7297a6b90d8745564e.gif" alt="img"></p>
<hr>
<h4 id="空格与换行"><a href="#空格与换行" class="headerlink" title="空格与换行"></a>空格与换行</h4><p>Typora 在空格与换行部分主要是使用 <a href="http://www.commonmark.cn/w/" target="_blank" rel="noopener">CommonMark</a> 作为标注规范。与前文提到的 GFM 一样，CommonMark 也是比较流行的 Markdown 语言规范（解析器）之一。</p>
<ul>
<li><strong>空格：</strong>在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。<br>你可以在源代码模式下，为每个空格前加一个 <code>\</code> 转义符，或者直接使用 HTML 风格的 <code>&amp;nbps;</code> 来保持连续的空格。</li>
<li><strong>软换行：</strong>需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 <code>Shift + Enter</code> 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。</li>
<li><strong>硬换行：</strong>你可以通过 <code>空格 + 空格 + Shift + Enter</code> 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。</li>
<li><strong>换段：</strong>你可以通过 <code>Enter</code> 完成一次换段。Typora 会自动帮你完成两次 <code>Shift + Enter</code> 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。</li>
<li><strong>Windows 风格（CR+LF）与 Unix 风格（CR）的换行符：</strong>CR 表示回车 <code>\r</code> ，即回到一行的开头，而 LF 表示换行 <code>\n</code> ，即另起一行。<br>所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 你可以在 <code>文件 - 偏好设置 - 编辑器 - 默认换行符</code> 中对此进行切换。</li>
</ul>
<p>下附以上各空格、换行、换段的测试结果图。具体内容你可以在官网的 <a href="http://support.typora.io/Line-Break/" target="_blank" rel="noopener">这篇文档</a> 中查阅。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/5c2fbaa53b27666a7fd0b07ac3e100bf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<hr>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>除了前文提到的文件侧边栏，Typora 还提供了一些耦合度不高的文件系统。</p>
<ul>
<li><strong>快速打开：</strong>你可以通过 <code>文件 - 快速打开...</code> 或 <code>Ctrl + P</code> 快捷键快速打开最近的文档。</li>
<li><strong>保存：</strong>Typora 支持自动保存，一般很少有写好的文档丢失的情况。同时它也提供了诸如「保存」、「另存为」、「保存全部打开的文件…」之类的功能。</li>
<li><strong>导入：</strong>Typora 支持非常多的文件格式：.docx, .latex, .tex, .ltx, .rst, .rest, .org, .wiki, .dokuwiki, .textile, .opml, .epub。</li>
<li><strong>导出：</strong>Typora 原生支持导出 PDF，HTML等格式。你可以根据软件内提示安装 <strong>Pandoc 插件</strong>来导出更多例如 docx，LaTeX 等格式。 </li>
</ul>
<p><img src="https://cdn.sspai.com/2019/05/24/ba295f21f0b71646bb36a0517e868ced.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img">导出</p>
<hr>
<h2 id="一个伪装成文本编辑器的浏览器"><a href="#一个伪装成文本编辑器的浏览器" class="headerlink" title="一个伪装成文本编辑器的浏览器"></a>一个伪装成文本编辑器的浏览器</h2><p>当我的一个朋友问我「Typora 有什么好写的？」时，我回答「Typora 是一个伪装成文本编辑器的浏览器」。是的，事实上如果你有一定的计算机基础，你可以找到许多有关于「Typora 其实是一个浏览器」的蛛丝马迹。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/13837bcdcded9ae406e8c4aac5f2d752.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img">图片插入</p>
<p>在图片插入的选项中，Typora 用了「复制图片到 ./${filename}.assets 文件夹」的说法，而这其实是网页前端常用的 Javascript 字符串模板语法的风格。</p>
<p>再比如，Typora 将更遵循 GFM 标准的 Markdown 语法模式称为「严格模式 Strict Mode」，这一说法常见于 HTML 和 JavaScript 编程中。类似「源代码模式」的说法也是同理。</p>
<p>当然，最明显的一点是当你按下 <code>Shift + F12</code> 快捷键时，页面会弹出一个基于 Chrome 的开发者工具栏，也就是我们在浏览器中常说的「审查元素」。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/da8c9b305a222cb5fadb41c12da81a12.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<hr>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>为了让文档更美观，我们可以为其加上 CSS style。我认为 Typora 对 CSS 的支持让它成为一众桌面笔记应用中最与众不同的一个。在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。你可以在 <code>文件 - 偏好设置 - 主题 - 打开主题文件夹</code> 看到这些 CSS 文件。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/7d3cfbc92721733e16ed63d72a48a572.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<hr>
<p>除此以外，如果你有一定的 Web 编程基础，你当然也可以自己修改、新建适合你使用需求的 CSS 文件。我自己就写了一份名为 WeChat 的 CSS 文件，来符合我公众号特定的排版需求，例如正文是 15px，页边距是 8，小标题是 18px 等等。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/317ac1df25fcfc817c03f92d6086764e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>使用 Typora 的「主题」功能写公众号的一个好处是，只需要每次都套用同样的主题，我们就可以在保证每次排版规范都相同的同时，节省许多重复的工作。</p>
<hr>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><img src="https://cdn.sspai.com/2019/05/24/98a04c4f9129e0f018d15bc790b376c2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>选择不同的主题可以使文档拥有不同的外观，但不会影响内容。Typora 自带了若干主题，你也可以在 <a href="http://theme.typora.io/" target="_blank" rel="noopener">官网</a> 下载更多的主题。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/efcf65ba993c4bb0b058d6eb8258df6f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<hr>
<h3 id="YAML-front-matter"><a href="#YAML-front-matter" class="headerlink" title="YAML front-matter"></a>YAML front-matter</h3><p>Typora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。</p>
<p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2013&#x2F;7&#x2F;13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure>


<p>参考文档：<a href="https://sspai.com/post/54912" target="_blank" rel="noopener">typora</a></p>
]]></content>
      <categories>
        <category>mysoft</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>mock语法</title>
    <url>/2020/07/30/mock%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="设置迟延时间"><a href="#设置迟延时间" class="headerlink" title="设置迟延时间"></a>设置迟延时间</h2><p>我们可以使用 Mock.setup 来设置模拟数据时的延迟时间，单位：毫秒。可以设置一个固定的时间，也可以使用-设置一个时间段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 延迟4秒</span><br><span class="line">Mock.setup(&#123;</span><br><span class="line">    timeout: 4000</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 延迟3~9秒</span><br><span class="line">Mock.setup(&#123;</span><br><span class="line">    timeout: &#39;3000-9000&#39;</span><br><span class="line">&#125;)</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="模拟数据"><a href="#模拟数据" class="headerlink" title="模拟数据"></a>模拟数据</h2><p>可以使用 Mock.mock 生成模拟数据。</p>
<ol>
<li>直接生成模拟数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mock.mock(模板|function)</span><br></pre></td></tr></table></figure>

<ol>
<li>为接口地址模拟数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mock.mock(url,模板|function)</span><br></pre></td></tr></table></figure>

<ol>
<li>为接口以及请求方式模拟数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mock.mock(url,type,模板|function)</span><br></pre></td></tr></table></figure>

<p>说明：url也可以是一个字符串也可以是一个正则。</p>
<p><img src="https://img-blog.csdnimg.cn/20181122001426963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>模拟数据时要根据模板来模拟，模板是一个对象类型的值，格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;名称|规则&#39;:&#39;值&#39;</span><br></pre></td></tr></table></figure>

<p>名称：模拟的数据的名字。<br>值：模拟的数据的值。<br>规则：模拟出数据的规则，常用的几个规则：</p>
<ol>
<li>min-max：生成的范围</li>
<li>count：生成的数量</li>
<li>+step：递增step<br><img src="https://img-blog.csdnimg.cn/2018112200152730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>如果值是一个数组，规则代表数组中元素的个数：</p>
<p><img src="https://img-blog.csdnimg.cn/20181122001606812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果希望生成的ID自增可以使用+1</p>
<p><img src="https://img-blog.csdnimg.cn/20181122001616852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="生成随机数据"><a href="#生成随机数据" class="headerlink" title="生成随机数据"></a>生成随机数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们一般在模拟数据时都希望生成一些随机的数据，mock中内置了很多种不同类型的随机数据，我们可以使用它们生成各种类型的随机数据：</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Type</th>
<th>Method</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>boolean, natural, integer, float, character, string, range, date, time, datetime, now</td>
</tr>
<tr>
<td>图片</td>
<td>image, dataImage</td>
</tr>
<tr>
<td>颜色</td>
<td>color</td>
</tr>
<tr>
<td>文本</td>
<td>paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle</td>
</tr>
<tr>
<td>姓名</td>
<td>first, last, name, cfirst, clast, cname</td>
</tr>
<tr>
<td>网站</td>
<td>url, domain, email, ip, tld</td>
</tr>
<tr>
<td>地址</td>
<td>area, region</td>
</tr>
<tr>
<td>编号</td>
<td>guid, id</td>
</tr>
</tbody></table>
<p>使用时我们只需要把值设置成 <strong>@方法名</strong> 即可，比如，生成一个随机的 Email：</p>
<p><img src="https://img-blog.csdnimg.cn/2018112200163380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="生成boolean"><a href="#生成boolean" class="headerlink" title="生成boolean"></a>生成boolean</h1><p>@boolean</p>
<h1 id="生成数字"><a href="#生成数字" class="headerlink" title="生成数字"></a>生成数字</h1><h2 id="自然数-gt-0整数"><a href="#自然数-gt-0整数" class="headerlink" title="自然数(&gt;=0整数)"></a>自然数(&gt;=0整数)</h2><p>@natural<br>@natural(min,max)</p>
<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>@integer<br>@integer(min,max)</p>
<h2 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h2><p>@float<br>@float(min,max,dmin,dmax)<br>dmin：小数部分位数最小值<br>dmax：小数部分位数最大值</p>
<h2 id="整数整组"><a href="#整数整组" class="headerlink" title="整数整组"></a>整数整组</h2><p>@range(min,max)<br>@range(min,max,step)<br> step：递增的步长</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@range(10)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">@range(3, 7)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; [3, 4, 5, 6]</span><br><span class="line">@range(1, 10, 2)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; [1, 3, 5, 7, 9]</span><br><span class="line">@range(1, 10, 3)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; [1, 4, 7]</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<h1 id="生成文本"><a href="#生成文本" class="headerlink" title="生成文本"></a>生成文本</h1><h2 id="单个字符"><a href="#单个字符" class="headerlink" title="单个字符"></a>单个字符</h2><p>@character<br>@character(‘lower/upper/number/symbol’)<br>@character(pool)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果传入了 &#96;&#39;lower&#39;&#96; 或 &#96;&#39;upper&#39;&#96;、&#96;&#39;number&#39;&#96;、&#96;&#39;symbol&#39;&#96;，表示从内置的字符池中选取一个字符：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    lower: &quot;abcdefghijklmnopqrstuvwxyz&quot;,</span><br><span class="line">    upper: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,</span><br><span class="line">    number: &quot;0123456789&quot;,</span><br><span class="line">    symbol: &quot;!@#$%^&amp;*()[]&quot;</span><br><span class="line">&#125;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>@string<br>@string(length)<br>@string(min,max)</p>
<h2 id="英文单词"><a href="#英文单词" class="headerlink" title="英文单词"></a>英文单词</h2><p>@word<br>@word(length)<br>@word(min,max)</p>
<h2 id="英文句子"><a href="#英文句子" class="headerlink" title="英文句子"></a>英文句子</h2><p>@sentence<br>@sentence(len)<br>@sentence(min,max)</p>
<h2 id="英文段落"><a href="#英文段落" class="headerlink" title="英文段落"></a>英文段落</h2><p>@paragraph<br>@paragraph(len)<br>@paragraph(min,max)</p>
<h2 id="中文汉字"><a href="#中文汉字" class="headerlink" title="中文汉字"></a>中文汉字</h2><p>@cword<br>@cword(pool)<br>@cword(len)<br>@cword(pool,len)<br>@cword(min,max)<br>@cword(pool,min,max)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@cword()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;干&quot;</span><br><span class="line">@cword(&#39;零一二三四五六七八九十&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;六&quot;</span><br><span class="line">@cword(3)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;别金提&quot;</span><br><span class="line">@cword(&#39;零一二三四五六七八九十&#39;, 3)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;&quot;七七七&quot;&quot;</span><br><span class="line">@cword(5, 7)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;设过证全争听&quot;</span><br><span class="line">@cword(&#39;零一二三四五六七八九十&#39;, 5, 7)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;九七七零四&quot;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<h2 id="中文句子"><a href="#中文句子" class="headerlink" title="中文句子"></a>中文句子</h2><p>@csentence<br>@csentence(len)<br>@csentence(min,max)</p>
<h2 id="中文段落"><a href="#中文段落" class="headerlink" title="中文段落"></a>中文段落</h2><p>@cparagraph<br>@cparagraph(len)<br>@cparagraph(min,max)</p>
<h2 id="中文标题"><a href="#中文标题" class="headerlink" title="中文标题"></a>中文标题</h2><p>@ctitle<br>@ctitle(len)<br>@ctitle(min,max)</p>
<h1 id="生成名字"><a href="#生成名字" class="headerlink" title="生成名字"></a>生成名字</h1><h2 id="英文名"><a href="#英文名" class="headerlink" title="英文名"></a>英文名</h2><p>@first<br>名<br>@last<br> 姓<br>@name<br> 姓名<br>@name(middle)<br> middle：是否生成中间名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@name()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;Larry Wilson&quot;</span><br><span class="line">@name(true)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;Helen Carol Martinez&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h2 id="中文名"><a href="#中文名" class="headerlink" title="中文名"></a>中文名</h2><p>@cfirst<br> 姓<br>@clast<br> 名<br>@cname<br> 姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@cname()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;袁军&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><h2 id="生成一个IP"><a href="#生成一个IP" class="headerlink" title="生成一个IP"></a>生成一个IP</h2><p>@ip</p>
<h2 id="生成一个Email"><a href="#生成一个Email" class="headerlink" title="生成一个Email"></a>生成一个Email</h2><p>@email<br>@email(domain)<br> domain：指定域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@email()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;x.davis@jackson.edu&quot;</span><br><span class="line">@email(&#39;nuysoft.com&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;h.pqpneix@nuysoft.com&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h2 id="生成域名"><a href="#生成域名" class="headerlink" title="生成域名"></a>生成域名</h2><p>@domain</p>
<h2 id="生成URL"><a href="#生成URL" class="headerlink" title="生成URL"></a>生成URL</h2><p>@url<br>@url(protocol,host)<br> protocol：指定协议，例如HTTP<br> host：指定域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@url()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;mid:&#x2F;&#x2F;axmg.bg&#x2F;bhyq&quot;</span><br><span class="line">@url(&#39;http&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;splap.yu&#x2F;qxzkyoubp&quot;</span><br><span class="line">@url(&#39;http&#39;, &#39;nuysoft.com&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;nuysoft.com&#x2F;ewacecjhe&quot;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h1 id="生成时间"><a href="#生成时间" class="headerlink" title="生成时间"></a>生成时间</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>@date<br>@time<br>@datetime</p>
<h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><p>可以通过 format 参数设置时间的格式</p>
<p>@date(format)<br>@time(format)<br>@datetime(format)</p>
<table>
<thead>
<tr>
<th>Format</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>yyyy</td>
<td>A full numeric representation of a year, 4 digits</td>
<td>1999 or 2003</td>
</tr>
<tr>
<td>yy</td>
<td>A two digit representation of a year</td>
<td>99 or 03</td>
</tr>
<tr>
<td>y</td>
<td>A two digit representation of a year</td>
<td>99 or 03</td>
</tr>
<tr>
<td>MM</td>
<td>Numeric representation of a month, with leading zeros</td>
<td>01 to 12</td>
</tr>
<tr>
<td>M</td>
<td>Numeric representation of a month, without leading zeros</td>
<td>1 to 12</td>
</tr>
<tr>
<td>dd</td>
<td>Day of the month, 2 digits with leading zeros</td>
<td>01 to 31</td>
</tr>
<tr>
<td>d</td>
<td>Day of the month without leading zeros</td>
<td>1 to 31</td>
</tr>
<tr>
<td>HH</td>
<td>24-hour format of an hour with leading zeros</td>
<td>00 to 23</td>
</tr>
<tr>
<td>H</td>
<td>24-hour format of an hour without leading zeros</td>
<td>0 to 23</td>
</tr>
<tr>
<td>hh</td>
<td>12-hour format of an hour without leading zeros</td>
<td>1 to 12</td>
</tr>
<tr>
<td>h</td>
<td>12-hour format of an hour with leading zeros</td>
<td>01 to 12</td>
</tr>
<tr>
<td>mm</td>
<td>Minutes, with leading zeros</td>
<td>00 to 59</td>
</tr>
<tr>
<td>m</td>
<td>Minutes, without leading zeros</td>
<td>0 to 59</td>
</tr>
<tr>
<td>ss</td>
<td>Seconds, with leading zeros</td>
<td>00 to 59</td>
</tr>
<tr>
<td>s</td>
<td>Seconds, without leading zeros</td>
<td>0 to 59</td>
</tr>
<tr>
<td>SS</td>
<td>Milliseconds, with leading zeros</td>
<td>000 to 999</td>
</tr>
<tr>
<td>S</td>
<td>Milliseconds, without leading zeros</td>
<td>0 to 999</td>
</tr>
<tr>
<td>A</td>
<td>Uppercase Ante meridiem and Post meridiem</td>
<td>AM or PM</td>
</tr>
<tr>
<td>a</td>
<td>Lowercase Ante meridiem and Post meridiem</td>
<td>am or pm</td>
</tr>
<tr>
<td>T</td>
<td>Milliseconds, since 1970-1-1 00:00:00 UTC</td>
<td>759883437303</td>
</tr>
</tbody></table>
<h1 id="生成地址"><a href="#生成地址" class="headerlink" title="生成地址"></a>生成地址</h1><h2 id="生成中国大区"><a href="#生成中国大区" class="headerlink" title="生成中国大区"></a>生成中国大区</h2><p>@region</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@region()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;华北&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h2 id="生成省份"><a href="#生成省份" class="headerlink" title="生成省份"></a>生成省份</h2><p>@province</p>
<h2 id="生成城市"><a href="#生成城市" class="headerlink" title="生成城市"></a>生成城市</h2><p>@city<br>@city(prefix)<br> prefix：布尔值，是否生成所属的省</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@city()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;唐山市&quot;</span><br><span class="line">@city(true)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;福建省 漳州市&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h2 id="生成县"><a href="#生成县" class="headerlink" title="生成县"></a>生成县</h2><p>@county<br>@county(prefix)<br> prefix：布尔值，是否生成所属省、市</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@county()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;上杭县&quot;</span><br><span class="line">@county(true)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;甘肃省 白银市 会宁县&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<h2 id="生成邮政编码"><a href="#生成邮政编码" class="headerlink" title="生成邮政编码"></a>生成邮政编码</h2><p>@zip</p>
<h1 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h1><h2 id="身份证"><a href="#身份证" class="headerlink" title="身份证"></a>身份证</h2><p>@ID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@id()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;420000200710091854&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h2 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h2><p>@guid</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@guid()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;662C63B4-FD43-66F4-3328-C54E3FF0D56E&quot;</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h1 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h1><h2 id="图片URL"><a href="#图片URL" class="headerlink" title="图片URL"></a>图片URL</h2><p>@image()<br>@image( size )<br>@image( size, background )<br>@image( size, background, text )<br>@image( size, background, foreground, text )<br>@image( size, background, foreground, format, text )<br> size：尺寸，格式为：‘宽x高’<br> background：背景色，格式为：#FFFFFF<br> text：图片上显示的文本<br> foreground：广本颜色<br> format：图片格式，可选值包括：png、gif、jpg。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@image()</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;125x125&quot;</span><br><span class="line">@image(&#39;200x100&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&quot;</span><br><span class="line">@image(&#39;200x100&#39;, &#39;#fb0a2a&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&#x2F;fb0a2a&quot;</span><br><span class="line">@image(&#39;200x100&#39;, &#39;#02adea&#39;, &#39;Hello&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&#x2F;02adea&amp;text&#x3D;Hello&quot;</span><br><span class="line">@image(&#39;200x100&#39;, &#39;#00405d&#39;, &#39;#FFF&#39;, &#39;Mock.js&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&#x2F;00405d&#x2F;FFF&amp;text&#x3D;Mock.js&quot;</span><br><span class="line">@image(&#39;200x100&#39;, &#39;#ffcc33&#39;, &#39;#FFF&#39;, &#39;png&#39;, &#39;!&#39;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;http:&#x2F;&#x2F;dummyimage.com&#x2F;200x100&#x2F;ffcc33&#x2F;FFF.png&amp;text&#x3D;!&quot;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<h2 id="Base64图片编码"><a href="#Base64图片编码" class="headerlink" title="Base64图片编码"></a>Base64图片编码</h2><p>@dataImage<br>@dataImage(size)<br>@dataImage(size,text)</p>
<h1 id="生成颜色"><a href="#生成颜色" class="headerlink" title="生成颜色"></a>生成颜色</h1><p>@color<br>@hex<br>@rgb<br>@rgba<br>@hsl<br><img src="https://img-blog.csdnimg.cn/20181122001849623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwMTAxNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>mock</tag>
        <tag>mock语法</tag>
      </tags>
  </entry>
  <entry>
    <title>mdUse</title>
    <url>/2020/07/14/mdUse/</url>
    <content><![CDATA[<h3 id="标题-号越多字越小"><a href="#标题-号越多字越小" class="headerlink" title="标题(#号越多字越小)"></a>标题(#号越多字越小)</h3><p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/620e64aa6522f5eaeb788a8b5f1faa5c10f74_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<hr>
<a id="more"></a>

<h3 id="列表（无序用‘-’有序用‘1-’）"><a href="#列表（无序用‘-’有序用‘1-’）" class="headerlink" title="列表（无序用‘*/-/+’有序用‘1.’）"></a>列表（无序用‘*/-/+’有序用‘1.’）</h3><p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/a72338b96cf4bfc1dacd610756786ae310f75_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<hr>
<h3 id="引用一小段别处的句子-使用’-gt-’"><a href="#引用一小段别处的句子-使用’-gt-’" class="headerlink" title="引用一小段别处的句子(使用’&gt;’)"></a>引用一小段别处的句子(使用’&gt;’)</h3><blockquote>
<p>引用一小段别处的句子</p>
</blockquote>
<blockquote>
<p>一级</p>
<blockquote>
<p>二级</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>三级</p>
</blockquote>
</blockquote>
</blockquote>
<p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/07bd8bf6fd38ea7d3bffdc3cae04f6f210f76_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<hr>
<h3 id="图片与链接-区别在于有无’-’"><a href="#图片与链接-区别在于有无’-’" class="headerlink" title="图片与链接(区别在于有无’!’)"></a>图片与链接(区别在于有无’!’)</h3><p>备注：插入图片的地址需要图床，这里推荐 CloudApp 的服务，生成URL地址即可。</p>
<p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/f96c892fc63933ab186235f7c910753b10f77_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<hr>
<h3 id="粗体与斜体与删除-左右两个-‘-’-左右一个-‘-’-左右两个‘-’"><a href="#粗体与斜体与删除-左右两个-‘-’-左右一个-‘-’-左右两个‘-’" class="headerlink" title="粗体与斜体与删除(左右两个 ‘*’ /左右一个 ‘ *’/左右两个‘~~’)"></a>粗体与斜体与删除(左右两个 ‘*’ /左右一个 ‘ *’/左右两个‘~~’)</h3><blockquote>
<p><strong>我加粗了</strong>  <em>我是斜体</em>    <del>删除</del></p>
</blockquote>
<hr>
<h3 id="代码框（用’-’包裹）"><a href="#代码框（用’-’包裹）" class="headerlink" title="代码框（用’`’包裹）"></a>代码框（用’`’包裹）</h3><p><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/0135456d6a3c1051f0ed54e37cef070010f78_mw_800_wm_1_wmp_3.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意java前面有空格</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="分割线（三个‘-’）"><a href="#分割线（三个‘-’）" class="headerlink" title="分割线（三个‘***’）"></a>分割线（三个‘***’）</h3><hr>
<h3 id="表格-默认左对齐"><a href="#表格-默认左对齐" class="headerlink" title="表格(默认左对齐)"></a>表格(默认左对齐)</h3><table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<hr>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>你可以在需要插入脚注标号的位置写 <code>[^ number ]</code> ，再在下方通过 <code>[^ number ]:</code> 在文档中插入脚注。注意不要遗漏了脚注编号 <code>number</code> 前后的空格。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/5f82606e6d89fe1eb24705c4ca6b895d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>这里是脚注<a href="https://www.baidu.com" target="_blank" rel="noopener">^1</a></p>
<hr>
<h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><p>在 Typora 中，你可以用 <code>:emoji:</code> 的形式来打出 emoji，软件会自动给出图形的提示，还是比较好用的。</p>
<p><img src="https://cdn.sspai.com/2019/05/24/ff26eeb5ff2d6fae16cab163ebfcd096.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>:horse:</p>
<hr>
<h3 id="常用弥补Markdown的Html标签"><a href="#常用弥补Markdown的Html标签" class="headerlink" title="常用弥补Markdown的Html标签"></a>常用弥补Markdown的Html标签</h3><p><span style="color:red">This is red</span></p>
<p align="left">居左文本</p>
<p align="center">居中文本</p> 
<p align="right">居右文本</p>

<p>换行<br></p>
<p>换行后</p>
<p><u>我是下划线<u></u></u></p>
<hr>
<h3 id="打开全局搜索"><a href="#打开全局搜索" class="headerlink" title="打开全局搜索"></a>打开全局搜索</h3><p>ctrl+shift+F</p>
<h3 id="几款主流好用的markdown编辑器介绍"><a href="#几款主流好用的markdown编辑器介绍" class="headerlink" title="几款主流好用的markdown编辑器介绍"></a>几款主流好用的markdown编辑器介绍</h3><ol>
<li><p>Mou</p>
<p> Mou 是一款由国人开发的Markdown 编辑器，支持实时预览，但是仅支持 苹果操作系统，可以说是目前最好用的免费 Markdown 编辑器，对汉字兼容性非常好。提供语法高亮、在线预览、同步滚动、全屏模式，支持自定保存、自动匹配，允许自定义主题等等。支持 CSS，HTML 和 PDF 导出等功能。</p>
<p>   　Mou是独立的软件。</p>
<p>   　更多介绍及下载：<a href="http://25.io/mou/" target="_blank" rel="noopener">http://25.io/mou/</a></p>
</li>
<li><p>MarkdownPad</p>
<p> MarkdownPad被很多人称赞为windows下最好用的Markdown编辑器之一，不过仅支持windows。它有免费版和收费版（MarkdownPad Pro），一般情况下免费版就够用了，想用pro版的可以自行网上下载，强大的国人crack无处不在的~ ~。</p>
<p>   　MarkdownPad支持键盘快捷键和工具栏操作，即可添加标记也可移除，支持即时HTML预览、支持自定义配色方案、字体、大小和布局、支持音乐视频，可以导出HTML和PDF。</p>
<p>   　MarkdownPad是独立的软件。</p>
<p>   　更多介绍及下载：<a href="http://markdownpad.com/" target="_blank" rel="noopener">http://markdownpad.com/</a></p>
</li>
<li><p>Typora (本文就是用的这个软件哦)</p>
<p> Typora也是非常用名，非常好用的markdown编辑器，它的设计理念很不一样，是真正的即时预览型编辑器，不同于左右两个窗口的编辑器。Typora的设计理念就是极致简洁，它将「写字」和「预览」这两件事情合并了。</p>
<p>   　如果要修改已经写好的markdown标记可以点击切换到“源代码模式”。</p>
<p>   　Typora 同样支持 Windows、OS X 和 Linux多个操作系统，支持数学编辑，可与 Word 直接格式转换，可以进行多种文档格式转换。Typora 流畅度和反应速度很快，特别适合那些手速快的人。</p>
<p>   　Typora是独立的软件。</p>
<p>   　更多介绍及下载：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p>
</li>
<li><p>Atom</p>
<p> Atom 可以说是专门为程序员推出的一个文本编辑器，界面简洁，支持实时预览。功能非常多，除了Markdown同时支持CSS，HTML，JavaScript等网页编程语言，还支持宏定义，自动分屏功能等。Atom还具有语义输入模式，比例输入code即会自动开启代码模式。</p>
<p>   　Atom支持windows、苹果、linux等多种操作系统。Atom是由著名的github平台出品的。</p>
<p>   　Atom是独立的软件，也支持插件方式。</p>
<p>   　更多介绍及下载：<a href="https://atom.io/" target="_blank" rel="noopener">https://atom.io/</a></p>
</li>
<li><p>Haroopad</p>
<p> Haroopad也是一款非常流行的编辑器，来自韩国。Haroopad支持 Windows、Mac OS X 和 Linux三大操作系统。Haroopad的特色是主题样式丰富，语法高亮支持无数种编程语言，几乎你能想到的编程语言他都支持。Ubuntu/Linux 用户使用该工具比例很高，Haroopad 也是开源免费的。Haroopad也支持导出HTML、PDF，也支持数学公式和流程图。</p>
<p>   　Haroopad是独立的软件。</p>
<p>   　更多介绍及下载：<a href="http://pad.haroopress.com/user.html" target="_blank" rel="noopener">http://pad.haroopress.com/user.html</a></p>
</li>
</ol>
<p>参考文档：<a href="https://sspai.com/post/54912" target="_blank" rel="noopener">typora</a></p>
]]></content>
      <categories>
        <category>mysoft</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>momentJs</title>
    <url>/2020/07/30/momentJs/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>UTC、GMT、时间戳之间的关系</p>
<p>时区</p>
<p>世界时区的划分以本初子午线为标准，向东12个时区，向西12个时区，子午线所在区为0时区，东十二区和西十二区重合，所以一共是24个时区。</p>
</li>
<li><p>GMT和UTC</p>
<p>GMT： 即格林威治时间（Greenwich Mean Time），也是0时区的标准时间。指太阳横穿格林威治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致GMT不精确，现在已经不再作为世界标准时间使用。</p>
<p>UTC： 即协调世界时间（Coordinated Universal Time）。UTC是以原子时秒长为基础，在时刻上尽量接近于GMT的一种时间计量系统。UTC现在作为世界标准时间使用。</p>
<p>所以，UTC与GMT基本上等同，误差不超过0.9秒。</p>
</li>
<li><p>时间戳</p>
<p>UNIX时间戳：是从UTC时间1970年1月1日起到现在的秒数，不考虑闰秒，一天有86400秒，它是和时区无关的，无论在地球上的那个角落，同一时刻，UNIX时间戳都是一样的，计算机的本地时间就是根据 Unix时间戳 + 时区差 转换而来的。</p>
</li>
<li><p>本地时间</p>
<p>本地时间 = UTC + 时区差</p>
<p>时区差：东为正，西为负。在此，把东八区时区差记为 +0800， UTC 是标准时间参照，GMT（格林威治时间）、CST（北京时间）、PST（太平洋时间）等等是具体的时区，兑换如下：</p>
<p>GMT: UTC +0    =    GMT: GMT +0CST: UTC +8    =    CST: GMT +8PST: UTC -8    =    PST: GMT -8</p>
</li>
</ul>
<a id="more"></a>

<h3 id="Moment安装与挂载"><a href="#Moment安装与挂载" class="headerlink" title="Moment安装与挂载"></a>Moment安装与挂载</h3><p>安装webpack</p>
<p>npm install moment</p>
<p>main.js 挂载</p>
<p>import moment from ‘moment’//导入文件</p>
<p>Vue.prototype.$moment = moment;//赋值使用</p>
<p>国际化，设置为简体中文，中文的星期是以星期一开始</p>
<p>moment.locale(“zh-cn”);</p>
<p>常用使用方法</p>
<h3 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h3><ul>
<li>Start of Time</li>
</ul>
<p>moment().startOf(String)</p>
<ul>
<li><ul>
<li>获取今天0时0分0秒</li>
</ul>
</li>
</ul>
<p>moment().startOf(‘day’)</p>
<ul>
<li><ul>
<li>获取本周第一天(周日)0时0分0秒</li>
</ul>
</li>
</ul>
<p>moment().startOf(‘week’)</p>
<ul>
<li><ul>
<li>获取本周周一0时0分0秒</li>
</ul>
</li>
</ul>
<p>moment().startOf(‘isoWeek’)</p>
<ul>
<li><ul>
<li>获取当前月第一天0时0分0秒</li>
</ul>
</li>
</ul>
<p>moment().startOf(‘month’)</p>
<ul>
<li>End of Time</li>
</ul>
<p>moment().endOf(String)</p>
<ul>
<li><ul>
<li>获取今天23时59分59秒</li>
</ul>
</li>
</ul>
<p>moment().endOf(‘day’)</p>
<ul>
<li><ul>
<li>获取本周最后一天(周六)23时59分59秒</li>
</ul>
</li>
</ul>
<p>moment().endOf(‘week’)</p>
<ul>
<li><ul>
<li>获取本周周日23时59分59秒</li>
</ul>
</li>
</ul>
<p>moment().endOf(‘isoWeek’)</p>
<ul>
<li><ul>
<li>获取当前月最后一天23时59分59秒</li>
</ul>
</li>
</ul>
<p>moment().endOf(‘month’)</p>
<ul>
<li><p>Days in Month</p>
</li>
<li><ul>
<li>获取当前月的总天数</li>
</ul>
</li>
</ul>
<p>moment().daysInMonth() </p>
<ul>
<li>Timestamp</li>
</ul>
<ul>
<li><ul>
<li>获取时间戳(以秒为单位)</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().format(‘X’) // 返回值为字符串类型</li>
<li>moment().unix() // 返回值为数值型</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取时间戳(以毫秒为单位)</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().format(‘x’) // 返回值为字符串类型</li>
<li>moment().valueOf() // 返回值为数值型</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li>Get Time</li>
</ul>
<ul>
<li><ul>
<li>获取年份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().year()</li>
<li>moment().get(‘year’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取月份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().month() (0~11, 0: January, 11: December)</li>
<li>moment().get(‘month’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取一个月中的某一天</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().date()</li>
<li>moment().get(‘date’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取一个星期中的某一天</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().day() (0~6, 0: Sunday, 6: Saturday)</li>
<li>moment().weekday() (0~6, 0: Sunday, 6: Saturday)</li>
<li>moment().isoWeekday() (1~7, 1: Monday, 7: Sunday)</li>
<li>moment().get(‘day’)</li>
<li>mment().get(‘weekday’)</li>
<li>moment().get(‘isoWeekday’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取小时</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().hours()</li>
<li>moment().get(‘hours’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取分钟</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().minutes()</li>
<li>moment().get(‘minutes’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取秒数</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().seconds()</li>
<li>moment().get(‘seconds’)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>获取当前的年月日时分秒</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().toArray() // [years, months, date, hours, minutes, seconds, milliseconds]</li>
<li>moment().toObject() // {years: xxxx, months: x, date: xx …}</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>设置时间</p>
<ul>
<li>Set Time</li>
</ul>
<ul>
<li><ol>
<li>moment().year(Number), moment().month(Number)…</li>
<li>moment().set(String, Int)</li>
<li>moment().set(Object)</li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>设置年份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().year(2019)</li>
<li>moment().set(‘year’, 2019)</li>
<li>moment().set({year: 2019})</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置月份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().month(11) (0~11, 0: January, 11: December)</li>
<li>moment().set(‘month’, 11) </li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置某个月中的某一天</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().date(15)</li>
<li>moment().set(‘date’, 15)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置某个星期中的某一天</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().weekday(0) // 设置日期为本周第一天（周日）</li>
<li>moment().isoWeekday(1) // 设置日期为本周周一</li>
<li>moment().set(‘weekday’, 0)</li>
<li>moment().set(‘isoWeekday’, 1)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置小时</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().hours(12)</li>
<li>moment().set(‘hours’, 12)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置分钟</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().minutes(30)</li>
<li>moment().set(‘minutes’, 30)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>设置秒数</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().seconds(30)</li>
<li>moment().set(‘seconds’, 30)</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li>Add Time（通过增加时间来改变原始的 moment，传入要增加的时间的键、以及要增加的数量）</li>
</ul>
<ul>
<li><ol>
<li>moment().add(Number, String)</li>
<li>moment().add(Object)</li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>增加年份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().add(1, ‘years’)</li>
<li>moment().add({years: 1})</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>增加月份</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘months’)</p>
<ul>
<li><ul>
<li>增加日期</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘days’)</p>
<ul>
<li><ul>
<li>增加星期</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘weeks’)</p>
<ul>
<li><ul>
<li>增加小时</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘hours’)</p>
<ul>
<li><ul>
<li>增加分钟</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘minutes’)</p>
<ul>
<li><ul>
<li>增加秒数</li>
</ul>
</li>
</ul>
<p>moment().add(1, ‘seconds’)</p>
<ul>
<li>Subtract Time(通过减去时间来改变原始的 moment)</li>
</ul>
<ul>
<li><ol>
<li>moment().subtract(Number, String)</li>
<li>moment().subtract(Object)</li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>减去年份</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>moment().subtract(1, ‘years’)</li>
<li>moment().subtract({years: 1})</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>减去月份</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘months’)</p>
<ul>
<li><ul>
<li>减去日期</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘days’)</p>
<ul>
<li><ul>
<li>减去星期</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘weeks’)</p>
<ul>
<li><ul>
<li>减去小时</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘hours’)</p>
<ul>
<li><ul>
<li>减去分钟</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘minutes’)</p>
<ul>
<li><ul>
<li>减去秒数</li>
</ul>
</li>
</ul>
<p>moment().subtract(1, ‘seconds’)</p>
<p>格式化时间</p>
<ul>
<li>Format Time</li>
</ul>
<ul>
<li><ol>
<li>moment().format()</li>
<li>moment().format(String)</li>
</ol>
</li>
</ul>
<ul>
<li><ul>
<li>格式化年月日： ‘xxxx年xx月xx日’</li>
</ul>
</li>
</ul>
<p>moment().format(‘YYYY年MM月DD日’)</p>
<ul>
<li><ul>
<li>格式化年月日： ‘xxxx-xx-xx’</li>
</ul>
</li>
</ul>
<p>moment().format(‘YYYY-MM-DD’)</p>
<ul>
<li><ul>
<li>格式化时分秒(24小时制)： ‘xx时xx分xx秒’</li>
</ul>
</li>
</ul>
<p>moment().format(‘HH时mm分ss秒’)</p>
<ul>
<li><ul>
<li>格式化时分秒(12小时制)：’xx:xx:xx am/pm’</li>
</ul>
</li>
</ul>
<p>moment().format(‘hh:mm:ss a’)</p>
<ul>
<li><ul>
<li>格式化时间戳(以秒为单位)</li>
</ul>
</li>
</ul>
<p>moment().format(‘X’) // 返回值为字符串类型</p>
<ul>
<li><ul>
<li>格式化时间戳(以毫秒为单位)</li>
</ul>
</li>
</ul>
<p>moment().format(‘x’) // 返回值为字符串类型</p>
<p>比较时间</p>
<ul>
<li>Difference</li>
</ul>
<p>moment().diff(Moment|String|Number|Date|Array)</p>
<ul>
<li><ul>
<li>获取两个日期之间的时间差</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ol>
<li>let start_date = moment().subtract(1, ‘weeks’)</li>
<li>let end_date = moment()</li>
<li>end_date.diff(start_date) // 返回毫秒数</li>
<li>end_date.diff(start_date, ‘months’) // 0</li>
<li>end_date.diff(start_date, ‘weeks’) // 1</li>
<li>end_date.diff(start_date, ‘days’) // 7</li>
<li>start_date.diff(end_date, ‘days’) // -7</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>将毫秒数转为时分秒</p>
<p>const msTime = 4800000;        //80分钟 </p>
<p>moment.duration(msTime).hours();       //转为小时，值为1</p>
<p>moment.duration(msTime).minutes();     //转为分钟，值为20</p>
<p>moment.duration(msTime).seconds();     //转为秒，值为0</p>
<p>转为其他单位：</p>
<p>moment.duration(msTime, ‘seconds’);        //转为秒</p>
<p>moment.duration(msTime, ‘minutes’);        //转为分</p>
<p>moment.duration(msTime, ‘hours’);          //转为小时</p>
<p>moment.duration(msTime, ‘days’);           //转为天</p>
<p>moment.duration(msTime, ‘weeks’);          //转为周</p>
<p>moment.duration(msTime, ‘months’);         //转为月</p>
<p>moment.duration(msTime, ‘years’);          //转为年</p>
<ol start="10">
<li>判断一个日期是否在两个日期之前  isBetween</li>
</ol>
<p>语法： this.moment().isBetween(moment-like, moment-like, String, String);</p>
<p>a. 不包含起始这两个日期（只有两个参数）   ==&gt;&gt; 中文网只有两个参数</p>
<p>this.moment(‘2010-10-20’).isBetween(‘2010-10-19’, ‘2010-10-25’); // true</p>
<p>this.moment(‘2010-10-19’).isBetween(‘2010-10-19’, ‘2010-10-25’); // false</p>
<p>this.moment(‘2010-10-25’).isBetween(‘2010-10-19’, ‘2010-10-25’); // false</p>
<p>b. 自定义是否包含起始日期（四个参数，主要是第四个参数）   ==&gt;&gt; 英文网才有四个参数</p>
<p>第三个参数，固定为null；</p>
<p>第四个参数，字符串，( ) 表示不包含，[ ] 表示包含。左括号制开始日期，右括号控制结束日期</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-10-30’, ‘2016-12-30’, null, ‘()’); //false</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-10-30’, ‘2016-12-30’, null, ‘[)’); //true</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-01-01’, ‘2016-10-30’, null, ‘()’); //false</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-01-01’, ‘2016-10-30’, null, ‘(]’); //true</p>
<p>this.moment(‘2016-10-30’).isBetween(‘2016-10-30’, ‘2016-10-30’, null, ‘[]’); //true</p>
]]></content>
      <categories>
        <category>moment</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>插件</tag>
        <tag>moment</tag>
      </tags>
  </entry>
  <entry>
    <title>mpVue</title>
    <url>/2020/07/30/mpVue/</url>
    <content><![CDATA[<p>前段时间，美团开源了<code>mpvue</code>这个项目，使得我们又多了一种用来开发小程序的框架选项。由于<code>mpvue</code>框架是完全基于Vue框架的（重写了其runtime和compiler），因此在用法上面是高度和Vue一致的（某些功能由于受限于小程序环境本身的原因而不能使用），这给使用过Vue开发Web应用的前端开发者提供了极低的切换门槛来开发小程序。</p>
<p>如果之前还未曾用过Vue这个框架的话，建议你可以快速浏览一下Vue的官方文档(<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2F" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a>)，或者通过下面的几个视频教程来了解下Vue的基本用法。</p>
<blockquote>
<p>Vue基础教程视频：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25142267" target="_blank" rel="noopener">https://www.bilibili.com/video/av25142267</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25143408" target="_blank" rel="noopener">https://www.bilibili.com/video/av25143408</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25144006" target="_blank" rel="noopener">https://www.bilibili.com/video/av25144006</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25148349" target="_blank" rel="noopener">https://www.bilibili.com/video/av25148349</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25148832" target="_blank" rel="noopener">https://www.bilibili.com/video/av25148832</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav25649895" target="_blank" rel="noopener">https://www.bilibili.com/video/av25649895</a></p>
</blockquote>
<a id="more"></a>

<h4 id="起手式：必要的开发环境"><a href="#起手式：必要的开发环境" class="headerlink" title="起手式：必要的开发环境"></a>起手式：必要的开发环境</h4><p>工欲善其事必先利其器！在开始写代码之前，请确保你已经安装了必要的开发环境和工具，以下是几个必需的和可选的工具：</p>
<p>1）node.js<br>现在，前端工具链基本都依赖Node.js，所以请率先安装它吧。</p>
<p>下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2Fdownload%2F" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
<p>安装完成后，打开你的命令行输入如下命令，验证安装是否成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node --version</span><br><span class="line">&#x2F;&#x2F;成功的话输出类似：v10.6.0</span><br><span class="line"></span><br><span class="line">npm --version</span><br><span class="line">&#x2F;&#x2F;成功的话输出类似：6.1.0</span><br></pre></td></tr></table></figure>

<p>然后，我们需要执行以下命令，将npm的下载源切换到国内淘宝的镜像，以提高下载时的速度和成功率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>2）vue-cli<br><code>vue-cli</code>是一个vue专用的项目脚手架工具，可以用于方便的创建vue项目骨架代码，包括我们要讲到的mpvue的项目代码。我们可以通过安装node.js后里面包含的npm工具来安装vue-cli，在命令行输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入如下命令进行验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 成功的话会输出如下内容：</span><br><span class="line">&#x2F;&#x2F; Usage: vue &lt;command&gt; [options]</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Options:</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    -V, --version  output the version number</span><br><span class="line">&#x2F;&#x2F;    -h, --help     output usage information</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Commands:</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    init           generate a new project from a template</span><br><span class="line">&#x2F;&#x2F;    list           list available official templates</span><br><span class="line">&#x2F;&#x2F;    build          prototype a new project</span><br><span class="line">&#x2F;&#x2F;    create         (for v3 warning only)</span><br><span class="line">&#x2F;&#x2F;    help [cmd]     display help for [cmd]</span><br></pre></td></tr></table></figure>

<p>3）微信开发者工具<br>这个工具是开发、调试和模拟运行微信小程序的最核心的工具了，所以必须安装。</p>
<p>下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fdownload.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>
<p>4）Visual Studio Code + Vetur<br>Visual Studio Code（简称vscode）是现在非常流行的一个轻量级代码编辑器，拥有非常多好用的辅助开发插件，在我的文章中我都会使用这个编辑器来编辑代码。当然，好用的代码编辑器有很多，比如Sublime Text、WebStorm等，同样可以达到我们的开发目的，你也尽管用你自己最喜欢的代码编辑器来写代码就行了。</p>
<p>下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcode.visualstudio.com" target="_blank" rel="noopener">https://code.visualstudio.com</a></p>
<p>安装完vscode后，在它的插件管理器中，查找<code>Vetur</code>并安装，然后重启一下vscode后，插件即生效：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-0d192ef619fc6cbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>安装Vetur插件</p>
<p>Vetur是一款可以提供Vue语法高亮、语法检查和代码快捷输入等功能的插件，可以为我们的开发过程提供很多便利。</p>
<h4 id="创建第一个基于mpvue的小程序项目代码"><a href="#创建第一个基于mpvue的小程序项目代码" class="headerlink" title="创建第一个基于mpvue的小程序项目代码"></a>创建第一个基于mpvue的小程序项目代码</h4><p>花了点时间装好了必要的开发环境，下面我们就来创建我们的第一个mpvue小程序项目。这里将用到前面已安装的vue-cli：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init mpvue&#x2F;mpvue-quickstart firstapp</span><br></pre></td></tr></table></figure>

<p>命令行将一步步的引导我们选择或填写项目的配置信息，如果你还不太明白这些内容的含义，可以先直接全部按回车：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? Project name firstapp</span><br><span class="line">? wxmp appid touristappid</span><br><span class="line">? Project description A Mpvue project</span><br><span class="line">? Author kevinzhang &lt;kevin.zhang@moredist.com&gt;</span><br><span class="line">? Vue build runtime</span><br><span class="line">? Use Vuex? Yes</span><br><span class="line">? Use ESLint to lint your code? Yes</span><br><span class="line">? Pick an ESLint preset Standard</span><br><span class="line">? 小程序测试，敬请关注最新微信开发者工具的“测试报告”功能 </span><br><span class="line"></span><br><span class="line">   vue-cli · Generated &quot;firstapp&quot;.</span><br><span class="line"></span><br><span class="line">   To get started:</span><br><span class="line">   </span><br><span class="line">     cd firstapp</span><br><span class="line">     npm install</span><br><span class="line">     npm run dev</span><br><span class="line">   </span><br><span class="line">   Documentation can be found at http:&#x2F;&#x2F;mpvue.com</span><br></pre></td></tr></table></figure>

<p>这个过程vue-cli主要是先从远程的代码仓库中下载了一份注册名为<code>mpvue/mpvue-quickstart</code>的模板代码，然后根据开发者在命令行提示过程中输入的信息，生成一份经过配置后的代码。</p>
<p>这份代码暂时还运行不起来，因为它还缺少依赖的库，我们需要执行以下命令进行依赖库的安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd firstapp </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>经过几分钟的下载安装，依赖库安装到了firstapp目录下，你可以看到该目录下多出了一个node_modules目录。</p>
<p>然后，执行命令让这个代码运行起来，进入开发模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>成功运行后，这个项目代码就进入开发模式，一旦有源代码发生修改，就会触发自动编译。因为mpvue使用的是Vue + HTML Web的开发方式开发小程序，它最终还是需要被转换成小程序的代码才可以在小程序环境运行，所以这里的自动编译的目的就是要把Web代码编译成小程序代码。编译后的代码会在<code>dist</code>目录下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-3572faed43dbdab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/668/format/webp" alt="img"></p>
<h4 id="运行并查看结果"><a href="#运行并查看结果" class="headerlink" title="运行并查看结果"></a>运行并查看结果</h4><p>上面的步骤中，我们开启开发模式后，其实并不能看到小程序的执行效果，要真正看小程序的运行界面的话，我们还是要借助微信开发者工具。</p>
<p>打开微信开发者工具，选择新增项目：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-3ceb36e7472d3ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>项目目录选择指向firstapp目录：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-b2d50fa4a653930e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/818/format/webp" alt="img"></p>
<p>点击“确定”按钮，进入小程序开发主界面，在左边的小程序模拟器中就能看到firstapp小程序的执行结果了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-fbc41e23b7cb9995.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/938/format/webp" alt="img"></p>
<p>【提醒】记得在微信开发者工具的菜单》设置 》编辑设置 中，将“保存时自动编译小程序”勾选上，这样当mpvue的代码自动编译完成后，模拟器才会自动刷新界面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-9b492a2bf48c8162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/878/format/webp" alt="img"></p>
<p>在Visual Studio Code里面打开项目文件夹，我们可以看到类似如下的文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstapp</span><br><span class="line">├── package.json</span><br><span class="line">├── project.config.json       </span><br><span class="line">├── static            </span><br><span class="line">├── src</span><br><span class="line">│    ├── components</span><br><span class="line">│    ├── pages</span><br><span class="line">│    ├── utils</span><br><span class="line">│    ├── App.vue</span><br><span class="line">│    └── main.js</span><br><span class="line">├── config</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── dev.env.js</span><br><span class="line">│   └── prod.env.js</span><br><span class="line">└── build</span><br></pre></td></tr></table></figure>

<h6 id="1）package-json文件"><a href="#1）package-json文件" class="headerlink" title="1）package.json文件"></a>1）package.json文件</h6><p>package.json是项目的主配置文件，里面包含了mpvue项目的基本描述信息、项目所依赖的各种第三方库以及版本信息、以及可执行的脚本信息。</p>
<p>我们看到该文件中的<code>scripts</code>部分配置了4个可执行的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;node build&#x2F;dev-server.js&quot;,</span><br><span class="line">&quot;start&quot;: &quot;node build&#x2F;dev-server.js&quot;,</span><br><span class="line">&quot;build&quot;: &quot;node build&#x2F;build.js&quot;,</span><br><span class="line">&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dev</code>和<code>start</code>是两个等价的命令，执行其中之一都可以将项目以开发模式启动。执行方式是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm start</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lint</code>指令是使用ESLint来进行代码语法和格式检查，以及修复一些可自动修复的问题。执行方式是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run lint  #检查语法和格式</span><br><span class="line">npm run lint -- --fix #检查代码语法和格式，并修复可自动修复的问题</span><br></pre></td></tr></table></figure>

<ul>
<li><code>build</code>指令是用于生成发布用代码的，它会对代码进行一些压缩优化处理。当小程序开发完成后，将要提交审核时，请使用<code>build</code>来生成发布的代码。</li>
</ul>
<h6 id="2）project-config-json文件"><a href="#2）project-config-json文件" class="headerlink" title="2）project.config.json文件"></a>2）project.config.json文件</h6><p><code>project.config.json</code>文件是用于管理微信开发者工具的小程序项目的配置文件，其中记录了小程序的appid、代码主目录、以及编译选项等等信息，在微信开发者工具中导入小程序项目的时候主要是通过该配置文件读取和写入配置信息。</p>
<h6 id="3）static目录"><a href="#3）static目录" class="headerlink" title="3）static目录"></a>3）static目录</h6><p><code>static</code>目录可以用于存放各种小程序本地静态资源，如图片、文本文件等。代码中可通过相对路径或绝对路径进行访问， 如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;static&#x2F;button.png&quot; &#x2F;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;static&#x2F;button.png&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h6 id="4）build目录"><a href="#4）build目录" class="headerlink" title="4）build目录"></a>4）build目录</h6><p><code>build</code>目录下是一些用于项目编译打包的node.js脚本和webpack配置文件。一般情况下不需要修改这些文件。</p>
<h6 id="5）config目录"><a href="#5）config目录" class="headerlink" title="5）config目录"></a>5）config目录</h6><p><code>config</code>目录下包含了用于开发和生产环境下的不同配置，<code>dev.env.js</code>用于开发环境，<code>prod.env.js</code>用于生产环境，你可以将开发阶段和生产阶段不一样的信息（如后台API的url地址等）配置到这两个文件中去，然后在代码中以变量的形式进行引用。例如，这2个文件中分别配置了不同的<code>API_BASE_URL</code>值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dev.env.js</span><br><span class="line">module.exports &#x3D; merge(prodEnv, &#123;</span><br><span class="line">  NODE_ENV: &#39;&quot;development&quot;&#39;,</span><br><span class="line">  API_BASE_URL: &#39;&quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&quot;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; prod.env.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  NODE_ENV: &#39;&quot;production&quot;&#39;,</span><br><span class="line">  API_BASE_URL: &#39;&quot;https:&#x2F;&#x2F;www.my-domain.com&#x2F;api&quot;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那你在编写请求后端API的代码时，你就可以使用这个环境配置，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const baseURL &#x3D; process.env.API_BASE_URL</span><br><span class="line">wx.request(&#123;</span><br><span class="line">  url: &#96;$&#123;baseURL&#125;&#x2F;products&#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样一来，开发阶段和上线发布阶段的环境可以清楚的区分开来。</p>
<h6 id="5）src目录"><a href="#5）src目录" class="headerlink" title="5）src目录"></a>5）src目录</h6><p><code>src</code>目录是我们主要进行小程序功能编写的地方。默认生成的demo代码为我们创建了几个子目录：<code>components</code>、<code>pages</code>和<code>utils</code>，还有2个文件：<code>App.vue</code>和<code>main.js</code>。其实它们都不是必须的，可以按照自己的风格进行定义和配置。不过默认创建的这个结构基本上是一个约定俗成的结构了，比较易于理解，所以我们可以遵循这个结构进行开发。</p>
<ul>
<li>components：在实际开发中，我们可以尽量将界面上可复用的部分，提取成vue组件放入该目录</li>
<li>pages：存放小程序的页面。请遵循每个小程序页面放入一个单独子目录的组织形式</li>
<li>utils：可选（可删）。可以将代码中一些公用工具函数组织成模块放入该目录下</li>
<li>可新建其他目录，存放你希望组织起来的代码。比如公用的业务逻辑代码、请求后台API的代码等等</li>
<li>main.js + App.vue：这两个是入口文件，相当于原生小程序框架中的<code>app.json</code>和<code>app.js</code>的复合体。</li>
</ul>
<p>为了清楚起见，我们将要对vue-cli生成的代码做一个清理工作，具体如下：</p>
<ul>
<li>删掉<code>src/components</code>、<code>src/pages</code>、<code>src/utils</code>三个目录下的所有代码文件</li>
<li>将<code>src/App.vue</code>文件中的内容重置成：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>将<code>src/main.js</code>文件中的内容重置成：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">App.mpType &#x3D; &#39;app&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; new Vue(App)</span><br><span class="line">app.$mount()</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    pages: [],</span><br><span class="line">    window: &#123;</span><br><span class="line">      backgroundTextStyle: &#39;light&#39;,</span><br><span class="line">      navigationBarBackgroundColor: &#39;#fff&#39;,</span><br><span class="line">      navigationBarTitleText: &#39;第一个小程序&#39;,</span><br><span class="line">      navigationBarTextStyle: &#39;black&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的代码就成了一个小程序页面都没有的初始状态。</p>
<h4 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h4><p>学习过使用小程序原生框架开发的朋友都知道，一个小程序的入口应该包含这三个最重要的部分：<br>1）app.json<br>2）app.js<br>3）首页</p>
<p>有了这三个部分，才能成功运行起一个最简单的小程序。</p>
<h6 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h6><p><code>app.json</code>是小程序的全局配置文件，其包含了小程序的页面文件路径配置、窗口的全局样式信息、底部选项卡式菜单栏的配置，以及一些小程序网络超时的配置等等。<code>app.json</code>的配置详情我们可以<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fconfig.html" target="_blank" rel="noopener">查阅参考小程序的官方文档来作进一步了解</a>。那么，在mpvue中我们如何来做与之等价的配置呢？</p>
<p>其实在<code>src/main.js</code>中，我们就可以完整的进行这些信息的配置，具体可以查看该文件的最底部代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 这部分相当于原生小程序的 app.json</span><br><span class="line">  config: &#123;</span><br><span class="line">    pages: [],</span><br><span class="line">    window: &#123;</span><br><span class="line">      backgroundTextStyle: &#39;light&#39;,</span><br><span class="line">      navigationBarBackgroundColor: &#39;#fff&#39;,</span><br><span class="line">      navigationBarTitleText: &#39;第一个小程序&#39;,</span><br><span class="line">      navigationBarTextStyle: &#39;black&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该代码中通过<code>export default</code>导出的对象的<code>config</code>属性下的值，就是这些小程序的配置信息了。</p>
<h6 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h6><p><code>app.js</code>中包含了小程序的各种原生生命周期方法，如<code>onLaunch</code>、<code>onShow</code>等等。而在mpvue中，它使用了一个简单的Vue组件<code>App.vue</code>来实现等价的功能。我们在这个<code>App.vue</code>组件中可以编写小程序的生命周期方法（通常使用Vue的生命周期方法，但也兼容原生的生命周期方法），也可以在其中加入小程序的全局样式（等价于原生方式下的<code>app.wxss</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;* 这部分相当于原生小程序的 app.js *&#x2F;</span><br><span class="line">export default &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    console.log(&#39;miniapp created!!!&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&#x2F;* 这部分相当于原生小程序的 app.wxss *&#x2F;</span><br><span class="line">.container &#123;</span><br><span class="line">  background-color: #cccccc;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>接着，这个<code>App.vue</code>组件被<code>src/main.js</code>引入并被设置了一个<code>mpType</code>的属性值，其值为<code>app</code>。这个值是为了与后面要讲的小程序页面组件所区分开来，因为小程序页面组件和这个<code>App.vue</code>组件的写法和引入方式是一致的，为了区分两者，需要设置<code>mpType</code>值。引入这个<code>App.vue</code>组件后，会用它作为参数来创建一个<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Finstance.html" target="_blank" rel="noopener">Vue的实例</a>，并调用<code>$mount()</code>方法加载。下面是这个过程的关键代码行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App.mpType &#x3D; &#39;app&#39;</span><br><span class="line">const app &#x3D; new Vue(App)</span><br><span class="line">app.$mount()</span><br></pre></td></tr></table></figure>

<h6 id="首页、以及其他页面"><a href="#首页、以及其他页面" class="headerlink" title="首页、以及其他页面"></a>首页、以及其他页面</h6><p>每个小程序都需要至少有一个页面，第一个展示的页面被叫做<em>首页</em>。因为前面已经把所有的页面代码都删完了，所以我们现在要新建一个首页。在<code>src/pages</code>目录下，我们新建一个名为<code>index</code>的子目录（请遵循每个页面放入一个子目录的良好习惯），然后在该子目录下，新建2个文件：一个用于实现页面主体功能的<code>index.vue</code>组件，另一个则用于将这个页面组件生成Vue实例并加载的<code>main.js</code>。以后的每一个mpvue页面组件都会拥有这样的结构。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-db653d8b653c1824.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/542/format/webp" alt="img"></p>
<p>然后在<code>main.js</code>中编写如下代码，非常简单的一段代码，它的功能是引入<code>index.vue</code>并创建Vue实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; new Vue(App)</span><br><span class="line">app.$mount()</span><br></pre></td></tr></table></figure>

<p>当然了，你也可以像在<code>src/main.js</code>中一样去导出一个页面级别的配置，因为小程序的每个页面都可以有一些单独的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">const app &#x3D; new Vue(App)</span><br><span class="line">app.$mount()</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    &#x2F;&#x2F; 注意，页面级可配置属性相当于只是&#96;src&#x2F;main.js&#96;中配置里的&#96;window&#96;部分</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;文章列表页面&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们需要实现<code>index.vue</code>页面组件，它的写法是最典型的Vue组件写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;Hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickHandle () &#123;</span><br><span class="line">      this.msg &#x3D; &#39;Clicked!!!!!!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.message &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个组件完全看不到小程序写法的影子，而是全部由Vue开发Web应用的写法来完成：数据绑定、事件处理、scoped局部样式、以及使用HTML标签来构建界面。这样最大化的保持和网页应用开发一致，减少了前端人员切换到小程序的学习理解成本，也为原先使用Vue开发的网页应用移植到小程序平台提供了降低迁移成本的可能。</p>
<p>模板部分我们通常可以用HTML标签来写，比如<code>div</code>、<code>span</code>等，它们会在编译的时候被自动转换成小程序的原生组件<code>view</code>、<code>text</code>之类；而那些小程序特有的组件如<code>swiper</code>、<code>rich-text</code>等，可以直接在模板中使用。</p>
<p>在原生小程序的页面（Page）中包含了很多页面的生命周期方法，如<code>onLoad</code>、<code>onUnload</code>、<code>onShow</code>、<code>onHide</code>、<code>onPullDownRefresh</code>等等，mpvue中推荐使用Vue组件生命周期方法，而像<code>onPullDownRefresh</code>、<code>onReachBottom</code>这类特殊功能的生命周期则需直接使用原生的。</p>
<p>回头再来看，当我们实现了这个<code>index.vue</code>页面组件后，其实还缺最后一个步骤，就是需要将这个页面组件指定为首页。如果我们的小程序只有一个页面的话，其实也可以省略这一步，因为mpvue会自动将<code>src/pages</code>目录下的页面组件路径添加到最终编译出来的小程序配置文件中去（可以打开<code>dist/app.json</code>文件观察一下）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pages&quot;: [</span><br><span class="line">    &quot;pages&#x2F;index&#x2F;main&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;window&quot;: &#123;</span><br><span class="line">    &quot;backgroundTextStyle&quot;: &quot;light&quot;,</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;第一个小程序&quot;,</span><br><span class="line">    &quot;navigationBarTextStyle&quot;: &quot;black&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，大多数情况下我们的小程序会由很多个页面组成，在<code>src/pages</code>目录下编写多个页面组件后，mpvue也会自动把它们都添加进配置文件，但是由于小程序有一个机制：</p>
<blockquote>
<p>配置文件中pages数组里的第一个page路径会被当做是首页</p>
</blockquote>
<p>如果你期望的首页组件并没有被mpvue添加到第一个路径的话，就不会被当做首页显示。比如有多个页面，并在<code>dist/app.json</code>里生成的是下面的序列，则第一个<code>pages/articles/main</code>页面会被当做首页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;pages&quot;: [</span><br><span class="line">  &quot;pages&#x2F;articles&#x2F;main&quot;,</span><br><span class="line">  &quot;pages&#x2F;authors&#x2F;main&quot;,</span><br><span class="line">  &quot;pages&#x2F;index&#x2F;main&quot;,</span><br><span class="line">  &quot;pages&#x2F;kickstart&#x2F;main&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>为了解决这种情况，我们需要显式的去指定首页。可以在<code>src/main.js</code>的配置里，加入这样一行配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages: [</span><br><span class="line">  &#39;^pages&#x2F;index&#x2F;main&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注意：以上配置中指定为首页的路径前面有个<code>^</code>符号。</p>
<p>加入这行配置之后，<code>pages/index/main</code>总是会在最终生成的<code>dist/app.json</code>中排在第一个位置，成为首页。</p>
<p>既然<code>mpvue</code>是基于Vue的，那么就没有理由不进一步学习一下Vue最核心的东西：<em>组件</em>。组件系统是Vue应用开发中最具价值的特性之一，在前文中其实我们就已经有在使用组件了，比如<code>App.vue</code>和首页<code>index.vue</code>就是两个Vue组件。</p>
<p>组件是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树，若干的小组件可以聚合成一个完整的界面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-63a928c25e48b726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>一个好的组件系统一定会有这些特点：封装性、复用性、扩展性。对于Vue的组件来说，这几点都算是实现的比较的优秀的。</p>
<h4 id="组件的封装性"><a href="#组件的封装性" class="headerlink" title="组件的封装性"></a>组件的封装性</h4><p>Vue组件的写法可以避免将属于一个独立逻辑单位的代码散落在各处，可以将界面（DOM）、样式（CSS）、行为（JS）三部分的代码很好的组织在一起（推荐的实践是使用<code>.vue</code>文件）。在设计编写一个组件时，我们要记住的原则就是：</p>
<blockquote>
<p>避免向外部暴露过多的东西，只暴露必要的外部交互接口（组件属性、事件、方法等）。</p>
</blockquote>
<p>下面我们来在原先的代码基础上，创建一个简单的按钮点击计数器组件，它将实现的功能是：点击按钮并展示已点击按钮次数、点击清零按钮实现点击次数的归零。在<code>src/components</code>目录下，新建一个<code>click-counter.vue</code>组件文件，并编写如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;click-counter&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;counter-num&quot;&gt;次数：&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-btn&quot; @click&#x3D;&quot;handleClick&quot;&gt;点我呀！&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-reset-btn&quot; @click&#x3D;&quot;handleResetClick&quot;&gt;清零&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      this.num +&#x3D; 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleResetClick() &#123;</span><br><span class="line">      this.num &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.click-counter &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #ffffff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.counter-num,</span><br><span class="line">.counter-btn,</span><br><span class="line">.counter-reset-btn &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  margin: 3px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>编写完这个组件后，我们来尝试在首页组件<code>src/pages/index/index.vue</code>文件中使用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 使用 click-counter 组件 --&gt;</span><br><span class="line">    &lt;click-counter &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 导入 click-counter 组件</span><br><span class="line">import ClickCounter from &quot;@&#x2F;components&#x2F;click-counter&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明在当前组件下使用 counter-click 组件</span><br><span class="line">  components: &#123; ClickCounter &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;Hello&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickHandle() &#123;</span><br><span class="line">      this.msg &#x3D; &quot;Clicked!!!!!!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.message &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>完成上面两个步骤后，记得重新运行一下命令行<code>npm run dev</code>（注意点：新增文件必须重新运行该命令，编译器不会自动检测新加入的文件）。成功后通过微信开发者工具的模拟器查看，结果界面将会是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-c8f38ba44e45af23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/377/format/webp" alt="img"></p>
<p>点击“点我呀！”按钮，计数器就会累加点击次数并更新界面上的数字；而点击“清零”按钮，则会将统计数字归零。</p>
<p>回到代码上来看，对于<code>click-counter.vue</code>的使用者<code>index.vue</code>来说，它并不关心太多<code>click-counter.vue</code>的实现细节，引入该组件文件并进行声明，就可以通过标签的形式来使用它了，非常简单明了。而且，这样一个<code>click-counter.vue</code>组件也可以被拿到其他的Vue/mpvue代码中使用，其他使用者也并不需要关注它的实现细节，而只需要关心它能实现什么功能就行了。这就是组件封装带来的好处。</p>
<p>不过，目前的这个click-counter组件还没有跟它的父组件之间有什么交互或通信，没有体现出“暴露接口”的特性，那让我们来增加点代码，了解下这一特性。首先解释一下我们要实现的功能：组件可以接收一个外部设置的初始点击次数值，在点击“点我呀！”按钮的时候，从这个初始值开始进行累加；并且点击按钮后，可以通知组件的使用者（即父组件）当前的点击统计值。</p>
<p>修改<code>click-counter.vue</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;click-counter&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;counter-num&quot;&gt;次数：&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-btn&quot; @click&#x3D;&quot;handleClick&quot;&gt;点我呀！&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-reset-btn&quot; @click&#x3D;&quot;handleResetClick&quot;&gt;清零&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 增加一个可从外部传入的属性initNum</span><br><span class="line">  props: &#123;</span><br><span class="line">    initNum: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: this.initNum &#x2F;&#x2F;使用传入的initNum值作为初始的点击数</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      this.num +&#x3D; 1;</span><br><span class="line">      this.notifyNum();</span><br><span class="line">    &#125;,</span><br><span class="line">    handleResetClick() &#123;</span><br><span class="line">      this.num &#x3D; 0;</span><br><span class="line">      this.notifyNum();</span><br><span class="line">    &#125;,</span><br><span class="line">    notifyNum() &#123;</span><br><span class="line">      &#x2F;&#x2F;触发自定义事件 clicknum</span><br><span class="line">      this.$emit(&quot;clicknum&quot;, &#123;</span><br><span class="line">        num: this.num</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.click-counter &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #ffffff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.counter-num,</span><br><span class="line">.counter-btn,</span><br><span class="line">.counter-reset-btn &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  margin: 3px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>修改<code>index.vue</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 使用 click-counter 组件 --&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;10&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 导入 click-counter 组件</span><br><span class="line">import ClickCounter from &quot;@&#x2F;components&#x2F;click-counter&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明在当前组件下使用 counter-click 组件</span><br><span class="line">  components: &#123; ClickCounter &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;Hello&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickHandle() &#123;</span><br><span class="line">      this.msg &#x3D; &quot;Clicked!!!!!!&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClickNum(data) &#123;</span><br><span class="line">      console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, data.num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.message &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>观察以上修改后的代码可以发现，在<code>click-couter.vue</code>中的主要变化是：</p>
<ol>
<li>使用<code>props</code>定义了一个名为<code>initNum</code>的数字型组件属性（且初始值为0）。它可用于接收使用组件外部传入的值。然后，这个<code>initNum</code>值被赋值到<code>data</code>中的属性<code>num</code>上作为它的初始值。</li>
<li>在两个按钮的click事件处理方法中，额外调用了一个<code>notifyNum()</code>方法，它向组件触发了一个自定义事件<code>clicknum</code>并携带了当前点击次数值。</li>
</ol>
<p>而在<code>index.vue</code>中的主要变化是实例化<code>click-counter</code>组件的这行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;click-counter :init-num&#x3D;&quot;10&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>实例化组件的时候，为组件传入了<code>initNum</code>属性值<code>10</code>；并且添加了一个对自定义事件<code>clicknum</code>的监听方法。</p>
<p>这样一个结构实现了数据进入组件/数据传出组件的机制，父子组件之间就能实现数据通信。通过有限的通信点进行数据互换，而不是直接进行函数调用，可以使得代码结构更优雅、更易维护。</p>
<h4 id="组件的复用性"><a href="#组件的复用性" class="headerlink" title="组件的复用性"></a>组件的复用性</h4><p>组件的复用性就好理解的多了，创建组件的目的，大多数时候就是希望这个组件可以被多个地方、多次使用，避免编写重复的代码。比如我们前面的计数器组件，有可能一个项目中的多个页面会用到，也可能一个页面就会使用多次。</p>
<p>Vue组件的复用也是很容易的，比如我们要在前面例子中的<code>index.vue</code>中复用计数器组件，创建3个计数器，那么直接在模板部分编写3个标签就行了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 创建 3个 click-counter 组件 --&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;10&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;20&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;30&quot; @clicknum&#x3D;&quot;handleClickNum&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>运行后的效果如下图所示，这三个计数器都能独立统计各自的点击数量：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-fc10dbe6b6f4c08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/379/format/webp" alt="img"></p>
<h4 id="组件的扩展性"><a href="#组件的扩展性" class="headerlink" title="组件的扩展性"></a>组件的扩展性</h4><p>谈到扩展性，有面向对象编程经验的开发者就会想到“继承(extends)”。继承是一种比较有效的扩展机制，不过随着继承的层次变深，代码也会变得难以理解。在Vue组件中，没有采用继承的机制，而是推荐使用“组合”的方式。</p>
<p>在组合理念下，我们尽量将想复用性高的组件设计到最小可拆分单位，比如按钮、输入框、单选框等等，然后再将这些低层组件放入更高层组件中，一层一层，慢慢拼装出满足需求的业务界面。</p>
<p>除了组合，Vue组件还提供了插槽(Slot)功能，相当于在一个组件中挖出了一个或多个坑，在具体使用这些具有插槽的组件时，可以选择往坑里面填什么内容（其他组件）。</p>
<p>举个例子，在计数器组件中，我们在清零按钮后面用<code>&lt;slot&gt;&lt;/slot&gt;</code>挖了一个坑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;click-counter&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;counter-num&quot;&gt;次数：&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-btn&quot; @click&#x3D;&quot;handleClick&quot;&gt;点我呀！&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;counter-reset-btn&quot; @click&#x3D;&quot;handleResetClick&quot;&gt;清零&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>而后，在<code>index.vue</code>中使用计数器组件时，在<code>&lt;click-counter&gt;</code>标签体中放入了额外的内容，会被传入该组件中去用于填坑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;clickHandle&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;message&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 使用 click-counter 组件 --&gt;</span><br><span class="line">    &lt;click-counter :init-num&#x3D;&quot;10&quot; @clicknum&#x3D;&quot;handleClickNum&quot;&gt;</span><br><span class="line">      &lt;!-- 填坑用... --&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;checkbox&quot; &#x2F;&gt; 禁用</span><br><span class="line">    &lt;&#x2F;click-counter&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>从运行结果可以看到，清零按钮后面已经多出了我们传入的复选框和文字内容:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-af53245a3d9a569a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/381/format/webp" alt="img"></p>
<p>插槽其实可以理解为是另一种形式的组件属性：普通组件属性传入的是比较简单类型的数据；而插槽传入的可以是更复杂的界面组件而已。</p>
<p>由于mpvue采用的是Vue框架的基础设施，所以大部分的功能都是和<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2F" target="_blank" rel="noopener">Vue</a>一致的。但是，mpvue的代码毕竟最终还是要转译成小程序原生框架下的代码的，由于小程序框架本身存在的一些功能限制，导致有些功能不能被翻译过去，也就是说有些标准的Vue功能在mpvue下是不可以使用或有特殊限制的。</p>
<p>今天我们就来罗列一下，在使用mpvue的时候那些需要特别注意的点。</p>
<h4 id="1-在模板中，动态插入HTML的v-html指令不可用"><a href="#1-在模板中，动态插入HTML的v-html指令不可用" class="headerlink" title="1. 在模板中，动态插入HTML的v-html指令不可用"></a>1. 在模板中，动态插入HTML的<code>v-html</code>指令不可用</h4><p>这条很好理解，小程序的界面并不是基于浏览器的BOM/DOM的，所以不能动态的在界面模板里直接插入HTML片段来显示。</p>
<p>题外话，如果有在小程序里插入html片段的需求怎么办？可以用<code>&lt;rich-text&gt;</code>组件或者<code>wxParse</code>(<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ficindy%2FwxParse" target="_blank" rel="noopener">https://github.com/icindy/wxParse</a>)来实现。</p>
<h4 id="2-在模板中，用于数据绑定的双括号语法插值表达式中的表达式功能存在诸多限制"><a href="#2-在模板中，用于数据绑定的双括号语法插值表达式中的表达式功能存在诸多限制" class="headerlink" title="2. 在模板中，用于数据绑定的双括号语法插值表达式中的表达式功能存在诸多限制"></a>2. 在模板中，用于数据绑定的双括号语法<code>插值表达式</code>中的表达式功能存在诸多限制</h4><p>在Vue本身的模板内双括号语法中，我们可以对绑定变量进行比较丰富的处理，比如：</p>
<ul>
<li>可以调用<code>methods</code>下的函数， 例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &#96;&lt;div&gt; formatMessage(msg) &lt;&#x2F;div&gt;&#96;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;Hello,World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    formatMessage(str) &#123;</span><br><span class="line">      return str.trim().split(&#39;,&#39;).join(&#39;#&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果变量是对象的话，也可以调用对象的成员方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; msg.trim().split(&#39;,&#39;).join(&#39;#&#39;) &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用过滤器来处理变量，最有用的场景算是格式化数据了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; msg | format &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>以上这些好用的功能，在mpvue中，记得都是通通不能用的哦！！！</p>
<p>我们只能在双括号中使用一些简单的运算符运算（<code>+ - * % ?: ! == === &gt; &lt; [] .</code>）。</p>
<p>但是也得找些可用的替代方案呐，大伙先考虑使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomputed.html" target="_blank" rel="noopener">计算属性(computed)</a>来做吧。</p>
<h4 id="3-在模板中，除事件监听外，其余地方都不能调用methods下的函数"><a href="#3-在模板中，除事件监听外，其余地方都不能调用methods下的函数" class="headerlink" title="3. 在模板中，除事件监听外，其余地方都不能调用methods下的函数"></a>3. 在模板中，除事件监听外，其余地方都不能调用<code>methods</code>下的函数</h4><p>在Vue中，模板里调用<code>methods</code>部分定义的函数是非常常见的，比如下面这段代码所示，在<code>v-if</code>指令中调用函数<code>getErrorNum()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if&#x3D;&quot;getErrorNum() &gt; 0  &amp;&amp; code &#x3D;&#x3D; 10001&quot; class&#x3D;&quot;error&quot;&gt; errorMsg &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>可是，在mpvue里就是不可以用！因为在小程序原生模板<code>wxml</code>里就不支持这种函数调用，导致mpvue没有很好的方式转译过去（虽然小程序有<code>wxs</code>，但是感觉翻译过去mpvue要做的工作会比较复杂）。</p>
<p>所以，可用的替代方案可能还是计算属性了。</p>
<h4 id="4-在模板中，不支持直接绑定一个对象到style或class属性上"><a href="#4-在模板中，不支持直接绑定一个对象到style或class属性上" class="headerlink" title="4. 在模板中，不支持直接绑定一个对象到style或class属性上"></a>4. 在模板中，不支持直接绑定一个对象到<code>style</code>或<code>class</code>属性上</h4><p>在Vue中我们可以为HTML元素的<code>class</code>或<code>style</code>绑定一个对象，并按照对象内的属性值来决定是否添加对应的属性名到HTML元素的样式名。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class&#x3D;&quot;classObject&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      classObject: &#123;</span><br><span class="line">        active: true,</span><br><span class="line">        &#39;text-danger&#39;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的运行后生成的HTML将是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;active&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>但是在mpvue下面这个特性也不能用，按官方说法是由于涉及到一些性能相关的原因。那如果要动态改变组件的<code>class</code>该怎么写呢？官方给出的方式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :class&#x3D;&quot;&#123; active: classObject.active, &#39;text-danger&#39;: classObject[&#39;text-danger&#39;]&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>其实改动不大，稍微多打了一些字而已，相当于在模板的<code>class</code>里再定义一个对象罢了。但是据文档中说这样会提升性能。好吧，为了性能，这点麻烦还是能忍受的。但是它又说了：从性能考虑，建议不要过度依赖此……看来即使这样，也还是有性能问题。</p>
<p>看来最好一点的方案，还是得使用计算属性，直接生成一串样式的字符串，绑定到<code>class</code>或<code>style</code>上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class&#x3D;&quot;classStr&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      classObject: &#123;</span><br><span class="line">        active: true,</span><br><span class="line">        &#39;text-danger&#39;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    classStr() &#123;</span><br><span class="line">      let arr &#x3D; []</span><br><span class="line">      for (let p in this.classObject) &#123;</span><br><span class="line">        if (this.classObject[p]) &#123;</span><br><span class="line">          arr.push(p)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr.join(&#39; &#39;) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-在模板中，嵌套使用v-for时，必须指定索引index"><a href="#5-在模板中，嵌套使用v-for时，必须指定索引index" class="headerlink" title="5. 在模板中，嵌套使用v-for时，必须指定索引index"></a>5. 在模板中，嵌套使用<code>v-for</code>时，必须指定索引<code>index</code></h4><p>通常，我们在Vue模板中嵌套循环渲染数组的时候，一般是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul v-for&#x3D;&quot;category in categories&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;product in category.products&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>但在mpvue中使用这种嵌套结构的<code>v-for</code>时，则必须每层的<code>v-for</code>上都给出索引，且索引需取不同名字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul v-for&#x3D;&quot;(category, index) in categories&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;(product, productIndex) in category.products&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-事件处理中的注意点"><a href="#6-事件处理中的注意点" class="headerlink" title="6. 事件处理中的注意点"></a>6. 事件处理中的注意点</h4><p>在mpvue中，一般可以使用Web的DOM事件名来绑定事件，mpvue会将Web事件名映射成对应的小程序事件名，对应列表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 左侧为WEB事件 : 右侧为对应的小程序事件</span><br><span class="line">&#123;</span><br><span class="line">    click: &#39;tap&#39;,</span><br><span class="line">    touchstart: &#39;touchstart&#39;,</span><br><span class="line">    touchmove: &#39;touchmove&#39;,</span><br><span class="line">    touchcancel: &#39;touchcancel&#39;,</span><br><span class="line">    touchend: &#39;touchend&#39;,</span><br><span class="line">    tap: &#39;tap&#39;,</span><br><span class="line">    longtap: &#39;longtap&#39;,</span><br><span class="line">    input: &#39;input&#39;,</span><br><span class="line">    change: &#39;change&#39;,</span><br><span class="line">    submit: &#39;submit&#39;,</span><br><span class="line">    blur: &#39;blur&#39;,</span><br><span class="line">    focus: &#39;focus&#39;,</span><br><span class="line">    reset: &#39;reset&#39;,</span><br><span class="line">    confirm: &#39;confirm&#39;,</span><br><span class="line">    columnchange: &#39;columnchange&#39;,</span><br><span class="line">    linechange: &#39;linechange&#39;,</span><br><span class="line">    error: &#39;error&#39;,</span><br><span class="line">    scrolltoupper: &#39;scrolltoupper&#39;,</span><br><span class="line">    scrolltolower: &#39;scrolltolower&#39;,</span><br><span class="line">    scroll: &#39;scroll&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的之外，Web表单组件<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>的change事件会被转为blur事件。</p>
<p>然后，像<code>keydown</code>、<code>keypress</code>之类的键盘事件也没有了，因为小程序没有键盘，所以不需要这些事件。</p>
<p>还有，Vue里面绑定事件的时候，可以指定事件修饰符，但是在mpvue里，官方给出了一些注意信息：</p>
<blockquote>
<ul>
<li>.stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！【这个亲测了一下，感觉是最新版本里修复了还是怎么的，没有文档里说的这个问题了】</li>
<li>.prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面【也就是不需要支持】</li>
<li>.capture 支持 1.0.9 【也就是在 mpvue 1.0.9及以后版本支持】</li>
<li>.self 没有可以判断的标识 【也就是不支持】</li>
<li>.once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑【也就是不支持】</li>
</ul>
</blockquote>
<p>所以呢，总之当你在遇到事件相关的问题，请回来查看一下文档，看看自己是否已经掉在坑里了。</p>
<h4 id="7-对于表单，请直接使用小程序原生的表单组件"><a href="#7-对于表单，请直接使用小程序原生的表单组件" class="headerlink" title="7. 对于表单，请直接使用小程序原生的表单组件"></a>7. 对于表单，请直接使用小程序原生的表单组件</h4><p>一句话，表单组件又多又复杂，框架可能Hold不住。所以在实际开发中，推荐直接使用小程序的表单组件标签来写，而不是使用Web的表单组件标签来写。当然了，在mpvue中使用了小程序的组件标签，数据绑定功能还是完全可以用的。给个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;picker @change&#x3D;&quot;handlePickerChange&quot; :value&#x3D;&quot;selectedIndex&quot; :range&#x3D;&quot;messages&quot;&gt;</span><br><span class="line">      &lt;view class&#x3D;&quot;picker&quot;&gt;当前消息： messages[selectedIndex] &lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;picker&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      selectedIndex: 0,</span><br><span class="line">      messages: [&#39;Hello&#39;, &#39;World&#39;, &#39;Haha&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handlePickerChange (e) &#123;</span><br><span class="line">      console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><p>另外，在Vue开发Web应用的时候，通常使用<code>vue-router</code>来进行页面路由。但是在mpvue小程序开发中，不能用这种方式，请使用<code>&lt;a&gt;</code>标签和小程序原生API <code>wx.navigateTo</code>等来做路由功能。</p>
<p>还有就是请求后端数据，我们通常在Web开发中使用<code>axios</code>等ajax库来实现，但是在小程序开发中也是不能用的，也请使用小程序的原生API <code>wx.request</code>等来进行。</p>
<p>如果你使用过原生的小程序框架，你一定经历过或思考过怎么解决以下的问题：</p>
<ul>
<li>怎么存放可全局访问的变量？</li>
<li>页面跳转的时候，怎么传递参数到下一个页面比较好？</li>
<li>页面返回上一页的时候，怎么传递当前页的数据到上一页？</li>
<li>多个页面间需要同步数据，怎么做比较好？</li>
</ul>
<p>网上一搜，解决的方法通常也是五花八门的，什么通过app上的globalData啊、通过存取storage啊、通过一个单独的模块(module)啊、通过Page路由栈啊、通过引入自定义事件啊、通过引入redux啊，等等等等……</p>
<p>在原生小程序框架里，确实没有提供什么太统一的方式来指导开发者解决这个问题，大家只能各自用着暂时能解决当前问题的方案。</p>
<p>不过，既然我们用了Vue/mpvue，遇到这种情况，自然而然的就会想到一个方案，那就是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" target="_blank" rel="noopener">Vuex</a>。Vuex 是一个专为 Vue 应用程序开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>通过使用Vuex，我们可以在mpvue里很方便的对需要在app、页面、组件之间共享的数据进行很好的统一管理，可以更方便有效的在各个代码部分对这些共享数据进行访问，同时可以使得你的代码条理变得更加清晰。</p>
<p>我们知道，Vuex一般有2种用法，当创建好store后：</p>
<ul>
<li>第一种用法是将store绑定到需要访问store内容的Vue实例上，然后通过该Vue实例下组件的<code>this.$store</code>来引用；或通过<code>mapState</code>等一系列映射函数将store中的state、getters、mutations、actions等映射成组件的计算属性或methods方法来使用；</li>
<li>第二种用法是直接在组件中通过<code>import</code>导入store所在的模块文件，然后调用该store上的相关方法和属性，比如<code>commit()</code>、<code>dispatch()</code>等方法来操作store中的内容。</li>
</ul>
<p>经过我的实测，上面的这两种方式在mpvue中也都是可用的。但是，由于mpvue不像Vue Web单页应用那种单Vue实例的结构，而是采用了多Vue实例的结构（app和各个页面都会由单独的Vue实例来管理），所以我个人推荐采用上面所说的第二种用法，这种方式会更加灵活和简单一些。</p>
<p>让我们开始写代码，先在<code>src</code>目录下新建一个stores目录，接着在stores目录下新建一个名为<code>global-store.js</code>的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment: (state) &#x3D;&gt; &#123;</span><br><span class="line">      state.count +&#x3D; 1</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: (state) &#x3D;&gt; &#123;</span><br><span class="line">      state.count -&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个代码中，我们新建了一个<code>Store</code>实例，管理了一个名为<code>count</code>的数字类型的状态，并定义了2个mutations去操作（增减）这个状态值。</p>
<p>接着，我们要在2个页面中访问这个store。让我们在<code>src/pages</code>目录下编写2个页面：index和test1。</p>
<p>这是<code>pages/index/index.vue</code>的代码内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;计数结果：&#123;&#123;count&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;&#x2F;pages&#x2F;test1&#x2F;main&quot; class&#x3D;&quot;navlink&quot;&gt;进入计数器页面&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import globalStore from &quot;..&#x2F;..&#x2F;stores&#x2F;global-store&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return globalStore.state.count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.navlink &#123;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>这是<code>pages/test1/index.vue</code>的代码内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container btns&quot;&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;calbtn&quot; @click&#x3D;&quot;hanleDecrement&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;calnum&quot;&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;calbtn&quot; @click&#x3D;&quot;hanleIncrement&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import globalStore from &quot;..&#x2F;..&#x2F;stores&#x2F;global-store&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return globalStore.state.count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    hanleIncrement() &#123;</span><br><span class="line">      globalStore.commit(&quot;increment&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    hanleDecrement() &#123;</span><br><span class="line">      globalStore.commit(&quot;decrement&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.btns &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.calnum &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  font-size: 32px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>这样，我们就有了2个使用了我们定义的global-store的页面，这些页面都会从store中获取<code>count</code>状态值并显示；在test1页面中，还会调用<code>increment</code>和<code>decrement</code>两个mutations去更新<code>count</code>值。</p>
<p>运行小程序，可以看到初始进入index页面时是这样的，页面上显示的计数结果是0：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-4a8524c7edf600c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/736/format/webp" alt="img"></p>
<p>index页面</p>
<p>然后点击“进入计数器页面”进到test1页面，并在这个页面上点击加减按钮操作一下，当中显示的count数会发生改变：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-aa5b58bdb9a7949b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/738/format/webp" alt="img"></p>
<p>test1页面</p>
<p>最后，点击左上角返回按钮返回index页面，你将发现这个页面上的计数结果也已经发生了改变，自动同步成前面操作后的结果了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3407939-37a8bffb4252c0ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/740/format/webp" alt="img"></p>
<p>返回index页面</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过这个例子，是不是感觉到使用Vuex做页面间的传值和数据同步特别简单？另外，你也可以在<code>src/stores</code>目录下按需创建多个store模块，独立管理不同业务范围的数据，并按需导入页面组件使用。</p>
<p>Vuex是开发中一件非常得力的工具，希望你能尽快掌握它。更多的用法可以参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" target="_blank" rel="noopener">官方文档</a>。</p>
<p>参考链接 <a href="https://www.jianshu.com/p/462494e458c2" target="_blank" rel="noopener">https://www.jianshu.com/p/462494e458c2</a></p>
]]></content>
      <categories>
        <category>mpvue</category>
      </categories>
      <tags>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的简单用法</title>
    <url>/2021/03/30/mysql%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>参考链接：<a href="https://mp.weixin.qq.com/s/0hWUZmX72OjQtoVlSfp-PQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0hWUZmX72OjQtoVlSfp-PQ</a></p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><ol>
<li>使用brew工具安装mysql</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure>

<ol>
<li>查看安装路径：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which mysql</span><br></pre></td></tr></table></figure>

<h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><ol>
<li>检查mysql服务进程：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep mysqld</span><br></pre></td></tr></table></figure>

<ol>
<li>启动服务：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql.server start</span><br></pre></td></tr></table></figure>

<ol>
<li>停止服务：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql.server stop</span><br></pre></td></tr></table></figure>

<ol>
<li>查看服务状态：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql.server status</span><br></pre></td></tr></table></figure>

<ol>
<li>重启服务状态：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql.server restart</span><br></pre></td></tr></table></figure>

<ol>
<li>重载配置（不影响数据写入)：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql.server reload</span><br></pre></td></tr></table></figure>

<ol>
<li>强制重载配置(不影响数据写入)：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql.server force-reload</span><br></pre></td></tr></table></figure>

<ol>
<li>退出mysql命令:Ctrl+D</li>
</ol>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><h4 id="1-新建数据库："><a href="#1-新建数据库：" class="headerlink" title="1. 新建数据库："></a>1. 新建数据库：</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br></pre></td></tr></table></figure>

<h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE mentu;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE mentu;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="2-查看数据库列表："><a href="#2-查看数据库列表：" class="headerlink" title="2. 查看数据库列表："></a>2. 查看数据库列表：</h4><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<h5 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h5><ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| logic_engine       |</span><br><span class="line">| mentu              |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-选择数据库："><a href="#3-选择数据库：" class="headerlink" title="3. 选择数据库："></a>3. 选择数据库：</h4><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>

<h5 id="实例：-2"><a href="#实例：-2" class="headerlink" title="实例："></a>实例：</h5><ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mentu;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mentu;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>

<h4 id="4-删除数据库："><a href="#4-删除数据库：" class="headerlink" title="4. 删除数据库："></a>4. 删除数据库：</h4><ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE IF EXISTS mentu;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="5-创建数据表："><a href="#5-创建数据表：" class="headerlink" title="5. 创建数据表："></a>5. 创建数据表：</h4><h5 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure>

<h5 id="实例：-3"><a href="#实例：-3" class="headerlink" title="实例："></a>实例：</h5><ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;user&#96;(</span><br><span class="line">   &#96;id&#96; INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   &#96;name&#96; VARCHAR(100) NOT NULL,</span><br><span class="line">   &#96;age&#96; INT  NOT NULL,</span><br><span class="line">   &#96;gender&#96; VARCHAR(100)  NOT NULL,</span><br><span class="line">   PRIMARY KEY ( &#96;id&#96; )</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE IF NOT EXISTS &#96;user&#96;(</span><br><span class="line">    -&gt;    &#96;id&#96; INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">    -&gt;    &#96;name&#96; VARCHAR(100) NOT NULL,</span><br><span class="line">    -&gt;    &#96;age&#96; INT  NOT NULL,</span><br><span class="line">    -&gt;    &#96;gender&#96; VARCHAR(100)  NOT NULL,</span><br><span class="line">    -&gt;    PRIMARY KEY ( &#96;id&#96; )</span><br><span class="line">    -&gt; )ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<h4 id="6-查看数据表"><a href="#6-查看数据表" class="headerlink" title="6. 查看数据表"></a>6. 查看数据表</h4><ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_mentu |</span><br><span class="line">+-----------------+</span><br><span class="line">| user            |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="7-删除数据表："><a href="#7-删除数据表：" class="headerlink" title="7. 删除数据表："></a>7. 删除数据表：</h4><h5 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE table_name ;</span><br></pre></td></tr></table></figure>

<h5 id="实例：-4"><a href="#实例：-4" class="headerlink" title="实例："></a>实例：</h5><ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE user;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE user;</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br></pre></td></tr></table></figure>

<h4 id="8-插入数据："><a href="#8-插入数据：" class="headerlink" title="8. 插入数据："></a>8. 插入数据：</h4><h5 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>

<h5 id="实例：-5"><a href="#实例：-5" class="headerlink" title="实例："></a>实例：</h5><ul>
<li>sql语句:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user (name,age,gender) VALUES (&quot;阿门&quot;,18,&quot;female&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO user (name,age,gender) VALUES (&quot;阿门&quot;,18,&quot;female&quot;);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<h4 id="9-查询数据"><a href="#9-查询数据" class="headerlink" title="9. 查询数据"></a>9. 查询数据</h4><p>先造一些数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user:</span><br><span class="line">+----+--------------+-----+--------+</span><br><span class="line">| id | name         | age | gender |</span><br><span class="line">+----+--------------+-----+--------+</span><br><span class="line">|  1 | 阿门1号      | 188 | female |</span><br><span class="line">|  2 | 阿门1号      |  19 | male   |</span><br><span class="line">|  3 | 阿门2号      |  20 | female |</span><br><span class="line">|  4 | 阿门3号      |  21 | male   |</span><br><span class="line">|  5 | 阿门888号    | 888 | female |</span><br><span class="line">|  6 | 阿门5号      |  23 | male   |</span><br><span class="line">|  7 | 阿门6号      |  24 | female |</span><br><span class="line">|  8 | 阿门7号      |  25 | male   |</span><br><span class="line">|  9 | 阿门8号      |  26 | female |</span><br><span class="line">+----+--------------+-----+--------+</span><br><span class="line"></span><br><span class="line">auth:</span><br><span class="line">+----+---------+-------+-----------------+</span><br><span class="line">| id | user_id | level | level_name      |</span><br><span class="line">+----+---------+-------+-----------------+</span><br><span class="line">|  1 | 1       |     0 | 超级管理员      |</span><br><span class="line">|  2 | 2       |     1 | 管理员          |</span><br><span class="line">|  3 | 3       |     1 | 管理员          |</span><br><span class="line">|  4 | 4       |     2 | 操作员          |</span><br><span class="line">|  5 | 5       |     2 | 操作员          |</span><br><span class="line">|  6 | 6       |     2 | 操作员          |</span><br><span class="line">|  7 | 7       |     2 | 操作员          |</span><br><span class="line">|  8 | 8       |     2 | 操作员          |</span><br><span class="line">|  9 | 9       |     2 | 操作员          |</span><br><span class="line">| 10 | 10      |     2 | 操作员          |</span><br><span class="line">+----+---------+-------+-----------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student:</span><br><span class="line">+----+--------+-----+---------+</span><br><span class="line">| id | name   | age | country |</span><br><span class="line">+----+--------+-----+---------+</span><br><span class="line">|  1 | 张三   |  12 | USA     |</span><br><span class="line">|  2 | 李四   |  12 | CN      |</span><br><span class="line">|  3 | 王五   |  12 | USA     |</span><br><span class="line">|  4 | 沈六   |  12 | CN      |</span><br><span class="line">+----+--------+-----+--------</span><br><span class="line"></span><br><span class="line">teacher:</span><br><span class="line">+----+------+-----+---------+</span><br><span class="line">| id | name | age | country |</span><br><span class="line">+----+------+-----+---------+</span><br><span class="line">|  1 | 老A  |  21 | USA     |</span><br><span class="line">|  2 | 老B  |  22 | CN      |</span><br><span class="line">|  3 | 老C  |  23 | USA     |</span><br><span class="line">|  4 | 老D  |  24 | CN      |</span><br><span class="line">+----+------+-----+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="语法：-6"><a href="#语法：-6" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M]</span><br></pre></td></tr></table></figure>

<h5 id="实例：-6"><a href="#实例：-6" class="headerlink" title="实例："></a>实例：</h5><ol>
<li>读取数据表：</li>
</ol>
<ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student;</span><br><span class="line">+----+--------+-----+---------+</span><br><span class="line">| id | name   | age | country |</span><br><span class="line">+----+--------+-----+---------+</span><br><span class="line">|  1 | 张三   |  12 | USA     |</span><br><span class="line">|  2 | 李四   |  12 | CN      |</span><br><span class="line">|  3 | 王五   |  12 | USA     |</span><br><span class="line">|  4 | 沈六   |  12 | CN      |</span><br><span class="line">+----+--------+-----+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li>WHERE的使用：</li>
</ol>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">[WHERE condition1 [AND [OR]] condition2.....</span><br></pre></td></tr></table></figure>

<ul>
<li>条件：</li>
</ul>
<blockquote>
<ol>
<li>逻辑操作符：AND 或者 OR 指定一个或多个条件;</li>
<li>关系操作符：= 、&gt; 、&lt; 、&lt;= 、&gt;=、&lt;&gt; 、!= ; 实例：</li>
</ol>
</blockquote>
<ul>
<li>基础用法1(单表单条件)：sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name,age FROM user WHERE gender&#x3D;&#39;male&#39;;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name,age FROM user WHERE gender&#x3D;&#39;male&#39;;</span><br><span class="line">+------------+-----+</span><br><span class="line">| name       | age |</span><br><span class="line">+------------+-----+</span><br><span class="line">| 阿门1号    |  19 |</span><br><span class="line">| 阿门3号    |  21 |</span><br><span class="line">| 阿门5号    |  23 |</span><br><span class="line">| 阿门7号    |  25 |</span><br><span class="line">+------------+-----+</span><br><span class="line">4 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>基础用法2(单表多条件)：sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name,age FROM user WHERE gender&#x3D;&#39;male&#39; AND age&gt;21 OR age&#x3D;19;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name,age FROM user WHERE gender&#x3D;&#39;male&#39; AND age&gt;21 OR age&#x3D;19;</span><br><span class="line">+------------+-----+</span><br><span class="line">| name       | age |</span><br><span class="line">+------------+-----+</span><br><span class="line">| 阿门1号    |  19 |</span><br><span class="line">| 阿门5号    |  23 |</span><br><span class="line">| 阿门7号    |  25 |</span><br><span class="line">+------------+-----+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>基础用法3(多表多条件)：</li>
</ul>
<p>sql语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name,age,level_name FROM user,auth WHERE user.id&#x3D;auth.user_id AND user.age&gt;25;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name,age,level_name FROM user,auth WHERE user.id&#x3D;auth.user_id AND user.age&gt;25;</span><br><span class="line">+--------------+-----+-----------------+</span><br><span class="line">| name         | age | level_name      |</span><br><span class="line">+--------------+-----+-----------------+</span><br><span class="line">| 阿门1号      | 188 | 超级管理员      |</span><br><span class="line">| 阿门888号    | 888 | 操作员          |</span><br><span class="line">| 阿门8号      |  26 | 操作员          |</span><br><span class="line">+--------------+-----+-----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li>like的使用(主要用于模糊查询)：语法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * from table  WHERE gender LIKE &#39;%fe&#39;;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<ul>
<li>sql语句:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * from user  WHERE gender LIKE &#39;%fe%&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * from user  WHERE gender LIKE &#39;%fe%&#39;;</span><br><span class="line">+----+--------------+-----+--------+</span><br><span class="line">| id | name         | age | gender |</span><br><span class="line">+----+--------------+-----+--------+</span><br><span class="line">|  1 | 阿门1号      | 188 | female |</span><br><span class="line">|  3 | 阿门2号      |  20 | female |</span><br><span class="line">|  5 | 阿门888号    | 888 | female |</span><br><span class="line">|  7 | 阿门6号      |  24 | female |</span><br><span class="line">|  9 | 阿门8号      |  26 | female |</span><br><span class="line">+----+--------------+-----+--------+</span><br></pre></td></tr></table></figure>

<ol>
<li>UNION(联表)：语法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">UNION [ALL | DISTINCT]</span><br><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions];</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, age, country</span><br><span class="line">FROM student</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT name, age, country</span><br><span class="line">FROM teacher;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name, age, country</span><br><span class="line">    -&gt; FROM student</span><br><span class="line">    -&gt; UNION ALL</span><br><span class="line">    -&gt; SELECT name, age, country</span><br><span class="line">    -&gt; FROM teacher;</span><br><span class="line">+--------+-----+---------+</span><br><span class="line">| name   | age | country |</span><br><span class="line">+--------+-----+---------+</span><br><span class="line">| 张三   |  12 | USA     |</span><br><span class="line">| 李四   |  12 | CN      |</span><br><span class="line">| 王五   |  12 | USA     |</span><br><span class="line">| 沈六   |  12 | CN      |</span><br><span class="line">| 老A    |  21 | USA     |</span><br><span class="line">| 老B    |  22 | CN      |</span><br><span class="line">| 老C    |  23 | USA     |</span><br><span class="line">| 老D    |  24 | CN      |</span><br><span class="line">+--------+-----+---------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li>排序：</li>
</ol>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br></pre></td></tr></table></figure>

<p><code>ASC</code>升序<code>DESC</code>降序</p>
<p>实例：-sql语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, age, country</span><br><span class="line">FROM student</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT name, age, country</span><br><span class="line">FROM teacher ORDER BY age DESC;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name, age, country</span><br><span class="line">    -&gt; FROM student</span><br><span class="line">    -&gt; UNION ALL</span><br><span class="line">    -&gt; SELECT name, age, country</span><br><span class="line">    -&gt; FROM teacher ORDER BY age DESC;</span><br><span class="line">+--------+-----+---------+</span><br><span class="line">| name   | age | country |</span><br><span class="line">+--------+-----+---------+</span><br><span class="line">| 老D    |  24 | CN      |</span><br><span class="line">| 老C    |  23 | USA     |</span><br><span class="line">| 老B    |  22 | CN      |</span><br><span class="line">| 老A    |  21 | USA     |</span><br><span class="line">| 张三   |  12 | USA     |</span><br><span class="line">| 李四   |  12 | CN      |</span><br><span class="line">| 王五   |  12 | USA     |</span><br><span class="line">| 沈六   |  12 | CN      |</span><br><span class="line">+--------+-----+---------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="10-更新数据数据："><a href="#10-更新数据数据：" class="headerlink" title="10. 更新数据数据："></a>10. 更新数据数据：</h4><h5 id="语法：-7"><a href="#语法：-7" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET field1&#x3D;new-value1, field2&#x3D;new-value2</span><br><span class="line">[WHERE Clause]</span><br></pre></td></tr></table></figure>

<h5 id="实例：-7"><a href="#实例：-7" class="headerlink" title="实例："></a>实例：</h5><ol>
<li>基础用法:</li>
</ol>
<ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET name&#x3D;&#39;阿门1号&#39;, age&#x3D;&#39;188&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE user SET name&#x3D;&#39;阿门1号&#39;, age&#x3D;&#39;188&#39;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>

<ul>
<li>更新后的效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM user;</span><br><span class="line">+----+------------+-----+--------+</span><br><span class="line">| id | name       | age | gender |</span><br><span class="line">+----+------------+-----+--------+</span><br><span class="line">|  1 | 阿门1号    | 188 | female |</span><br><span class="line">+----+------------+-----+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li>使用WHERE条件:</li>
</ol>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET field1&#x3D;new-value1, field2&#x3D;new-value2</span><br><span class="line">[WHERE condition1 [AND [OR]] condition2.....</span><br></pre></td></tr></table></figure>

<ul>
<li>实例: sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET name&#x3D;&#39;阿门888号&#39;, age&#x3D;&#39;888&#39; WHERE id&#x3D;5;</span><br><span class="line">WHERE&#96;的条件使用参考 **查询数据** 模块的&#96;WHERE</span><br></pre></td></tr></table></figure>

<h4 id="11-删除数据"><a href="#11-删除数据" class="headerlink" title="11. 删除数据"></a>11. 删除数据</h4><h5 id="语法：-8"><a href="#语法：-8" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure>

<h5 id="实例：-8"><a href="#实例：-8" class="headerlink" title="实例："></a>实例：</h5><ul>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM user WHERE id&#x3D;10;</span><br></pre></td></tr></table></figure>

<p><code>WHERE</code>的条件使用参考 <strong>1.查询数据</strong> 模块的<code>WHERE</code>使用；</p>
<ul>
<li>效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELETE FROM user WHERE id&#x3D;10;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行后表的数据：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+--------------+-----+--------+</span><br><span class="line">| id | name         | age | gender |</span><br><span class="line">+----+--------------+-----+--------+</span><br><span class="line">|  1 | 阿门1号      | 188 | female |</span><br><span class="line">|  2 | 阿门1号      |  19 | male   |</span><br><span class="line">|  3 | 阿门2号      |  20 | female |</span><br><span class="line">|  4 | 阿门3号      |  21 | male   |</span><br><span class="line">|  5 | 阿门888号    | 888 | female |</span><br><span class="line">|  6 | 阿门5号      |  23 | male   |</span><br><span class="line">|  7 | 阿门6号      |  24 | female |</span><br><span class="line">|  8 | 阿门7号      |  25 | male   |</span><br><span class="line">|  9 | 阿门8号      |  26 | female |</span><br><span class="line">+----+--------------+-----+--------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>npm是什么最全记录</title>
    <url>/2020/07/29/npm%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%80%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="npm是什么？"><a href="#npm是什么？" class="headerlink" title="npm是什么？"></a>npm是什么？</h3><p>npm全称Node Package Manager，是node.js的模块依赖管理工具，它有一个日益强大的对手叫yarn，yarn是Facebook发布的一款依赖管理工具。</p>
<a id="more"></a>

<h3 id="npm的使用场景："><a href="#npm的使用场景：" class="headerlink" title="npm的使用场景："></a>npm的使用场景：</h3><p>上传分享自己写的程序代码（包），下载别人写的程序代码（包）。</p>
<h3 id="npm的组成："><a href="#npm的组成：" class="headerlink" title="npm的组成："></a>npm的组成：</h3><ul>
<li>npm官网（<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" rel="noopener">https://www.npmjs.com/</a>），用来管理设置上面的代码程序包</li>
<li>一个大数据库，大家分享的程序就放在那里</li>
<li>命令行工具（CLI），我们通过CLI来与npm交流</li>
</ul>
<h3 id="npm怎么安装与升级"><a href="#npm怎么安装与升级" class="headerlink" title="npm怎么安装与升级"></a>npm怎么安装与升级</h3><p>与NodeJs一起集成安装，安装NodeJS时自动安装npm。</p>
<h3 id="查看npm版本"><a href="#查看npm版本" class="headerlink" title="查看npm版本"></a>查看npm版本</h3><p>npm -v#6.5.0</p>
<h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><p>npm help <command></p>
<h3 id="升级npm"><a href="#升级npm" class="headerlink" title="升级npm"></a>升级npm</h3><p>npm install npm -gnpm install npm@latest -g #升级到最新版本</p>
<h3 id="包是什么？"><a href="#包是什么？" class="headerlink" title="包是什么？"></a>包是什么？</h3><p>npm的核心是包，npm将它管理的程序都叫包，每个包里有个package.json文件，位于包的根目录下，用于定义包的属性（配置信息），比如包的名称、版本、许可证等等。</p>
<p>在进行npm install命令时，就是根据这个配置文件，来自动下载这个包所需的模块，配置项目所需的运行和开发环境。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json是一个JSON对象，每一个键值对就是当面包的一个配置。</p>
<p>一个package.json常用字段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Hello World&quot;, &#x2F;&#x2F;包名   </span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,&#x2F;&#x2F;包的版本号，主版本.次版本.补丁版本    </span><br><span class="line">  &quot;author&quot;: &quot;张三&quot;,&#x2F;&#x2F;包的作者，格式设置：Your Name &lt;email@example.com&gt; (http:&#x2F;&#x2F;example.com)    </span><br><span class="line">  &quot;description&quot;: &quot;第一个node.js程序&quot;,&#x2F;&#x2F;包的描述    </span><br><span class="line">  &quot;keywords&quot;: [&quot;node.js&quot;, &quot;javascript&quot;],&#x2F;&#x2F;包的关键词        </span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,&#x2F;&#x2F;main 字段指定了程序的主入口文件，require(&#39;moduleName&#39;) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。   </span><br><span class="line">  &quot;repository&quot;: &#123;&#x2F;&#x2F; 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。   </span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;https:&#x2F;&#x2F;path&#x2F;to&#x2F;url&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,&#x2F;&#x2F;包的版权协议  </span><br><span class="line">  &quot;engines&quot;: &#123; &quot;node&quot;: &quot;0.10.x&quot; &#125;,&#x2F;&#x2F;该模块运行的平台，比如 Node 的某个版本或者浏览器</span><br><span class="line">  &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;http:&#x2F;&#x2F;path&#x2F;to&#x2F;bug&quot;, &quot;email&quot;: &quot;bug@example.com&quot; &#125;,</span><br><span class="line">  &quot;contributors&quot;: [&#123; &quot;name&quot;: &quot;李四&quot;, &quot;email&quot;: &quot;lisi@example.com&quot; &#125;],&#x2F;&#x2F;包的其他贡献者姓名  </span><br><span class="line">  &quot;scripts&quot;: &#123;&#x2F;&#x2F;运行脚本命令的npm命令行缩写，执行命令：npm run &lt;命令名&gt;  </span><br><span class="line">    &quot;start&quot;: &quot;node index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;config&quot;: &#123;&#x2F;&#x2F;添加命令行的环境变量      </span><br><span class="line">    &quot;port&quot;: &quot;8080&quot;&#x2F;&#x2F;可以在js中通过process.env.npm_package_config_port获取，可以通过npm config set &lt;包名&gt;:port 80修改        &#125;, </span><br><span class="line">    &quot;browser&quot;: &#123;&#x2F;&#x2F;供浏览器使用的版本       </span><br><span class="line">      &quot;tipso&quot;: &quot;.&#x2F;node_modules&#x2F;tipso&#x2F;src&#x2F;tipso.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;&#x2F;&#x2F;项目运行依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 * node_module 目录下    </span><br><span class="line">      &quot;express&quot;: &quot;latest&quot;,</span><br><span class="line">      &quot;mongoose&quot;: &quot;~3.8.3&quot;,</span><br><span class="line">      &quot;handlebars-runtime&quot;: &quot;~1.0.12&quot;,</span><br><span class="line">      &quot;express3-handlebars&quot;: &quot;~0.5.0&quot;,</span><br><span class="line">      &quot;MD5&quot;: &quot;~1.2.0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;devDependencies&quot;: &#123;&#x2F;&#x2F;项目开发依赖包列表   </span><br><span class="line">      &quot;bower&quot;: &quot;~1.2.8&quot;,</span><br><span class="line">      &quot;grunt&quot;: &quot;~0.4.1&quot;,</span><br><span class="line">      &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,</span><br><span class="line">      &quot;grunt-contrib-jshint&quot;: &quot;~0.7.2&quot;,</span><br><span class="line">      &quot;grunt-contrib-uglify&quot;: &quot;~0.2.7&quot;,</span><br><span class="line">      &quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;,</span><br><span class="line">      &quot;browserify&quot;: &quot;2.36.1&quot;,</span><br><span class="line">      &quot;grunt-browserify&quot;: &quot;~1.3.0&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="依赖包版本格式"><a href="#依赖包版本格式" class="headerlink" title="依赖包版本格式:"></a>依赖包版本格式:</h3><ol>
<li><p>指定：1.2.2</p>
</li>
<li><p><del>+指定：</del>1.2.2，表示安装1.2.x的最新版本（不低于1.2.2，小于1.3.x）</p>
</li>
<li><p>^ + 指定版本：^1.2.2，表示安装1.x.x的最新版本，（不低于1.2.2，小于2.x.x）</p>
</li>
<li><p>latest：最新版本</p>
</li>
</ol>
<h3 id="package-json生成方式："><a href="#package-json生成方式：" class="headerlink" title="package.json生成方式："></a>package.json生成方式：</h3><ol>
<li>手写</li>
<li>执行npm init生成</li>
</ol>
<h3 id="依赖包写入package-json"><a href="#依赖包写入package-json" class="headerlink" title="依赖包写入package.json"></a>依赖包写入package.json</h3><p>不在package.json的包要写入，使用–save 或者–save-dev</p>
<p>npm install express –save     # 将该模块写入dependencies属性</p>
<p>npm install express –save-dev   #将该模块写入devDependencies属性</p>
<h3 id="下载安装、卸载、更新包"><a href="#下载安装、卸载、更新包" class="headerlink" title="下载安装、卸载、更新包"></a>下载安装、卸载、更新包</h3><p>安装方式（全局安装与本地安装）</p>
<p>npm install express       //本地安装</p>
<p>npm i express         //简写     </p>
<p>npm install express -g   //全局安装</p>
<ul>
<li>全局安装：安装包放在 /usr/local 下或者你 node 的安装目录，可以在命令行直接使用</li>
<li>本地安装：安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），没有时会自动创建，通过 require() 来引入本地安装的包</li>
</ul>
<h3 id="引用下载的包"><a href="#引用下载的包" class="headerlink" title="引用下载的包"></a>引用下载的包</h3><p>//var <Module name>= require(‘<Module name>‘);</Module></Module></p>
<p>var express = require(‘express’);</p>
<h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><p>npm uninstall express   //删除node_modules目录下面的包</p>
<p>npm uninstall –save express      //删除node_modules的包和package.json中的运行时依赖</p>
<p>npm uninstall –save-dev express      //删除node_modules的包和package.json中的开发依赖</p>
<p>npm uninstall -g express #全局卸载</p>
<h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><p>npm update expressnpm update express -g //更新全局包</p>
<h3 id="package-json中的依赖全部更新成最新的"><a href="#package-json中的依赖全部更新成最新的" class="headerlink" title="package.json中的依赖全部更新成最新的"></a>package.json中的依赖全部更新成最新的</h3><p>npm i -g npm-check-updates</p>
<p>ncu -u</p>
<p>npm install</p>
<h3 id="npm-version"><a href="#npm-version" class="headerlink" title="npm version"></a>npm version</h3><p><code>npm version --help</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease [--preid&#x3D;&lt;prerelease-id&gt;] | from-git]</span><br><span class="line">(run in package dir)</span><br><span class="line">&#39;npm -v&#39; or &#39;npm --version&#39; to print npm version (6.4.1)</span><br><span class="line">&#39;npm view &lt;pkg&gt; version&#39; to view a package&#39;s published version</span><br><span class="line">&#39;npm ls&#39; to inspect current package&#x2F;dependency versions</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p><code>npm version</code>获取当前的详细版本信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &#39;npm-version-test&#39;: &#39;1.0.0&#39;,</span><br><span class="line">  npm: &#39;6.4.1&#39;,</span><br><span class="line">  ares: &#39;1.14.0&#39;,</span><br><span class="line">  cldr: &#39;33.1&#39;,</span><br><span class="line">  http_parser: &#39;2.8.0&#39;,</span><br><span class="line">  icu: &#39;62.1&#39;,</span><br><span class="line">  modules: &#39;64&#39;,</span><br><span class="line">  napi: &#39;3&#39;,</span><br><span class="line">  nghttp2: &#39;1.33.0&#39;,</span><br><span class="line">  node: &#39;10.10.0&#39;,</span><br><span class="line">  openssl: &#39;1.1.0i&#39;,</span><br><span class="line">  tz: &#39;2018e&#39;,</span><br><span class="line">  unicode: &#39;11.0&#39;,</span><br><span class="line">  uv: &#39;1.23.0&#39;,</span><br><span class="line">  v8: &#39;6.8.275.30-node.24&#39;,</span><br><span class="line">  zlib: &#39;1.2.11&#39; &#125;</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>版本号有三位</p>
<blockquote>
<p>   <strong>major.minor.patch</strong></p>
<p>   主版本号.次版本号.修补版本号</p>
<ul>
<li>patch：修复bug，兼容老版本</li>
<li>minor：新增功能，兼容老版本</li>
<li>major：新的架构调整，不兼容老版本</li>
</ul>
</blockquote>
<h5 id="prerelease"><a href="#prerelease" class="headerlink" title="prerelease"></a>prerelease</h5><ol>
<li><code>npm version prerelease</code><br>package.json 中的版本号<code>1.0.0</code>变为 <code>1.0.1-0</code></li>
<li>再次执行 <code>npm version prerelease</code><br>package.json 中的版本号<code>1.0.1-0</code>变为 <code>1.0.1-1</code></li>
</ol>
<blockquote>
<p>5,6操作说明 当执行<code>npm version prerelease</code>时，如果没有预发布号，则增加minor，同时prerelease 设为0；<br>如果有prerelease， 则prerelease 增加1。</p>
</blockquote>
<h5 id="prepatch"><a href="#prepatch" class="headerlink" title="prepatch"></a>prepatch</h5><ol>
<li><code>npm version prepatch</code><br>package.json 中的版本号<code>1.0.1-1</code>变为 <code>1.0.2-0</code></li>
</ol>
<blockquote>
<p>prepatch - 直接升级小号，增加预发布号为0。</p>
</blockquote>
<h5 id="preminor"><a href="#preminor" class="headerlink" title="preminor"></a>preminor</h5><ol>
<li><code>npm version preminor</code><br>package.json 中的版本号<code>1.0.2-0</code>变为 <code>1.1.0-0</code></li>
</ol>
<blockquote>
<p>preminor - 直接升级中号，小号置为0，增加预发布号为0。</p>
</blockquote>
<ol>
<li><code>npm version premajor</code><br>package.json 中的版本号<code>1.1.0-0</code>变为 <code>2.0.0-0</code></li>
</ol>
<blockquote>
<p>premajor - 直接升级大号，中号、小号置为0，增加预发布号为0。</p>
</blockquote>
<h5 id="patch-主要目的升级patch"><a href="#patch-主要目的升级patch" class="headerlink" title="patch: 主要目的升级patch"></a>patch: 主要目的升级patch</h5><ol>
<li><code>npm version patch</code><br>package.json 中的版本号<code>2.0.0-0</code>变为 <code>2.0.0</code>;</li>
<li>再次执行<code>npm version patch</code><br>package.json 中的版本号<code>2.0.0</code>变为 <code>2.0.1</code>;</li>
</ol>
<blockquote>
<p>10,11 操作说明，patch：如果有prerelease ，则去掉prerelease ，其他保持不变；<br>如果没有prerelease ，则升级minor.</p>
</blockquote>
<h5 id="minor：-主要目的升级minor"><a href="#minor：-主要目的升级minor" class="headerlink" title="minor： 主要目的升级minor"></a>minor： 主要目的升级minor</h5><ol>
<li><code>npm version minor</code><br>package.json 中的版本号<code>2.0.1</code>变为 <code>2.1.0</code>;</li>
</ol>
<blockquote>
<p>如果没有prerelease，直接升级minor， 同时patch设置为0；</p>
</blockquote>
<ol>
<li><code>npm version premajor</code> <code>2.1.0</code>–&gt; <code>3.0.0-0</code>;</li>
<li><code>npm version minor</code> <code>3.0.0-0</code>–&gt; <code>3.0.0</code>;</li>
<li><code>npm version prepatch</code> <code>3.0.0</code>–&gt;<code>3.0.1-0</code>;</li>
<li><code>npm version minor</code> <code>3.0.1-0</code>–&gt;<code>3.1.0</code>;</li>
</ol>
<blockquote>
<p>如果有prerelease， 首先需要去掉prerelease；如果patch为0，则不升级minor：如<code>14</code>；<br>如果patch不为0， 则升级minor，同时patch设为0，如<code>16</code>。</p>
</blockquote>
<h5 id="major-：主要目的升级major"><a href="#major-：主要目的升级major" class="headerlink" title="major ：主要目的升级major"></a>major ：主要目的升级major</h5><ol>
<li><code>npm version major</code> : <code>3.1.0</code> –&gt;<code>4.0.0</code></li>
</ol>
<blockquote>
<p>如果没有prelease，则直接升级major，其他位都置为0；</p>
</blockquote>
<ol>
<li><code>npm version premajor</code>: <code>4.0.0</code> –&gt; <code>5.0.0-0</code>;</li>
</ol>
<blockquote>
<p>如果有预发布号： minor和patch都为0，则不升级major，只将prerelease 去掉。</p>
</blockquote>
<ol>
<li><code>npm version preminor</code> : <code>5.0.0-0</code>–&gt; <code>5.1.0-0</code></li>
<li><code>npm version major</code> : <code>5.1.0-0</code> –&gt;<code>6.0.0</code></li>
</ol>
<h3 id="查看安装包信息"><a href="#查看安装包信息" class="headerlink" title="查看安装包信息"></a>查看安装包信息</h3><p>npm list    #查看本地安装包信息</p>
<p>npm list -g  #查看全局安装包信息</p>
<p>npm list express #查看某个安装包信息</p>
<p>npm ls    #npm list简写</p>
<p><img src="http://upload-images.jianshu.io/upload_images/15009210-77025bd3552afff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327/format/webp" alt="img"></p>
<h3 id="提升下载包的速度"><a href="#提升下载包的速度" class="headerlink" title="提升下载包的速度"></a>提升下载包的速度</h3><p>由于npm的包大多是在国外数据库，下载速度会受到影响，我们想快一点，可以使用国内的淘宝镜像。</p>
<p>淘宝NPM镜像是一个完成的npmjs.org镜像，基本与官网服务一致。</p>
<h3 id="镜像地址"><a href="#镜像地址" class="headerlink" title="镜像地址"></a>镜像地址</h3><h4 id="淘宝镜像："><a href="#淘宝镜像：" class="headerlink" title="淘宝镜像："></a>淘宝镜像：</h4><ul>
<li>搜索地址：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fnpm.taobao.org%2F" target="_blank" rel="noopener">http://npm.taobao.org/</a></li>
<li>registry地址：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fregistry.npm.taobao.org%2F" target="_blank" rel="noopener">http://registry.npm.taobao.org/</a></li>
</ul>
<h4 id="官网镜像："><a href="#官网镜像：" class="headerlink" title="官网镜像："></a>官网镜像：</h4><ul>
<li>搜索地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" rel="noopener">https://www.npmjs.com/</a></li>
<li>registry地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fregistry.npmjs.org%2F" target="_blank" rel="noopener">https://registry.npmjs.org/</a></li>
</ul>
<h4 id="使用淘宝镜像"><a href="#使用淘宝镜像" class="headerlink" title="使用淘宝镜像"></a>使用淘宝镜像</h4><p>//临时使用淘宝镜像</p>
<p>#安装包时临时制定镜像地址 npm –registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> </p>
<p>install express</p>
<p>//持久使用淘宝镜像</p>
<p>先配置npm镜像，然后再安装包</p>
<ul>
<li><p>配置镜像：</p>
<p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>  #设置成淘宝镜像</p>
<p>npm config set registry <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a>    #设置成官网的</p>
</li>
<li><p>监测是否设置成功</p>
<p>npm config get registry   #查询镜像地址</p>
<p>npm info express #查询镜像地址</p>
</li>
<li><p>使用cnpm来使用淘宝镜像</p>
</li>
<li><p>安装cnpm</p>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</li>
<li><p>使用cnpm安装包</p>
<p>cnpm install [name]</p>
</li>
<li><p>使用nrm来管理切换npm源</p>
<p>nrm专门用来管理和快速切换私人配置的registry。</p>
</li>
<li><p>安装</p>
<p>npm install -g nrm</p>
</li>
<li><p>列出可选源</p>
<p>nrm ls</p>
</li>
<li><p>切换源</p>
<p>nrm use taobao</p>
</li>
<li><p>增加源</p>
<p>nrm add &lt;源名称&gt; &lt;源地址&gt;   #比如企业或组织有自己的私有源（镜像）时</p>
</li>
<li><p>删除源</p>
<p>nrm del</p>
</li>
<li><p>测试源响应</p>
<p>nrm test   #测试所有源nrm test npm  #测试npm官方源</p>
</li>
</ul>
<h3 id="如何创建和发布自己的包"><a href="#如何创建和发布自己的包" class="headerlink" title="如何创建和发布自己的包"></a>如何创建和发布自己的包</h3><ul>
<li><p>创建模块</p>
<p>npm init</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/15009210-39b52d3d66dece35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp" alt="img"></p>
<p>​    此时，生成了package.json配置文件</p>
<ul>
<li><p>增加入口文件</p>
<p>默认的入口文件是根目录下的index.js，在根目录下创建index.js</p>
<p>//index.js</p>
<p>exports.printMsg = function() {    </p>
<p>​    console.log(“This is a message from the demo package”);</p>
<p>}</p>
</li>
</ul>
<ul>
<li><p>登录或注册npm账号</p>
<p>npm adduser  #注册npm账号</p>
<p>npm login #登录npm账号</p>
</li>
</ul>
<ul>
<li><p>发布包</p>
<p>发布包之前，我们需要做两步：</p>
</li>
</ul>
<ol>
<li><p>修改CHANGE.MD，这里记录了我们包发布的版本变化情况，格式自定</p>
</li>
<li><p>修改package.json中的version字段，表示这次发布的包的版本，如果不修改，发布会报错。</p>
<p>发布包：</p>
<p>npm publish</p>
</li>
</ol>
<ul>
<li><p>撤销发布</p>
<p>撤销发布自己发布过的某个版本代码</p>
<p>npm unpublish <package>@<version></version></package></p>
<p>发布成功之后，这个包就可以通过npm install命令来进行安装了。</p>
</li>
<li><p>管理包的版本</p>
<p>当我们下载和发布我们的包时，都会关注到包的版本号，npm使用语义版本号来管理包。</p>
<p>语义版本号组成：X.Y.Z</p>
<ul>
<li>X代表主版本号，表示有大变动，向下不兼容</li>
<li>Y代表次版本号，表示新增功能，向下兼容</li>
<li>Z代表补丁版本号，表示修复BUG</li>
</ul>
</li>
</ul>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul>
<li>卸载nodejs</li>
</ul>
<p>C:\ProgramData\Microsoft\Windows\Start Menu这个路径下面有个uninstall node.js点击运行在安装就行了，正常卸载才能重装</p>
<ul>
<li>清除缓存</li>
</ul>
<p>npm cache clean –force</p>
<ul>
<li><p>show和update</p>
<p>npm show xxx  //显示模块详情<br>npm update  //升级当前目录下的项目的所有模块<br>npm update xxx  //升级当前目录下的项目的指定模块<br>npm update -g xxx  //升级全局安装的指定模块</p>
</li>
</ul>
<ul>
<li><p>安装/卸载 babel</p>
<p>npm install <a href="mailto:babel-loader@7.1.5">babel-loader@7.1.5</a></p>
<p>npm uninstall babel-loader</p>
</li>
<li><p>install细讲</p>
<p>npm install xxx  //安装模块如不指定版本号，默认会安装最新的版本，安装但不写package.json<br>npm install xxx 0.0.1  //安装指定版本的模块<br>npm install –save xxx //安装并把模块的版本信息保存到dependencies（生产环境依赖）中，即你的package.json文件的dependencies字段中<br>npm install –global xxx<br>npm install –save-dev xxx //安装并把模块版本信息保存到devDependencies（开发环境依赖）中，即你的package.json文件的devDependencies字段中<br>npm install –save-optional xxx //安装并把模块安装到optionalDependencies（可选环境依赖）中，即你的package.json文件的optionalDependencies字段中<br>npm install –save-exact xxx //精确的安装指定版本的模块，dependencies字段里每个模块版本号前面的^会取消掉</p>
</li>
<li><p>常见安装</p>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<p>npm国内淘宝的镜像（因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。” ）</p>
</li>
</ul>
<p>  npm install -g express</p>
<p>  全局安装express模块</p>
<p>  npm install -g vue-cli</p>
<p>  全局安装vue-cli模块</p>
<p>  npm install -g supervisor</p>
<p>  用于服务器上Node.js应用崩溃的时候，自动重新启动。当然它也可以监控你的项目的js文件变化，自动重启来方便调试。</p>
<p>  npm install -g pm2</p>
<p>  PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>
<p>  npm install -s mongoose</p>
<p>  Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具,可以简单理解为链接、操作MongoDB数据库</p>
<p>  npm install -s md5</p>
<p>  这个就不解释了，MD5数据加密</p>
<p>  npm install -s express-session</p>
<p>  操作服务器端的session</p>
<p>  npm install -s connect-flash</p>
<p>  connect-flash是nodejs中的一个模块，flash是一个暂存器，而且暂存器里面的值使用过一次便被清空，适合用来做网站的提示信息。</p>
<p>  npm install -s multer</p>
<p>  Multer是一个node.js中间件，用于处理multipart/form-data，主要用于上传文件。</p>
<h3 id="‘gulp’不是内部或外部命令，也没是可运行的程序或批处理文件-问题解决方法"><a href="#‘gulp’不是内部或外部命令，也没是可运行的程序或批处理文件-问题解决方法" class="headerlink" title="‘gulp’不是内部或外部命令，也没是可运行的程序或批处理文件,问题解决方法"></a>‘gulp’不是内部或外部命令，也没是可运行的程序或批处理文件,问题解决方法</h3><p>解决方法：</p>
<p><strong>解决方法一</strong>：设置环境变量</p>
<p>1.计算机(右击)-&gt;属性-&gt;高级系统设置 -&gt; 高级-&gt;环境变量</p>
<p>2.找到node全局文件路径，输入npm config get prefix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure>

<p>C:\Users\Administrator\AppData\Roaming\npm 这个路径就是node全局文件路径</p>
<p><img src="https://images2015.cnblogs.com/blog/1119043/201704/1119043-20170405172531019-1392920719.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/1119043/201704/1119043-20170405172858613-839239581.png" alt="img"></p>
<p>3.关闭命令行窗口，重新打开</p>
<p><strong>解决方法二</strong>：全局安装gulp(简单快速，推荐)</p>
<p>1.说明：全局安装gulp的目的是通过它执行gulp任务</p>
<p>2.安装：命令提示符执行npm install gulp -g</p>
<p>3.命令提示符执行gulp -v ，验证一下是否正确安装</p>
<p>出现版本号，说明问题已经解决，可以使用gulp-v、gulp less、gulp build等执行操作</p>
<p><img src="https://images2015.cnblogs.com/blog/1119043/201704/1119043-20170405173920191-1512489935.png" alt="img"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1.两种方法配置完成之后，命令提示符都需关闭之后，再重新打开，才能起作用。</p>
<p>2.没有安装全局的gulp，只安装了本地gulp,命令行无法执行gulp-v，也无法执行gulp其它的相关命令。</p>
<p>参考资料：</p>
<p>官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com.cn%2Fgetting-started%2Finstalling-npm-packages-locally%2F" target="_blank" rel="noopener">https://www.npmjs.com.cn/getting-started/installing-npm-packages-locally/</a></p>
<p>菜鸟教程：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-npm.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-npm.html</a></p>
<p>npm脚本使用：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F10%2Fnpm_scripts.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a></p>
<p>package.json说明：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fnodejs%2Fpackagejson.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/packagejson.html</a></p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>packageJson</tag>
      </tags>
  </entry>
  <entry>
    <title>nrm切换仓库源</title>
    <url>/2020/07/30/nrm%E5%88%87%E6%8D%A2%E4%BB%93%E5%BA%93%E6%BA%90/</url>
    <content><![CDATA[<h2 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h2><p>先描述一下没有nrm时我们是怎样使用npm源的</p>
<p>查看npm源地址，终端中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure>

<p>可以看到npm源</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">metrics-registry &#x3D; &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>如果需要修改registry地址，例如切换到国内的淘宝源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>如果要删除这个源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config rm registry</span><br></pre></td></tr></table></figure>

<p>这种方式缺乏对源的管理，切换源需要每次配置地址。如果使用中切换源比较频繁，那么步骤也很繁琐，所以我引入nrm这一源管理器。</p>
<h2 id="1-nrm是什么"><a href="#1-nrm是什么" class="headerlink" title="1. nrm是什么"></a>1. nrm是什么</h2><p>nrm 是一个 npm 源管理器，允许你快速地在 npm 源间切换。</p>
<p>什么意思呢，npm默认情况下是使用npm官方源（使用npm config ls命令可以查看），在国内用这个源肯定是不靠谱的，一般我们都会用淘宝npm源：<a href="https://registry.npm.taobao.org/，修改源的方式也很简单，在终端输入：" target="_blank" rel="noopener">https://registry.npm.taobao.org/，修改源的方式也很简单，在终端输入：</a></p>
<p>npm set registry <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a></p>
<p>再npm config ls查看，已经切换成功。</p>
<h2 id="2-安装nrm"><a href="#2-安装nrm" class="headerlink" title="2. 安装nrm"></a>2. 安装nrm</h2><p>在命令行执行如下命令，全局安装nrm。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure>

<h2 id="3-添加新的源"><a href="#3-添加新的源" class="headerlink" title="3. 添加新的源"></a>3. 添加新的源</h2><p>执行命令 nrm add <registry> <url>，其中 registry 为源名，<code>url</code>为源的路径。例如下面添加公司的私有源。</url></registry></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm add yuxxxx http:&#x2F;&#x2F;sinxxx.yuxxxx.cn:4123&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="4-切换源"><a href="#4-切换源" class="headerlink" title="4. 切换源"></a>4. 切换源</h2><p>执行命令 nrm use <registry>切换源。</registry></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm use yuxxxx</span><br></pre></td></tr></table></figure>

<h2 id="5-查看源"><a href="#5-查看源" class="headerlink" title="5. 查看源"></a>5. 查看源</h2><p>用nrm ls命令查看默认配置，带*号即为当前使用的源。可以看出切换已生效。</p>
<p><img src="https://img2018.cnblogs.com/blog/1001990/201905/1001990-20190515011742654-110730281.png" alt="img"></p>
<h2 id="6-测试源响应时间"><a href="#6-测试源响应时间" class="headerlink" title="6. 测试源响应时间"></a>6. 测试源响应时间</h2><p>通过nrm test <registry>测试相应源的响应时间。</registry></p>
<h2 id="7-删除源"><a href="#7-删除源" class="headerlink" title="7. 删除源"></a>7. 删除源</h2><p>执行命令 nrm del <registry> 删除对应的源。</registry></p>
<h2 id="8-使用zpm私有仓库源"><a href="#8-使用zpm私有仓库源" class="headerlink" title="8. 使用zpm私有仓库源"></a>8. 使用zpm私有仓库源</h2><p>举例</p>
<p>全局安装nrm</p>
<p>npm i nrm -g</p>
<p>添加仓库源<br>nrm add zpm <a href="http://119.45.186.39:4873/" target="_blank" rel="noopener">http://119.45.186.39:4873/</a></p>
<p>删除仓库源<br>nrm del zpm</p>
<p>登录用户<br>npm login</p>
<p>注册用户<br>npm adduser –registry <a href="http://119.45.186.39:4873/" target="_blank" rel="noopener">http://119.45.186.39:4873/</a></p>
<p>接下来会提示用户名，密码，邮箱，请记住这些，因为接下来还会用到<br>打开浏览器访问 <a href="http://119.45.186.39:4873/" target="_blank" rel="noopener">http://119.45.186.39:4873/</a><br>点击右上角登录，输入用户名密码，这时展示臻旅提供的包则说明可以下载<br>使用私有仓库源<br>nrm use zpm</p>
<p>补充说明：<br>nrm 命令报错（无法加载文件 C:\Users\hc\AppData\Roaming\npm\nrm.ps1 ，因为在此系统上禁止运行脚本。）<br>解决方式如下：<br>1.win+s 搜索powershell 以管理身份运行<br>2.使用set-ExecutionPolicy RemoteSigned命令将计算机上的执行策略更改为 RemoteSigned,输入Y确定<br>3.查看计算机执行策略get-ExecutionPolicy<br>4.执行命令：Set-ExecutionPolicy RemoteSigned -Scope Process再次输入Y问题解`</p>
]]></content>
      <categories>
        <category>nrm</category>
      </categories>
      <tags>
        <tag>nrm</tag>
        <tag>zpm</tag>
        <tag>仓库源</tag>
      </tags>
  </entry>
  <entry>
    <title>overflow</title>
    <url>/2020/07/30/overflow/</url>
    <content><![CDATA[<h3 id="overflow详解"><a href="#overflow详解" class="headerlink" title="overflow详解"></a>overflow详解</h3><p>为使 overflow 有效果，块级容器必须有一个指定的高度（height或者max-height）或者将white-space设置为nowrap。</p>
<p>注意:  设置一个轴为visible（默认值），同时设置另一个轴为不同的值，会导致设置visible的轴的行为会变成auto。 </p>
<p>注意: 即使将overflow设置为hidden，也可以使用JavaScript <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/API/Element/scrollTop" target="_blank" rel="noopener">Element.scrollTop</a> 属性来滚动HTML元素。</p>
<a id="more"></a>

<p>语法</p>
<p>/* 默认值。内容不会被修剪，会呈现在元素框之外 <em>/overflow: visible;/</em> 内容会被修剪，并且其余内容不可见 <em>/overflow: hidden;/</em> 内容会被修剪，浏览器会显示滚动条以便查看其余内容 <em>/overflow: scroll;/</em> 由浏览器定夺，如果内容被修剪，就会显示滚动条 <em>/overflow: auto;/</em> 规定从父元素继承overflow属性的值 */overflow: inherit;</p>
<p> 从下面列表中选出一个或两个关键字来指定overflow 属性。如果指定了两个关键字，第一个关键字应用于overflow-x，第二个关键字应用于overflow-y。否则，overflow-x和overflow-y都设置为相同的值。</p>
<p>注意: 在Firefox 63之前，这些值是反向的，第一个值应用于overflow-y，第二个值应用于overflow-x。Firefox 63更新了这个顺序，以匹配对<a href="https://www.fxsitecompat.com/en-CA/docs/2018/overflow-shorthand-syntax-has-been-updated-to-swap-2-values/" target="_blank" rel="noopener">规范的更改</a>。此更改是为了匹配使用新逻辑属性overflow-block和overflow-inline时的顺序。</p>
<p>overflow-x: scroll;overflow-y: hidden;</p>
<p>/* On Firefox 61 and 62, this is the same as <em>/  overflow: hidden scroll;</em></p>
<p>/* But on Firefox 63 and later, it will be */   overflow: scroll hidden;</p>
<p>值</p>
<p>visible</p>
<p>默认值。内容不会被修剪，可以呈现在元素框之外。</p>
<p>hidden</p>
<p>如果需要，内容将被剪裁以适合填充框。 不提供滚动条。</p>
<p>scroll</p>
<p>如果需要，内容将被剪裁以适合填充框。 浏览器显示滚动条，无论是否实际剪切了任何内容。 （这可以防止滚动条在内容更改时出现或消失。）打印机仍可能打印溢出的内容。</p>
<p>auto</p>
<p>取决于用户代理。 如果内容适合填充框内部，则它看起来与可见内容相同，但仍会建立新的块格式化上下文。 如果内容溢出，桌面浏览器会提供滚动条。</p>
<p>overlay  </p>
<p>行为与auto相同，但滚动条绘制在内容之上而不是占用空间。 仅在基于WebKit（例如，Safari）和基于Blink的（例如，Chrome或Opera）浏览器中受支持。</p>
<p>Mozilla 扩展</p>
<p>-moz-scrollbars-none <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow#Deprecated" target="_blank" rel="noopener">[1]</a></p>
<p>使用 overflow:hidden 代替.</p>
<p>-moz-scrollbars-horizontal <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow#Deprecated" target="_blank" rel="noopener">[1]</a></p>
<p>推荐使用 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow-x" target="_blank" rel="noopener">overflow-x</a> 和 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow-y" target="_blank" rel="noopener">overflow-y</a> .</p>
<p>-moz-scrollbars-vertical <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow#Deprecated" target="_blank" rel="noopener">[1]</a></p>
<p>推荐使用 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow-x" target="_blank" rel="noopener">overflow-x</a> 和 <a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/overflow-y" target="_blank" rel="noopener">overflow-y</a> .</p>
<p>-moz-hidden-unscrollable </p>
<p>主要用于内部和主题。禁用 方向键 和 鼠标滚轮 来滚动XML跟元素以及<HTML>和<body>元素。</body></HTML></p>
]]></content>
      <categories>
        <category>overflow</category>
      </categories>
      <tags>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title>packageJson</title>
    <url>/2020/07/30/packageJson/</url>
    <content><![CDATA[<h3 id="packageJson"><a href="#packageJson" class="headerlink" title="packageJson"></a>packageJson</h3><p>随着前端由多页面到单页面，由零散的文件到模块化开发，在一个完整的项目中，package.json 文件无处不在。首先，在项目根目录会有，其次在 node_modules 中也频现。那么这个文件到底是干嘛的，又有什么作用，今天给大家揭晓。</p>
<h3 id="一、package-json-文件作用"><a href="#一、package-json-文件作用" class="headerlink" title="一、package.json 文件作用"></a>一、package.json 文件作用</h3><p>package.json 文件其实就是对项目或者模块包的描述，里面包含许多元信息。比如项目名称，项目版本，项目执行入口文件，项目贡献者等等。npm install 命令会根据这个文件下载所有依赖模块。</p>
<a id="more"></a>

<h3 id="二、package-json-文件创建"><a href="#二、package-json-文件创建" class="headerlink" title="二、package.json 文件创建"></a>二、package.json 文件创建</h3><p>package.json 文件创建有两种方式，手动创建或者自动创建。</p>
<p>手动创建</p>
<p>直接在项目根目录新建一个 package.json 文件，然后输入相关的内容。</p>
<p>自动创建</p>
<p>也是在项目根目录下执行 npm init，然后根据提示一步步输入相应的内容完成后即可自动创建。</p>
<h3 id="三、package-json-文件示例"><a href="#三、package-json-文件示例" class="headerlink" title="三、package.json 文件示例"></a>三、package.json 文件示例</h3><p><img src="/2020/07/30/packageJson/clipboard.png" alt="clipboard"></p>
<h3 id="四、package-json-文件配置说明"><a href="#四、package-json-文件配置说明" class="headerlink" title="四、package.json 文件配置说明"></a>四、package.json 文件配置说明</h3><ul>
<li>name：项目/模块名称，长度必须小于等于214个字符，不能以”.”(点)或者”_”(下划线)开头，不能包含大写字母。</li>
<li>version：项目版本。</li>
<li>author：项目开发者，它的值是你在<a href="https://npmjs.org网站的有效账户名，遵循“账户名" target="_blank" rel="noopener">https://npmjs.org网站的有效账户名，遵循“账户名</a>&lt;邮件&gt;”的规则，例如：zhangsan <a href="mailto:zhangsan@163.com">zhangsan@163.com</a>。</li>
<li>description：项目描述，是一个字符串。它可以帮助人们在使用npm search时找到这个包。</li>
<li>keywords：项目关键字，是一个字符串数组。它可以帮助人们在使用npm search时找到这个包。</li>
<li>private：是否私有，设置为 true 时，npm 拒绝发布。</li>
<li>license：软件授权条款，让用户知道他们的使用权利和限制。</li>
<li>bugs：bug 提交地址。</li>
<li>contributors：项目贡献者 。</li>
<li>repository：项目仓库地址。</li>
<li>homepage：项目包的官网 URL。</li>
<li>dependencies：生产环境下，项目运行所需依赖。</li>
<li>devDependencies：开发环境下，项目所需依赖。</li>
<li>scripts：执行 npm 脚本命令简写，比如 “start”: “react-scripts start”, 执行 npm start 就是运行 “react-scripts start”。</li>
<li>bin：内部命令对应的可执行文件的路径。</li>
<li>main：项目默认执行文件，比如 require(‘webpack’)；就会默认加载 lib 目录下的 webpack.js 文件，如果没有设置，则默认加载项目跟目录下的 index.js 文件。</li>
<li>module：是以 ES Module(也就是 ES6)模块化方式进行加载，因为早期没有 ES6 模块化方案时，都是遵循 CommonJS 规范，而 CommonJS 规范的包是以 main 的方式表示入口文件的，为了区分就新增了 module 方式，但是 ES6 模块化方案效率更高，所以会优先查看是否有 module 字段，没有才使用 main 字段。</li>
<li>eslintConfig：EsLint 检查文件配置，自动读取验证。</li>
<li>engines：项目运行的平台。</li>
<li>browserslist：供浏览器使用的版本列表。</li>
<li>style：供浏览器使用时，样式文件所在的位置；样式文件打包工具parcelify，通过它知道样式文件的打包位置。</li>
<li>files：被项目包含的文件名数组。</li>
</ul>
<p>补充（<a href="http://www.w3cbus.com/nodejs/packagejson.html#toc11" target="_blank" rel="noopener">http://www.w3cbus.com/nodejs/packagejson.html#toc11</a>）</p>
<ul>
<li><p>man字段</p>
<p>man用来指定当前模块的man文档的位置。</p>
<p>“man” :[ “./doc/calc.1” ]</p>
</li>
<li><p>preferGlobal字段</p>
</li>
<li><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>
</li>
<li><p>browser字段</p>
<p>browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。</p>
<p>“browser”: {  “tipso”: “./node_modules/tipso/src/tipso.js”},</p>
</li>
<li><p>config字段</p>
<p>config字段用于向环境变量输出值。</p>
</li>
</ul>
<p>下面是一个package.json文件。</p>
<p>{  “name” : “foo”,  “config” : { “port” : “8080” },  “scripts” : { “start” : “node server.js” }}</p>
<p>然后，在server.js脚本就可以引用config字段的值。</p>
<p>http.createServer(…).listen(process.env.npm_package_config_port)</p>
<p>用户可以改变这个值。</p>
<p>$ npm config set foo:port 80</p>
<p>peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。</p>
<p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。</p>
<p>大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>
<p>最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。</p>
<p>{  “name”: “chai-as-promised”,  “peerDependencies”: {    “chai”: “1.x”  }}</p>
<p>上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。</p>
<p>注意，从npm 3.0版开始，peerDependencies不再会默认安装了。</p>
<p>![clipboard (1)](packageJson.assets/clipboard (1).png)</p>
]]></content>
      <categories>
        <category>packageJson</category>
      </categories>
      <tags>
        <tag>packageJson</tag>
      </tags>
  </entry>
  <entry>
    <title>postman</title>
    <url>/2020/07/30/postman/</url>
    <content><![CDATA[<h3 id="Postman介绍"><a href="#Postman介绍" class="headerlink" title="Postman介绍"></a>Postman介绍</h3><p>Postman是google开发的一款功能强大的网页调试与发送网页HTTP请求，并能运行测试用例的的Chrome插件。其主要功能包括：</p>
<ul>
<li><strong>模拟各种HTTP requests</strong></li>
</ul>
<p>从常用的 GET、POST 到 RESTful 的 PUT 、 DELETE …等等。 甚至还可以发送文件、送出额外的 header。</p>
<ul>
<li><strong>Collection 功能（测试集合）</strong></li>
</ul>
<a id="more"></a>

<p>Collection 是 requests的集合，在做完一個测试的時候， 你可以把這次的 request 存到特定的 Collection 里面，如此一來，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API.而且 Collection 还可以 Import 或是 Share 出來，让团队里面的所有人共享你建立起來的 Collection。</p>
<ul>
<li><strong>人性化的Response整理</strong></li>
</ul>
<p>一般在用其他工具來测试的時候，response的内容通常都是纯文字的 raw， 但如果是 JSON ，就是塞成一整行的 JSON。这会造成阅读的障碍 ，而 Postman 可以针对response内容的格式自动美化。 JSON、 XML 或是 HTML 都會整理成我们可以阅读的格式</p>
<ul>
<li><strong>内置测试脚本语言</strong></li>
</ul>
<p>Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果</p>
<ul>
<li><strong>设定变量与环境</strong></li>
</ul>
<p>Postman 可以自由 设定变量与Environment，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我們可能会有多种环境， development 、 staging 或 local， 而这几种环境中的 request URL 也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。</p>
<h3 id="安装Postman"><a href="#安装Postman" class="headerlink" title="安装Postman"></a>安装Postman</h3><p>Postman作为一个chrome的插件，你可以打开chrome，在chrome webstore里面找到。当然，如果是在国内，你需要翻墙，否则的话，你只能百度一下，搜索postman的安装包自己安装到chrome上（这里就不赘述了，有很多类似的文章）。这里需要提一下的是，你可以不用打开chrome而直接使用Postman，具体的方法是：</p>
<p>选项-&gt;更多工具-&gt;扩展程序</p>
<p><img src="https://img-blog.csdn.net/20160601165759918" alt="img"></p>
<p>详细信息-&gt;创建快捷方式-&gt;‘全部勾上’<br><img src="https://img-blog.csdn.net/20160601165947779" alt="img"><br>这样你就可以在任何地方启动你的Postman了</p>
<h3 id="Postman-sending-requests"><a href="#Postman-sending-requests" class="headerlink" title="Postman sending requests"></a>Postman sending requests</h3><p>安装好之后，我们先打开Postman，可以看到界面分成左右两个部分，右边是我们后头要讲的collection，左边是现在要讲的request builder。在request builder中，我们可以通过Postman快速的随意组装出我们希望的request。一般来说，所有的HTTP Request都分成4个部分，URL, method, headers和body。而Postman针对这几部分都有针对性的工具。</p>
<p><img src="https://img-blog.csdn.net/20160601170546927" alt="img"></p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>要组装一条Request, URL永远是你首先要填的内容，在Postman里面你曾输入过的URL是可以通过下拉自动补全的哦。如果你点击<strong>Params</strong>按钮，Postman会弹出一个键值编辑器，你可以在哪里输入URL的Parameter，Postman会帮你自动加入到URL当中，反之，如果你的URL当中已经有了参数，那Postman会在你打开键值编辑器的时候把参数自动载入</p>
<p><img src="https://img-blog.csdn.net/20160601171111335" alt="这里写图片描述"></p>
<h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h4><p>点击’Headers’按钮，Postman同样会弹出一个键值编辑器。在这里，你可以随意添加你想要的Header attribute，同样Postman为我们通过了很贴心的auto-complete功能，敲入一个字母，你可以从下拉菜单里选择你想要的标准atrribute</p>
<p><img src="https://img-blog.csdn.net/20160601172202011" alt="这里写图片描述"></p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>要选择Request的Method是很简单的，Postman支持所有的Method，而一旦你选择了Method，Postman的request body编辑器会根据的你选择，自动的发生改变</p>
<p><img src="https://img-blog.csdn.net/20160601172720544" alt="这里写图片描述"></p>
<h4 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a>Request Body</h4><p>如果我们要创建的request是类似于POST，那我们就需要编辑Request Body，Postman根据body type的不同，提供了4中编辑方式：</p>
<ul>
<li>form-data</li>
<li>x-www-form-urlencoded</li>
<li>raw</li>
<li>binary</li>
<li><img src="https://img-blog.csdn.net/20160601173348297" alt="img"></li>
</ul>
<p>（我们这里是可以传文件的哦）</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>我这里创建一条发送给google geocode的request，看看是啥结果：</p>
<p><img src="https://img-blog.csdn.net/20160601173955815" alt="这里写图片描述"></p>
<p>注意，在URL里面我使用了变量googleMaps，并用插值表达式调用它，这里是类似于AngulaJs的语法（果然是同一家人），其返回值是：<a href="http://maps.googleapis.com/maps/api/geocode/json" target="_blank" rel="noopener">http://maps.googleapis.com/maps/api/geocode/json</a>。而这个变量我是定义在我的环境GoogleApiTest里面的。这部分的内容会在接下来的文章里面讲到。</p>
<p>点击了Send之后，可以在Postman上直接看到response的内容，内容很漂亮，Postman根据内容检索自动按JSON的格式显示出来，同时我们可以清楚的看到status code和花费的时间。</p>
<p><img src="https://img-blog.csdn.net/20160601174202429" alt="这里写图片描述"></p>
<p>写到这，我想大家已经能够了解如何用Postman组装Request并且查看Response的内容了，那我们怎么用Postman去做测试呢，且听下回分解</p>
<p>我们已经知道如何用Postman组装并发送消息，那我们如何根据需求用Postman来做测试呢？在这开始之前，我们先来看看Postman的左边面板：</p>
<p><img src="https://img-blog.csdn.net/20160601175613918" alt="这里写图片描述"></p>
<p>这里包含了History和Collection，我们可以在History里面看到我们曾经发送过的HTTP Request, 我们可以很方便的通过点击上面的项重新构建我们的request。而右边的Request Builder面板上，还有两个按钮，Pre-request Script和Tests。</p>
<ul>
<li>Pre-request Script<br>定义我们在发送request之前需要运行的一些脚本，应用场景主要是设置全局变量和环境变量</li>
<li>Tests<br>定义发送Request之后，需要用脚本检测的内容，也就是Test case的内容。</li>
</ul>
<p>这里的的Tests是我们关键。</p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>打开Tests，我们可以看到窗口分成两部分，一部分是左边的代码窗口和右边的Snippet窗口，点击对应的snippet，postman会在左边的窗口为我们生成对应的代码，在下面的图中，我选择了“Response body: is equal to a String”和“Response time is less than 200ms”，可以看到Postman在代码窗口为我加载对应的语句，这里我把希望的responseBody改成了“No valid parameters!!”.<br>这样我就完成一条简单的测试用例：</p>
<ul>
<li>当HTTP Get request没有带任何参数的时候，希望response的body返回字符串“No valid parameters!!”</li>
<li>responseTime小于200ms</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160602113359840" alt="这里写图片描述"></p>
<h3 id="Variables-and-Environment"><a href="#Variables-and-Environment" class="headerlink" title="Variables and Environment"></a>Variables and Environment</h3><p>另外，这里大家可以看到在URL输入框中，我使用了，那我们如何定义变量呢，首先，我们得创建一个Environment，点击Environment那个button（在这里是“SampleEnv”那个button，因为我将其选择我当前使用的Environment）</p>
<p><img src="https://img-blog.csdn.net/20160602124514851" alt="这里写图片描述"></p>
<p>在Postman里面：</p>
<ul>
<li>Environements包含global Environment，即全局的Environment，里面定义的变量在任何地方地方都可以看到</li>
<li>local Environment, 里面定义的变量只有在当前Environment里面才可以看到，这里，我定义了一个“SampleEnv”</li>
<li>Environment可以被share，通过你的postman账号或者google账号</li>
<li>Environment可以通过文件import</li>
</ul>
<p>点击之后，选择Manage Environments。若要新建，选择Add。若要编辑global Environment, 选择Globals</p>
<p><img src="https://img-blog.csdn.net/20160602113947217" alt="这里写图片描述"></p>
<p>我们来看看我已经创建好的SampleEnv，这里只创建了一个变量myLocalHost，也就是我们之前看到的在URL里的那个变量，这个变量在URL里可以用，在test script里面可以用，任何其他地方你都可以通过插值表达式符号获得它的值。</p>
<p><img src="https://img-blog.csdn.net/20160602125204573" alt="这里写图片描述"></p>
<p>这里稍微举例一下变量的好处，比如你把APP部署在自己的机器上时使用的域名是localhost，而部署在服务器上时，域名就是具体的服务器ip。为了在两种不同环境上测试你的API，你在构建request的时候就需要输入不同的url，但如果你使用了变量，你就可以使用变量来复用你的url，你只需在不同的environment里面给url赋不同的值，那你的request就完全不需要变。同理，在tests里面也是一样的。这里就不赘述</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>定义好了test case （写好的Request和定义好结果检查tests）,我们就需要运行，你可以简单点击send按钮查看结果，但这时候你不会明显的看到测试的结果，你需要把这条request加入到collection当中。我们先创建一个collection:</p>
<p><img src="https://img-blog.csdn.net/20160602130152503" alt="这里写图片描述"></p>
<p>在弹出的窗口中创建你的collection，命名为你test suite的名字：</p>
<p><img src="https://img-blog.csdn.net/20160602130316608" alt="这里写图片描述"></p>
<p>创建collection之后，把已经写好的request(test case)保存到collection（test suite）当中。</p>
<ul>
<li>点击save，把Request Name改成你的test case的名字，比如“test_NoParameter_Expect_WarningInfo”;</li>
<li>save to exist collection，选择之前创建好的collection, “TestParameters”;</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160602130547344" alt="这里写图片描述"></p>
<p>点击窗口中的save之后我们就可以在左界面上看到我们的这个collection和collection中的request了：</p>
<p><img src="https://img-blog.csdn.net/20160602131229470" alt="这里写图片描述"></p>
<p>点击 ‘&gt;’按钮（点击了之后会变成 ‘&lt;’）,我们就会看到弹出的窗口中有一个‘Run’，运行一下，就会弹出一个collection runner的窗口。点击一下start test，你就可以看到运行的结果，这里我选择了运行100次，在左边窗口你还可以看到之前的运行记录：</p>
<p><img src="https://img-blog.csdn.net/20160602131658457" alt="这里写图片描述"></p>
<p>加入我把App的接口改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    protected void doGet( HttpServletRequest request, HttpServletResponse response )</span><br><span class="line">        throws ServletException,</span><br><span class="line">            IOException</span><br><span class="line">    &#123;</span><br><span class="line">        if( request.getParameter( &quot;name&quot; ) !&#x3D; null )</span><br><span class="line">        &#123;</span><br><span class="line">            response.getWriter().print( &quot;lex&quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            response.getWriter().print( &quot;No valid parameters???&quot; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<p>这会导致response body的比较不匹配 No valid parameters??? ！= No valid parameters！！</p>
<p><img src="https://img-blog.csdn.net/20160602132110919" alt="这里写图片描述"></p>
<p>那你就会看到 Body is correct case是FAIL的.</p>
<p>怎么样？学会了吗？</p>
<p>参考链接<a href="https://blog.csdn.net/u013613428/article/details/51557804" target="_blank" rel="noopener">https://blog.csdn.net/u013613428/article/details/51557804</a></p>
<p>参考链接<a href="https://blog.csdn.net/u013613428/article/details/51557914" target="_blank" rel="noopener">https://blog.csdn.net/u013613428/article/details/51557914</a></p>
<h3 id="拓展-（postwoman）"><a href="#拓展-（postwoman）" class="headerlink" title="拓展 （postwoman）"></a>拓展 （postwoman）</h3><p><code>Postwoman</code> 就非常方便，直接运行在浏览器</p>
<h4 id="在线访问"><a href="#在线访问" class="headerlink" title="在线访问"></a>在线访问</h4><p>chorme插件（应用商店下载）</p>
<h4 id="部署到本地"><a href="#部署到本地" class="headerlink" title="部署到本地"></a>部署到本地</h4><h5 id="Git-部署"><a href="#Git-部署" class="headerlink" title="Git 部署"></a>Git 部署</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> https:<span class="comment">//github.com/liyasthomas/postwoman.git</span></span><br><span class="line">cd postwoman</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>打开浏览器输入 <code>http://localhost:3000</code> 即可。</p>
<h5 id="docker-compose-部署"><a href="#docker-compose-部署" class="headerlink" title="docker-compose 部署"></a>docker-compose 部署</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> https:<span class="comment">//github.com/liyasthomas/postwoman.git</span></span><br><span class="line">cd postwoman</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p>同理也是 <code>http://localhost:3000</code> 端口访问。</p>
<h5 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pull</span></span><br><span class="line">docker pull liyasthomas/postwoman</span><br><span class="line"></span><br><span class="line"><span class="comment">#run</span></span><br><span class="line">docker run -p <span class="number">3000</span>:<span class="number">3000</span> liyasthomas/postwoman:latest</span><br><span class="line"></span><br><span class="line"><span class="comment">#build</span></span><br><span class="line">docker build -t postwoman:latest</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>postman</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>postman</tag>
        <tag>Chrome插件</tag>
      </tags>
  </entry>
  <entry>
    <title>react之hooks</title>
    <url>/2021/03/02/react%E4%B9%8Bhooks/</url>
    <content><![CDATA[<h2 id="为什么使用hooks"><a href="#为什么使用hooks" class="headerlink" title="为什么使用hooks"></a>为什么使用hooks</h2><p>类写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p>
<p><strong>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。</strong></p>
<p>以下面的函数组件为例。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个函数只做一件事，就是根据输入的参数，返回组件的 HTML 代码。这种只进行单纯的数据计算（换算）的函数，在函数式编程里面称为 <strong>“纯函数”</strong>（pure function）。</p>
<h2 id="副效应是什么？"><a href="#副效应是什么？" class="headerlink" title="副效应是什么？"></a>副效应是什么？</h2><p>看到这里，你可能会产生一个疑问：如果纯函数只能进行数据计算，那些不涉及计算的操作（比如生成日志、储存数据、改变应用状态等等）应该写在哪里呢？</p>
<p>函数式编程将那些跟数据计算无关的操作，都称为 “副效应” <strong>（side effect）</strong> 。如果函数内部直接包含产生副效应的操作，就不再是纯函数了，我们称之为不纯的函数。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020091410.jpg" alt="img"></p>
<p>纯函数内部只有通过间接的手段（即通过其他函数调用），才能包含副效应。</p>
<a id="more"></a>

<h2 id="钩子（hook）的作用"><a href="#钩子（hook）的作用" class="headerlink" title="钩子（hook）的作用"></a>钩子（hook）的作用</h2><p>说了半天，那么钩子到底是什么？</p>
<p>一句话，<strong>钩子（hook）就是 React 函数组件的副效应解决方案，用来为函数组件引入副效应。</strong> 函数组件的主体只应该用来返回组件的 HTML 代码，所有的其他操作（副效应）都必须通过钩子引入。</p>
<p>由于副效应非常多，所以钩子有许多种。React 为许多常见的操作（副效应），都提供了专用的钩子。</p>
<ul>
<li><code>useState()</code>：保存状态</li>
<li><code>useContext()</code>：保存上下文</li>
<li><code>useRef()</code>：保存引用</li>
<li>……</li>
</ul>
<p>上面这些钩子，都是引入某种特定的副效应，而 <strong><code>useEffect()</code>是通用的副效应钩子</strong> 。找不到对应的钩子时，就可以用它。其实，从名字也可以看出来，它跟副效应（side effect）直接相关。所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用<code>use</code>前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。</p>
<p>下面介绍 React 默认提供的四个最常用的钩子。</p>
<blockquote>
<ul>
<li>useState()</li>
<li>useContext()</li>
<li>useReducer()</li>
<li>useEffect()</li>
</ul>
</blockquote>
<h2 id="useState-：状态钩子"><a href="#useState-：状态钩子" class="headerlink" title="useState()：状态钩子"></a>useState()：状态钩子</h2><p><code>useState()</code>用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p>
<p>案例：用户点击按钮，会导致按钮的文字改变，文字取决于用户是否点击，这就是状态。使用<code>useState()</code>重写如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>  <span class="title">Button</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="keyword">const</span>  [buttonText, setButtonText] =  useState(<span class="string">"Click me,   please"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setButtonText(<span class="string">"Thanks, been clicked!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  <span class="xml"><span class="tag">&lt;<span class="name">button</span>  <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>&#123;buttonText&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，Button 组件是一个函数，内部使用<code>useState()</code>钩子引入状态。</p>
<p><code>useState()</code>这个函数接受状态的初始值，作为参数，上例的初始值为按钮的文字。该函数返回一个数组，数组的第一个成员是一个变量（上例是<code>buttonText</code>），指向状态的当前值。第二个成员是一个函数，用来更新状态，约定是<code>set</code>前缀加上状态的变量名（上例是<code>setButtonText</code>）。</p>
<h2 id="useContext-：共享状态钩子"><a href="#useContext-：共享状态钩子" class="headerlink" title="useContext()：共享状态钩子"></a>useContext()：共享状态钩子</h2><p>如果需要在组件之间共享状态，可以使用<code>useContext()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useContext &#125; from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import &quot;.&#x2F;styles.css&quot;;</span><br><span class="line"></span><br><span class="line">const AppContext &#x3D; React.createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">const Navbar &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; username &#125; &#x3D; useContext(AppContext)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;navbar&quot;&gt;</span><br><span class="line">      &lt;p&gt;AwesomeSite&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;&#123;username&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Messages &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; username &#125; &#x3D; useContext(AppContext)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;messages&quot;&gt;</span><br><span class="line">      &lt;h1&gt;Messages&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p&gt;1 message for &#123;username&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;message&quot;&gt;useContext is awesome!&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;AppContext.Provider value&#x3D;&#123;&#123;</span><br><span class="line">      username: &#39;superawesome&#39;</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">      &lt;div className&#x3D;&quot;App&quot;&gt;</span><br><span class="line">        &lt;Navbar &#x2F;&gt;</span><br><span class="line">        &lt;Messages &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;AppContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rootElement &#x3D; document.getElementById(&quot;root&quot;);</span><br><span class="line">ReactDOM.render(&lt;App &#x2F;&gt;, rootElement);</span><br></pre></td></tr></table></figure>



<h2 id="useReducer-：action-钩子"><a href="#useReducer-：action-钩子" class="headerlink" title="useReducer()：action 钩子"></a>useReducer()：action 钩子</h2><p>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</p>
<p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是<code>(state, action) =&gt; newState</code>。</p>
<p><code>useReducers()</code>钩子用来引入 Reducer 功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import &quot;.&#x2F;styles.css&quot;;</span><br><span class="line"></span><br><span class="line">const myReducer &#x3D; (state, action) &#x3D;&gt; &#123;</span><br><span class="line">  switch(action.type) &#123;</span><br><span class="line">    case(&#39;countUp&#39;):</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + 1</span><br><span class="line">      &#125;</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(myReducer, &#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;App&quot;&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;countUp&#39; &#125;)&#125;&gt;</span><br><span class="line">        +1</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;state.count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rootElement &#x3D; document.getElementById(&quot;root&quot;);</span><br><span class="line">ReactDOM.render(&lt;App &#x2F;&gt;, rootElement);</span><br></pre></td></tr></table></figure>

<h2 id="useEffect-：副作用钩子"><a href="#useEffect-：副作用钩子" class="headerlink" title="useEffect()：副作用钩子"></a>useEffect()：副作用钩子</h2><p><code>useEffect()</code>用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在<code>componentDidMount</code>里面的代码，现在可以放在<code>useEffect()</code>。</p>
<p><code>useEffect()</code>的用法如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>  =&gt;</span>  &#123;</span><br><span class="line">  <span class="comment">// Async Action</span></span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面用法中，<code>useEffect()</code>接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，<code>useEffect()</code>就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行<code>useEffect()</code>。</p>
<p>下面看一个例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">&#123; personId &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>); </span><br><span class="line">    fetch(<span class="string">`https://swapi.co/api/people/<span class="subst">$&#123;personId&#125;</span>/`</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        setPerson(data);</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>You're viewing: &#123;person.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Height: &#123;person.height&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Mass: &#123;person.mass&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，每当组件参数<code>personId</code>发生变化，<code>useEffect()</code>就会执行。组件第一次渲染时，<code>useEffect()</code>也会执行。</p>
<h2 id="清理副效应"><a href="#清理副效应" class="headerlink" title="清理副效应"></a>清理副效应</h2><p><code>useEffect()</code>允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，<code>useEffect()</code>就不用返回任何值。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.source]);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>useEffect()</code>在组件加载时订阅了一个事件，并且返回一个清理函数，在组件卸载时取消订阅。</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>react之router</title>
    <url>/2021/03/03/react%E4%B9%8Brouter/</url>
    <content><![CDATA[<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p>React Router 安装命令如下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -S react-router</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用时，路由器<code>Router</code>就是React的一个组件。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">Router</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>));</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<p><code>Router</code>组件本身只是一个容器，真正的路由要通过<code>Route</code>组件定义。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router, Route, hashHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"></span><br><span class="line">render((</span><br><span class="line">  &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">), document.getElementById('app'));</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，用户访问根路由<code>/</code>（比如<code>http://www.example.com/</code>），组件<code>APP</code>就会加载到<code>document.getElementById(&#39;app&#39;)</code>。</p>
<p>你可能还注意到，<code>Router</code>组件有一个参数<code>history</code>，它的值<code>hashHistory</code>表示，路由的切换由URL的hash变化决定，即URL的<code>#</code>部分发生变化。举例来说，用户访问<code>http://www.example.com/</code>，实际会看到的是<code>http://www.example.com/#/</code>。</p>
<p><code>Route</code>组件定义了URL路径与组件的对应关系。你可以同时使用多个<code>Route</code>组件。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Router history&#x3D;&#123;hashHistory&#125;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&#x2F;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;repos&quot; component&#x3D;&#123;Repos&#125;&#x2F;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Router&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，用户访问<code>/repos</code>（比如<code>http://localhost:8080/#/repos</code>）时，加载<code>Repos</code>组件；访问<code>/about</code>（<code>http://localhost:8080/#/about</code>）时，加载<code>About</code>组件。</p>
<h2 id="二、嵌套路由"><a href="#二、嵌套路由" class="headerlink" title="二、嵌套路由"></a>二、嵌套路由</h2><p><code>Route</code>组件还可以嵌套。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/repos"</span> component=&#123;Repos&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Router&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，用户访问<code>/repos</code>时，会先加载<code>App</code>组件，然后在它的内部再加载<code>Repos</code>组件。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line">  &lt;Repos&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;App&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>App</code>组件要写成下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;this.props.children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>App</code>组件的<code>this.props.children</code>属性就是子组件。</p>
<p>子路由也可以不写在<code>Router</code>组件里面，单独传入<code>Router</code>组件的<code>routes</code>属性。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let routes &#x3D; &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;repos&quot; component&#x3D;&#123;Repos&#125;&#x2F;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;;</span><br><span class="line"></span><br><span class="line">&lt;Router routes&#x3D;&#123;routes&#125; history&#x3D;&#123;browserHistory&#125;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、-path-属性"><a href="#三、-path-属性" class="headerlink" title="三、 path 属性"></a>三、 path 属性</h2><p><code>Route</code>组件的<code>path</code>属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。</p>
<p>请看下面的例子。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;inbox&quot; component&#x3D;&#123;Inbox&#125;&gt;</span><br><span class="line">   &lt;Route path&#x3D;&quot;messages&#x2F;:id&quot; component&#x3D;&#123;Message&#125; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，当用户访问<code>/inbox/messages/:id</code>时，会加载下面的组件。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Inbox&gt;</span><br><span class="line">  &lt;Message&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Inbox&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果省略外层<code>Route</code>的<code>path</code>参数，写成下面的样子。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route component&#x3D;&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;inbox&#x2F;messages&#x2F;:id&quot; component&#x3D;&#123;Message&#125; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在用户访问<code>/inbox/messages/:id</code>时，组件加载还是原来的样子。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Inbox&gt;</span><br><span class="line">  &lt;Message&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Inbox&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、通配符"><a href="#四、通配符" class="headerlink" title="四、通配符"></a>四、通配符</h2><p><code>path</code>属性可以使用通配符。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;&#x2F;hello&#x2F;:name&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello&#x2F;michael</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello&#x2F;ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;hello(&#x2F;:name)&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello&#x2F;michael</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello&#x2F;ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;files&#x2F;*.*&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;hello.jpg</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;hello.html</span><br><span class="line"></span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;files&#x2F;*&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F; </span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;a</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;a&#x2F;b</span><br><span class="line"></span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;**&#x2F;*.jpg&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;hello.jpg</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;path&#x2F;to&#x2F;file.jpg</span><br></pre></td></tr></table></figure>
</blockquote>
<p>通配符的规则如下。</p>
<blockquote>
<p><strong>（1）<code>:paramName</code></strong></p>
<p><code>:paramName</code>匹配URL的一个部分，直到遇到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。这个路径参数可以通过<code>this.props.params.paramName</code>取出。</p>
<p><strong>（2）<code>()</code></strong></p>
<p><code>()</code>表示URL的这个部分是可选的。</p>
<p><strong>（3）<code>\*</code></strong></p>
<p><code>*</code>匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</p>
<p><strong>（4） `\</strong>`**</p>
<p><code>**</code> 匹配任意字符，直到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。匹配方式是贪婪模式。</p>
</blockquote>
<p><code>path</code>属性也可以使用相对路径（不以<code>/</code>开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。</p>
<p>路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;&#x2F;comments&quot; ... &#x2F;&gt;</span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;comments&quot; ... &#x2F;&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，路径<code>/comments</code>同时匹配两个规则，第二个规则不会生效。</p>
<p>设置路径参数时，需要特别小心这一点。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;:userName&#x2F;:id&quot; component&#x3D;&#123;UserPage&#125;&#x2F;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;about&#x2F;me&quot; component&#x3D;&#123;About&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Router&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，用户访问<code>/about/me</code>时，不会触发第二个路由规则，因为它会匹配<code>/:userName/:id</code>这个规则。因此，带参数的路径一般要写在路由规则的底部。</p>
<p>此外，URL的查询字符串<code>/foo?bar=baz</code>，可以用<code>this.props.location.query.bar</code>获取。</p>
<h2 id="五、IndexRoute-组件"><a href="#五、IndexRoute-组件" class="headerlink" title="五、IndexRoute 组件"></a>五、IndexRoute 组件</h2><p>下面的例子，你会不会觉得有一点问题？</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;accounts&quot; component&#x3D;&#123;Accounts&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;statements&quot; component&#x3D;&#123;Statements&#125;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Route&gt;</span><br><span class="line">&lt;&#x2F;Router&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，访问根路径<code>/</code>，不会加载任何子组件。也就是说，<code>App</code>组件的<code>this.props.children</code>，这时是<code>undefined</code>。</p>
<p>因此，通常会采用<code>{this.props.children || &lt;Home/&gt;}</code>这样的写法。这时，<code>Home</code>明明是<code>Accounts</code>和<code>Statements</code>的同级组件，却没有写在<code>Route</code>中。</p>
<p><code>IndexRoute</code>就是解决这个问题，显式指定<code>Home</code>是根路由的子组件，即指定默认情况下加载的子组件。你可以把<code>IndexRoute</code>想象成某个路径的<code>index.html</code>。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">    &lt;IndexRoute component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;accounts&quot; component&#x3D;&#123;Accounts&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;statements&quot; component&#x3D;&#123;Statements&#125;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Route&gt;</span><br><span class="line">&lt;&#x2F;Router&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在，用户访问<code>/</code>的时候，加载的组件结构如下。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line">  &lt;Home&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;App&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这种组件结构就很清晰了：<code>App</code>只包含下级组件的共有元素，本身的展示内容则由<code>Home</code>组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。</p>
<p>注意，<code>IndexRoute</code>组件没有路径参数<code>path</code>。</p>
<h2 id="六、Redirect-组件"><a href="#六、Redirect-组件" class="headerlink" title="六、Redirect 组件"></a>六、Redirect 组件</h2><p><code>&lt;Redirect&gt;</code>组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;inbox&quot; component&#x3D;&#123;Inbox&#125;&gt;</span><br><span class="line">  &#123;&#x2F;* 从 &#x2F;inbox&#x2F;messages&#x2F;:id 跳转到 &#x2F;messages&#x2F;:id *&#x2F;&#125;</span><br><span class="line">  ＜Redirect from&#x3D;&quot;messages&#x2F;:id&quot; to&#x3D;&quot;&#x2F;messages&#x2F;:id&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在访问<code>/inbox/messages/5</code>，会自动跳转到<code>/messages/5</code>。</p>
<h2 id="七、IndexRedirect-组件"><a href="#七、IndexRedirect-组件" class="headerlink" title="七、IndexRedirect 组件"></a>七、IndexRedirect 组件</h2><p><code>IndexRedirect</code>组件用于访问根路由的时候，将用户重定向到某个子组件。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">  ＜IndexRedirect to&#x3D;&quot;&#x2F;welcome&quot; &#x2F;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;welcome&quot; component&#x3D;&#123;Welcome&#125; &#x2F;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，用户访问根路径时，将自动重定向到子组件<code>welcome</code>。</p>
<h2 id="八、Link"><a href="#八、Link" class="headerlink" title="八、Link"></a>八、Link</h2><p><code>Link</code>组件用于取代<code>&lt;a&gt;</code>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<code>&lt;a&gt;</code>元素的React 版本，可以接收<code>Router</code>的状态。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;ul role="nav"&gt;</span><br><span class="line">      &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;Link to="/repos"&gt;Repos&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果希望当前的路由与其他路由有不同样式，这时可以使用<code>Link</code>组件的<code>activeStyle</code>属性。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Link to&#x3D;&quot;&#x2F;about&quot; activeStyle&#x3D;&#123;&#123;color: &#39;red&#39;&#125;&#125;&gt;About&lt;&#x2F;Link&gt;</span><br><span class="line">&lt;Link to&#x3D;&quot;&#x2F;repos&quot; activeStyle&#x3D;&#123;&#123;color: &#39;red&#39;&#125;&#125;&gt;Repos&lt;&#x2F;Link&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，当前页面的链接会红色显示。</p>
<p>另一种做法是，使用<code>activeClassName</code>指定当前路由的<code>Class</code>。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Link to&#x3D;&quot;&#x2F;about&quot; activeClassName&#x3D;&quot;active&quot;&gt;About&lt;&#x2F;Link&gt;</span><br><span class="line">&lt;Link to&#x3D;&quot;&#x2F;repos&quot; activeClassName&#x3D;&quot;active&quot;&gt;Repos&lt;&#x2F;Link&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，当前页面的链接的<code>class</code>会包含<code>active</code>。</p>
<p>在<code>Router</code>组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line">browserHistory.push(<span class="string">'/some/path'</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="九、IndexLink"><a href="#九、IndexLink" class="headerlink" title="九、IndexLink"></a>九、IndexLink</h2><p>如果链接到根路由<code>/</code>，不要使用<code>Link</code>组件，而要使用<code>IndexLink</code>组件。</p>
<p>这是因为对于根路由来说，<code>activeStyle</code>和<code>activeClassName</code>会失效，或者说总是生效，因为<code>/</code>会匹配任何子路由。而<code>IndexLink</code>组件会使用路径的精确匹配。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IndexLink to&#x3D;&quot;&#x2F;&quot; activeClassName&#x3D;&quot;active&quot;&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;&#x2F;IndexLink&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，根路由只会在精确匹配时，才具有<code>activeClassName</code>。</p>
<p>另一种方法是使用<code>Link</code>组件的<code>onlyActiveOnIndex</code>属性，也能达到同样效果。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Link to&#x3D;&quot;&#x2F;&quot; activeClassName&#x3D;&quot;active&quot; onlyActiveOnIndex&#x3D;&#123;true&#125;&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;&#x2F;Link&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>实际上，<code>IndexLink</code>就是对<code>Link</code>组件的<code>onlyActiveOnIndex</code>属性的包装。</p>
<h2 id="十、histroy-属性"><a href="#十、histroy-属性" class="headerlink" title="十、histroy 属性"></a>十、histroy 属性</h2><p><code>Router</code>组件的<code>history</code>属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。</p>
<p><code>history</code>属性，一共可以设置三种值。</p>
<blockquote>
<ul>
<li>browserHistory</li>
<li>hashHistory</li>
<li>createMemoryHistory</li>
</ul>
</blockquote>
<p>如果设为<code>hashHistory</code>，路由将通过URL的hash部分（<code>#</code>）切换，URL的形式类似<code>example.com/#/some/path</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hashHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果设为<code>browserHistory</code>，浏览器的路由就不再通过<code>Hash</code>完成了，而显示正常的路径<code>example.com/some/path</code>，背后调用的是浏览器的History API。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是，这种情况需要对<a href="https://github.com/reactjs/react-router/blob/master/docs/guides/Histories.md#configuring-your-server" target="_blank" rel="noopener">服务器改造</a>。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。</p>
<p>如果开发服务器使用的是<code>webpack-dev-server</code>，加上<code>--history-api-fallback</code>参数就可以了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ webpack-dev-server --inline --content-base . --<span class="built_in">history</span>-api-fallback</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>createMemoryHistory</code>主要用于服务器渲染。它创建一个内存中的<code>history</code>对象，不与浏览器URL互动。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> history = createMemoryHistory(location)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="十一、表单处理"><a href="#十一、表单处理" class="headerlink" title="十一、表单处理"></a>十一、表单处理</h2><p><code>Link</code>组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？</p>
<p>下面是一个表单。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;userName&quot;&#x2F;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;repo&quot;&#x2F;&gt;</span><br><span class="line">  &lt;button type&#x3D;&quot;submit&quot;&gt;Go&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第一种方法是使用<code>browserHistory.push</code></p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="keyword">const</span> userName = event.target.elements[<span class="number">0</span>].value</span><br><span class="line">    <span class="keyword">const</span> repo = event.target.elements[<span class="number">1</span>].value</span><br><span class="line">    <span class="keyword">const</span> path = <span class="string">`/repos/<span class="subst">$&#123;userName&#125;</span>/<span class="subst">$&#123;repo&#125;</span>`</span></span><br><span class="line">    browserHistory.push(path)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第二种方法是使用<code>context</code>对象。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for `router` from context</span></span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    router: React.PropTypes.object</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.context.router.push(path)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="十二、路由的钩子"><a href="#十二、路由的钩子" class="headerlink" title="十二、路由的钩子"></a>十二、路由的钩子</h2><p>每个路由都有<code>Enter</code>和<code>Leave</code>钩子，用户进入或离开该路由时触发。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;</span><br><span class="line">＜Route path&#x3D;&quot;inbox&quot; component&#x3D;&#123;Inbox&#125;&gt;</span><br><span class="line">  ＜Redirect from&#x3D;&quot;messages&#x2F;:id&quot; to&#x3D;&quot;&#x2F;messages&#x2F;:id&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码中，如果用户离开<code>/messages/:id</code>，进入<code>/about</code>时，会依次触发以下的钩子。</p>
<blockquote>
<ul>
<li><code>/messages/:id</code>的<code>onLeave</code></li>
<li><code>/inbox</code>的<code>onLeave</code></li>
<li><code>/about</code>的<code>onEnter</code></li>
</ul>
</blockquote>
<p>下面是一个例子，使用<code>onEnter</code>钩子替代<code>&lt;Redirect&gt;</code>组件。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;inbox&quot; component&#x3D;&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path&#x3D;&quot;messages&#x2F;:id&quot;</span><br><span class="line">    onEnter&#x3D;&#123;</span><br><span class="line">      (&#123;params&#125;, replace) &#x3D;&gt; replace(&#96;&#x2F;messages&#x2F;$&#123;params.id&#125;&#96;)</span><br><span class="line">    &#125; </span><br><span class="line">  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>onEnter</code>钩子还可以用来做认证。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const requireAuth &#x3D; (nextState, replace) &#x3D;&gt; &#123;</span><br><span class="line">    if (!auth.isAdmin()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Redirect to Home page if not an Admin</span><br><span class="line">        replace(&#123; pathname: &#39;&#x2F;&#39; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export const AdminRoutes &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">     &lt;Route path&#x3D;&quot;&#x2F;admin&quot; component&#x3D;&#123;Admin&#125; onEnter&#x3D;&#123;requireAuth&#125; &#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = withRouter(</span><br><span class="line">  React.createClass(&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.router.setRouteLeaveHook(</span><br><span class="line">        <span class="keyword">this</span>.props.route, </span><br><span class="line">        <span class="keyword">this</span>.routerWillLeave</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    routerWillLeave(nextLocation) &#123;</span><br><span class="line">      <span class="comment">// 返回 false 会继续停留当前页面，</span></span><br><span class="line">      <span class="comment">// 否则，返回一个字符串，会显示给用户，让其自己决定</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.state.isSaved)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'确认要离开？'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>setRouteLeaveHook</code>方法为<code>Leave</code>钩子指定<code>routerWillLeave</code>函数。该方法如果返回<code>false</code>，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>react之井字棋</title>
    <url>/2020/09/25/react%E4%B9%8B%E4%BA%95%E5%AD%97%E6%A3%8B/</url>
    <content><![CDATA[<p>见下文</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Square(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button className&#x3D;&quot;square&quot; onClick&#x3D;&#123;props.onClick&#125;&gt;</span><br><span class="line">      &#123;props.value&#125;</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Board extends React.Component &#123;</span><br><span class="line">  renderSquare(i) &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Square</span><br><span class="line">        value&#x3D;&#123;this.props.squares[i]&#125;</span><br><span class="line">        onClick&#x3D;&#123;() &#x3D;&gt; this.props.onClick(i)&#125;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(0)&#125;</span><br><span class="line">          &#123;this.renderSquare(1)&#125;</span><br><span class="line">          &#123;this.renderSquare(2)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(3)&#125;</span><br><span class="line">          &#123;this.renderSquare(4)&#125;</span><br><span class="line">          &#123;this.renderSquare(5)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(6)&#125;</span><br><span class="line">          &#123;this.renderSquare(7)&#125;</span><br><span class="line">          &#123;this.renderSquare(8)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Game extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      history: [</span><br><span class="line">        &#123;</span><br><span class="line">          squares: Array(9).fill(null)</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      stepNumber: 0,</span><br><span class="line">      xIsNext: true</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(i) &#123;</span><br><span class="line">    const history &#x3D; this.state.history.slice(0, this.state.stepNumber + 1);</span><br><span class="line">    const current &#x3D; history[history.length - 1];</span><br><span class="line">    const squares &#x3D; current.squares.slice();</span><br><span class="line">    if (calculateWinner(squares) || squares[i]) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    squares[i] &#x3D; this.state.xIsNext ? &quot;X&quot; : &quot;O&quot;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      history: history.concat([</span><br><span class="line">        &#123;</span><br><span class="line">          squares: squares</span><br><span class="line">        &#125;</span><br><span class="line">      ]),</span><br><span class="line">      stepNumber: history.length,</span><br><span class="line">      xIsNext: !this.state.xIsNext</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jumpTo(step) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      stepNumber: step,</span><br><span class="line">      xIsNext: (step % 2) &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const history &#x3D; this.state.history;</span><br><span class="line">    const current &#x3D; history[this.state.stepNumber];</span><br><span class="line">    const winner &#x3D; calculateWinner(current.squares);</span><br><span class="line"></span><br><span class="line">    const moves &#x3D; history.map((step, move) &#x3D;&gt; &#123;</span><br><span class="line">      const desc &#x3D; move ?</span><br><span class="line">        &#39;Go to move #&#39; + move :</span><br><span class="line">        &#39;Go to game start&#39;;</span><br><span class="line">      return (</span><br><span class="line">        &lt;li key&#x3D;&#123;move&#125;&gt;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.jumpTo(move)&#125;&gt;&#123;desc&#125;&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let status;</span><br><span class="line">    if (winner) &#123;</span><br><span class="line">      status &#x3D; &quot;Winner: &quot; + winner;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      status &#x3D; &quot;Next player: &quot; + (this.state.xIsNext ? &quot;X&quot; : &quot;O&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;game&quot;&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;game-board&quot;&gt;</span><br><span class="line">          &lt;Board</span><br><span class="line">            squares&#x3D;&#123;current.squares&#125;</span><br><span class="line">            onClick&#x3D;&#123;i &#x3D;&gt; this.handleClick(i)&#125;</span><br><span class="line">          &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;game-info&quot;&gt;</span><br><span class="line">          &lt;div&gt;&#123;status&#125;&lt;&#x2F;div&gt;</span><br><span class="line">          &lt;ol&gt;&#123;moves&#125;&lt;&#x2F;ol&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Game &#x2F;&gt;, document.getElementById(&quot;root&quot;));</span><br><span class="line"></span><br><span class="line">function calculateWinner(squares) &#123;</span><br><span class="line">  const lines &#x3D; [</span><br><span class="line">    [0, 1, 2],</span><br><span class="line">    [3, 4, 5],</span><br><span class="line">    [6, 7, 8],</span><br><span class="line">    [0, 3, 6],</span><br><span class="line">    [1, 4, 7],</span><br><span class="line">    [2, 5, 8],</span><br><span class="line">    [0, 4, 8],</span><br><span class="line">    [2, 4, 6]</span><br><span class="line">  ];</span><br><span class="line">  for (let i &#x3D; 0; i &lt; lines.length; i++) &#123;</span><br><span class="line">    const [a, b, c] &#x3D; lines[i];</span><br><span class="line">    if (squares[a] &amp;&amp; squares[a] &#x3D;&#x3D;&#x3D; squares[b] &amp;&amp; squares[a] &#x3D;&#x3D;&#x3D; squares[c]) &#123;</span><br><span class="line">      return squares[a];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>井字棋</tag>
      </tags>
  </entry>
  <entry>
    <title>react之脚手架搭建项目</title>
    <url>/2021/02/20/react%E4%B9%8B%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="一-认识脚手架"><a href="#一-认识脚手架" class="headerlink" title="一. 认识脚手架"></a>一. 认识脚手架</h1><h2 id="1-1-前端工程的复杂化"><a href="#1-1-前端工程的复杂化" class="headerlink" title="1.1. 前端工程的复杂化"></a>1.1. 前端工程的复杂化</h2><p>如果我们只是开发几个小的demo程序，那么永远不需要考虑一些复杂的问题：</p>
<ul>
<li>比如目录结构如何组织划分；</li>
<li>比如如何管理文件之间的相互依赖；</li>
<li>比如如何管理第三方模块的依赖；</li>
<li>比如项目发布前如何压缩、打包项目；</li>
<li>等等…</li>
</ul>
<a id="more"></a>

<p>现代的前端项目已经越来越复杂了：</p>
<ul>
<li>不会再是在HTML中引入几个css文件，引入几个编写的js文件或者第三方的js文件这么简单；</li>
<li>比如css可能是使用less、sass等预处理器进行编写，我们需要将它们转成普通的css才能被浏览器解析；</li>
<li>比如JavaScript代码不再只是编写在几个文件中，而是通过模块化的方式，被组成在<strong>成百上千</strong>个文件中，我们需要通过模块化的技术来管理它们之间的相互依赖；</li>
<li>比如项目需要依赖很多的第三方库，如何更好的管理它们（比如管理它们的依赖、版本升级等）；</li>
</ul>
<p>为了解决上面这些问题，我们需要再去学习一些工具：</p>
<ul>
<li>比如babel、webpack、gulp。配置它们转换规则、打包依赖、热更新等等一些的内容；</li>
<li>你会发现，你还没有开始做项目，你就面临一系列的工程化问题；</li>
</ul>
<p><strong>脚手架的出现，就是帮助我们解决这一系列问题的；</strong></p>
<h2 id="1-2-脚手架是什么呢？"><a href="#1-2-脚手架是什么呢？" class="headerlink" title="1.2. 脚手架是什么呢？"></a>1.2. 脚手架是什么呢？</h2><p>脚手架</p>
<p>编程中提到的脚手架（Scaffold），其实是一种工具，帮我们可以快速生成项目的工程化结构；</p>
<ul>
<li>每个项目作出完成的效果不同，但是它们的基本工程化结构是相似的；</li>
<li>既然相似，就没有必要每次都从零开始搭建，完全可以使用一些工具，帮助我们生产基本的工程化模板；</li>
<li>不同的项目，在这个模板的基础之上进行项目开发或者进行一些配置的简单修改即可；</li>
<li>这样也可以间接保证项目的基本结构一致性，方便后期的维护；</li>
</ul>
<p>总结：<strong>脚手架让项目从搭建到开发，再到部署，整个流程变得快速和便捷；</strong></p>
<p>对于现在比较流行的三大框架都有属于自己的脚手架：</p>
<ul>
<li>Vue的脚手架：vue-cli</li>
<li>Angular的脚手架：angular-cli</li>
<li>React的脚手架：create-react-app</li>
</ul>
<p>它们的作用都是帮助我们生成一个通用的目录结构，并且已经将我们所需的工程环境配置好。</p>
<p>使用这些脚手架需要依赖什么呢？</p>
<ul>
<li>目前这些脚手架都是使用node编写的，并且都是基于webpack的；</li>
<li>所以我们必须在自己的电脑上安装node环境；</li>
</ul>
<p>这里我们主要是学习React，所以我们还是以React的脚手架工具：create-react-app作为讲解；</p>
<h1 id="二-create-react-app"><a href="#二-create-react-app" class="headerlink" title="二. create-react-app"></a>二. create-react-app</h1><h2 id="2-1-安装相关的依赖"><a href="#2-1-安装相关的依赖" class="headerlink" title="2.1. 安装相关的依赖"></a>2.1. 安装相关的依赖</h2><h2 id="2-1-1-安装node"><a href="#2-1-1-安装node" class="headerlink" title="2.1.1. 安装node"></a>2.1.1. 安装node</h2><p>React脚手架本身需要依赖node，所以我们需要安装node环境：</p>
<ul>
<li>无论是windows还是Mac OS，都可以通过node官网直接下载；</li>
<li>官网地址：<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/download/">https://nodejs.org/en/download/</a></li>
<li>注意：这里推荐大家下载LTS（Long-term support ）版本，是长期支持版本，会比较稳定；</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-833ee448306a0de9b3898f7603add168_720w.jpg" alt="img"></p>
<p>nodejs下载</p>
<p>下载后，双击安装即可：</p>
<ul>
<li>1.安装过程中，会自动配置环境变量；</li>
<li>2.安装时，会同时帮助我们安装npm管理工具；</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-c5c4d577c00109fe720e3f54c69811fc_720w.jpg" alt="img"></p>
<p>检测安装的版本</p>
<h2 id="2-1-2-包管理工具"><a href="#2-1-2-包管理工具" class="headerlink" title="2.1.2. 包管理工具"></a>2.1.2. 包管理工具</h2><p><strong>什么是npm？</strong></p>
<ul>
<li>全称 Node Package Manager，即“node包管理器”；</li>
<li>作用肯定是帮助我们管理一下依赖的工具包（比如react、react-dom、axios、babel、webpack等等）；</li>
<li>作者开发的目的就是为了解决“模块管理很糟糕”的问题；</li>
</ul>
<p><strong>另外，还有一个大名鼎鼎的node包管理工具yarn：</strong></p>
<ul>
<li>Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；</li>
<li>Yarn 是为了弥补 npm 的一些缺陷而出现的；</li>
<li>早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；</li>
<li>虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；</li>
<li>React脚手架默认也是使用yarn；</li>
</ul>
<p>安装yarn：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>



<p><img src="https://pic4.zhimg.com/80/v2-8bf754189d539c0e829480e6df2de34f_720w.jpeg" alt="img"></p>
<p>检测yarn安装的版本</p>
<p><strong>yarn和npm的命令对比</strong></p>
<p>NpmYarnnpm installyarn installnpm install [package]yarn add [package]npm install –save [package]yarn add [package]npm install –save-dev [package]yarn add [package] [–dev/-D]npm rebuildyarn install –forcenpm uninstall [package]yarn remove [package]npm uninstall –save [package]yarn remove [package]npm uninstall –save-dev [package]yarn remove [package]npm uninstall –save-optional [package]yarn remove [package]npm cache cleanyarn cache cleanrm -rf node_modules &amp;&amp; npm installyarn upgrade</p>
<p><strong>cnpm的使用</strong></p>
<p>在国内，某些情况使用npm和yarn可能无法正常安装一个库，这个时候我们可以选择使用cnpm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="2-1-3-安装脚手架"><a href="#2-1-3-安装脚手架" class="headerlink" title="2.1.3. 安装脚手架"></a>2.1.3. 安装脚手架</h2><p>最后一个需要安装的是创建React项目的脚手架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure>



<p><img src="https://pic1.zhimg.com/80/v2-f0e7a077c9560cd6b8b189e59635fa14_720w.jpeg" alt="img"></p>
<p>检查React脚手架</p>
<h2 id="2-2-创建React项目"><a href="#2-2-创建React项目" class="headerlink" title="2.2. 创建React项目"></a>2.2. 创建React项目</h2><h2 id="2-2-1-创建React项目"><a href="#2-2-1-创建React项目" class="headerlink" title="2.2.1. 创建React项目"></a>2.2.1. 创建React项目</h2><p>现在，我们就可以通过脚手架来创建React项目了。</p>
<p>创建React项目的命令如下：</p>
<ul>
<li>注意：项目名称不能包含大写字母</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create-react-app 项目名称</span><br></pre></td></tr></table></figure>

<p>另外还有更多创建项目的方式，可以参考GitHub的readme</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/facebook/create-react-app">https://github.com/facebook/create-react-app</a>；</li>
<li>上面的创建方式，默认使用的yarn来管理整个项目包相关的依赖的；</li>
<li>如果希望使用npm，也可以在参数后面加上 –use-npm；</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-e8adfd153e2ba949d3b21645cda356e1_720w.jpg" alt="img"></p>
<p>image-20200615115822464</p>
<p>创建完成后，进入对应的目录，就可以将项目跑起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 01-test-react</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>



<p><img src="https://pic3.zhimg.com/80/v2-c001ac893f7ecfa2200467b51c698476_720w.jpg" alt="img"></p>
<p>项目效果</p>
<h2 id="2-2-2-目录结构分析"><a href="#2-2-2-目录结构分析" class="headerlink" title="2.2.2. 目录结构分析"></a>2.2.2. 目录结构分析</h2><p>我们可以通过VSCode打开项目：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e2143939102786485db3bb55afe28538_720w.jpg" alt="img"></p>
<p>项目目录结构</p>
<p>目录结构分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test-react</span><br><span class="line">├─ README.md &#x2F;&#x2F; readme说明文档</span><br><span class="line">├─ package.json &#x2F;&#x2F; 对整个应用程序的描述：包括应用名称、版本号、一些依赖包、以及项目的启动、打包等等（node管理项目必备文件）</span><br><span class="line">├─ public</span><br><span class="line">│    ├─ favicon.ico &#x2F;&#x2F; 应用程序顶部的icon图标</span><br><span class="line">│    ├─ index.html &#x2F;&#x2F; 应用的index.html入口文件</span><br><span class="line">│    ├─ logo192.png &#x2F;&#x2F; 被在manifest.json中使用</span><br><span class="line">│    ├─ logo512.png &#x2F;&#x2F; 被在manifest.json中使用</span><br><span class="line">│    ├─ manifest.json &#x2F;&#x2F; 和Web app配置相关</span><br><span class="line">│    └─ robots.txt &#x2F;&#x2F; 指定搜索引擎可以或者无法爬取哪些文件</span><br><span class="line">├─ src</span><br><span class="line">│    ├─ App.css &#x2F;&#x2F; App组件相关的样式</span><br><span class="line">│    ├─ App.js &#x2F;&#x2F; App组件的代码文件</span><br><span class="line">│    ├─ App.test.js &#x2F;&#x2F; App组件的测试代码文件</span><br><span class="line">│    ├─ index.css &#x2F;&#x2F; 全局的样式文件</span><br><span class="line">│    ├─ index.js &#x2F;&#x2F; 整个应用程序的入口文件</span><br><span class="line">│    ├─ logo.svg &#x2F;&#x2F; 刚才启动项目，所看到的React图标</span><br><span class="line">│    ├─ serviceWorker.js &#x2F;&#x2F; 默认帮助我们写好的注册PWA相关的代码</span><br><span class="line">│    └─ setupTests.js &#x2F;&#x2F; 测试初始化文件</span><br><span class="line">└─ yarn.lock</span><br></pre></td></tr></table></figure>

<p>整个目录结构都非常好理解，只是有一个PWA相关的概念：</p>
<ul>
<li>PWA全称Progressive Web App，即渐进式WEB应用；</li>
<li>一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能；</li>
<li>这种Web存在的形式，我们也称之为是 Web App；</li>
</ul>
<p>PWA解决了哪些问题呢？</p>
<ul>
<li>可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏；</li>
<li>实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能；</li>
<li>实现了消息推送；</li>
<li>等等一系列类似于Native App相关的功能；</li>
</ul>
<p>更多PWA相关的知识，可以自行去学习更多；</p>
<h2 id="2-2-3-webpack配置"><a href="#2-2-3-webpack配置" class="headerlink" title="2.2.3. webpack配置"></a>2.2.3. webpack配置</h2><p>我们说过React的脚手架是基于Webpack来配置的：</p>
<ul>
<li>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)；</li>
<li>当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle；</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-c0cbdd82bd4defac7bd0422fafba825a_720w.jpg" alt="img"></p>
<p>webpack</p>
<p>在这里我们暂时不展开来讲webpack，因为里面的内容是非常多的（后续会有专门讲webpack的专题）；</p>
<p>但是，很奇怪：我们并没有在目录结构中看到任何webpack相关的内容？</p>
<ul>
<li>原因是React脚手架将webpack相关的配置隐藏起来了（其实从Vue CLI3开始，也是进行了隐藏）；</li>
</ul>
<p>如果我们希望看到webpack的配置信息，应该怎么来做呢？</p>
<ul>
<li>我们可以执行一个package.json文件中的一个脚本：”eject”: “react-scripts eject”</li>
<li>这个操作是不可逆的，所以在执行过程中会给予我们提示；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn eject</span><br></pre></td></tr></table></figure>



<p><img src="https://pic3.zhimg.com/80/v2-1e864c0d1ea72fa9a3c84d1a47084106_720w.jpeg" alt="img"></p>
<p>执行脚本</p>
<p>查看和学习webpack相关的配置信息：</p>
<p><img src="https://pic2.zhimg.com/80/v2-132539d8ffad9c3a9e66f389cbc132f5_720w.jpg" alt="img"></p>
<p>webpack相关配置</p>
<h2 id="2-3-从零编写项目"><a href="#2-3-从零编写项目" class="headerlink" title="2.3. 从零编写项目"></a>2.3. 从零编写项目</h2><h2 id="2-3-1-文件的删减"><a href="#2-3-1-文件的删减" class="headerlink" title="2.3.1. 文件的删减"></a>2.3.1. 文件的删减</h2><p>通过脚手架创建完项目，很多同学还是会感觉目录结构过于复杂，所以我打算从零带着大家来编写代码。</p>
<p>我们先将不需要的文件统统删掉：</p>
<ul>
<li>1.将src下的所有文件都删除</li>
<li>2.将public文件下除列favicon.ico和index.html之外的文件都删除掉</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-5e08b8a2e69d0b1adf6672a5f395f125_720w.jpg" alt="img"></p>
<p>删除后的目录结构</p>
<p>修改index.html文件：</p>
<ul>
<li>我们需要删除选中的内容；</li>
<li>这两行内容是我们之前引入的一个图标和manifest文件</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-75a8403d08b6d580ccad8c5de712244c_720w.jpg" alt="img"></p>
<p>删除选中的两行内容</p>
<h2 id="2-3-2-开始编写代码"><a href="#2-3-2-开始编写代码" class="headerlink" title="2.3.2. 开始编写代码"></a>2.3.2. 开始编写代码</h2><p>在src目录下，创建一个index.js文件，因为这是webpack打包的入口。</p>
<p>在index.js中开始编写React代码：</p>
<ul>
<li>我们会发现和写的代码是逻辑是一致的；</li>
<li>只是在模块化开发中，我们需要手动的来导入React、ReactDOM，因为它们都是在我们安装的模块中；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;h2&gt;Hello React&lt;&#x2F;h2&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure>



<p><img src="https://pic4.zhimg.com/80/v2-e4a7139edc918d9ef6d0a0583b833523_720w.jpg" alt="img"></p>
<p>展示效果</p>
<p>如果我们不希望直接在 ReactDOM.render 中编写过多的代码，就可以单独抽取一个组件App.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h2&gt;Hello App&lt;&#x2F;h2&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在index.js中引入App，并且使用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line"></span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App&#x2F;&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure>



<p><img src="https://pic2.zhimg.com/80/v2-74bc4c6a8ed4f527620ffd0c5e3838ad_720w.jpg" alt="img"></p>
<h1 id="三-在React中使用react-router-dom路由"><a href="#三-在React中使用react-router-dom路由" class="headerlink" title="三.在React中使用react-router-dom路由"></a>三.在React中使用react-router-dom路由</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先进入项目目录，使用npm安装react-router-dom：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install react-router-dom --save-dev <span class="comment">//这里可以使用cnpm代替npm命令</span></span><br></pre></td></tr></table></figure>



<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>然后我们新建两个页面，分别命名为“home”和“detail”。在页面中编写如下代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;去detail&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>home.js</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a&gt;回到home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>detail.js</p>
<p>然后再新建一个路由组件，命名为“Router.js”，并编写如下代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HashRouter, Route, Switch&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../home'</span>;</span><br><span class="line"><span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">'../detail'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BasicRoute = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">"/detail"</span> component=&#123;Detail&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BasicRoute;</span><br></pre></td></tr></table></figure>

<p>如上代码定义了一个纯路由组件，将两个页面组件Home和Detail使用Route组件包裹，外面套用Switch作路由匹配，当路由组件检测到地址栏与Route的path匹配时，就会自动加载响应的页面。<br> 然后在入口文件中——我这里指定的是index.js——编写如下代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'./router/router'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里相当于向页面返回了一个路由组件。我们先运行项目看一下效果，在地址栏输入“<a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F%23%2F" target="_blank" rel="noopener">http://localhost:3000/#/</a>”：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6334988-218f06c2483c59ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/954/format/webp" alt="img"></p>
<p>home.js</p>
<p>输入“<a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F%23%2Fdetail" target="_blank" rel="noopener">http://localhost:3000/#/detail</a>”：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6334988-1acaaedd68e07674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/954/format/webp" alt="img"></p>
<p>detail.js</p>
<h2 id="通过a标签跳转"><a href="#通过a标签跳转" class="headerlink" title="通过a标签跳转"></a>通过a标签跳转</h2><p>可以看到其实路由已经开始工作了，接下来我们再来做页面间的跳转。在home.js和detail.js中，我们修改如下代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                &lt;a href=<span class="string">'#/detail'</span>&gt;去detail&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>home.js</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=<span class="string">'#/'</span>&gt;回到home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>detail.js</p>
<p>重新打包运行，在浏览器地址栏输入“<a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F" target="_blank" rel="noopener">http://localhost:3000/</a>”，试试看页面能否正常跳转。如果不能，请按步骤一步一步检查代码是否有误。以上是使用a标签的href进行页面间跳转，此外react-router-dom还提供了通过函数的方式跳转页面。</p>
<h2 id="通过函数跳转"><a href="#通过函数跳转" class="headerlink" title="通过函数跳转"></a>通过函数跳转</h2><p>首先我们需要修改router.js中的两处代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> &#123;HashRouter, Route, Switch, hashHistory&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line">...</span><br><span class="line">&lt;HashRouter history=&#123;hashHistory&#125;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后在home.js中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=<span class="string">'#/detail'</span>&gt;去detail&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; this.props.history.push('detail')&#125;&gt;通过函数跳转&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在a标签下面添加一个按钮并加上onClick事件，通过this.props.history.push这个函数跳转到detail页面。在路由组件中加入的代码就是将history这个对象注册到组件的props中去，然后就可以在子组件中通过props调用history的push方法跳转页面。</p>
<p>很多场景下，我们还需要在页面跳转的同时传递参数，在react-router-dom中，同样提供了两种方式进行传参。</p>
<h2 id="url传参"><a href="#url传参" class="headerlink" title="url传参"></a>url传参</h2><p>在router.js中，修改如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">"/detail/:id"</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;/</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后修改detail.js，使用this.props.match.params获取url传过来的参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.props.match.params);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在地址栏输入“<a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F%23%2Fdetail%2F3" target="_blank" rel="noopener">http://localhost:3000/#/detail/3</a>”，打开控制台：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6334988-28182a2ede7ea1f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/421/format/webp" alt="img"></p>
<p>可以看到传过去的id=3已经被获取到了。react-router-dom就是通过“/:”去匹配url传递的参数。</p>
<h2 id="隐式传参"><a href="#隐式传参" class="headerlink" title="隐式传参"></a>隐式传参</h2><p>此外还可以通过push函数隐式传参。</p>
<p>修改home.js代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=<span class="string">'#/detail/3'</span>&gt;去detail&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;button onClick=&#123;() =&gt; this.props.history.push(&#123;</span></span><br><span class="line"><span class="regexp">                        pathname: '/</span>detail<span class="string">',</span></span><br><span class="line"><span class="string">                        state: &#123;</span></span><br><span class="line"><span class="string">                            id: 3</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                &#125;)&#125;&gt;通过函数跳转&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在detail.js中，就可以使用this.props.history.location.state获取home传过来的参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="comment">//console.log(this.props.match.params);</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.props.history.location.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转后打开控制台可以看到参数被打印：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6334988-e7b04222dd82d74f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/365/format/webp" alt="img"></p>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>有些场景下，重复使用push或a标签跳转会产生死循环，为了避免这种情况出现，react-router-dom提供了replace。在可能会出现死循环的地方使用replace来跳转：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.replace(<span class="string">'/detail'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="goBack"><a href="#goBack" class="headerlink" title="goBack"></a>goBack</h3><p>场景中需要返回上级页面的时候使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.props</span><span class="selector-class">.history</span><span class="selector-class">.goBack</span>();</span><br></pre></td></tr></table></figure>



<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>嵌套路由的适用场景还是比较多的，接下来就来介绍一下实现方法。<br> 首先在Vue中实现嵌套路由，只需要将配置文件写成children嵌套，然后在需要展示子路由的位置加上<router-view></router-view>即可。React中应该如何实现呢？其实原理和Vue类似，只需要在父级路由中包含子路由即可。这样说可能很多同学会一头雾水，直接上代码（不使用上面的例子）：<br> 首先定义父级组件MainLayout</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./MainLayout.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLayout</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">'main-layout'</span>&gt;</span><br><span class="line">                父组件</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后定义子组件Home：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Modal, Select&#125; <span class="keyword">from</span> <span class="string">"antd"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;addCount&#125; <span class="keyword">from</span> <span class="string">'../../servers/home'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [visible, setVisible] = useState(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">countNum</span>: &#123;count&#125;, dispatch&#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure>

<p>然后将它们添加进路由router.js，并且关联父子关系：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HashRouter, Route, Switch&#125; from <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> Home from <span class="string">'../pages/Home/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> MainLayout from <span class="string">'../layout/MainLayout'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BasicRouter = () =&gt; (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/index"</span> component=&#123;</span><br><span class="line">                &lt;MainLayout&gt;</span><br><span class="line">                  &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route exact path=<span class="string">"/index"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">                  &lt;Route path=<span class="string">"/index/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">                &lt;/MainLayout&gt;</span><br><span class="line">             &#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BasicRouter;</span><br></pre></td></tr></table></figure>

<p>在MainLayout中，修改如下代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./MainLayout.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Header, Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLayout</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">'main-layout'</span>&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如此，一个嵌套路由就完成了。</p>
<h1 id="非脚手架搭建"><a href="#非脚手架搭建" class="headerlink" title="非脚手架搭建"></a>非脚手架搭建</h1><p>使用 React 的网页源码，结构大致如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;script src=<span class="string">"../build/react.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="../</span>build/react-dom.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="</span>../build/browser.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="</span>example<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/babel<span class="string">"&gt;</span></span><br><span class="line"><span class="string">      // ** Our code goes here! **</span></span><br><span class="line"><span class="string">		var names = ['Alice', 'Emily', 'Kate'];</span></span><br><span class="line"><span class="string">        var arr = [</span></span><br><span class="line"><span class="string">          &lt;h1&gt;Hello world!&lt;/h1&gt;,</span></span><br><span class="line"><span class="string">          &lt;h2&gt;React is awesome&lt;/h2&gt;,</span></span><br><span class="line"><span class="string">        ];</span></span><br><span class="line"><span class="string">        ReactDOM.render(</span></span><br><span class="line"><span class="string">          &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt; &#123;</span></span><br><span class="line"><span class="string">                names.map(function (name) &#123;</span></span><br><span class="line"><span class="string">                  return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt;</span></span><br><span class="line"><span class="string">                &#125;)</span></span><br><span class="line"><span class="string">            &#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;&#123;arr&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;,</span></span><br><span class="line"><span class="string">          document.getElementById('example')</span></span><br><span class="line"><span class="string">        );</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>上面代码有两个地方需要注意。首先，最后一个 <code>&lt;script&gt;</code> 标签的 <code>type</code> 属性为 <code>text/babel</code> 。这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 <code>type=&quot;text/babel&quot;</code> 。</p>
</li>
<li><p>其次，上面代码一共用了三个库： <code>react.js</code> 、<code>react-dom.js</code> 和 <code>Browser.js</code> ，它们必须首先加载。其中，<code>react.js</code> 是 React 的核心库，<code>react-dom.js</code> 是提供与 DOM 相关的功能，<code>Browser.js</code> 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。</p>
</li>
</ul>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ babel src --out-dir build</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>上面命令可以将 <code>src</code> 子目录的 <code>js</code> 文件进行语法转换，转码后的文件全部放在 <code>build</code> 子目录。</p>
</li>
<li><p>HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 <a href="http://facebook.github.io/react/docs/displaying-data.html#jsx-syntax" target="_blank" rel="noopener">JSX 的语法</a>，它允许 HTML 与 JavaScript 的混写，遇到 HTML 标签（以 <code>&lt;</code> 开头），就用 HTML 规则解析；遇到代码块（以 <code>{</code> 开头），就用 JavaScript 规则解析。</p>
</li>
<li><p>JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员</p>
</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage name=<span class="string">"John"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>上面代码中，变量 <code>HelloMessage</code> 就是一个组件类。模板插入 <code>&lt;HelloMessage /&gt;</code> 时，会自动生成 <code>HelloMessage</code> 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 <code>render</code> 方法，用于输出组件。</p>
</li>
<li><p>注意，组件类的第一个字母必须大写，否则会报错，比如<code>HelloMessage</code>不能写成<code>helloMessage</code>。另外，组件类只能包含一个顶层标签，否则也会报错。</p>
</li>
<li><p>组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 <code>&lt;HelloMessage name=&quot;John&quot;&gt;</code> ，就是 <code>HelloMessage</code> 组件加入一个 <code>name</code> 属性，值为 <code>John</code>。组件的属性可以在组件类的 <code>this.props</code> 对象上获取，比如 <code>name</code> 属性就可以通过 <code>this.props.name</code> 读取。</p>
</li>
<li><p>添加组件属性，有一个地方需要注意，就是 <code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code> ，这是因为 <code>class</code> 和 <code>for</code> 是 JavaScript 的保留字。</p>
</li>
</ul>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><ul>
<li><code>this.props</code> 对象的属性与组件的属性一一对应，但是有一个例外，就是 <code>this.props.children</code> 属性。它表示组件的所有子节点。这种用法是属于react中的组件的组合：将一个组件写在另一个组件的内容中，然后在外层组件中通过 this.props.children来接收内容中的组件， 效果上类似vue中的插槽。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> NotesList = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ol&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        React.Children.map(<span class="keyword">this</span>.props.children, <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;child&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;<span class="regexp">/ol&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;NotesList&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;hello&lt;/</span>span&gt;</span><br><span class="line">    &lt;span&gt;world&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>NotesList&gt;,</span><br><span class="line">  <span class="built_in">document</span>.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码的 <code>NoteList</code> 组件有两个 <code>span</code> 子节点，它们都可以通过 <code>this.props.children</code> 读取，运行结果如下。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033110.png" alt="img"></p>
<p>这里需要注意， <code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。</p>
<p>React 提供一个工具方法 <a href="https://facebook.github.io/react/docs/top-level-api.html#react.children" target="_blank" rel="noopener"><code>React.Children</code></a> 来处理 <code>this.props.children</code> 。我们可以用 <code>React.Children.map</code> 来遍历子节点，而不用担心 <code>this.props.children</code> 的数据类型是 <code>undefined</code> 还是 <code>object</code>。更多的 <code>React.Children</code> 的方法，请参考<a href="https://facebook.github.io/react/docs/top-level-api.html#react.children" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="getDefaultProps-方法可以用来设置组件属性的默认值。"><a href="#getDefaultProps-方法可以用来设置组件属性的默认值。" class="headerlink" title="getDefaultProps 方法可以用来设置组件属性的默认值。"></a><code>getDefaultProps</code> 方法可以用来设置组件属性的默认值。</h3><blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyTitle = React.createClass(&#123;</span><br><span class="line">  getDefaultProps : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title : <span class="string">'Hello World'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;this.props.title&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyTitle /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="获取真实的DOM节点"><a href="#获取真实的DOM节点" class="headerlink" title="获取真实的DOM节点"></a>获取真实的DOM节点</h2><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 <a href="http://calendar.perfplanet.com/2013/diff/" target="_blank" rel="noopener">DOM diff</a> ，它可以极大提高网页的性能表现。</p>
<p>但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性（查看 <a href="https://github.com/ruanyf/react-demos/blob/master/demo07/index.html" target="_blank" rel="noopener">demo07</a> ）。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.myTextInput.focus();</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=<span class="string">"myTextInput"</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"Focus the text input"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;MyComponent /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，组件 <code>MyComponent</code> 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 <code>ref</code> 属性，然后 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点。</p>
<p>需要注意的是，由于 <code>this.refs.[refName]</code> 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 <code>Click</code> 事件的回调函数，确保了只有等到真实 DOM 发生 <code>Click</code> 事件之后，才会读取 <code>this.refs.[refName]</code> 属性。</p>
<p>React 组件支持很多事件，除了 <code>Click</code> 事件以外，还有 <code>KeyDown</code> 、<code>Copy</code>、<code>Scroll</code> 等，完整的事件清单请查看<a href="http://facebook.github.io/react/docs/events.html#supported-events" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="this-state"><a href="#this-state" class="headerlink" title="this.state"></a>this.state</h2><p>组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI （查看 <a href="https://github.com/ruanyf/react-demos/blob/master/demo08/index.html" target="_blank" rel="noopener"><code>demo08</code></a> ）。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> LikeButton = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">liked</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">liked</span>: !<span class="keyword">this</span>.state.liked&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="keyword">this</span>.state.liked ? <span class="string">'like'</span> : <span class="string">'haven\'t liked'</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        You &#123;text&#125; <span class="keyword">this</span>. Click to toggle.</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;LikeButton /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码是一个 <code>LikeButton</code> 组件，它的 <code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。当用户点击组件，导致状态变化，<code>this.setState</code> 方法就修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。</p>
<p>由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>用户在表单填入的内容，属于用户跟组件的互动，所以不能用 <code>this.props</code> 读取（查看 <a href="https://github.com/ruanyf/react-demos/blob/master/demo09/index.html" target="_blank" rel="noopener"><code>demo9</code></a> ）。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Input = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="string">'Hello!'</span>&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  handleChange: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.state.value;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> value=&#123;value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;p&gt;&#123;value&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Input</span>/&gt;</span></span>, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，文本输入框的值，不能用 <code>this.props.value</code> 读取，而要定义一个 <code>onChange</code> 事件的回调函数，通过 <code>event.target.value</code> 读取用户输入的值。<code>textarea</code> 元素、<code>select</code>元素、<code>radio</code>元素都属于这种情况，更多介绍请参考<a href="http://facebook.github.io/react/docs/forms.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>组件的<a href="https://facebook.github.io/react/docs/working-with-the-browser.html#component-lifecycle" target="_blank" rel="noopener">生命周期</a>分成三个状态：</p>
<blockquote>
<ul>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ul>
</blockquote>
<p>React 为每个状态都提供了两种处理函数，<code>will</code> 函数在进入状态之前调用，<code>did</code> 函数在进入状态之后调用，三种状态共计五种处理函数。</p>
<blockquote>
<ul>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillUpdate(object nextProps, object nextState)</li>
<li>componentDidUpdate(object prevProps, object prevState)</li>
<li>componentWillUnmount()</li>
</ul>
</blockquote>
<p>此外，React 还提供两种特殊状态的处理函数。</p>
<blockquote>
<ul>
<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>脚手架</tag>
        <tag>create-react-app</tag>
      </tags>
  </entry>
  <entry>
    <title>this之常见的四种用法</title>
    <url>/2020/09/27/this%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><span style="color:red;">箭头函数的this指向window！！！！！！！！</span></p>
<p>1.在一般函数方法中使用 this 指代全局对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">　　　　this.x &#x3D; 1;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>2.作为对象方法调用，this 指代上级对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">情况一</span><br><span class="line">var x&#x3D;10</span><br><span class="line">function test()&#123;</span><br><span class="line">　　alert(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line">o.x &#x3D; 1;</span><br><span class="line">o.m &#x3D; test;</span><br><span class="line">o.m(); &#x2F;&#x2F; 1 this指的是对象</span><br><span class="line"></span><br><span class="line">情况二</span><br><span class="line">var x&#x3D;10</span><br><span class="line">function test()&#123;</span><br><span class="line">　　alert(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line">o.x &#x3D; 1;</span><br><span class="line">o.m &#x3D; test;</span><br><span class="line">var qa&#x3D;o.m</span><br><span class="line">qa(); &#x2F;&#x2F; 10 this指的是window</span><br></pre></td></tr></table></figure>



<p>3.作为构造函数调用，this 指代new 出的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x &#x3D; 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o &#x3D; new test();</span><br><span class="line">　　alert(o.x); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：</span><br><span class="line">　　var x &#x3D; 2;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x &#x3D; 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o &#x3D; new test();</span><br><span class="line">　　alert(x); &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>



<p>4.apply 调用 ，apply方法作用是改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this指代第一个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　var x &#x3D; 0;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o&#x3D;&#123;&#125;;</span><br><span class="line">　　o.x &#x3D; 1;</span><br><span class="line">　　o.m &#x3D; test;</span><br><span class="line">　　o.m.apply(); &#x2F;&#x2F;0</span><br><span class="line">&#x2F;&#x2F;apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为</span><br><span class="line"></span><br><span class="line">　　o.m.apply(o); &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>seecky之地图开发记录</title>
    <url>/2020/12/23/seecky%E4%B9%8B%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="react开发记录"><a href="#react开发记录" class="headerlink" title="react开发记录"></a>react开发记录</h2><p>杂记</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Fragment </span><br><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line">&lt;Fragment&gt;</span><br><span class="line">    </span><br><span class="line">&lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">不想生成多余的标签可以用这个，相当于&lt;template&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class testComp extends Component&#123;</span><br><span class="line">constructor(props)&#123;</span><br><span class="line">	super(props) &#x2F;&#x2F;接受其他组件的参数,必须在使用this之前调用</span><br><span class="line">	this.state&#x3D;&#123; &#x2F;&#x2F;定义自己的变量</span><br><span class="line">			num:1,</span><br><span class="line">			flag:true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">export default testComp</span><br></pre></td></tr></table></figure>

<p>*<em>tips: *</em></p>
<p>Es6中的super可以用在类的继承中，super关键字，它指代父类的实例（即父类的this对象）。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。</p>
<p>如果不调用super方法，子类就得不到this对象。</p>
<a id="more"></a>

<h3 id="创建组件的两种方式"><a href="#创建组件的两种方式" class="headerlink" title="创建组件的两种方式"></a>创建组件的两种方式</h3><p>函数式组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎进入&#123;props.name&#125;的世界<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// React组件的调用方式</span></span><br><span class="line">  &lt;App name=<span class="string">"react"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>class组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 注意这里得用this.props.name, 必须用this.props</span></span><br><span class="line">      &lt;h1&gt;欢迎进入&#123;<span class="keyword">this</span>.props.name&#125;的世界&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;App name="react" /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="属性-props"><a href="#属性-props" class="headerlink" title="属性(props)"></a>属性(props)</h3><p>总的来说，在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为组件 <code>props</code> 对象的键值。通过箭头函数创建的组件，需要通过函数的参数来接收<code>props</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;h1&gt;欢迎进入&#123;<span class="keyword">this</span>.props.name&#125;的世界&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Content = (props) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;&#123;props.name&#125;是一个构建UI的库&lt;/</span>p&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">        &lt;Title name=<span class="string">"React"</span> /&gt;</span><br><span class="line">        &lt;Content name=<span class="string">"React.js"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;App/</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="设置组件的默认props"><a href="#设置组件的默认props" class="headerlink" title="设置组件的默认props"></a>设置组件的默认props</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用类创建的组件，直接在这里写static方法，创建defaultProps</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name: <span class="string">'React'</span></span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;h1&gt;欢迎进入&#123;<span class="keyword">this</span>.props.name&#125;的世界&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Content = (props) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;&#123;props.name&#125;是一个构建UI的库&lt;/</span>p&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数创建的组件，需要在这个组件上直接写defaultProps属性</span></span><br><span class="line">Content.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">'React.js'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">        &#123;<span class="comment">/* 由于设置了defaultProps， 不传props也能正常运行，如果传递了就会覆盖defaultProps的值 */</span>&#125;</span><br><span class="line">        &lt;Title /&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;App/</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="props-children"><a href="#props-children" class="headerlink" title="props.children"></a>props.children</h3><p>要在自定义组件的使用嵌套结构，就需要使用 <code>props.children</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Content = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p&gt;&#123;props.children&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;Fragment&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Content&gt;&lt;i&gt;React.js&lt;/i</span>&gt;是一个构建UI的库&lt;<span class="regexp">/Content&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="使用prop-types检测props数据类型"><a href="#使用prop-types检测props数据类型" class="headerlink" title="使用prop-types检测props数据类型"></a>使用prop-types检测props数据类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;安装</span><br><span class="line">npm install prop-types --save</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引入</span><br><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line">TodoItem.propTypes &#x3D; &#123;</span><br><span class="line">    test: PropTypes.string.isRequired,   &#x2F;&#x2F;加上isRequired以后，即使父组件没传递值也会抛出警告</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line">TodoItem.propTypes &#x3D; &#123;</span><br><span class="line">    test: PropTypes.arrayOf(PropTypes.string, PropTypes.number)   &#x2F;&#x2F;可以设置多个类型</span><br><span class="line">　　 test: PropTypes.oneOfType([PropTypes.string, PropTypes.number])   &#x2F;&#x2F;符合任意一个类型即可</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">那么如何解决父组件没传递值也会抛出的警告呢？可以使用react里的defaultProps来设置默认的props值</span><br><span class="line">TodoItem.defaultProps &#x3D; &#123;</span><br><span class="line">  test: &#39;hello word&#39;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详解: <a href="https://www.cnblogs.com/sexintercourse/p/12054344.html" target="_blank" rel="noopener">https://www.cnblogs.com/sexintercourse/p/12054344.html</a></p>
<h3 id="生命周期（钩子函数）"><a href="#生命周期（钩子函数）" class="headerlink" title="生命周期（钩子函数）"></a>生命周期（钩子函数）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dom渲染成功前（相当于beforeMounted）</span><br><span class="line">componentWillMount()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">渲染函数</span><br><span class="line">render()&#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;div&gt;</span><br><span class="line">			123456</span><br><span class="line">			&lt;div&gt;123456&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line">dom渲染成功后（相当于mounted）</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">卸载前</span><br><span class="line">componentWillUnmount()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">触发的一系列的方法 ，这就是组件的生命周期函数</span><br><span class="line"></span><br><span class="line">组件加载的时候触发的函数：</span><br><span class="line"></span><br><span class="line">    constructor 、componentWillMount、 render 、componentDidMount</span><br><span class="line"></span><br><span class="line">组件数据更新的时候触发的生命周期函数：</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate</span><br><span class="line"></span><br><span class="line">你在父组件里面改变props传值的时候触发的：</span><br><span class="line"></span><br><span class="line">    componentWillReceiveProps</span><br><span class="line"></span><br><span class="line">组件销毁的时候触发的：</span><br><span class="line"></span><br><span class="line">    componentWillUnmount</span><br><span class="line"></span><br><span class="line">必须记住的生命周期函数：</span><br><span class="line"></span><br><span class="line">    *加载的时候：componentWillMount、 render 、componentDidMount（dom操作）</span><br><span class="line"></span><br><span class="line">    更新的时候：componentWillUpdate、render、componentDidUpdate</span><br><span class="line"></span><br><span class="line">    *销毁的时候： componentWillUnmount</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/16775500-8d325f8093591c76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/740/format/webp" alt="img"></p>
<h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><p>JSX 即Javascript XML，它是对JavaScript 语法扩展。React 使用 JSX 来替代常规的 JavaScript。你也可以认为JSX其实就是JavaScript。当遇到&lt;，JSX就当HTML解析，遇到{就当JavaScript解析。</p>
<p><strong>最外层只能嵌套一个母标签，不要嵌套多个</strong></p>
<p><strong>支持表达式，只需要将表达式写到{}内即可，不能使用if else 的，但可以使用三元运算表达式</strong><br><strong>所有变量或者方法使用{}，style使用插值表达式，方式调用或者是</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;</span><br><span class="line">    var ok&#x3D;1;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;ok&#x3D;&#x3D;1?&quot;我很帅&quot;:&quot;我很有才华&quot;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;,</span><br><span class="line">        document.querySelector(&quot;#wrap&quot;)</span><br><span class="line">    )</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="dangerouslySetHTML（innerHTML）"><a href="#dangerouslySetHTML（innerHTML）" class="headerlink" title="dangerouslySetHTML（innerHTML）"></a>dangerouslySetHTML（innerHTML）</h3><p>使用<code>dangerouslySetHTML</code>属性，它允许我们动态设置<code>innerHTML</code>,否则会直接转义成文本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      content : <span class="string">"&lt;p&gt;React.js是一个构建UI的库&lt;/p&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div</span><br><span class="line">        <span class="comment">// 注意这里是两个下下划线 __html</span></span><br><span class="line">        dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: <span class="keyword">this</span>.state.content&#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="JSX上的style"><a href="#JSX上的style" class="headerlink" title="JSX上的style"></a>JSX上的style</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ok=<span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> myStyle=&#123;</span></span><br><span class="line"><span class="actionscript">        color:<span class="string">"red"</span>,</span></span><br><span class="line">        fontSize:50</span><br><span class="line">    &#125;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;myStyle&#125;</span>&gt;</span>&#123;ok==1?"我很帅":"我很有才华"&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">"#wrap"</span>)</span></span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ok=<span class="number">1</span>;</span></span><br><span class="line">    ReactDOM.render(</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">//style此处应为双括号</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="actionscript">                color:<span class="string">"red"</span>,</span></span><br><span class="line">                fontSize:50</span><br><span class="line"><span class="actionscript">            &#125;&#125;&gt;&#123;ok==<span class="number">1</span>?<span class="string">"我很帅"</span>:<span class="string">"我很有才华"</span>&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">"#wrap"</span>)</span></span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JSX上的数组输出"><a href="#JSX上的数组输出" class="headerlink" title="JSX上的数组输出"></a>JSX上的数组输出</h3><h4 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr=[</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你是风儿<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是沙<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>,</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>缠缠绵绵到天涯<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span></span><br><span class="line">    ];</span><br><span class="line">    ReactDOM.render(</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            &#123;arr&#125;</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">"#wrap"</span>)</span></span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式二（map渲染）"><a href="#方式二（map渲染）" class="headerlink" title="方式二（map渲染）"></a>方式二（<strong>map渲染</strong>）</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr=[<span class="string">"你是风儿"</span>,<span class="string">"我是沙"</span>,<span class="string">"缠缠绵绵到天涯"</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> lis=arr.map(<span class="function"><span class="keyword">function</span><span class="params">(v)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;v&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span></span><br><span class="line">    &#125;)</span><br><span class="line">    ReactDOM.render(</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            &#123;lis&#125;</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">"#wrap"</span>)</span></span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="方式一：内联调用法"><a href="#方式一：内联调用法" class="headerlink" title="方式一：内联调用法"></a>方式一：内联调用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class func extends Component&#123;</span><br><span class="line">    constructor(porps)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    funcOne()&#123;</span><br><span class="line">        console.log(&#39;内联调用法&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.funcOne.bind(this)&#125;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式二：配置中调用法"><a href="#方式二：配置中调用法" class="headerlink" title="方式二：配置中调用法"></a>方式二：配置中调用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class func extends Component&#123;</span><br><span class="line">    constructor(porps)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.funcTwo &#x3D; this.funcTwo.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">    funcTwo()&#123;</span><br><span class="line">        console.log(&#39;配置中调用法&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.funcTwo&#125;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式三：箭头函数调用法（最推荐）"><a href="#方式三：箭头函数调用法（最推荐）" class="headerlink" title="方式三：箭头函数调用法（最推荐）"></a>方式三：箭头函数调用法（最推荐）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class func extends Component&#123;</span><br><span class="line">    constructor(porps)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    funcThree:() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;箭头函数调用法&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.funcThree&#125;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="map配置"><a href="#map配置" class="headerlink" title="map配置"></a>map配置</h2><h3 id="从接口读取map配置"><a href="#从接口读取map配置" class="headerlink" title="从接口读取map配置"></a>从接口读取map配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getMapParams() &#123;</span><br><span class="line">        let that &#x3D; this;</span><br><span class="line">        mapAction.getMapParams(that, &#123;</span><br><span class="line">            mapCode: &quot;bigMap&quot;,</span><br><span class="line">            dataReturn: function (params) &#123;</span><br><span class="line">                that.setState(&#123;</span><br><span class="line">                    mapParams: params</span><br><span class="line">                &#125;)</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    that.mapInit();</span><br><span class="line">                &#125;, 500);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="地图初始化"><a href="#地图初始化" class="headerlink" title="地图初始化"></a>地图初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapInit() &#123;</span><br><span class="line">        if (map &#x3D;&#x3D; null) &#123;</span><br><span class="line">            let mapUrl &#x3D; &quot;.&#x2F;file&#x2F;loadFMap&quot;;</span><br><span class="line">            map &#x3D; new commonMap.FMMap(&#123;</span><br><span class="line">                &#x2F;&#x2F;渲染dom</span><br><span class="line">                container: document.getElementById(&#39;mapApplyContainer&#39;),</span><br><span class="line">                &#x2F;&#x2F;地图服务器地址</span><br><span class="line">                mapServerURL: mapUrl,</span><br><span class="line">                &#x2F;&#x2F;主题服务地址</span><br><span class="line">                mapThemeURL: &#39;.&#x2F;fmaptheme&#x2F;&#39; + localStorage.appid_device + &#39;&#x2F;&#39; + localStorage.buildId_device,</span><br><span class="line">                &#x2F;&#x2F;主题id</span><br><span class="line">                defaultThemeName: this.state.mapParams.themeId,</span><br><span class="line">                &#x2F;&#x2F;地图默认比例尺级别</span><br><span class="line">                defaultMapScaleLevel: this.state.mapParams.defaultMapScaleLevel,</span><br><span class="line">                &#x2F;&#x2F;地图默认自定义比例尺</span><br><span class="line">                defaultMapScale: this.state.mapParams.defaultMapScale,</span><br><span class="line">                &#x2F;&#x2F;支持单击模型高亮，false为单击时模型不高亮</span><br><span class="line">                modelSelectedEffect: false,</span><br><span class="line">                &#x2F;&#x2F;默认旋转角</span><br><span class="line">                rotateAngle: this.state.mapParams.rotateAngle,</span><br><span class="line">                &#x2F;&#x2F;默认倾斜角</span><br><span class="line">                defaultTiltAngle: this.state.mapParams.defaultTiltAngle,</span><br><span class="line">                &#x2F;&#x2F;楼层间距</span><br><span class="line">                defaultGroupSpace: this.state.mapParams.defaultGroupSpace,</span><br><span class="line">                &#x2F;&#x2F;默认地图模型（2D&#x2F;3D）</span><br><span class="line">                defaultViewMode: this.state.mapParams.defaultViewMode &#x3D;&#x3D; &quot;2D&quot; ? commonMap.FMViewMode.MODE_2D : commonMap.FMViewMode.MODE_3D,</span><br><span class="line">                &#x2F;&#x2F;开场动画</span><br><span class="line">                viewModeAnimateMode: true,</span><br><span class="line">                focusAlphaMode: false,</span><br><span class="line">                focusAnimateMode: false,</span><br><span class="line">                focusAlpha: 0.1,</span><br><span class="line">                key: this.state.mapParams.webKey,</span><br><span class="line">                appName: this.state.mapParams.webName,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;buildId_device -- 建筑id</span><br><span class="line">        map.openMapById(localStorage.buildId_device);</span><br><span class="line">        const that &#x3D; this;</span><br><span class="line">        &#x2F;&#x2F;地图渲染结束回调</span><br><span class="line">        map.on(&quot;loadComplete&quot;, function (event) &#123;</span><br><span class="line">            that.loadComplete(event);</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F;地图点击事件</span><br><span class="line">        map.on(&quot;mapClickNode&quot;, function (event) &#123;</span><br><span class="line">            that.MapClickNode(event);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="地图渲染结束回调"><a href="#地图渲染结束回调" class="headerlink" title="地图渲染结束回调"></a>地图渲染结束回调</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadComplete &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;设置地图背景颜色</span><br><span class="line">        map.setBackgroundColor(&quot;#EEF3F4&quot;, 1);</span><br><span class="line">        &#x2F;&#x2F;进场动画</span><br><span class="line">        var angle &#x3D; this.state.mapParams.rotateAngle % 360;</span><br><span class="line">        map._map.rotateTo(angle, &#123; animate: true &#125;);</span><br><span class="line">        &#x2F;&#x2F;获取可视楼层</span><br><span class="line">        &#x2F;&#x2F;mapGroupNames&#x3D;[&quot;b1&quot;,&quot;f1&quot;,&quot;f2&quot;,&quot;f3&quot;,&quot;f4&quot;,&quot;f5&quot;]</span><br><span class="line">        var mapGroupNames &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; map.listGroups.length; i++) &#123;</span><br><span class="line">            var floorName &#x3D; map.listGroups[i].gname;</span><br><span class="line">            mapGroupNames.push(floorName.toLowerCase());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;渲染楼层切换数据</span><br><span class="line">        &#x2F;&#x2F;读取groupIDs  map.groupIDs&#x3D;[1,2,3,4,5]</span><br><span class="line">        &#x2F;&#x2F;floorList&#x3D;[&#123;floorNum: &quot;b1&quot;,floorStr: &quot;b1楼&quot;,groupID: 1&#125;]...</span><br><span class="line">        floorList &#x3D; mapAction.changeGroupNames(mapGroupNames, map.groupIDs);</span><br><span class="line">        if (!this.state.defaultFloor) &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                defaultFloor: floorList[0].floorNum</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取聚焦楼层的id</span><br><span class="line">        focusGroupID &#x3D; mapAction.changeFloorIdToGroupId(this.state.defaultFloor, floorList);</span><br><span class="line">        map.focusGroupID &#x3D; focusGroupID;</span><br><span class="line">        &#x2F;&#x2F;设置楼层可见个数（）</span><br><span class="line">        if (this.state.multiFloorDisplayFlag) &#123;</span><br><span class="line">            map.visibleGroupIDs &#x3D; map.groupIDs;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.visibleGroupIDs &#x3D; [map.focusGroupID];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="切换楼层-得到当前的楼层focusGroupID"><a href="#切换楼层-得到当前的楼层focusGroupID" class="headerlink" title="切换楼层(得到当前的楼层focusGroupID)"></a>切换楼层(得到当前的楼层focusGroupID)</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>楼层<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Select</span></span></span><br><span class="line"><span class="tag">            <span class="attr">value</span>=<span class="string">&#123;focusGroupID&#125;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">width:</span> <span class="attr">150</span> &#125;//此处应为双括号</span></span><br><span class="line"><span class="tag">            <span class="attr">onChange</span>=<span class="string">&#123;this.floorChange&#125;</span></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">        floorList.map(item =&gt; &#123;</span><br><span class="line">        return (item ? <span class="tag">&lt;<span class="name">Select.Option</span> <span class="attr">value</span>=<span class="string">&#123;item.groupID&#125;</span> <span class="attr">key</span>=<span class="string">&#123;item.groupIDs&#125;</span>&gt;</span>&#123;item.floorStr&#125;<span class="tag">&lt;/<span class="name">Select.Option</span>&gt;</span> : null)</span><br><span class="line">        &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">js</span><br><span class="line">floorChange = (value) =&gt; &#123;</span><br><span class="line">        focusGroupID = value</span><br><span class="line">        map.focusGroupID = value</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="切换单楼层-多楼层-showSingerOrMultiGroup"><a href="#切换单楼层-多楼层-showSingerOrMultiGroup" class="headerlink" title="切换单楼层/多楼层(showSingerOrMultiGroup)"></a>切换单楼层/多楼层(showSingerOrMultiGroup)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div onClick&#x3D;&#123;this.multiFloorDisplay&#125;&gt;</span><br><span class="line">                            &lt;img src&#x3D;&#123;this.state.multiFloorDisplayFlag ? require(&#39;..&#x2F;..&#x2F;img&#x2F;singleFloor.png&#39;) : require(&#39;..&#x2F;..&#x2F;img&#x2F;mulFloor.png&#39;)&#125;&gt;&lt;&#x2F;img&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">js                   </span><br><span class="line">    multiFloorDisplay &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;切换flag</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            multiFloorDisplayFlag: !this.state.multiFloorDisplayFlag</span><br><span class="line">        &#125;)</span><br><span class="line">        let that &#x3D; this;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;改变单层多层</span><br><span class="line">            map.showSingerOrMultiGroup(that.state.multiFloorDisplayFlag);</span><br><span class="line">            &#x2F;&#x2F;改变2D&#x2F;3D</span><br><span class="line">            if (this.state.multiFloorDisplayFlag) &#123;</span><br><span class="line">                map.viewMode &#x3D; commonMap.FMViewMode.MODE_3D</span><br><span class="line">                this.state.mapParams.defaultViewMode &#x3D; &#39;3D&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="切换2D-3D"><a href="#切换2D-3D" class="headerlink" title="切换2D/3D"></a>切换2D/3D</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.modeChange&#125;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">userSelect:</span> '<span class="attr">none</span>' &#125;&gt;</span>&#123;this.state.mapParams.defaultViewMode == '2D' ? '3D' : '2D'&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">js</span><br><span class="line">modeChange = () =&gt; &#123;</span><br><span class="line">        let mode = this.state.mapParams;</span><br><span class="line">        if (mode.defaultViewMode == '2D') &#123;</span><br><span class="line">            mode.defaultViewMode = '3D';</span><br><span class="line">            map.viewMode = commonMap.FMViewMode.MODE_3D</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mode.defaultViewMode = '2D'</span><br><span class="line">            map.viewMode = commonMap.FMViewMode.MODE_2D</span><br><span class="line">        &#125;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            mapParams: mode</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="戳点与更新"><a href="#戳点与更新" class="headerlink" title="戳点与更新"></a>戳点与更新</h3><h4 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 坐标转换</span><br><span class="line">convertX(x) &#123;</span><br><span class="line">	return parseInt((x - map.minX) * 1000);</span><br><span class="line">&#125;</span><br><span class="line">convertY(y) &#123;</span><br><span class="line">	return parseInt((map.maxY - y) * 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;接口坐标改为map坐标，戳点</span><br><span class="line">convertFmapX(x) &#123;</span><br><span class="line">	return (x &#x2F; 1000 + map.minX);</span><br><span class="line">&#125;</span><br><span class="line">convertFmapY(y) &#123;</span><br><span class="line">	return (map.maxY - y &#x2F; 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="图标戳点"><a href="#图标戳点" class="headerlink" title="图标戳点"></a>图标戳点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addImageMarkerNormal &#x3D; (pointData) &#x3D;&gt; &#123;</span><br><span class="line">        const pointGroupId &#x3D; mapAction.changeFloorStrToGroupID(pointData.floorNo, floorList);</span><br><span class="line">        if (!pointGroupId) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let imgSrc &#x3D; require(&#39;..&#x2F;imgs&#x2F;woman.png&#39;);</span><br><span class="line">        var group &#x3D; map.getFMGroup(pointGroupId);</span><br><span class="line">        var layer &#x3D; group.getOrCreateLayer(&#39;imageMarker&#39;);</span><br><span class="line">        var im &#x3D; new commonMap.FMImageMarker(&#123;</span><br><span class="line">            id: pointData.id,</span><br><span class="line">            x: this.convertFmapX(pointData.x),</span><br><span class="line">            y: this.convertFmapY(pointData.y),</span><br><span class="line">            height: 1,</span><br><span class="line">            groupID: pointGroupId,</span><br><span class="line">            url: imgSrc,</span><br><span class="line">            size: 30,</span><br><span class="line">            isAlwaysShow: true,</span><br><span class="line">            callback: function () &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        layer.addMarker(im);</span><br><span class="line">        &#x2F;&#x2F; im.userGroupID &#x3D; pointGroupId;</span><br><span class="line">        pointMarkerList.push(im)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="文本戳点"><a href="#文本戳点" class="headerlink" title="文本戳点"></a>文本戳点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addTextMarker &#x3D; (pointData) &#x3D;&gt; &#123;</span><br><span class="line">        let gid &#x3D; mapAction.changeFloorStrToGroupID(pointData.floorNo, floorList)</span><br><span class="line">        if (!gid) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        var group &#x3D; map.getFMGroup(gid);</span><br><span class="line">        var layer &#x3D; group.getOrCreateLayer(&#39;textMarker&#39;);</span><br><span class="line">        var tm &#x3D; new commonMap.FMTextMarker(&#123;</span><br><span class="line">            id: pointData.id,</span><br><span class="line">            x: this.convertFmapX(pointData.x),</span><br><span class="line">            y: this.convertFmapY(pointData.y),</span><br><span class="line">            groupID: gid,</span><br><span class="line">            name: pointData.name,</span><br><span class="line">            fontsize: 13,</span><br><span class="line">            fillcolor: &#39;72,61,139&#39;,</span><br><span class="line">            &#x2F;&#x2F; isAlwaysShow: false,</span><br><span class="line">            height: 1,</span><br><span class="line">            alpha: &#39;0.3&#39;,</span><br><span class="line">            callback: function () &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        layer.addMarker(tm);</span><br><span class="line">        tm.userGroupID &#x3D; gid;</span><br><span class="line">        textMarkerList.push(tm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="更新图标点位"><a href="#更新图标点位" class="headerlink" title="更新图标点位"></a>更新图标点位</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updatePoint &#x3D; (pointData) &#x3D;&gt; &#123;</span><br><span class="line">        const pointGroupId &#x3D; mapAction.changeFloorStrToGroupID(pointData.floorNo, floorList);</span><br><span class="line">        if (!pointGroupId) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let imgSrc &#x3D; pointData.alarmStatus ? pointImgObj.warning : pointImgObj.normal;</span><br><span class="line">        imgSrc &#x3D; pointData.localStatus !&#x3D; 1 ? pointImgObj.offline : imgSrc;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; pointMarkerList.length; i++) &#123;</span><br><span class="line">            if (pointMarkerList[i].id_ &#x3D;&#x3D; pointData.id) &#123;</span><br><span class="line">                pointMarkerList[i].setPosition(this.convertFmapX(pointData.x), this.convertFmapY(pointData.y), pointGroupId, 2)</span><br><span class="line">                pointMarkerList[i]._url &#x3D; pointImgObj.warning;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="更新文字点位"><a href="#更新文字点位" class="headerlink" title="更新文字点位"></a>更新文字点位</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updateTextMarker &#x3D; (pointData) &#x3D;&gt; &#123;</span><br><span class="line">        var gid &#x3D; mapAction.changeFloorStrToGroupID(pointData.floorNo, floorList);</span><br><span class="line">        for (let i &#x3D; 0; i &lt; textMarkerList.length; i++) &#123;</span><br><span class="line">            if (textMarkerList[i].id_ &#x3D;&#x3D; pointData.id || textMarkerList[i].id &#x3D;&#x3D; pointData.id) &#123;</span><br><span class="line">                textMarkerList[i].setPosition(this.convertFmapX(pointData.x), this.convertFmapY(pointData.y), gid, 2)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="根据id删除图片点位"><a href="#根据id删除图片点位" class="headerlink" title="根据id删除图片点位"></a>根据id删除图片点位</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">removeImgMarkerByMarker &#x3D; (id) &#x3D;&gt; &#123;</span><br><span class="line">        var index &#x3D; -1;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; pointMarkerList.length; i++) &#123;</span><br><span class="line">            const obj &#x3D; pointMarkerList[i];</span><br><span class="line">            if ((obj.selfID || obj.id || obj.id_) &#x3D;&#x3D;&#x3D; id) &#123;</span><br><span class="line">                index &#x3D; i;</span><br><span class="line">                var group &#x3D; map.getFMGroup(obj.groupID);</span><br><span class="line">                if (!group) &#123;</span><br><span class="line">                    pointMarkerList.splice(i, 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                var layer &#x3D; group.getOrCreateLayer(&#39;imageMarker&#39;);</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    layer.removeMarker(obj);</span><br><span class="line">                &#125;, 0);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index !&#x3D; -1) &#123;</span><br><span class="line">            pointMarkerList.splice(index, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="根据id删除文字点位"><a href="#根据id删除文字点位" class="headerlink" title="根据id删除文字点位"></a>根据id删除文字点位</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">removeTextMarkerById(id) &#123;</span><br><span class="line">        var index &#x3D; -1;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; textMarkerList.length; i++) &#123;</span><br><span class="line">            const obj &#x3D; textMarkerList[i];</span><br><span class="line">            if ((obj.selfID || obj.id || obj.id_) &#x3D;&#x3D;&#x3D; id) &#123;</span><br><span class="line">                index &#x3D; i;</span><br><span class="line">                var group &#x3D; map.getFMGroup(obj.groupID);</span><br><span class="line">                if (!group) &#123;</span><br><span class="line">                    textMarkerList.splice(i, 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                var layer &#x3D; group.getOrCreateLayer(&#39;textMarker&#39;);</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    layer.removeMarker(obj);</span><br><span class="line">                &#125;, 0);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index !&#x3D; -1) &#123;</span><br><span class="line">            textMarkerList.splice(index, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="websocket简单用法"><a href="#websocket简单用法" class="headerlink" title="websocket简单用法"></a>websocket简单用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let webSocketHost &#x3D; &#39;&#39;</span><br><span class="line">let ws &#x3D; null</span><br><span class="line"></span><br><span class="line">componentWillMount() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取websocket请求地址</span><br><span class="line">	var webSocketType &#x3D; (&#39;https:&#39; &#x3D;&#x3D;&#x3D; document.location.protocol) ? &#39;wss&#39; : &#39;ws&#39;;</span><br><span class="line">	webSocketHost &#x3D; webSocketType + &#39;:&#x2F;&#x2F;&#39; + document.location.host + &quot;&#x2F;websocket&#x2F;&quot; + localStorage.buildId_device</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从websocket中读取数据</span><br><span class="line">webSocketStart() &#123;</span><br><span class="line">        let that &#x3D; this;</span><br><span class="line">        if (ws) &#123;</span><br><span class="line">            ws.close()</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;172.16.10.74:8086&#x2F;websocket&#x2F;&quot; + localStorage.buildId_device);</span><br><span class="line">        ws &#x3D; new WebSocket(webSocketHost)</span><br><span class="line">        &#x2F;&#x2F;根据条件查询websocket</span><br><span class="line">        ws.onopen &#x3D; function (evt) &#123;</span><br><span class="line">            if (that.state.exactID !&#x3D; &quot;&quot;) &#123;</span><br><span class="line">                ws.send(&#39;&#123;&quot;direction&quot;:&quot;bTos&quot;,&quot;requestMethod&quot;:&quot;initGoodsByCondition&quot;,id:&quot;&#39; + that.state.exactID + &#39;&quot;&#125;&#39;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ws.send(&#39;&#123;&quot;direction&quot;:&quot;bTos&quot;,&quot;requestMethod&quot;:&quot;initGoodsByCondition&quot;,nameOrSn:&quot;&#39; + that.state.vagueField + &#39;&quot;,category:&quot;&#39; + (that.state.wsCategory &#x3D;&#x3D; &#39;全部&#39; ? &#39;&#39; : that.state.wsCategory) + &#39;&quot;,dept:&quot;&#39; + (that.state.wsDept &#x3D;&#x3D; &#39;全部&#39; ? &#39;&#39; : that.state.wsDept) + &#39;&quot;&#125;&#39;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.onmessage &#x3D; function (evt) &#123;</span><br><span class="line">            const d &#x3D; JSON.parse(evt.data);</span><br><span class="line">            if (d.responseType &#x3D;&#x3D;&#x3D; &quot;ping&quot;) &#123;</span><br><span class="line">                &#x2F;&#x2F;保持呼吸</span><br><span class="line">                ws.send(&#39;&#123;&quot;direction&quot;:&quot;bTos&quot;,&quot;requestMethod&quot;:&quot;pong&quot;,&quot;data&quot;:null&#125;&#39;)</span><br><span class="line">            &#125; else if (d.responseType &#x3D;&#x3D;&#x3D; &quot;initGoodsMonitorPage&quot; || d.responseType &#x3D;&#x3D;&#x3D; &quot;initGoodsByCondition&quot;) &#123;</span><br><span class="line">                &#x2F;&#x2F;处理数据</span><br><span class="line">                &#x2F;&#x2F;移除所有点位</span><br><span class="line">                that.removeAllTextMarker();</span><br><span class="line">                that.removePointMarker();</span><br><span class="line">                if (d.data.ok) &#123;</span><br><span class="line">                    &#x2F;&#x2F;正式数据</span><br><span class="line">                    allResData.data &#x3D; JSON.parse(d.data.data).goodsItems;</span><br><span class="line">                    &#x2F;* 烟感温湿度 *&#x2F;</span><br><span class="line">                    shList &#x3D; JSON.parse(d.data.data).shList;</span><br><span class="line">                    if (showSmokeImg) &#123;</span><br><span class="line">                        for (let kk &#x3D; 0; kk &lt; shList.length; kk++) &#123;</span><br><span class="line">                            const obj &#x3D; shList[kk];</span><br><span class="line">                            that.addSmokeImg(obj);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;* 文字和图片点位的添加 *&#x2F;</span><br><span class="line">                    for (let i &#x3D; 0; i &lt; allResData.data.length; i++) &#123;</span><br><span class="line">                        const obj &#x3D; allResData.data[i];</span><br><span class="line">                        that.addImageMarkerNormal(obj);</span><br><span class="line">                        if (showPointText) &#123;</span><br><span class="line">                            that.addTextMarker(obj);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (d.responseType &#x3D;&#x3D;&#x3D; &#39;goodsLocation&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; console.log(&#39;goodsLocation************&#39;, d.data)</span><br><span class="line">                &#x2F;&#x2F; 更新&#x2F;增加点位</span><br><span class="line">                if (!d.data.floorNo) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;判断楼层是否改变，改变先删除定位点再添加</span><br><span class="line">                let isNewPoint &#x3D; true;</span><br><span class="line">                let oldPointFloorChangeFlag &#x3D; true;</span><br><span class="line">                for (let i &#x3D; 0; i &lt; allResData.data.length; i++) &#123;</span><br><span class="line">                    if (d.data.id &#x3D;&#x3D;&#x3D; allResData.data[i].id) &#123;</span><br><span class="line">                        isNewPoint &#x3D; false;</span><br><span class="line">                        if (d.data.floorNo !&#x3D;&#x3D; allResData.data[i].floorNo) &#123;</span><br><span class="line">                            oldPointFloorChangeFlag &#x3D; false;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 判断是否为新出现的点，如果是，添加点位</span><br><span class="line">                if (isNewPoint) &#123;</span><br><span class="line">                    allResData.data.push(d.data);</span><br><span class="line">                    that.addImageMarkerNormal(d.data);</span><br><span class="line">                    if (showPointText) &#123;</span><br><span class="line">                        that.addTextMarker(d.data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (oldPointFloorChangeFlag) &#123;</span><br><span class="line">                        that.removeImgMarkerByMarker(d.data.id);</span><br><span class="line">                        that.removeTextMarkerById(d.data.id)</span><br><span class="line">                        that.addImageMarkerNormal(d.data);</span><br><span class="line">                        if (showPointText) &#123;</span><br><span class="line">                            that.addTextMarker(d.data);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (showPointText) &#123;</span><br><span class="line">                            that.updateTextMarker(d.data);</span><br><span class="line">                        &#125;</span><br><span class="line">                        that.updatePoint(d.data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                that.changeData(d.data);</span><br><span class="line"></span><br><span class="line">            &#125; else if (d.responseType &#x3D;&#x3D;&#x3D; &#39;smokeTH&#39;) &#123;</span><br><span class="line">                if (showSmokeImg) &#123;</span><br><span class="line">                    for (let i &#x3D; 0; i &lt; shList.length; i++) &#123;</span><br><span class="line">                        if (shList[i].sn &#x3D;&#x3D; d.data.sn) &#123;</span><br><span class="line">                            shList[i].humidity &#x3D; d.data.humidity;</span><br><span class="line">                            shList[i].humidityAlarm &#x3D; d.data.humidityAlarm;</span><br><span class="line">                            shList[i].occurrenceTime &#x3D; d.data.occurrenceTime;</span><br><span class="line">                            shList[i].smokeAlarm &#x3D; d.data.smokeAlarm;</span><br><span class="line">                            shList[i].temperature &#x3D; d.data.temperature;</span><br><span class="line">                            shList[i].temperatureAlarm &#x3D; d.data.temperatureAlarm;</span><br><span class="line">                            that.updateSmokePoint(shList[i]);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.onclose &#x3D; function (evt) &#123;</span><br><span class="line">            console.log(&quot;Connection closed.&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>react</category>
        <category>map</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>totalcontrol</title>
    <url>/2020/09/04/totalcontrol/</url>
    <content><![CDATA[<h1 id="Total-Control，电脑与手机初次连接详细教程听语音"><a href="#Total-Control，电脑与手机初次连接详细教程听语音" class="headerlink" title="Total Control，电脑与手机初次连接详细教程听语音"></a>Total Control，电脑与手机初次连接详细教程听语音</h1><p>对于很多使用手机群控软件的用户而言，Total Control 绝对都不陌生。但是，不论谁都是从小白经历过来的，一开始也不知道 Total Control 怎么用。这篇教程会以酷派 5952 为例给大家详细解析手机初次连接时可能遇到的问题，并提供对应的解决方法，供大家参考使用。</p>
<p>注：此教程仅适用于手机与 Total Control 无法自动连接的情况。</p>
<h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul>
<li>电脑</li>
<li>安卓手机</li>
<li>Total Control手机群控软件</li>
</ul>
<a id="more"></a>

<h2 id="打开手机-USB-调试"><a href="#打开手机-USB-调试" class="headerlink" title="打开手机 USB 调试"></a>打开手机 USB 调试</h2><ol>
<li><p>1</p>
<p>下载 Total Control 手机群控软件。官方网址为：<a href="http://tc.sigma-rt.com.cn/" target="_blank" rel="noopener">http://tc.sigma-rt.com.cn/</a></p>
<p><img src="https://exp-picture.cdn.bcebos.com/cd93a56651598540371b2d51b5a23a42a17ac487.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>2</p>
<p>打开 Total Control 电脑控制手机软件，点击[新设备向导]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/a31e1214c27bd282b3b888f53cb1eef97ebd3684.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>3</p>
<p>点击[连接向导]，按照连接向导中的步骤指示进行操作；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/7efc527c34b33c410e8bfaf2887de137c8762e84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>4</p>
<p>首先，将手机的 USB 线与电脑断开连接；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/7c84d1672b5fd54642a791a77fd0b503c9d22484.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>5</p>
<p>断开 USB 连接之后，进行下一步的设置：打开手机端的 USB 调试选项。</p>
<p>（温馨提示：请不要将手机设置为省电模式，否则可能导致连接失败。）</p>
<p><img src="https://exp-picture.cdn.bcebos.com/b57fb6db574afa32c4ad054454b2dc19cf2c1484.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>6</p>
<p>点击[设置]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/f59dbe39131fceecb1e840c679c4ec9958430b84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>7</p>
<p>选择[关于手机]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/49bf00425d6b04d12518b33bb213e8e5edee0184.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>8</p>
<p>在[手机配置信息]中找到[版本号]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/3852f6e5eceeadbccc1e6ec3cd18dfdae53b7b84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>9</p>
<p>拉到屏幕最下方，找到 [版本号]，快速点击 5-7 下；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/4e168d5653bbf82019cabfb8ba21056105a36e84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>10</p>
<p>此时屏幕上会显示“您现在处于开发者模式！”；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/82eff6d7592ae3ef67493d8254b6326c56666484.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>11</p>
<p>返回到设置界面,点击进入[开发者选项]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/38332303bbea3e86a87948f05cd4483105eb5584.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>12</p>
<p>选择[ USB 调试]并打开；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/f7e6410f822b74eebd0362abda2c8cf1d9a74a84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>13</p>
<p>点击[确定]后，此时手机的 USB 调试已经设置完毕。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/49c5d3e34b2c56eed04eafbdf775e5f4fdf54084.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
<p>END</p>
</li>
</ol>
<h2 id="安装通用驱动"><a href="#安装通用驱动" class="headerlink" title="安装通用驱动"></a>安装通用驱动</h2><ol>
<li><p>1</p>
<p><strong>一部分用户在完成以上操作之后，就可以正常将手机与 Total Control 连接并使用。但如果仍然没有解决您的问题，请继续按照下面的指示进行操作，安装通用驱动</strong>。</p>
</li>
<li><p>2</p>
<p>点击[安装驱动]下的[查看如何安装]进入步骤一；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/ef4c24ceaad7726bb8d34c54bf0f64781523b984.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>3</p>
<p>步骤一：点击[设备管理器]，找到你需要卸载的设备，</p>
<p><img src="https://exp-picture.cdn.bcebos.com/bff8683e21c2bbd65ce1445b116186254093ae84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>4</p>
<p>点击鼠标右键，选择[卸载]，点击[确定]，开始卸载驱动；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/555acf0ff2260d9af93f3e2a622abab84340a584.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>5</p>
<p>步骤二：点击[安装通用驱动]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/430174fec314f1c545df68723c27ac5307889d84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>6</p>
<p>跟着安装向导安装通用驱动即可；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/07c98f2ca5cadce84879294ffcf7980e5e209584.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
<p>END</p>
</li>
</ol>
<h2 id="安装手机专属的-USB-驱动"><a href="#安装手机专属的-USB-驱动" class="headerlink" title="安装手机专属的 USB 驱动"></a>安装手机专属的 USB 驱动</h2><ol>
<li><p>1</p>
<p><strong>安装通用驱动以后，又会解决掉一部分用户的问题，但如果依旧不能顺利连接并使用 Total Control 手机群控软件，则需要安装对应手机型号的专属 USB 驱动。这里以酷派 5952 为例为大家演示。</strong></p>
</li>
<li><p>2</p>
<p>在浏览器中搜索“酷派 usb 驱动下载”；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/5e615d715fdb3620590be43aabc5260f89358d84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>3</p>
<p>下载对应手机驱动，并安装；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/c6b994775ddd884c107b06946cef28066a01f684.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
<p>END</p>
</li>
</ol>
<h2 id="检测驱动是否安装正常"><a href="#检测驱动是否安装正常" class="headerlink" title="检测驱动是否安装正常"></a>检测驱动是否安装正常</h2><ol>
<li><p><strong>驱动安装成功后，我们提供两种方式来检测驱动是否安装完成。</strong></p>
<p><strong>方式一：打开命令行窗口，执行 adb devices 命令检测；</strong></p>
<p><strong>方式二：通过找到 Total Control 手机群控软件所在的文件夹地址粘贴到命令行窗口执行 adb devices 命令来检测。</strong></p>
</li>
<li><p>方式一： 点击开始，选择[运行]；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/9881b1fce186242fab40bdac35e434daf15ee884.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>输入“cmd” 打开命令行窗口，执行 adb devices 命令；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/ff5c88d818196120a9ff25dd70f202b374d7df84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>如果能正常显示下图中的串号，则证明驱动识别正常。</p>
<p><img src="https://exp-picture.cdn.bcebos.com/7496877bbbf4da5864e8f7faea0f8b56ac04d784.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>方式二：打开 Total Control 所在的文件夹，复制 Total Control 所在文件夹地址；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/ac45306817e951e110ca71e55e3da824d9e9cf84.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>将地址粘贴到命令行窗口中，执行 adb devices 命令，如果显示下图中的串号，则驱动安装正常；</p>
<p><img src="https://exp-picture.cdn.bcebos.com/5917cb3da824d8e9efe092d5da598540112ac884.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
</li>
<li><p>7</p>
<p><strong>以上步骤完成后，将手机与电脑连接，连接成功后，电脑端就会显示手机已经和 Total Control 电脑控制手机软件成功匹配，此时手机已经成功连接到了 Total Control 上，可以正式使用手机群控的软件了！以上就是我为大家整理的详细的 Total Control 电脑与手机初次连接教程，你学会了吗？</strong></p>
</li>
</ol>
<p>   <img src="https://exp-picture.cdn.bcebos.com/84010e2a04e23ea2107089c92b10bc33ed38c384.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="Total Control，电脑与手机初次连接详细教程"></p>
]]></content>
  </entry>
  <entry>
    <title>this指向详解</title>
    <url>/2020/07/30/this%E6%8C%87%E5%90%91%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="前端面试之彻底搞懂this指向"><a href="#前端面试之彻底搞懂this指向" class="headerlink" title="前端面试之彻底搞懂this指向"></a>前端面试之彻底搞懂this指向</h3><p>this是JavaScript中的一个关键字，但是又一个相对比较特别的关键字，不像function、var、for、if这些关键字一样，可以很清楚的搞清楚它到底是如何使用的。</p>
<p>this会在执行上下文中绑定一个对象，但是是根据什么条件绑定的呢？在不同的执行条件下会绑定不同的对象，这也是让人捉摸不定的地方。</p>
<p>这一次，我们一起来彻底搞定this到底是如何绑定的吧！</p>
<a id="more"></a>

<p>一. 理解this</p>
<p>1.1. 为什么使用this</p>
<p>在常见的编程语言中，几乎都有this这个关键字（Objective-C中使用的是self），但是JavaScript中的this和常见的面向对象语言中的this不太一样：</p>
<ul>
<li>常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在类的方法中。</li>
<li>也就是你需要有一个类，类中的方法（特别是实例方法）中，this代表的是当前调用对象。</li>
<li>但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义。</li>
</ul>
<p>使用this有什么意义呢？下面的代码中，我们通过对象字面量创建出来一个对象，当我们调用对象的方法时，希望将对象的名称一起进行打印。</p>
<p>如果没有this，那么我们的代码会是下面的写法：</p>
<ul>
<li>在方法中，为了能够获取到name名称，必须通过obj的引用（变量名称）来获取。</li>
<li>但是这样做有一个很大的弊端：如果我将obj的名称换成了info，那么所有的方法中的obj都需要换成info。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  running: function () &#123;</span><br><span class="line">    console.log(obj.name + &quot; running&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  eating: function () &#123;</span><br><span class="line">    console.log(obj.name + &quot; eating&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  studying: function () &#123;</span><br><span class="line">    console.log(obj.name + &quot; studying&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>事实上，上面的代码，在实际开发中，我们都会使用this来进行优化：</p>
<ul>
<li>当我们通过obj去调用running、eating、studying这些方法时，this就是指向的obj对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  running: function () &#123;</span><br><span class="line">    console.log(this.name + &quot; running&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  eating: function () &#123;</span><br><span class="line">    console.log(this.name + &quot; eating&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  studying: function () &#123;</span><br><span class="line">    console.log(this.name + &quot; studying&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>  name: “why”,</p>
<p>  running: function() {</p>
<p>​    console.log(this.name + “ running”);</p>
<p>  },</p>
<p>  eating: function() {</p>
<p>​    console.log(this.name + “ eating”);</p>
<p>  },</p>
<p>  studying: function() {</p>
<p>​    console.log(this.name + “ studying”);</p>
<p>  }</p>
<p>}</p>
<p>所以我们会发现，在某些函数或者方法的编写中，this可以让我们更加便捷的方式来引用对象，在进行一些API设计时，代码更加的简洁和易于复用。</p>
<p>当然，上面只是应用this的一个场景而已，开发中使用到this的场景到处都是，这也是为什么它不容易理解的原因。</p>
<p>1.2. this指向什么</p>
<p>我们先说一个最简单的，this在全局作用域下指向什么？</p>
<ul>
<li>这个问题非常容易回答，在浏览器中测试就是指向window</li>
<li>所以，在全局作用域下，我们可以认为this就是指向的window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;why&quot;;</span><br><span class="line"></span><br><span class="line">console.log(this.name); &#x2F;&#x2F; why</span><br><span class="line"></span><br><span class="line">console.log(window.name); &#x2F;&#x2F; why</span><br></pre></td></tr></table></figure>



<p>但是，开发中很少直接在全局作用域下去使用this，通常都是在函数中使用。</p>
<p>所有的函数在被调用时，都会创建一个执行上下文：</p>
<ul>
<li>这个上下文中记录着函数的调用栈、函数的调用方式、传入的参数信息等；</li>
<li>this也是其中的一个属性；</li>
</ul>
<p>我们先来看一个让人困惑的问题：</p>
<ul>
<li>定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个函数</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1.调用方式一: 直接调用</span><br><span class="line">foo(); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.调用方式二: 将foo放到一个对象中,再调用</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() &#x2F;&#x2F; obj对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.调用方式三: 通过call&#x2F;apply调用</span><br><span class="line">foo.call(&quot;abc&quot;); &#x2F;&#x2F; String &#123;&quot;abc&quot;&#125;对象</span><br></pre></td></tr></table></figure>

<p>上面的案例可以给我们什么样的启示呢？</p>
<ul>
<li>1.函数在调用时，JavaScript会默认给this绑定一个值；</li>
<li>2.this的绑定和定义的位置（编写的位置）没有关系；</li>
<li>3.this的绑定和调用方式以及调用的位置有关系；</li>
<li>4.this是在运行时被绑定的；</li>
</ul>
<p>那么this到底是怎么样的绑定规则呢？一起来学习一下吧</p>
<p>二. this绑定规则</p>
<p>我们现在已经知道this无非就是在函数调用时被绑定的一个对象，我们就需要知道它在不同的场景下的绑定规则即可。</p>
<p>2.1. 默认绑定</p>
<p>什么情况下使用默认绑定呢？独立函数调用。</p>
<ul>
<li>独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用；</li>
</ul>
<p>案例一：普通函数调用</p>
<ul>
<li>该函数直接被调用，并没有进行任何的对象关联；</li>
<li>这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的this指向全局对象（window）；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>



<p>案例二：函数调用链（一个函数又调用另外一个函数）</p>
<ul>
<li>所有的函数调用都没有被绑定到某个对象上；</li>
</ul>
<p>// 2.案例二:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test1() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">  test2();</span><br><span class="line">&#125;</span><br><span class="line">function test2() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">  test3()</span><br><span class="line">&#125;</span><br><span class="line">function test3() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br></pre></td></tr></table></figure>



<p>案例三：将函数作为参数，传入到另一个函数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(func) &#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br><span class="line">foo(bar);</span><br></pre></td></tr></table></figure>



<p>我们对案例进行一些修改，考虑一下打印结果是否会发生变化：</p>
<ul>
<li>这里的结果依然是window，为什么呢？</li>
<li>原因非常简单，在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(func) &#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  bar: function() &#123;</span><br><span class="line">    console.log(this); &#x2F;&#x2F; window</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(obj.bar);</span><br></pre></td></tr></table></figure>



<p>2.2. 隐式绑定</p>
<p>另外一种比较常见的调用方式是通过某个对象进行调用的：</p>
<ul>
<li>也就是它的调用位置中，是通过某个对象发起的函数调用。</li>
</ul>
<p>案例一：通过对象调用函数</p>
<ul>
<li>foo的调用位置是obj.foo()方式进行调用的</li>
<li>那么foo调用时this会隐式的被绑定到obj对象上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; obj对象</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>



<p>案例二：案例一的变化</p>
<ul>
<li>我们通过obj2又引用了obj1对象，再通过obj1对象调用foo函数；</li>
<li>那么foo调用的位置上其实还是obj1被绑定了this；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; obj对象</span><br><span class="line">&#125;</span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj2&quot;,</span><br><span class="line">  obj1: obj1</span><br><span class="line">&#125;</span><br><span class="line">obj2.obj1.foo();</span><br></pre></td></tr></table></figure>



<p>案例三：隐式丢失</p>
<ul>
<li>结果最终是window，为什么是window呢？</li>
<li>因为foo最终被调用的位置是bar，而bar在进行调用时没有绑定任何的对象，也就没有形成隐式绑定；</li>
<li>相当于是一种默认绑定；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 讲obj1的foo赋值给bar</span><br><span class="line">var bar &#x3D; obj1.foo;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>



<p>2.3. 显示绑定</p>
<p>隐式绑定有一个前提条件：</p>
<ul>
<li>必须在调用的对象内部有一个对函数的引用（比如一个属性）；</li>
<li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误；</li>
<li>正是通过这个引用，间接的将this绑定到了这个对象上；</li>
</ul>
<p>如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？</p>
<ul>
<li>JavaScript所有的函数都可以使用call和apply方法（这个和Prototype有关）。</li>
</ul>
<ul>
<li><ul>
<li>它们两个的区别这里不再展开；</li>
<li>其实非常简单，第一个参数是相同的，后面的参数，apply为数组，call为参数列表；</li>
</ul>
</li>
</ul>
<ul>
<li>这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给this准备的。</li>
<li>在调用这个函数时，会将this绑定到这个传入的对象上。</li>
</ul>
<p>因为上面的过程，我们明确的绑定了this指向的对象，所以称之为 显示绑定。</p>
<p>2.3.1. call、apply</p>
<p>通过call或者apply绑定this对象</p>
<ul>
<li>显示绑定后，this就会明确的指向绑定的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(window); &#x2F;&#x2F; window</span><br><span class="line">foo.call(&#123;name: &quot;why&quot;&#125;); &#x2F;&#x2F; &#123;name: &quot;why&quot;&#125;</span><br><span class="line">foo.call(123); &#x2F;&#x2F; Number对象,存放时123</span><br></pre></td></tr></table></figure>



<p>2.3.2. bind函数</p>
<p>如果我们希望一个函数总是显示的绑定到一个对象上，可以怎么做呢？</p>
<p>方案一：自己手写一个辅助函数（了解）</p>
<ul>
<li>我们手动写了一个bind的辅助函数</li>
<li>这个辅助函数的目的是在执行foo时，总是让它的this绑定到obj对象上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;</span><br><span class="line">&#125;</span><br><span class="line">function bind(func, obj) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    return func.apply(obj, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var bar &#x3D; bind(foo, obj);</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br></pre></td></tr></table></figure>



<p>方案二：使用Function.prototype.bind</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;why&quot;</span><br><span class="line">&#125;</span><br><span class="line">var bar &#x3D; foo.bind(obj);</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br></pre></td></tr></table></figure>



<p>2.3.3. 内置函数</p>
<p>有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数。</p>
<ul>
<li>这些内置函数会要求我们传入另外一个函数；</li>
<li>我们自己并不会显示的调用这些函数，而且JavaScript内部或者第三方库内部会帮助我们执行；</li>
<li>这些函数中的this又是如何绑定的呢？</li>
</ul>
<p>案例一：setTimeout</p>
<ul>
<li>setTimeout中会传入一个函数，这个函数中的this通常是window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>



<p>为什么这里是window呢？</p>
<ul>
<li>这个和setTimeout源码的内部调用有关；</li>
<li>setTimeout内部是通过apply进行绑定的this对象，并且绑定的是全局对象；</li>
</ul>
<p>案例二：数组的forEach</p>
<p>数组有一个高阶函数forEach，用于函数的遍历：</p>
<ul>
<li>在forEach中传入的函数打印的也是Window对象；</li>
<li>这是因为默认情况下传入的函数是自动调用函数（默认绑定）；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var names &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line">names.forEach(function(item) &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; 三次window</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>我们是否可以改变该函数的this指向呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forEach参数</span><br><span class="line">var names &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line">var obj &#x3D; &#123;name: &quot;why&quot;&#125;;</span><br><span class="line">names.forEach(function(item) &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; 三次obj对象</span><br><span class="line">&#125;, obj);</span><br></pre></td></tr></table></figure>



<p>案例三：div的点击</p>
<p>如果我们有一个div元素：</p>
<ul>
<li><p>注意：省略了部分代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>获取元素节点，并且监听点击：</p>
<ul>
<li>在点击事件的回调中，this指向谁呢？box对象；</li>
<li>这是因为在发生点击时，执行传入的回调函数被调用时，会将box对象绑定到该函数中；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var box &#x3D; document.querySelector(&quot;.box&quot;);</span><br><span class="line">box.onclick &#x3D; function() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; box对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以传入到内置函数的回调函数this如何确定呢？</p>
<ul>
<li>某些内置的函数，我们很难确定它内部是如何调用传入的回调函数；</li>
<li>一方面可以通过分析源码来确定，另一方面我们可以通过经验（见多识广）来确定；</li>
<li>但是无论如何，通常都是我们之前讲过的规则来确定的；</li>
</ul>
<p>2.4. new绑定</p>
<p>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。</p>
<p>使用new关键字来调用函数时，会执行如下的操作：</p>
<ul>
<li>1.创建一个全新的对象；</li>
<li>2.这个新对象会被执行Prototype连接；</li>
<li>3.这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；</li>
<li>4.如果函数没有返回其他对象，表达式会返回这个新对象；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建Person</span><br><span class="line"></span><br><span class="line">function Person(name) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this); &#x2F;&#x2F; Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">  this.name &#x3D; name; &#x2F;&#x2F; Person &#123;name: &quot;why&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new Person(&quot;why&quot;);</span><br><span class="line"></span><br><span class="line">console.log(p);</span><br></pre></td></tr></table></figure>



<p>2.5. 规则优先级</p>
<p>学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？</p>
<p>1.默认规则的优先级最低</p>
<p>毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this</p>
<p>2.显示绑定优先级高于隐式绑定</p>
<p>显示绑定和隐式绑定哪一个优先级更高呢？这个我们可以测试一下：</p>
<ul>
<li>结果是obj2，说明是显示绑定生效了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line"></span><br><span class="line">  foo: foo</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj2&quot;,</span><br><span class="line"></span><br><span class="line">  foo: foo</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定</span><br><span class="line"></span><br><span class="line">obj1.foo(); &#x2F;&#x2F; obj1</span><br><span class="line"></span><br><span class="line">obj2.foo(); &#x2F;&#x2F; obj2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定和显示绑定同时存在</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2); &#x2F;&#x2F; obj2, 说明隐式绑定优先级更高</span><br></pre></td></tr></table></figure>



<p>3.new绑定优先级高于隐式绑定</p>
<ul>
<li>结果是foo，说明是new绑定生效了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line"></span><br><span class="line">  foo: foo</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new obj.foo(); &#x2F;&#x2F; foo对象, 说明new绑定优先级更高</span><br></pre></td></tr></table></figure>



<p>4.new绑定优先级高于bind</p>
<p>new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new foo.call(obj);</span><br></pre></td></tr></table></figure>



<p>new和call同时使用</p>
<p>但是new绑定是否可以和bind后的函数同时使用呢？可以</p>
<ul>
<li>结果显示为foo，那么说明是new绑定生效了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; var foo &#x3D; new foo.call(obj);</span><br><span class="line"></span><br><span class="line">var bar &#x3D; foo.bind(obj);</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new bar(); &#x2F;&#x2F; 打印foo, 说明使用的是new绑定</span><br></pre></td></tr></table></figure>



<p>优先级总结：</p>
<ul>
<li>new绑定 &gt; 显示绑定（bind）&gt; 隐式绑定 &gt; 默认绑定</li>
</ul>
<p>三. this规则之外</p>
<p>我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外。（神话故事和动漫中总是有类似这样的人物）</p>
<p>3.1. 忽略显示绑定</p>
<p>如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;why&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj); &#x2F;&#x2F; obj对象</span><br><span class="line"></span><br><span class="line">foo.call(null); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">foo.call(undefined); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">var bar &#x3D; foo.bind(null);</span><br><span class="line"></span><br><span class="line">bar(); &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure>



<p>3.2. 间接函数引用</p>
<p>另外一种情况，创建一个函数的 间接引用，这种情况使用默认绑定规则。</p>
<p>我们先来看下面的案例结果是什么？</p>
<ul>
<li>(num2 = num1)的结果是num1的值；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num1 &#x3D; 100;</span><br><span class="line"></span><br><span class="line">var num2 &#x3D; 0;</span><br><span class="line"></span><br><span class="line">var result &#x3D; (num2 &#x3D; num1);</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; 100</span><br></pre></td></tr></table></figure>



<p>我们来下面的函数赋值结果：</p>
<ul>
<li>赋值(obj2.foo = obj1.foo)的结果是foo函数；</li>
<li>foo函数被直接调用，那么是默认绑定；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line"></span><br><span class="line">  foo: foo</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;obj2&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo(); &#x2F;&#x2F; obj1对象</span><br><span class="line"></span><br><span class="line">(obj2.foo &#x3D; obj1.foo)();  &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure>



<p>3.3. ES6箭头函数</p>
<p>在ES6中新增一个非常好用的函数类型：箭头函数</p>
<ul>
<li>这里不再具体介绍箭头函数的用法，可以自行学习。</li>
</ul>
<p>箭头函数不使用this的四种标准规则（也就是不绑定this），而是根据外层作用域来决定this。</p>
<p>我们来看一个模拟网络请求的案例：</p>
<ul>
<li>这里我使用setTimeout来模拟网络请求，请求到数据后如何可以存放到data中呢？</li>
<li>我们需要拿到obj对象，设置data；</li>
<li>但是直接拿到的this是window，我们需要在外层定义：var _this = this</li>
<li>在setTimeout的回调函数中使用_this就代表了obj对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  data: [],</span><br><span class="line"></span><br><span class="line">  getData: function() &#123;</span><br><span class="line"></span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 模拟获取到的数据</span><br><span class="line"></span><br><span class="line">      var res &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line"></span><br><span class="line">      _this.data.push(...res);</span><br><span class="line"></span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure>



<p>上面的代码在ES6之前是我们最常用的方式，从ES6开始，我们会使用箭头函数：</p>
<ul>
<li>为什么在setTimeout的回调函数中可以直接使用this呢？</li>
<li>因为箭头函数并不绑定this对象，那么this引用就会从上层作用域中找到对应的this</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  data: [],</span><br><span class="line"></span><br><span class="line">  getData: function() &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 模拟获取到的数据</span><br><span class="line"></span><br><span class="line">      var res &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line"></span><br><span class="line">      this.data.push(...res);</span><br><span class="line"></span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure>



<p>思考：如果getData也是一个箭头函数，那么setTimeout中的回调函数中的this指向谁呢？</p>
<ul>
<li>答案是window；</li>
<li>依然是不断的从上层作用域找，那么找到了全局作用域；</li>
<li>在全局作用域内，this代表的就是window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  data: [],</span><br><span class="line"></span><br><span class="line">  getData: () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure>



<p>四. this面试题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.1. 面试题一：</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;person&quot;,</span><br><span class="line"></span><br><span class="line">  sayName: function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(this.name);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function sayName() &#123;</span><br><span class="line"></span><br><span class="line">  var sss &#x3D; person.sayName;</span><br><span class="line"></span><br><span class="line">  sss(); </span><br><span class="line"></span><br><span class="line">  person.sayName(); </span><br><span class="line"></span><br><span class="line">  (person.sayName)(); </span><br><span class="line"></span><br><span class="line">  (b &#x3D; person.sayName)(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayName();</span><br><span class="line"></span><br><span class="line">这道面试题非常简单，无非就是绕一下，希望把面试者绕晕：</span><br><span class="line"></span><br><span class="line">function sayName() &#123;</span><br><span class="line"></span><br><span class="line">  var sss &#x3D; person.sayName;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 独立函数调用，没有和任何对象关联</span><br><span class="line"></span><br><span class="line">  sss(); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 关联</span><br><span class="line"></span><br><span class="line">  person.sayName(); &#x2F;&#x2F; person</span><br><span class="line"></span><br><span class="line">  (person.sayName)(); &#x2F;&#x2F; person</span><br><span class="line"></span><br><span class="line">  (b &#x3D; person.sayName)(); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.2. 面试题二：</span><br><span class="line"></span><br><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name: &#39;person1&#39;,</span><br><span class="line"></span><br><span class="line">  foo1: function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(this.name)</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  foo2: () &#x3D;&gt; console.log(this.name),</span><br><span class="line"></span><br><span class="line">  foo3: function () &#123;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this.name)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  foo4: function () &#123;</span><br><span class="line"></span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this.name)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person2 &#x3D; &#123; name: &#39;person2&#39; &#125;</span><br><span class="line"></span><br><span class="line">person1.foo1(); </span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2); </span><br><span class="line"></span><br><span class="line">person1.foo2();</span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2);</span><br><span class="line"></span><br><span class="line">person1.foo3()();</span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)();</span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2);</span><br><span class="line"></span><br><span class="line">person1.foo4()();</span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)();</span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2);</span><br><span class="line"></span><br><span class="line">下面是代码解析：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定，肯定是person1</span><br><span class="line"></span><br><span class="line">person1.foo1(); &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定和显示绑定的结合，显示绑定生效，所以是person2</span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2); &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()是一个箭头函数，不适用所有的规则</span><br><span class="line"></span><br><span class="line">person1.foo2() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2依然是箭头函数，不适用于显示绑定的规则</span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2) &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到foo3，但是调用位置是全局作用于下，所以是默认绑定window</span><br><span class="line"></span><br><span class="line">person1.foo3()() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo3显示绑定到person2中</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 但是拿到的返回函数依然是在全局下调用，所以依然是window</span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo3返回的函数，通过显示绑定到person2中，所以是person2</span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4()的函数返回的是一个箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数的执行找上层作用域，是person1</span><br><span class="line"></span><br><span class="line">person1.foo4()() &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4()显示绑定到person2中，并且返回一个箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数找上层作用域，是person2</span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4返回的是箭头函数，箭头函数只看上层作用域</span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2) &#x2F;&#x2F; person1</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.3. 面试题三:</span><br><span class="line"></span><br><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line"></span><br><span class="line">function Person (name) &#123;</span><br><span class="line"></span><br><span class="line">  this.name &#x3D; name</span><br><span class="line"></span><br><span class="line">  this.foo1 &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(this.name)</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  this.foo2 &#x3D; () &#x3D;&gt; console.log(this.name),</span><br><span class="line"></span><br><span class="line">  this.foo3 &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this.name)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  this.foo4 &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      console.log(this.name)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; new Person(&#39;person1&#39;)</span><br><span class="line"></span><br><span class="line">var person2 &#x3D; new Person(&#39;person2&#39;)</span><br><span class="line"></span><br><span class="line">person1.foo1()</span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo2()</span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo3()()</span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo4()()</span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2)</span><br><span class="line"></span><br><span class="line">下面是代码解析：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定</span><br><span class="line"></span><br><span class="line">person1.foo1() &#x2F;&#x2F; peron1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示绑定优先级大于隐式绑定</span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo是一个箭头函数，会找上层作用域中的this，那么就是person1</span><br><span class="line"></span><br><span class="line">person1.foo2() &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo是一个箭头函数，使用call调用不会影响this的绑定，和上面一样向上层查找</span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2) &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用位置是全局直接调用，所以依然是window（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.foo3()() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终还是拿到了foo3返回的函数，在全局直接调用（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo3返回的函数后，通过call绑定到person2中进行了调用</span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4返回了箭头函数，和自身绑定没有关系，上层找到person1</span><br><span class="line"></span><br><span class="line">person1.foo4()() &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4调用时绑定了person2，返回的函数是箭头函数，调用时，找到了上层绑定的person2</span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4调用返回的箭头函数，和call调用没有关系，找到上层的person1</span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2) &#x2F;&#x2F; person1</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.4. 面试题四：</span><br><span class="line"></span><br><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line"></span><br><span class="line">function Person (name) &#123;</span><br><span class="line"></span><br><span class="line">  this.name &#x3D; name</span><br><span class="line"></span><br><span class="line">  this.obj &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">    name: &#39;obj&#39;,</span><br><span class="line"></span><br><span class="line">    foo1: function () &#123;</span><br><span class="line"></span><br><span class="line">      return function () &#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    foo2: function () &#123;</span><br><span class="line"></span><br><span class="line">      return () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; new Person(&#39;person1&#39;)</span><br><span class="line"></span><br><span class="line">var person2 &#x3D; new Person(&#39;person2&#39;)</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()()</span><br><span class="line"></span><br><span class="line">person1.obj.foo1.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.obj.foo1().call(person2)</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()()</span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.obj.foo2().call(person2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面是代码解析：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj.foo1()返回一个函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终还是拿到一个返回的函数（虽然多了一步call的绑定）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.obj.foo1.call(person2)() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">person1.obj.foo1().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo2()的返回值，是一个箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，就是obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()() &#x2F;&#x2F; obj</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数，但是在执行foo2时绑定了person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，找到的是person2</span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数通过call调用是不会绑定this，所以找上层作用域下的this是obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo2().call(person2) &#x2F;&#x2F; obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()()</span><br><span class="line"></span><br><span class="line">person1.obj.foo1.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.obj.foo1().call(person2)</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()()</span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.obj.foo2().call(person2)</span><br><span class="line"></span><br><span class="line">下面是代码解析：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj.foo1()返回一个函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终还是拿到一个返回的函数（虽然多了一步call的绑定）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line"></span><br><span class="line">person1.obj.foo1.call(person2)() &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">person1.obj.foo1().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo2()的返回值，是一个箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，就是obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()() &#x2F;&#x2F; obj</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数，但是在执行foo2时绑定了person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，找到的是person2</span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数通过call调用是不会绑定this，所以找上层作用域下的this是obj</span><br><span class="line"></span><br><span class="line">person1.obj.foo2().call(person2) &#x2F;&#x2F; obj</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>ts之重构vue项目</title>
    <url>/2021/02/24/ts%E4%B9%8B%E9%87%8D%E6%9E%84vue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="vue项目中使用ts（typescript）入门教程"><a href="#vue项目中使用ts（typescript）入门教程" class="headerlink" title="vue项目中使用ts（typescript）入门教程"></a>vue项目中使用ts（typescript）入门教程</h3><h3 id="1、引入Typescript"><a href="#1、引入Typescript" class="headerlink" title="1、引入Typescript"></a>1、引入Typescript</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install vue-<span class="class"><span class="keyword">class</span>-<span class="title">component</span> <span class="title">vue</span>-<span class="title">property</span>-<span class="title">decorator</span> --<span class="title">save</span></span></span><br><span class="line"><span class="class"><span class="title">npm</span> <span class="title">install</span> <span class="title">ts</span>-<span class="title">loader</span> <span class="title">typescript</span> <span class="title">tslint</span> <span class="title">tslint</span>-<span class="title">loader</span> <span class="title">tslint</span>-<span class="title">config</span>-<span class="title">standard</span> --<span class="title">save</span>-<span class="title">dev</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>vue-class-component</code>：扩展vue支持typescript，将原有的vue语法通过声明的方式来支持ts</li>
<li><code>vue-property-decorator</code>：基于vue-class-component扩展更多装饰器</li>
<li><code>ts-loader</code>：让webpack能够识别ts文件</li>
<li><code>tslint-loader</code>：tslint用来约束文件编码</li>
<li><code>tslint-config-standard</code>： tslint 配置 standard风格的约束</li>
</ul>
<h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><h4 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h4><p>根据项目的不同配置的地方不同，如果是vue cli 3.0创建的项目需要在vue.config.js中配置，如果是3.0以下版本的话，需要webpack.base.conf中配置。(以下说明是在webpack.base.conf文件中更改)</p>
<ol>
<li>在resolve.extensions中增加.ts，目的是在代码中引入ts文件不用写.ts后缀</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>, <span class="string">'.ts'</span>],</span><br><span class="line">  alias: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在module.rules中增加ts的rules</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">     &#123;</span><br><span class="line">       test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">       exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">       enforce: <span class="string">'pre'</span>,</span><br><span class="line">       loader: <span class="string">'tslint-loader'</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">       loader: <span class="string">'ts-loader'</span>,</span><br><span class="line">       exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">       options: &#123;</span><br><span class="line">         appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>tsconfig.json配置<br>ts-loader会检索文件中的tsconfig.json.以其中的规则来解析ts文件，详细的配置可以参考<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/tsconfig-json.html</a><br>贴上测试项目tsconfig.json文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 编译选项</span></span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出目录</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./output"</span>,</span><br><span class="line">    <span class="comment">// 是否包含可以用于 debug 的 sourceMap</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 以严格模式解析</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 采用的模块系统</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"esnext"</span>,</span><br><span class="line">    <span class="comment">// 如何处理模块</span></span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="comment">// 编译输出目标 ES 版本</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="comment">// 允许从没有设置默认导出的模块中默认导入</span></span><br><span class="line">    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 将每个文件作为单独的模块</span></span><br><span class="line">    <span class="string">"isolatedModules"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 启用设计类型元数据（用于反射）</span></span><br><span class="line">    <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 在表达式和声明上有隐含的any类型时报错</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不是函数的所有返回路径都有返回值时报错。</span></span><br><span class="line">    <span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 从 tslib 导入外部帮助库: 比如__extends，__rest等</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 编译过程中打印文件名</span></span><br><span class="line">    <span class="string">"listFiles"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 移除注释</span></span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"suppressImplicitAnyIndexErrors"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 允许编译javascript文件</span></span><br><span class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line">    <span class="comment">// 指定特殊模块的路径</span></span><br><span class="line">    <span class="string">"paths"</span>: &#123;</span><br><span class="line">      <span class="string">"jquery"</span>: [</span><br><span class="line">        <span class="string">"node_modules/jquery/dist/jquery"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 编译过程中需要引入的库文件的列表</span></span><br><span class="line">    <span class="string">"lib"</span>: [</span><br><span class="line">      <span class="string">"dom"</span>,</span><br><span class="line">      <span class="string">"es2015"</span>,</span><br><span class="line">      <span class="string">"es2015.promise"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>tslint.json配置<br>在目录中新增tslint.json文件，由于我们前面安装了tslint-config-standard，所以可以直接用tslint-config-standard中规则，文件如下:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"tslint-config-standard"</span>,</span><br><span class="line">  <span class="string">"globals"</span>: &#123;</span><br><span class="line">    <span class="string">"require"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、让项目识别-ts"><a href="#3、让项目识别-ts" class="headerlink" title="3、让项目识别.ts"></a>3、让项目识别.ts</h3><p>由于 TypeScript 默认并不支持 *.vue 后缀的文件，所以在 vue 项目中引入的时候需要创建一个 vue-shim.d.ts 文件，放在根目录下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'*.vue'</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、实际应用"><a href="#4、实际应用" class="headerlink" title="4、实际应用"></a>4、实际应用</h3><p>回顾下我们日常工作中常用的vue的东西</p>
<ul>
<li>data() 中定义数据</li>
<li>子组件通过props接受父组件传来的值</li>
<li>子组件通过$emit给父组件传递信息</li>
<li>通过watch来进行观察数据</li>
<li>通过computed计算属性</li>
<li>vue组件的生命周期方法</li>
<li>路由以及vuex<br> 这一篇章将根据<strong>vue-class-component</strong>以及<strong>vue-property-decorator</strong>来说明除了路由以及vuex的使用方法，通过通过vue写ts有两种方法，一种是和原有写法类似的还有一种是基于类的写法。以下所有的写法都是基于类的写法</li>
</ul>
<h4 id="data-中定义数据"><a href="#data-中定义数据" class="headerlink" title="data()中定义数据"></a>data()中定义数据</h4><p>前面说过了，装饰器class将类的原型中的数据直接挂在相对应的原有vue方法中，但是data除外，data只直接将非装饰器以及非方法的直接放在data()中 ，所以我们定义的时候只需要这样做即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="title">extends</span> <span class="title">Vue</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span> message1: <span class="built_in">string</span> = <span class="string">"asd"</span></span><br><span class="line"> <span class="keyword">public</span> message2: <span class="built_in">string</span> = <span class="string">"asd1"</span>;</span><br><span class="line"> <span class="keyword">public</span> message3: <span class="built_in">string</span> = <span class="string">"asd2"</span>;</span><br></pre></td></tr></table></figure>



<h4 id="props传值"><a href="#props传值" class="headerlink" title="props传值"></a>props传值</h4><p>props的话就没有data那么舒服了，因为他需要使用装饰器了，写法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Prop(&#123;</span><br><span class="line">   type: Number,</span><br><span class="line">   default: 1,</span><br><span class="line">   required: false</span><br><span class="line"> &#125;)</span><br><span class="line"> propA?: number</span><br><span class="line"> &#x2F;&#x2F;会最终转换成</span><br><span class="line"> props:&#123;</span><br><span class="line">      propA:&#39;&#39;</span><br><span class="line"> &#125;</span><br><span class="line"> @Prop()</span><br><span class="line"> propB:string</span><br></pre></td></tr></table></figure>

<p>如果没有默认值的建议使用可选属性？来定义，这样避免报错。</p>
<h4 id="emit传值"><a href="#emit传值" class="headerlink" title="$emit传值"></a>$emit传值</h4><p>$emit传值涉及到两部分，一个是父组件定义的方法，一个是子组件触发。当前emit有三种方法<br> 首先子组件的写法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test-container"</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点击触发父级方法"</span> @<span class="attr">click</span>=<span class="string">"bindSend"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点击触发父级方法"</span> @<span class="attr">click</span>=<span class="string">"handleSend"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点击触发父级方法"</span> @<span class="attr">click</span>=<span class="string">"bindSend2"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;Hello&gt;&lt;/Hello&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; Component, Prop, Vue, Watch, Emit &#125; <span class="keyword">from</span> <span class="string">"vue-property-decorator"</span>;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 注明此类为一个vue组件</span></span></span><br><span class="line">@Component(&#123;&#125;)</span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 第一种</span></span></span><br><span class="line">  @Emit()</span><br><span class="line"><span class="actionscript">  <span class="keyword">private</span> bindSend():string&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="keyword">this</span>.message</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript"> <span class="comment">// 第二种</span></span></span><br><span class="line">  @Emit()</span><br><span class="line"><span class="actionscript">  <span class="keyword">private</span> bindSend1(msg:string)&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 如果不处理可以不写下面的，会自动将参数回传</span></span></span><br><span class="line"><span class="actionscript">      msg += <span class="string">'love'</span>;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> msg;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript">  <span class="comment">//原有放在methods中的方法平铺出来</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">public</span> handleSend():<span class="keyword">void</span> &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.bindSend1(<span class="keyword">this</span>.message);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript">  <span class="comment">// 第三种</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 这里的emit中的参数是表明父级通过什么接受，类似以前的$emit('父级定义的方法')</span></span></span><br><span class="line"><span class="actionscript">  @Emit(<span class="string">'test'</span>)</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">private</span> bindSend2()&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="string">'这个可以用test接受'</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件的接收代码,这里父组件懒得换成ts写法了，意思到了就行了（哈哈）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Test</span> <span class="attr">:propA</span>=<span class="string">"propA"</span> @<span class="attr">bind-send</span> = <span class="string">"bindSend"</span> @<span class="attr">bind-send1</span> = <span class="string">'handleSend1'</span> @<span class="attr">test</span> = <span class="string">'handleSend2'</span>&gt;</span><span class="tag">&lt;/<span class="name">Test</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line"><span class="javascript">    Test:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./components/test.vue'</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    bindSend(val) &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'子集触发了emit方法'</span> +val);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    handleSend1(val) &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'子集触发了emit方法'</span> +val);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    handleSend2(val) &#123;</span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(<span class="string">'子集触发了emit方法'</span> +val);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们需要传多个值的话，我们怎么弄呢？来一起看看源码的实现你就知道了</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Emit</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">_target, propertyKey, descriptor</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> key = hyphenate(propertyKey);</span><br><span class="line">        <span class="keyword">var</span> original = descriptor.value;</span><br><span class="line">        descriptor.value = <span class="function"><span class="keyword">function</span> <span class="title">emitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">var</span> args = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; <span class="built_in">arguments</span>.length; _i++) &#123;</span><br><span class="line">                args[_i] = <span class="built_in">arguments</span>[_i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> emit = <span class="function"><span class="keyword">function</span> (<span class="params">returnValue</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> emitName = event || key;</span><br><span class="line">                <span class="keyword">if</span> (returnValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (args.length === <span class="number">0</span>) &#123;</span><br><span class="line">                        _this.$emit(emitName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (args.length === <span class="number">1</span>) &#123;</span><br><span class="line">                        _this.$emit(emitName, args[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _this.$emit.apply(_this, [emitName].concat(args));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (args.length === <span class="number">0</span>) &#123;</span><br><span class="line">                        _this.$emit(emitName, returnValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (args.length === <span class="number">1</span>) &#123;</span><br><span class="line">                        _this.$emit(emitName, returnValue, args[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _this.$emit.apply(_this, [emitName, returnValue].concat(args));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">var</span> returnValue = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">            <span class="keyword">if</span> (isPromise(returnValue)) &#123;</span><br><span class="line">                returnValue.then(emit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                emit(returnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们可以发现有两种方法，如果在方法中也就是</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Emit()</span></span><br><span class="line"> <span class="keyword">private</span> bindSend1(msg:string)&#123;</span><br><span class="line">     <span class="comment">// 如果不处理可以不写下面的，会自动将参数回传</span></span><br><span class="line">     msg += <span class="string">'love'</span>;</span><br><span class="line">     <span class="keyword">return</span> msg;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过return返回的方式话的话只会取args[0]，所以这种情况建议直接以一个对象或者数组方式传递<br> 上面说到了给父组件传值的时候可以只通过参数，而不需要return,那么源码中可以看到<strong>var returnValue = original.apply(this, args);</strong>所以我们也可以这样来传</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">@Emit()</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">bindSend1</span>(<span class="params">msg:<span class="keyword">string</span>,love:<span class="keyword">string</span></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="comment">//原有放在methods中的方法平铺出来</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">handleSend</span>(<span class="params"></span>):<span class="keyword">void</span></span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.bindSend1(<span class="keyword">this</span>.message,<span class="string">'love'</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>父组件中接受数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">handleSend1(<span class="keyword">val</span>,val1) &#123;</span><br><span class="line">  console.log(<span class="string">'子集触发了emit方法'</span> +<span class="keyword">val</span> + val1);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h4 id="watch观察数据"><a href="#watch观察数据" class="headerlink" title="watch观察数据"></a>watch观察数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;原有的watch属性</span><br><span class="line">  @Watch(&#39;propA&#39;,&#123;</span><br><span class="line">      deep:true</span><br><span class="line">  &#125;)</span><br><span class="line">  test(newValue:string,oldValue:string)&#123;</span><br><span class="line">      console.log(&#39;propA值改变了&#39; + newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;会被转化成</span><br><span class="line">watch：&#123;</span><br><span class="line">  propA：handler(newValue,oldValue)&#123;</span><br><span class="line">      this.test(newValue,oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  deep:true</span><br><span class="line">&#125;</span><br><span class="line">test方法会被转化到methods中</span><br></pre></td></tr></table></figure>

<h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><p>在前面<strong>vue-class-component</strong>介绍里面我们提到过Component怎么处理数据的</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (descriptor.<span class="keyword">get</span> || descriptor.<span class="keyword">set</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在get和set,则为计算属性</span></span><br><span class="line">   (options.computed || (options.computed = &#123;&#125;))[key] = &#123;</span><br><span class="line">      <span class="keyword">get</span>: descriptor.<span class="keyword">get</span>,</span><br><span class="line">       <span class="keyword">set</span>: descriptor.<span class="keyword">set</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们在写计算属性的时候只需要按照以下方法写即可</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">get</span> <span class="title">computedMsg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'这里是计算属性'</span> + <span class="keyword">this</span>.message;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">set</span> <span class="title">computedMsg</span>(<span class="params">message:<span class="keyword">string</span></span>)</span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="vue组件的生命周期方法"><a href="#vue组件的生命周期方法" class="headerlink" title="vue组件的生命周期方法"></a>vue组件的生命周期方法</h4><p>和以前一样使用即可</p>
]]></content>
      <categories>
        <category>ts</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>v-lazy</title>
    <url>/2020/07/27/v-lazy/</url>
    <content><![CDATA[<h3 id="vue图片懒加载插件–v-lazy"><a href="#vue图片懒加载插件–v-lazy" class="headerlink" title="vue图片懒加载插件–v-lazy"></a>vue图片懒加载插件–v-lazy</h3><ol>
<li><p>安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-lazyload --save-dev</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ol>
<ol>
<li><p>main.js引入插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueLazyLoad from &#39;vue-lazyload&#39;</span><br><span class="line">Vue.use(VueLazyLoad,&#123;</span><br><span class="line">    error:&#39;.&#x2F;static&#x2F;error.png&#39;,</span><br><span class="line">    loading:&#39;.&#x2F;static&#x2F;loading.png&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>vue文件中将需要懒加载的图片绑定 v-bind:src 修改为 v-lazy </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img class&#x3D;&quot;item-pic&quot; v-lazy&#x3D;&quot;newItem.picUrl&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>v-lazy</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>插件</tag>
        <tag>v-lazy</tag>
      </tags>
  </entry>
  <entry>
    <title>vantweapp</title>
    <url>/2020/07/22/vantweapp/</url>
    <content><![CDATA[<h3 id="小程序插件–vantWeapp"><a href="#小程序插件–vantWeapp" class="headerlink" title="小程序插件–vantWeapp"></a>小程序插件–vantWeapp</h3><blockquote>
<ol>
<li>新建个项目</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>找到项目文件夹 npm init 初始化一个叫package.json的文件一路回车即可</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>继续执行命令安装 Vant Weapp<br><code>npm i @vant/weapp -S --production</code> </li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>点击 开发者菜单里面的工具 &gt;构建npm 如下图</li>
</ol>
</blockquote>
<a id="more"></a>

<p><img src="http://upload-images.jianshu.io/upload_images/7211385-9510055e041611cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/939/format/webp" alt="img"></p>
<blockquote>
<ol start="5">
<li>还是开发者工具里面的详情 使用npm模块勾选上</li>
</ol>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/7211385-d50190f6a674c31d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/684/format/webp" alt="img"></p>
<blockquote>
<ol start="6">
<li>在引用的页面json或者app.json里添加引入的组件名字</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;usingComponents&quot;: &#123;</span><br><span class="line">  &quot;van-button&quot;: &quot;@vant&#x2F;weapp&#x2F;button&#x2F;index&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="http://upload-images.jianshu.io/upload_images/7211385-6163f82f17c59fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/984/format/webp" alt="img"></p>
<blockquote>
<ol start="7">
<li>最后就是在你的页面用使用了 如下图：</li>
</ol>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/7211385-d2fbd97f8301d40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><a href="https://www.jianshu.com/p/a63f21206b91" target="_blank" rel="noopener">参考链接</a></p>
<p><a href="https://youzan.github.io/vant-weapp/#/intro" target="_blank" rel="noopener">官网地址</a></p>
]]></content>
      <categories>
        <category>plugins</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>verdaccio私服搭建</title>
    <url>/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="1-安装verdaccio"><a href="#1-安装verdaccio" class="headerlink" title="1 安装verdaccio"></a>1 安装verdaccio</h3><p><code>$ npm install --global verdaccio</code></p>
<h4 id="1-1-verdaccio目录结构"><a href="#1-1-verdaccio目录结构" class="headerlink" title="1.1 verdaccio目录结构"></a>1.1 verdaccio目录结构</h4><p>安装后的文件在：C:\Users(用户名)\AppData\Roaming\verdaccio下</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/01.png" alt="01"></p>
<a id="more"></a>

<h4 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h4><hr>
<p>1、配置npm仓库的位置，找一个位置新建一个目录，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/02.png" alt="01"></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/02.png" alt="01"></p>
<p>2、找到配置文件的storage选项，然后把仓库的位置填写进去，注意是用斜线，而不是反斜线，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/03.png" alt="01"></p>
<h3 id="2-本地localhost启动"><a href="#2-本地localhost启动" class="headerlink" title="2 本地localhost启动"></a>2 本地localhost启动</h3><p><code>$ verdaccio</code></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/04.png" alt="01"><br>直接打开 <a href="http://localhost:4873/" target="_blank" rel="noopener">http://localhost:4873/</a></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/05.png" alt="01"></p>
<h3 id="3-创建用户"><a href="#3-创建用户" class="headerlink" title="3 创建用户"></a>3 创建用户</h3><p><code>$ npm adduser --registry http://localhost:4873</code><br>然后我们在<a href="http://localhost:4873/上面直接点Login就可以登陆了" target="_blank" rel="noopener">http://localhost:4873/上面直接点Login就可以登陆了</a></p>
<p><strong>这里，如果我们已经装了nrm ，可以简便上面这句操作：我们直接利用nrm把镜像源切换到我们的<a href="http://localhost:4873/上面，然后$" target="_blank" rel="noopener">http://localhost:4873/上面，然后$</a> npm adduser就可以了</strong></p>
<h5 id="nrm操作方法"><a href="#nrm操作方法" class="headerlink" title="nrm操作方法"></a>nrm操作方法</h5><ul>
<li><p><code>$ npm install -g nrm</code><br>全局安装nrm</p>
</li>
<li><p><code>$ nrm ls</code><br>用来查看npm源</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/06.png" alt="01"></p>
<p>名称前有* 的是当前用npm下载包的时候的地址，比如截图里面，当我<code>npm install</code>以后，就会从<a href="http://localhost:4873/上面下载包，而不是从npm网站上面下载" target="_blank" rel="noopener">http://localhost:4873/上面下载包，而不是从npm网站上面下载</a></p>
</li>
<li><p><code>$ nrm use 源名称</code><br>设置当前npm源</p>
</li>
<li><p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/07.png" alt="01"><br>这里我就把npm源换成了npmjs，当然咱们安装node以后，npm默认就是从这里下载。</p>
</li>
<li><p><code>$ nrm add 名称 地址</code><br>创建新的源</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/08.png" alt="01"></p>
</li>
<li><p><code>$ nrm del 名称</code><br>删除源</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/09.png" alt="01"></p>
</li>
</ul>
<ul>
<li><p>这些记不住都没关系，直接<code>$ nrm</code>全都可以查看</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/10.png" alt="01"></p>
</li>
</ul>
<h3 id="4-发布包"><a href="#4-发布包" class="headerlink" title="4 发布包"></a>4 发布包</h3><p><code>$ npm publish --registry http://localhost:4873</code><br>这里我随便新建一个文件夹，通过npm init新建一个项目，然后在这个目录下，<code>npm publish --registry http://localhost:4873</code></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/11.png" alt="01"></p>
<p>此时，文件里面有了package.json</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/12.png" alt="01"></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/13.png" alt="01"></p>
<h3 id="5-在需要的项目中引入包"><a href="#5-在需要的项目中引入包" class="headerlink" title="5 在需要的项目中引入包"></a>5 在需要的项目中引入包</h3><ol>
<li>新建一个目录，npm init </li>
<li>npm install 包的名字（在package.json中加上包的名字和版本，npm i）</li>
</ol>
<h3 id="6-配置成任意ip，别的电脑可以访问私有包"><a href="#6-配置成任意ip，别的电脑可以访问私有包" class="headerlink" title="6 配置成任意ip，别的电脑可以访问私有包"></a>6 配置成任意ip，别的电脑可以访问私有包</h3><p>1、在配置文件的末尾添加listen: 0.0.0.0:4873，配置此选项则是允许任何外部的所有IP都可以访问到此服务，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/14.png" alt="01"></p>
<p>2、然后重新启动verdaccio，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/15.png" alt="01"></p>
<p>3、然后在另外一台电脑即可打开，如下图所示：</p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/16.png" alt="01"></p>
<p>4、由于电脑的Ip是自动获取的，当电脑重启IP有可能会改变，因此最好需要手动设置一个IP，然后使用nrm add localnpm <a href="http://192.168.1.250:4873添加到npm源中，如下图所示：">http://192.168.1.250:4873添加到npm源中，如下图所示：</a></p>
<p><img src="/2020/08/11/verdaccio%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/17.png" alt="01"></p>
<p>5、然后通过nrm use localnpm来切换源，如下图所示，我们就切换到我们刚刚添加的源了：</p>
<h3 id="报错记录"><a href="#报错记录" class="headerlink" title="报错记录"></a>报错记录</h3><p>npm adduser报错Unable to authenticate和npm publish报错404</p>
<p>解决办法：就是用户名已经被注册了，换个用户名</p>
]]></content>
      <categories>
        <category>verdaccio</category>
      </categories>
      <tags>
        <tag>私有服务器</tag>
        <tag>verdaccio</tag>
      </tags>
  </entry>
  <entry>
    <title>vs和vsCode的plugins</title>
    <url>/2020/07/17/vs%E5%92%8CvsCode%E7%9A%84plugins/</url>
    <content><![CDATA[<h3 id="vs和vsCode插件"><a href="#vs和vsCode插件" class="headerlink" title="vs和vsCode插件"></a>vs和vsCode插件</h3><a id="more"></a>

<ol>
<li><p>vs</p>
<blockquote>
<ul>
<li>web compiler  将less和js编译成css和es5</li>
<li>force UTF-8 （No Bom）  将文档编译成utf-8的文档格式输出(也可以用记事本打开另存为,解决页面打开出现&amp;#65279，显示多余空白)</li>
<li>force UTF-8 （With Bom）</li>
</ul>
</blockquote>
</li>
</ol>
<ol start="2">
<li><blockquote>
<ul>
<li>Auto Close Tag   自动闭合标签</li>
<li>Image preview  悬停时显示图像预览</li>
<li>CSS Peek 内联加载 css 文件并在那里进行快速编辑</li>
<li>Auto Rename Tag 自动重命名标签</li>
<li>Highlight Matching Tag  突出显示匹配的开始或结束标签</li>
<li>Auto-Save on Window Change 关闭窗口自动保存</li>
<li>Chinese (Simplified) Language Pack for Visual Studio Code 中文包</li>
<li>CSS Tree 选中标签生成css文件树（Ctrl + shift + p选择 Generate CSS tree）</li>
<li>Easy LESS 可直接生成小程序wxss</li>
<li>filesize 查看文件大小</li>
<li>Path Intellisense 自动提示文件路径</li>
<li>Git Histroy/Local Histroy 文件历史记录</li>
<li>Material Icon Theme 文件图标</li>
<li>vscode-icons 图标插件</li>
<li>Bracket Pair Colorizer 括号颜色高亮</li>
<li>open in browser 在浏览器中打开</li>
<li>vscode-fileheader 文件头部信息</li>
<li>Vue 2 Snippets vue代码片段提示</li>
<li>vetur  vue语法高亮/格式化/代码片段/语法检查等</li>
<li>minapp 微信小程序标签、属性的智能补全（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）</li>
<li>Stylus Language  基于Node.js的CSS的预处理框架</li>
<li>live-server 实时简易服务器</li>
<li>Live Share 实时共享（vs 和vscode）</li>
<li>Live Share Audio 实时共享音频</li>
</ul>
</blockquote>
</li>
</ol>
<p><a href="https://marketplace.visualstudio.com/search?term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%8A%A9%E6%89%8B&target=VSCode&category=Programming%20Languages&sortBy=Relevance">插件官网地址</a></p>
<p><a href="https://mp.weixin.qq.com/s/LAe29D9nZvCcvs_Kr_PWZQ" target="_blank" rel="noopener">更多插件</a></p>
]]></content>
      <categories>
        <category>vs和vsCode</category>
      </categories>
      <tags>
        <tag>vs</tag>
        <tag>plugins</tag>
        <tag>vsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-devtools</title>
    <url>/2020/07/30/vue-devtools/</url>
    <content><![CDATA[<h3 id="Vue-js-devtools"><a href="#Vue-js-devtools" class="headerlink" title="Vue.js devtools"></a>Vue.js devtools</h3><p>Vue.js devtools是基于google chrome浏览器的一款调试vue.js应用的开发者浏览器扩展，可以在浏览器开发者工具下调试代码。</p>
<a id="more"></a>

<p>1）首先在github下载devtools源码，地址：<a href="https://github.com/vuejs/vue-devtools%E3%80%82" target="_blank" rel="noopener">https://github.com/vuejs/vue-devtools。</a></p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919205434540-2015837660.png" alt="img"></p>
<p>2）下载好后进入vue-devtools-master工程 执行cnpm install, 下载依赖，然后执行npm run build，编译源程序。</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919191704853-826104445.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919191820884-273399978.png" alt="img"></p>
<p>3）编译完成后，目录结构如下：<br><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919191916743-1974845966.png" alt="img"></p>
<p>修改shells、chrome目录下的mainifest.json 中的persistant为true：</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919192429618-1364706689.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919192727806-166414555.png" alt="img"></p>
<p> 4）打开谷歌浏览器的设置—&gt;扩展程序，并勾选开发者模式</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919203319915-287514806.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919203457306-737425079.png" alt="img"></p>
<p>然后将刚刚编译后的工程中的shells目录下，chrome的整个文件夹直接拖拽到当前浏览器中，并选择启用，即可将插件安装到浏览器。</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919203631071-371299784.png" alt="img"></p>
<p>5）打开一个已有的vue项目，运行项目，然后在浏览器中—&gt;设置—&gt;更多工具—&gt;开发者工具，进入调试模式：</p>
<p>发现vue.js is not detected  ，可以调整一下webpack.config.js的代码，</p>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919204337603-2116004923.png" alt="img"></p>
<hr>
<p><img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919205246228-260599521.png" alt="img"></p>
<p>最后，重启一下你的vue项目应该就可以使用了。</p>
<p> <img src="https://images2017.cnblogs.com/blog/1215920/201709/1215920-20170919205319915-1870577461.png" alt="img"></p>
<p> 参考链接：<a href="https://www.cnblogs.com/tanyongli/p/7554045.html" target="_blank" rel="noopener">https://www.cnblogs.com/tanyongli/p/7554045.html</a></p>
]]></content>
      <categories>
        <category>devtools</category>
      </categories>
      <tags>
        <tag>devtools</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-filter</title>
    <url>/2020/08/04/vue-filter/</url>
    <content><![CDATA[<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ol>
<li>全局过滤方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;全局过滤器控制浮点数计算显示几位小数，默认2位</span><br><span class="line">main.js</span><br><span class="line">Vue.filter(&#39;tofixed&#39;, function (value,num&#x3D;2) &#123;</span><br><span class="line">  if (!value) return 0</span><br><span class="line">  return value.toFixed(num)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">页面使用</span><br><span class="line">&lt;span&gt;(vipData.DiscountRate*10) | tofixed(1)&lt;&#x2F;span</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>局部过滤器</p>
<a id="more"></a>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      that:this,</span><br><span class="line">      searchValue: &quot;&quot;,</span><br><span class="line">      searchResult: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters:&#123;</span><br><span class="line">    brightenKeyword(val,that)&#123;</span><br><span class="line">      const Reg &#x3D; new RegExp(that.searchValue, &#39;ig&#39;);</span><br><span class="line">      return val.replace(Reg, &#96;&lt;span class&#x3D;&quot;redColor&quot;&gt;$&#123;that.searchValue&#125;&lt;&#x2F;span&gt;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">页面使用</span><br><span class="line"> &lt;li v-for&#x3D;&quot;item in searchResult&quot; :key&#x3D;&quot;item&quot; v-html&#x3D;&quot;$options.filters.brightenKeyword(item,that)&quot;&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>注册全局组件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常注册全局组件的时候，第二个参数应该是对象。全局组件必须写在Vue实例创建之前，才在该根元素下面生效；</span><br><span class="line">Vue.component(&#39;public1&#39;, &#123;</span><br><span class="line"> template: &#39;&lt;div&gt;正常的组件模式&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>私有组件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app1&quot;&gt;</span><br><span class="line">    &lt;child-component&gt;&lt;&#x2F;child-component&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#app1&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;child-component&quot;:&#123;</span><br><span class="line">                template:&quot;&lt;h1&gt;我是局部组件&lt;&#x2F;h1&gt;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>filter</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-lottie动画</title>
    <url>/2020/07/30/vue-lottie%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>安装vue-lottie包</p>
<p>npm install –save vue-lottie</p>
<a id="more"></a>

<p>引用vue-lottie</p>
<p>在main.js引入并全局注册组件</p>
<p>import lottie from ‘vue-lottie’;</p>
<p>Vue.component(‘lottie’, lottie)</p>
<p>引入Lottie动画资源</p>
<p>将我们在<a href="https://www.lottiefiles.com/popular" target="_blank" rel="noopener">Lottiefiles</a>下载下来的相应动画资源保存到项目中并映入</p>
<p>// 第一步：script中引入资源import * as animationData from “../assets/lottie/loading.json”;</p>
<p>// 第二步：使用组件</p>
<lottie :options="defaultOptions" :height="200" :width="200" v-on:animcreated="handleAnimation">

<p>// 第三步：data里面添加相应属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        defaultOptions: &#123;</span><br><span class="line">            animationData: animationData</span><br><span class="line">        &#125;,</span><br><span class="line">        animationSpeed: <span class="number">1</span>,</span><br><span class="line">        anim: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//第四步：定义方法</span></span><br><span class="line">methods: &#123;    </span><br><span class="line">	handleAnimation: <span class="function"><span class="keyword">function</span>(<span class="params">anim</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.anim = anim;        </span><br><span class="line">		<span class="built_in">console</span>.log(anim); <span class="comment">//这里可以看到 lottie 对象的全部属性    </span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</lottie>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>lottie</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-mixin</title>
    <url>/2020/07/30/vue-mixin/</url>
    <content><![CDATA[<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><h4 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h4><p>1.创建mixin的js文件</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const info&#x3D;&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &quot;curry&quot;,</span><br><span class="line">            sex: &quot;man&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.引入创建的js文件（花括号必须写，mixins，s不能忘）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;info&#125; from &#39;mixin文件的路径&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">	mixins:[info]　 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.使用mixin中的数据（组件中直接使用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this.name) &#x2F;&#x2F;curry</span><br></pre></td></tr></table></figure>



<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p><strong>方法一</strong>：在工程的main.js中直接注册，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line"></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&#39;全局混入的钩子函数&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>方法二</strong>：</p>
<p>模块化注册，新建mixin.js文件并添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      created() &#123;</span><br><span class="line">        console.log(&#39;全局混入的钩子函数&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main.js中引入该文件并使用use方法进行注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import myMixin from &#39;.&#x2F;mixin.js&#39;;</span><br><span class="line"></span><br><span class="line">Vue.use(myMixin);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mixin</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>mixin</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-mock</title>
    <url>/2020/07/30/vue-mock/</url>
    <content><![CDATA[<h3 id="vue中使用mock"><a href="#vue中使用mock" class="headerlink" title="vue中使用mock"></a>vue中使用mock</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>npm install mockjs –save</p>
<p>npm install axios –save</p>
<p>安装axios是为了能模拟后台接口。</p>
<a id="more"></a>

<h3 id="建立目录结构如下："><a href="#建立目录结构如下：" class="headerlink" title="建立目录结构如下："></a>建立目录结构如下：</h3><p><img src="https://img-blog.csdn.net/20180731124828244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFvamllMTIzMjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="在main-js引入mockjs"><a href="#在main-js引入mockjs" class="headerlink" title="在main.js引入mockjs"></a>在main.js引入mockjs</h3><p><img src="https://img-blog.csdn.net/20180731125441827?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFvamllMTIzMjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="mock-js"><a href="#mock-js" class="headerlink" title="mock.js"></a>mock.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span> <span class="comment">// 引入mockjs</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> Random = Mock.Random <span class="comment">// Mock.Random 是一个工具类，用于生成各种随机数据</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> data = [] <span class="comment">// 用于接受生成数据的数组</span></span><br><span class="line"><span class="keyword">let</span> size = [</span><br><span class="line">  <span class="string">'300x250'</span>, <span class="string">'250x250'</span>, <span class="string">'240x400'</span>, <span class="string">'336x280'</span>, </span><br><span class="line">  <span class="string">'180x150'</span>, <span class="string">'720x300'</span>, <span class="string">'468x60'</span>, <span class="string">'234x60'</span>, </span><br><span class="line">  <span class="string">'88x31'</span>, <span class="string">'120x90'</span>, <span class="string">'120x60'</span>, <span class="string">'120x240'</span>, </span><br><span class="line">  <span class="string">'125x125'</span>, <span class="string">'728x90'</span>, <span class="string">'160x600'</span>, <span class="string">'120x600'</span>, </span><br><span class="line">  <span class="string">'300x600'</span></span><br><span class="line">] <span class="comment">// 定义随机值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123; <span class="comment">// 可自定义生成的个数</span></span><br><span class="line">  <span class="keyword">let</span> template = &#123;</span><br><span class="line">    <span class="string">'Boolean'</span>: Random.boolean, <span class="comment">// 可以生成基本数据类型</span></span><br><span class="line">    <span class="string">'Natural'</span>: Random.natural(<span class="number">1</span>, <span class="number">10</span>), <span class="comment">// 生成1到100之间自然数</span></span><br><span class="line">    <span class="string">'Integer'</span>: Random.integer(<span class="number">1</span>, <span class="number">100</span>), <span class="comment">// 生成1到100之间的整数</span></span><br><span class="line">    <span class="string">'Float'</span>: Random.float(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">5</span>), <span class="comment">// 生成0到100之间的浮点数,小数点后尾数为0到5位</span></span><br><span class="line">    <span class="string">'Character'</span>: Random.character(), <span class="comment">// 生成随机字符串,可加参数定义规则</span></span><br><span class="line">    <span class="string">'String'</span>: Random.string(<span class="number">2</span>, <span class="number">10</span>), <span class="comment">// 生成2到10个字符之间的字符串</span></span><br><span class="line">    <span class="string">'Range'</span>: Random.range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>), <span class="comment">// 生成一个随机数组</span></span><br><span class="line">    <span class="string">'Date'</span>: Random.date(), <span class="comment">// 生成一个随机日期,可加参数定义日期格式</span></span><br><span class="line">    <span class="string">'Image'</span>: Random.image(Random.size, <span class="string">'#02adea'</span>, <span class="string">'Hello'</span>), <span class="comment">// Random.size表示将从size数据中任选一个数据</span></span><br><span class="line">    <span class="string">'Color'</span>: Random.color(), <span class="comment">// 生成一个颜色随机值</span></span><br><span class="line">    <span class="string">'Paragraph'</span>:Random.paragraph(<span class="number">2</span>, <span class="number">5</span>), <span class="comment">//生成2至5个句子的文本</span></span><br><span class="line">    <span class="string">'Name'</span>: Random.name(), <span class="comment">// 生成姓名</span></span><br><span class="line">    <span class="string">'Url'</span>: Random.url(), <span class="comment">// 生成web地址</span></span><br><span class="line">    <span class="string">'Address'</span>: Random.province() <span class="comment">// 生成地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  data.push(template)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Mock.mock(<span class="string">'/data/index'</span>, <span class="string">'post'</span>, data) <span class="comment">// 根据数据模板生成模拟数据</span></span><br></pre></td></tr></table></figure>

<h3 id="api-js"><a href="#api-js" class="headerlink" title="api.js"></a>api.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"> </span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 封装axios的post请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.post(url, params)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(response.data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mockdata(url, params) &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(url, params);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mock-vue"><a href="#mock-vue" class="headerlink" title="mock.vue"></a>mock.vue</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./../axios/api.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Mock'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      dataShow: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.getdata()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      api.mockdata(<span class="string">'/data/index'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="keyword">this</span>.dataShow = res.data;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="控制台打印出的数据"><a href="#控制台打印出的数据" class="headerlink" title="控制台打印出的数据"></a>控制台打印出的数据</h3><p><img src="https://img-blog.csdn.net/20180731125545864?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFvamllMTIzMjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>以上是使用mockjs生成的模拟数据，基本可以满足平时开发的需要，不过mockjs还有其他的用法未能一一列出来，建议各位朋友们去mock官网的文档了解更多，地址：<a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a> 。</p>
]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-nextTick</title>
    <url>/2020/08/06/vue-nextTick/</url>
    <content><![CDATA[<h4 id="异步更新队列："><a href="#异步更新队列：" class="headerlink" title="异步更新队列："></a>异步更新队列：</h4><p>请记住：<strong>vue是依靠数据驱动视图更新的，该更新的过程是异步的。</strong>即：当侦听到你的数据发生变化时， Vue将开启一个队列（该队列被Vue官方称为异步更新队列）。视图需要等队列中所有数据变化完成之后，再统一进行更新。示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;myApp&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点我呀&quot; @click&#x3D;&quot;changeStr&quot;&gt;</span><br><span class="line">    &lt;p ref&#x3D;&quot;myP&quot;&gt;&#123;&#123;str&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#myApp&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            str:&quot;公众号 张培跃，关注它的人很少！&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            changeStr()&#123;</span><br><span class="line">                this.str &#x3D; &quot;欢迎关注公众号 张培跃，收看更多精彩内容！&quot;;</span><br><span class="line">                &#x2F;&#x2F; 输出结果：公众号 张培跃，关注它的人很少！</span><br><span class="line">                console.log(this.$refs.myP.innerText)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>通过以上示例的输出结果可以有力证明：<strong>Vue 实现的响应式并不是数据发生变化之后视图立即变化。</strong></p>
<p>更改上个示例中的changeStr方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">changeStr()&#123;</span><br><span class="line">    this.str &#x3D; &quot;欢迎关注公众号 张培跃，收看更多精彩内容！&quot;;</span><br><span class="line">    this.$nextTick(()&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; 输出结果：我爱你中国，我亲爱的母亲！</span><br><span class="line">        console.log(this.$refs.myP.innerText);</span><br><span class="line">    &#125;);</span><br><span class="line">    this.str &#x3D; &quot;我爱你中国，我亲爱的母亲！&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出的结果可以看出：我们可以通过<code>$nextTick()</code> 获取到更新之后的<code>DOM</code>。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>1、如果要在<code>created()</code>钩子函数中进行的<code>DOM</code>操作，由于<code>created()</code>钩子函数中还未对DOM进行任何渲染，所以无法直接操作，需要通过<code>$nextTick()</code>来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    this.$nextTick(()&#x3D;&gt;&#123;</span><br><span class="line">        this.$refs.myP.innerText &#x3D; &quot;我是一只小小小小鸟，想要飞，却怎么样也飞不高！&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注：在<code>created()</code>钩子函数中进行的<code>DOM</code>操作，不使用<code>$nextTick()</code>会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  Error in created hook: &quot;TypeError: Cannot set property &#39;innerText&#39; of undefined&quot;</span><br><span class="line">created()&#123;</span><br><span class="line">    this.$refs.myP.innerText &#x3D; &quot;我是一只小小小小鸟，想要飞，却怎么样也飞不高！&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、更新数据后，想要使用js对新的视图进行操作时。</p>
<p>3、在使用某些第三方插件时 ，这些插件需要dom动态变化后重新应用该插件，这时候就需要使用<code>$nextTick()</code>来重新应用插件的方法。示例（略）</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-ref</title>
    <url>/2020/08/06/vue-ref/</url>
    <content><![CDATA[<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>在原生里获取DOM元素，需document.querySelector（”.input1”）获取这个dom节点，然后在获取input1的值。</p>
<p>但是用ref绑定之后，我们就不需要在获取dom节点了，直接在上面的input上绑定input1，然后$refs里面调用就行。</p>
<p>然后在javascript里面这样调用：this.$refs.input1  这样就可以减少获取dom节点的消耗了</p>
<a id="more"></a>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>ref 有三种用法：</p>
<p>　　1、ref 加在普通的元素上，用this.$refs.name 获取到的是dom元素</p>
<p>　　2、ref 加在子组件上，用his.$refs.name 获取到的是<strong>组件实例，可以使用组件的所有方法</strong>。</p>
<p>​    3、<strong>ref 需要在dom渲染完成后才会有</strong>，在使用的时候确保dom已经渲染完成。比如在生命周期 <strong>mounted(){} 钩子中调用</strong>，或者<strong>在 this.$nextTick(()=&gt;{}) 中调用</strong>。</p>
<p>　　4、如果ref 是循环出来的，<strong>有多个重名，那么ref的值会是一个数组</strong> ，此时要拿到单个的ref 只需要循环就可以了。</p>
<p><img src="https://images2018.cnblogs.com/blog/1158910/201808/1158910-20180801214632214-356594092.png" alt="img"></p>
<h3 id="一、ref使用在外面的组件上"><a href="#一、ref使用在外面的组件上" class="headerlink" title="一、ref使用在外面的组件上"></a>一、ref使用在外面的组件上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;ref-outside-component&quot; v-on:click&#x3D;&quot;consoleRef&quot;&gt;</span><br><span class="line">    &lt;component-father ref&#x3D;&quot;outsideComponentRef&quot;&gt;</span><br><span class="line">    &lt;&#x2F;component-father&gt;</span><br><span class="line">    &lt;p&gt;ref在外面的组件上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refoutsidecomponentTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39;&gt;&lt;h5&gt;我是子组件&lt;&#x2F;h5&gt;&lt;&#x2F;div&gt;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refoutsidecomponent&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-outside-component&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refoutsidecomponentTem</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F; #ref-outside-component     vue实例</span><br><span class="line">                console.log(this.$refs.outsideComponentRef);  &#x2F;&#x2F; div.childComp vue实例，组件实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h3 id="二、ref作用在外面元素上"><a href="#二、ref作用在外面元素上" class="headerlink" title="二、ref作用在外面元素上"></a>二、ref作用在外面元素上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在外面的元素上</span><br><span class="line">&lt;div id&#x3D;&quot;ref-outside-dom&quot; v-on:click&#x3D;&quot;consoleRef&quot; &gt;</span><br><span class="line">   &lt;component-father&gt;</span><br><span class="line">   &lt;&#x2F;component-father&gt;</span><br><span class="line">   &lt;p ref&#x3D;&quot;outsideDomRef&quot;&gt;ref在外面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refoutsidedomTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39;&gt;&lt;h5&gt;我是子组件&lt;&#x2F;h5&gt;&lt;&#x2F;div&gt;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refoutsidedom&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-outside-dom&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refoutsidedomTem</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F; #ref-outside-dom    vue实例</span><br><span class="line">                console.log(this.$refs.outsideDomRef);  &#x2F;&#x2F;  &lt;p&gt;标签dom元素 ref在外面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>[</p>
<h3 id="三、ref使用在里面的元素上–局部注册组件"><a href="#三、ref使用在里面的元素上–局部注册组件" class="headerlink" title="三、ref使用在里面的元素上–局部注册组件"></a>三、ref使用在里面的元素上–局部注册组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在里面的元素上</span><br><span class="line">&lt;div id&#x3D;&quot;ref-inside-dom&quot;&gt;</span><br><span class="line">    &lt;component-father&gt;</span><br><span class="line">    &lt;&#x2F;component-father&gt;</span><br><span class="line">    &lt;p&gt;ref在里面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refinsidedomTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39; v-on:click&#x3D;&#39;consoleRef&#39;&gt;&quot; +</span><br><span class="line">                       &quot;&lt;h5 ref&#x3D;&#39;insideDomRef&#39;&gt;我是子组件&lt;&#x2F;h5&gt;&quot; +</span><br><span class="line">                  &quot;&lt;&#x2F;div&gt;&quot;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this);  &#x2F;&#x2F; div.childComp   vue实例 </span><br><span class="line">                console.log(this.$refs.insideDomRef);  &#x2F;&#x2F; &lt;h5 &gt;我是子组件&lt;&#x2F;h5&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refinsidedom&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-inside-dom&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refinsidedomTem</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);[</span><br></pre></td></tr></table></figure>

<h3 id="四、ref使用在里面的元素上–全局注册组件"><a href="#四、ref使用在里面的元素上–全局注册组件" class="headerlink" title="四、ref使用在里面的元素上–全局注册组件"></a>四、ref使用在里面的元素上–全局注册组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在里面的元素上--全局注册</span><br><span class="line">&lt;div id&#x3D;&quot;ref-inside-dom-all&quot;&gt;</span><br><span class="line">    &lt;ref-inside-dom-quanjv&gt;&lt;&#x2F;ref-inside-dom-quanjv&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    Vue.component(&quot;ref-inside-dom-quanjv&quot;,&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;insideFather&#39;&gt; &quot; +</span><br><span class="line">                    &quot;&lt;input type&#x3D;&#39;text&#39; ref&#x3D;&#39;insideDomRefAll&#39; v-on:input&#x3D;&#39;showinsideDomRef&#39;&gt;&quot; +</span><br><span class="line">                    &quot;  &lt;p&gt;ref在里面的元素上--全局注册 &lt;&#x2F;p&gt; &quot; +</span><br><span class="line">                  &quot;&lt;&#x2F;div&gt;&quot;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            showinsideDomRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F;这里的this其实还是div.insideFather</span><br><span class="line">                console.log(this.$refs.insideDomRefAll); &#x2F;&#x2F; &lt;input  type&#x3D;&quot;text&quot;&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    var refinsidedomall&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-inside-dom-all&quot;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ref</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router</title>
    <url>/2020/08/05/vue-router/</url>
    <content><![CDATA[<h3 id="Vue路由（vue-router）详细讲解指南"><a href="#Vue路由（vue-router）详细讲解指南" class="headerlink" title="Vue路由（vue-router）详细讲解指南"></a><a href="https://www.cnblogs.com/dengyao-blogs/p/11562257.html" target="_blank" rel="noopener">Vue路由（vue-router）详细讲解指南</a></h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>中文文档：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">https://router.vuejs.org/zh/</a></p>
<p>Vue Router 是 <a href="http://cn.vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。路由实际上就是可以理解为指向，就是我在页面上点击一个按钮需要跳转到对应的页面，这就是路由跳转；</p>
<a id="more"></a>

<h4 id="单词解析"><a href="#单词解析" class="headerlink" title="单词解析"></a>单词解析</h4><p>首先我们来学习三个单词（route，routes，router）：</p>
<p>　　<strong>route</strong>：首先它是个单数，译为路由，即我们可以理解为单个路由或者某一个路由；<strong>可以获取 name ， path ，params，query等；</strong></p>
<p>　　<strong>router</strong>：译为路由器，上面都是路由，这个是路由器，我们可以理解为一个容器包含上述两个或者说它是一个管理者，负责管理上述两个；举个常见的场景的例子：当用户在页面上点击按钮的时候，这个时候router就会去routes中去查找route，就是说路由器会去路由集合中找对应的路由；<strong>$router.push可以跳转页面</strong>，<strong>$router.go则返回上一个页面</strong></p>
<p>　　<strong>routes</strong>：它是个复数，表示多个的集合才能为复数；即我们可以理解为多个路由的集合，JS中表示多种不同状态的集合的形式只有数组和对象两种，事实上官方定义routes是一个数组；所以我们记住了，routes表示多个数组的集合；<strong>route.js中routes存放的路由集合</strong></p>
<h4 id="安装项目"><a href="#安装项目" class="headerlink" title="安装项目"></a>安装项目</h4><p>　　首先需要安装vue-cli来构建一个vue的开发环境，安装完vue-cli之后，我们的项目目录结构如下：</p>
<p>　　　<img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921113853486-2102414267.png" alt="img"></p>
<p> 　　然后我们在命令行中输入npm install vue-router -g来安装vue-router，安装完之后我们可以打开package.json看到vue-router的版本号</p>
<h5 id="简单跳转"><a href="#简单跳转" class="headerlink" title="简单跳转"></a>简单跳转</h5><p>我们在src目录下新建三个文件，分别为page1.vue和page2.vue以及router.js：</p>
<p>page1.vue：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;page1&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;我是page1组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p> page2.vue：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;page2&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;我是page2组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p>router.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入vue</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引入vue-router</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三方库需要use一下才能用</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引用page1页面</span><br><span class="line">import page1  from &#39;.&#x2F;page1.vue&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引用page2页面</span><br><span class="line">import page2  from &#39;.&#x2F;page2.vue&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义routes路由的集合，数组类型</span><br><span class="line">const routes&#x3D;[</span><br><span class="line">    &#x2F;&#x2F;单个路由均为对象类型，path代表的是路径，component代表组件</span><br><span class="line">    &#123;path:&#39;&#x2F;page1&#39;,component:page1&#125;,</span><br><span class="line">    &#123;path:&quot;&#x2F;page2&quot;,component:page2&#125;,</span><br><span class="line">    &#x2F;&#x2F;懒加载写法</span><br><span class="line">    &#123;path:&quot;&#x2F;page3&quot;,component:() &#x3D;&gt; import(&#39;.&#x2F;page3.vue&#39;)&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例化VueRouter并将routes添加进去</span><br><span class="line">const router&#x3D;new VueRouter(&#123;</span><br><span class="line">&#x2F;&#x2F;ES6简写，等于routes：routes</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;抛出这个这个实例对象方便外部读取以及访问</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<p>这里我们再修改一下main.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">&#x2F;&#x2F;引用router.js</span><br><span class="line">import router from &#39;.&#x2F;router.js&#39;</span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">&#x2F;&#x2F;一定要注入到vue的实例对象上</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>修改App.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">	&#x2F;&#x2F;router-link定义页面中点击触发部分　　</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page1&quot;&gt;Page1&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page2&quot;&gt;Page2&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">	&#x2F;&#x2F;router-view定义页面中显示部分</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>就这样，我们的页面就可以进行路由跳转和切换了，路由的基本使用就完成了；但是有个问题就是我们第一次进去是看不到路由页面的，这是因为我们没有设置默认值，我们首次进入的时候路径是为空的，那么我们可以这么解决：</p>
<p>router.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">import page1  from &#39;.&#x2F;page1.vue&#39;;</span><br><span class="line">import page2  from &#39;.&#x2F;page2.vue&#39;;</span><br><span class="line">import user   from &#39;.&#x2F;user.vue&#39;</span><br><span class="line"></span><br><span class="line">const routes&#x3D;[</span><br><span class="line">    &#123;path:&#39;&#x2F;page1&#39;,component:page1&#125;,</span><br><span class="line">    &#123;path:&quot;&#x2F;page2&quot;,component:page2&#125;,</span><br><span class="line">    &#x2F;&#x2F;可以配置重定向</span><br><span class="line">    &#123;path:&#39;&#39;,redirect:&quot;page1&quot;&#125;</span><br><span class="line">    &#x2F;&#x2F;或者重新写个路径为空的路由</span><br><span class="line">    &#123;path:&quot;&quot;,component:page1&#125;</span><br><span class="line">]</span><br><span class="line">const router&#x3D;new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>



<p>上面的两种解决方案都是可以解决的，配置重定向的意思就是当匹配到路径为空的时候，就会重定向到page1，执行page1的路由；或者我们也可以重新配置个路由，路径为空的时候router-view展示page1的页面；</p>
<p>用重定向和单独配置路由的区别：</p>
<p>　　重定向实际上是当匹配到路径符合条件的时候去执行对应的路由，当然这个时候的url上面的地址显示的是对应的路由，页面也是对应的路由页面；</p>
<p>　　重新配置路由是当匹配到路径符合条件的时候，router-view页面展示部分负责拿符合条件路由的页面来展示，实际上url是没有发生变化的；</p>
<h5 id="动态路由匹配："><a href="#动态路由匹配：" class="headerlink" title="动态路由匹配："></a>动态路由匹配：</h5><p>　　其实我们的生活中有很多这样的例子，不知道大家留意没有？比如一个网站或者后台管理系统中，在我们登录之后，是不是通常会有一个欢迎回来，XXX之类的提示语，这个我们就可以通过动态路由来实现这个效果；</p>
<p>首先在src目录下新建一个user.vue文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;user&lt;&#x2F;h1&gt;</span><br><span class="line">       &#x2F;&#x2F;这里可以通过$route.params.name来获取路由的参数</span><br><span class="line">        &lt;p&gt;欢迎回来,$route.params.name&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;我是page1组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p>然后我们修改App.vue文件的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page1&quot;&gt;Page1&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page2&quot;&gt;Page2&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加两个router-link标签</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;xianyu&quot;&gt;动态路由咸鱼&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;mengxiang&quot;&gt;动态路由梦想&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>修改我们的router.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">import page1  from &#39;.&#x2F;page1.vue&#39;;</span><br><span class="line">import page2  from &#39;.&#x2F;page2.vue&#39;;</span><br><span class="line">import user   from &#39;.&#x2F;user.vue&#39;</span><br><span class="line"></span><br><span class="line">const routes&#x3D;[</span><br><span class="line">    &#123;path:&#39;&#x2F;page1&#39;,component:page1&#125;,</span><br><span class="line">    &#123;path:&quot;&#x2F;page2&quot;,component:page2&#125;,</span><br><span class="line">    &#x2F;&#x2F; &#123;path:&#39;&#39;,redirect:&quot;page1&quot;&#125;</span><br><span class="line">    &#123;path:&quot;&quot;,component:page1&#125;,</span><br><span class="line"> 	&#x2F;&#x2F;使用冒号标记，当匹配到的时候，参数值会被设置到this.$route.params中</span><br><span class="line">    &#123;path:&quot;&#x2F;user&#x2F;:name&quot;,component:user&#125;</span><br><span class="line">    </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const router&#x3D;new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<p>配置好了，不出意外是能正常运行的，我们来看一下效果：</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921135641595-1931722345.png" alt="img"></p>
<p> 动态路由匹配给我们提供了方便，使得我们通过配置一个路由来实现页面局部修改的效果，给用户造成一种多个页面的感觉，是不是很酷！！！</p>
<p>酷的同时也会给我们带来一些问题，因为使用路由参数时，从/user/xianyu导航到/user/mengxiang，原来的组件实例会被复用，两个路由都渲染同个组件，比起销毁再创建，显示复用显得效率更高，带来的的只管问题就是生命周期钩子函数不会再被调用，也就是不会再被触发；但是办法总比问题多，我们可以通过监听$route对象来实现;</p>
<p>修改user.vue的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;user&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;欢迎回来,&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                &#x2F;&#x2F; msg: &quot;我是page1组件&quot;</span><br><span class="line">                msg:&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123;</span><br><span class="line">		&#x2F;&#x2F;to表示即将要进入的那个组件，from表示从哪个组件过来的</span><br><span class="line">            $route(to,from)&#123;</span><br><span class="line">                this.msg&#x3D;to.params.name; </span><br><span class="line">                console.log(111);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>效果图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921141325741-575913091.png" alt="img"></p>
<p> 我们可以很明显的看到我们监听的$route对象被触发了，控制台也输出了；</p>
<p>下面我们来一起看一下嵌套路由：</p>
<p>#####　嵌套路由：</p>
<p>很多时候我们的页面结构决定了我们可能需要嵌套路由，比如当我们进入主页之后有分类，然后当选择其中一个分类之后进入对应的详情，这个时候我们就可以用到嵌套路由；官方文档中给我们提供了一个children属性，这个属性是一个数组类型，里面实际放着一组路由；这个时候父子关系结构就出来了，所以children属性里面的是路由相对来说是children属性外部路由的子路由；</p>
<p>好记性不如烂代码，让我们通过代码来看一看：</p>
<p>　　首先在我们的src目录下新建两个vue文件，分别是phone.vue和computer.vue</p>
<p>　　phone.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;嵌套手机组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>　　computer.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;嵌套电脑组件&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们再修改我们的App.vue文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;router-link to&#x3D;&quot;&#x2F;page1&quot;&gt;Page1&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>通过上面的App.vue文件我们可以看到，我们此时页面只有一个page1的标签了；</p>
<p>我们再来修改router.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">import page1  from &#39;.&#x2F;page1.vue&#39;;</span><br><span class="line">import page2  from &#39;.&#x2F;page2.vue&#39;;</span><br><span class="line">import user   from &#39;.&#x2F;user.vue&#39;;</span><br><span class="line">import phone  from &#39;.&#x2F;phone.vue&#39;;</span><br><span class="line">import computer from &#39;.&#x2F;computer.vue&#39;</span><br><span class="line"></span><br><span class="line">const routes&#x3D;[</span><br><span class="line">    &#123;</span><br><span class="line">        path:&#39;&#x2F;page1&#39;,</span><br><span class="line">        component:page1,</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                path: &quot;phone&quot;,</span><br><span class="line">                component: phone</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: &quot;computer&quot;,</span><br><span class="line">                component: computer</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const router&#x3D;new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<p>为了大家看的直观点，其他路由全部注释了，页面只剩下/page1这一个路由了；</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921144040749-976651739.png" alt="img"></p>
<p>上面说到了，children属性其实就是一个子路由集合，数组结构里面放着子路由；</p>
<p>效果图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201909/1650307-20190921144102502-80898094.png" alt="img"></p>
<h5 id="路由导航两种方式："><a href="#路由导航两种方式：" class="headerlink" title="路由导航两种方式："></a>路由导航两种方式：</h5><p>　　<strong>标签导航：</strong>标签导航<router-link><router-link>是通过转义为<a></a>标签进行跳转，其中router-link标签中的to属性会被转义为a标签中的href属性；</router-link></router-link></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;跳转到名为user路由，并传递参数userId</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>​    <strong>编程式导航：</strong>我们可以通过this.$router.push()这个方法来实现编程式导航，当然也可以实现参数传递，这种编程式导航一般是用于按钮点击之后跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>这两者都会把路由导航到user/123路径</p>
<h5 id="路由传参-params-与-query"><a href="#路由传参-params-与-query" class="headerlink" title="路由传参 params 与 query"></a>路由传参 params 与 query</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query要用path来引入，params要用name来引入</span><br><span class="line">tourlname()&#123;</span><br><span class="line">   this.$router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">tourlpath()&#123;</span><br><span class="line">   this.$router.push(&#123; path: &#39;&#x2F;user&#39;, query: &#123; userId: 123 &#125;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取参数的不同</span><br><span class="line">$route.params.userId</span><br><span class="line">$route.query.userId</span><br><span class="line"></span><br><span class="line">params类似于post，不显示参数名</span><br><span class="line">query类似于我们ajax中get传参，在浏览器地址栏中显示参数名，</span><br></pre></td></tr></table></figure>

<p>使用params传递参数，url上只会出现数据，不会出现具体字段<br><img src="https://img-blog.csdnimg.cn/20200718154856867.png" alt="在这里插入图片描述"><br>而使用查询参数query的方式，url上会出现具体的字段，比较不安全<br><img src="https://img-blog.csdnimg.cn/2020071815491147.png" alt="在这里插入图片描述"></p>
<p>多个参数<br>直接在路由路径上拼接多个参数<br><img src="https://img-blog.csdnimg.cn/20200718154421681.png" alt="在这里插入图片描述"><br>对应组件使用路由的方法如下：<br><img src="https://img-blog.csdnimg.cn/20200718154444639.png" alt="在这里插入图片描述"></p>
<p><strong>注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的</strong></p>
<h5 id="props传参"><a href="#props传参" class="headerlink" title="props传参"></a>props传参</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A跳到B页面</span><br><span class="line"></span><br><span class="line">布尔模式</span><br><span class="line">A页面</span><br><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;you&#x2F;18&quot;&gt;user&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">B页面</span><br><span class="line">props:[&quot;id&quot;,&quot;age&quot;],</span><br><span class="line"></span><br><span class="line">router.js</span><br><span class="line">&#123;</span><br><span class="line">    path: &quot;&#x2F;B&#x2F;:id&#x2F;:age&quot;,</span><br><span class="line">    component: user,</span><br><span class="line">    props: true</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">函数模式</span><br><span class="line">A页面</span><br><span class="line">&lt;p @click&#x3D;&quot;url&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  url() &#123;</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">      path: &quot;&#x2F;user&#x2F;test&quot;,</span><br><span class="line">      query: &#123;</span><br><span class="line">      	articleTitle: &quot;文章1&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line">B页面</span><br><span class="line">props:[&quot;id&quot;,&quot;age&quot;],</span><br><span class="line"></span><br><span class="line">router.js</span><br><span class="line">&#123;</span><br><span class="line">    path: &quot;&#x2F;B&#x2F;:id&quot;,</span><br><span class="line">    component: user,</span><br><span class="line">    props: (route) &#x3D;&gt; (&#123;</span><br><span class="line">      id: route.params.id,</span><br><span class="line">      age: route.query.age</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">对象模式</span><br><span class="line">router.js</span><br><span class="line">&#123;</span><br><span class="line">    path: &quot;&#x2F;user&#x2F;:id&quot;,</span><br><span class="line">    component: user,</span><br><span class="line">    props: &#123;  &#x2F;&#x2F; 写死</span><br><span class="line">      food: &#39;banana&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>params拼接参数值，页面刷新会丢失<br>query拼接参数名和参数值,而且暴露了信息（最常用）<br>props参数值，页面刷新也不会丢失（最保险）</p>
<h5 id="命名路由："><a href="#命名路由：" class="headerlink" title="命名路由："></a>命名路由：</h5><p>有的时候，通过一个名称来标识一个路由显得更方便一些，所以官方为了方便我们偷懒，又给我们在路由中添加了一个name属性，命名这个属性之后我们访问这个属性就等于直接访问到路由；</p>
<p>　　普通路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.push(&#123; path: &#39;&#x2F;user&#x2F;:userId&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>



<p>　　命名路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>其实两者并没有什么区别，只是提供了两种方式来访问路由，可以通过路径来匹配也可以通过别名来匹配；</p>
<h5 id="路由字段"><a href="#路由字段" class="headerlink" title="路由字段"></a>路由字段</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const routes &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;&#x2F;user&#x2F;:name&quot;, &#x2F;&#x2F;动态路由</span><br><span class="line">    name: &quot;user&quot;, &#x2F;&#x2F; 命名设置 name 值</span><br><span class="line">    alias: &#39;&#x2F;home_page&#39;, &#x2F;&#x2F; 别名</span><br><span class="line">    meta: &#123;  &#x2F;&#x2F; 路由元信息 &lt;h1&gt; $route.meta.title&lt;&#x2F;h1&gt;，可变 this.$route.meta.title &#x3D; &quot;首页&quot;;</span><br><span class="line">      title: &#39;主页&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: user, </span><br><span class="line">    components: &#123;  &#x2F;&#x2F; 加s 命名多个视图</span><br><span class="line">      default: () &#x3D;&gt; import(&#39;views&#x2F;child.vue&#39;),</span><br><span class="line">      email: () &#x3D;&gt; import(&#39;views&#x2F;email.vue&#39;),</span><br><span class="line">      tel: () &#x3D;&gt; import(&#39;views&#x2F;tel.vue&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;hash&#39;,  &#x2F;&#x2F; 默认 #&#x2F;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,  </span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h5><p>首先我们在router文件夹中创建一个index.js作为路由的入口文件，然后新建一个modules文件夹，里面存放各个模块的路由文件。例如这里储存了一个vote.js投票模块的路由文件和一个公共模块的路由文件。下面直接上index.js吧，而后在简单介绍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 公共页面的路由文件</span><br><span class="line">import PUBLIC from &#39;.&#x2F;modules&#x2F;public&#39; </span><br><span class="line">&#x2F;&#x2F; 投票模块的路由文件</span><br><span class="line">import VOTE from &#39;.&#x2F;modules&#x2F;vote&#39; </span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义路由</span><br><span class="line">const router &#x3D; new Router(&#123;  </span><br><span class="line">    mode: &#39;history&#39;,  </span><br><span class="line">    routes: [    </span><br><span class="line">        ...PUBLIC,    </span><br><span class="line">        ...VOTE,  </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路由变化时</span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;    </span><br><span class="line">    if (document.title !&#x3D;&#x3D; to.meta.title) &#123;        </span><br><span class="line">        document.title &#x3D; to.meta.title;    </span><br><span class="line">    &#125;    </span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导出</span><br><span class="line">export default router复制代码</span><br></pre></td></tr></table></figure>

<p>首先引入vue和router最后导出，这就不多说了，基本的操作。</p>
<p>这里把router.beforeEach的操作写了router的index.js文件中，有些人可能会写在main.js中，这也没有错，只不过，个人而言，既然是路由的操作，还是放在路由文件中管理更好些。这里就顺便演示了，如何在页面切换时，自动修改页面标题的操作。</p>
<p>而后引入你根据路由模块划分的各个js文件，然后在实例化路由的时候，在routes数组中，将导入的各个文件通过结构赋值的方法取出来。最终的结果和正常的写法是一样的。</p>
<p>然后看下我们导入的vote.js吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * 投票模块的router列表  </span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">export default [    </span><br><span class="line">    &#x2F;&#x2F; 投票模块首页    </span><br><span class="line">    &#123;        </span><br><span class="line">        path: &#39;&#x2F;vote&#x2F;index&#39;,        </span><br><span class="line">        name: &#39;VoteIndex&#39;,        </span><br><span class="line">        component: resolve &#x3D;&gt; require([&#39;@&#x2F;view&#x2F;vote&#x2F;index&#39;], resolve),        </span><br><span class="line">        meta: &#123;            </span><br><span class="line">            title: &#39;投票&#39;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    &#x2F;&#x2F; 详情页    </span><br><span class="line">    &#123;        </span><br><span class="line">        path: &#39;&#x2F;vote&#x2F;detail&#39;,        </span><br><span class="line">        name: &#39;VoteDetail&#39;,        </span><br><span class="line">        component: resolve &#x3D;&gt; require([&#39;@&#x2F;view&#x2F;vote&#x2F;detail&#39;], resolve),</span><br><span class="line">        meta: &#123;            </span><br><span class="line">            title: &#39;投票详情&#39;        </span><br><span class="line">        &#125;    </span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>



<h5 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a><strong>过渡动效</strong></h5><ul>
<li>单个路由过渡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition name&#x3D;&quot;router&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;transition&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .router-enter &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-enter-active &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-enter-to &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-leave &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-leave-active &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  .router-leave-to &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态过渡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用动态的 transition name --&gt;</span><br><span class="line">&lt;transition :name&#x3D;&quot;transitionName&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;transition&gt;</span><br><span class="line"></span><br><span class="line">路由的meta中定义一个tree属性</span><br><span class="line">const routers&#x3D;[</span><br><span class="line">    	&#123;</span><br><span class="line">    		path: &#39;&#x2F;test&#39;,</span><br><span class="line">    		name: &#39;test&#39;,   &#x2F;&#x2F;财务查询页</span><br><span class="line">    		component: resolve &#x3D;&gt; require([&#39;@&#x2F;page&#x2F;test&#x2F;test&#39;], resolve),</span><br><span class="line">    		meta:&#123;</span><br><span class="line">    		   	title : &#39;测试页&#39;, &#x2F;&#x2F; 标题设置在这里</span><br><span class="line">    			tree: 4,</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: &#39;&#x2F;list1&#39;,</span><br><span class="line">		name: &#39;list1&#39;,   &#x2F;&#x2F;财务查询页</span><br><span class="line">		component: resolve &#x3D;&gt; require([&#39;@&#x2F;page&#x2F;test&#x2F;list1&#39;], resolve),</span><br><span class="line">		meta:&#123;</span><br><span class="line">		   	title : &#39;测试页&#39;, &#x2F;&#x2F; 标题设置在这里</span><br><span class="line">			tree: 1,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">导航守卫</span><br><span class="line">&#x2F;&#x2F;路由跳转前进后退动画,Vue原型上定义transition为动画效果</span><br><span class="line">router.beforeEach ( (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    Vue.prototype.transition &#x3D; &#39;slide-none&#39;;</span><br><span class="line">    if(from.meta.tree &gt; to.meta.tree) &#123;</span><br><span class="line">        &#x2F;&#x2F; 后退,想右滑动</span><br><span class="line">        Vue.prototype.transition &#x3D; &#39;slide-right&#39;;</span><br><span class="line">        from.meta.keepAlive &#x3D; false;</span><br><span class="line">        to.meta.keepAlive &#x3D; true;</span><br><span class="line">    &#125; else if(from.meta.tree &lt; to.meta.tree) &#123;</span><br><span class="line">        &#x2F;&#x2F; 前进,想左滑动</span><br><span class="line">        Vue.prototype.transition &#x3D; &#39;slide-left&#39;;</span><br><span class="line">        from.meta.keepAlive &#x3D; true;</span><br><span class="line">        to.meta.keepAlive &#x3D; false;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		&#x2F;&#x2F; 同一层级,无动画</span><br><span class="line">		Vue.prototype.transition &#x3D; &#39;slide-none&#39;;</span><br><span class="line">		from.meta.keepAlive &#x3D; true;</span><br><span class="line">		to.meta.keepAlive &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;使用title作为路由名称</span><br><span class="line">	if (to.meta.title) &#123;</span><br><span class="line">        document.title &#x3D; to.meta.title;</span><br><span class="line">    &#125;</span><br><span class="line">	next();</span><br><span class="line">&#125;)</span><br><span class="line">或者</span><br><span class="line">&#x2F;&#x2F; watch $route 决定使用哪种过渡 （弃用）</span><br><span class="line">watch: &#123;</span><br><span class="line">&#39;$route&#39; (to, from) &#123;</span><br><span class="line">    const toDepth &#x3D; to.meta.tree</span><br><span class="line">    const fromDepth &#x3D; from.meta.tree</span><br><span class="line">    this.transitionName &#x3D; toDepth &lt; fromDepth ? &#39;slide-right&#39; : &#39;slide-left&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">css</span><br><span class="line">@keyframes slideInLeft &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        transform: translate3d(100%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        transform: translate3d(0, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes slideInRight &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        transform: translate3d(0%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        transform: translate3d(-100%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.slide-left-enter-active&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0%;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    animation: slideInLeft 1s linear forwards;</span><br><span class="line">&#125;</span><br><span class="line">.slide-left-leave-active&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0%;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    animation: slideInRight 1s linear forwards;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*向右滑动*&#x2F;</span><br><span class="line">@keyframes slideOutLeft &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        transform: translate3d(-100%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        transform: translate3d(0%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes slideOutRight &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">        transform: translate3d(0%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">        transform: translate3d(100%, 0, 0);</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.slide-right-enter-active&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0%;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    animation: slideOutLeft 1s linear forwards;</span><br><span class="line">&#125;</span><br><span class="line">.slide-right-leave-active&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0%;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    animation: slideOutRight 1s linear forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h5 id="导航守卫-钩子函数-生命周期函数-、"><a href="#导航守卫-钩子函数-生命周期函数-、" class="headerlink" title="导航守卫(钩子函数/生命周期函数)、"></a><strong>导航守卫</strong>(钩子函数/生命周期函数)、</h5><ul>
<li>全局导航守卫</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;router&#x2F;index.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import routes from &#39;.&#x2F;router.js&#39;</span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">const router &#x3D;  new Router(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设登录判断</span><br><span class="line">const HAS_LOGIN &#x3D; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全局路由前置守卫</span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; to 即将跳转到的路由对象</span><br><span class="line">  &#x2F;&#x2F; from 将要离开的路由对象</span><br><span class="line">  &#x2F;&#x2F; next() 函数</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 开始是否进入登录</span><br><span class="line">  if (to.name !&#x3D;&#x3D; &#39;login&#39;) &#123;</span><br><span class="line">    if (HAS_LOGIN) next()  &#x2F;&#x2F; 如果登录了, 继续</span><br><span class="line">    else next(&#123;</span><br><span class="line">      name: &#39;login&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 如果跳转到登录页面</span><br><span class="line">    if (HAS_LOGIN) next(&#123;name: &#39;home&#39;&#125;) &#x2F;&#x2F; 登录了, 到主页</span><br><span class="line">    else next()  &#x2F;&#x2F; 没有登录 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全局路由后置守卫</span><br><span class="line">router.afterEach((to, from) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 可以设置 loading 的进度 为 false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<ul>
<li>路由独享守卫</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router.js</span><br><span class="line">import Home from &#39;.&#x2F;views&#x2F;Home.vue&#39;</span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,  &#x2F;&#x2F; url 路径</span><br><span class="line">    name: &#39;Home&#39;,</span><br><span class="line">    component: Home,  &#x2F;&#x2F; 路径对应渲染组件</span><br><span class="line">    beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>组件内的钩子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; home.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  home</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    beforeRouteEnter (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">      &#x2F;&#x2F; 不！能！获取组件实例 &#96;this&#96;</span><br><span class="line">      &#x2F;&#x2F; 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">      next(vm &#x3D;&gt; &#123;</span><br><span class="line">        console.log(vm)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 用户编辑未保存离开, 可以询问是否离开</span><br><span class="line">    beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">      &#x2F;&#x2F; 导航离开该组件的对应路由时调用</span><br><span class="line">      &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class="line">      const leave &#x3D; confirm(&#39;您确认要离开吗&#39;)</span><br><span class="line">      if (leave) next()</span><br><span class="line">      else next(false)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; argu.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  argu</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">      &#x2F;&#x2F; 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">      &#x2F;&#x2F; 举例来说，对于一个带有动态参数的路径 &#x2F;foo&#x2F;:id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，</span><br><span class="line">      &#x2F;&#x2F; 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">      &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整的导航解析流程</li>
</ul>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。<code>beforeRouteLeave</code></li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 <code>DOM</code> 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 next 的回调函数。</li>
</ol>
<h5 id="路由钩子在实际开发中的应用场景"><a href="#路由钩子在实际开发中的应用场景" class="headerlink" title="路由钩子在实际开发中的应用场景"></a>路由钩子在实际开发中的应用场景</h5><p>beforeRouteLeave, 使用场景分别为一下三类情况：<br>1、清除当前组件中的定时器,当一个组件中有一个定时器时, 在路由进行切换的时候, 可使用beforeRouteLeave将定时器进行清楚, 以免占用内存:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line"> window.clearInterval(this.timer) &#x2F;&#x2F;清除定时器</span><br><span class="line"> next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转如果页面内有重要的信息需要用户保存后才能进行跳转, 或者有弹出框的情况. 应该阻止用户跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line"> &#x2F;&#x2F;判断是否弹出框的状态和保存信息与否</span><br><span class="line"> if (this.dialogVisibility &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">  this.dialogVisibility &#x3D; false &#x2F;&#x2F;关闭弹出框</span><br><span class="line">  next(false) &#x2F;&#x2F;回到当前页面, 阻止页面跳转</span><br><span class="line"> &#125;else if(this.saveMessage &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">  &#x2F;&#x2F;弹出警告</span><br><span class="line">  next(false) &#x2F;&#x2F;回到当前页面, 阻止页面跳转</span><br><span class="line"> &#125;else &#123;</span><br><span class="line">  next() &#x2F;&#x2F;否则允许跳转</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、保存相关内容到Vuex中或Session中,当用户需要关闭页面时, 可以将公用的信息保存到session或Vuex中;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">  localStorage.setItem(name, content); &#x2F;&#x2F;保存到localStorage中</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>除了使用钩子函数外，我们也可以使用 watch 来监听 $route 对象，然后根据路由参数的变化来进行响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      &#39;$route&#39; (to, from) &#123;</span><br><span class="line">        &#x2F;&#x2F; 对路由变化作出响应...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-skeleton-webpack-plugin</title>
    <url>/2020/09/10/vue-skeleton-webpack-plugin/</url>
    <content><![CDATA[<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2020/09/10/vue-skeleton-webpack-plugin/image-20200910115921296.png" alt="image-20200910115921296"></p>
<a id="more"></a>

<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-skeleton-webpack-plugin</span><br></pre></td></tr></table></figure>



<h3 id="新建webpack-skeleton-conf-js"><a href="#新建webpack-skeleton-conf-js" class="headerlink" title="新建webpack.skeleton.conf.js"></a>新建webpack.skeleton.conf.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const merge &#x3D; require(&#39;webpack-merge&#39;)</span><br><span class="line">const baseWebpackConfig &#x3D; require(&#39;.&#x2F;webpack.base.conf&#39;)</span><br><span class="line">const nodeExternals &#x3D; require(&#39;webpack-node-externals&#39;)</span><br><span class="line">const utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">const config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">const isProduction &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">const sourceMapEnabled &#x3D; isProduction</span><br><span class="line">  ? config.build.productionSourceMap</span><br><span class="line">  : config.dev.cssSourceMap</span><br><span class="line"></span><br><span class="line">function resolve(dir) &#123;</span><br><span class="line">  return path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let skeletonWebpackConfig &#x3D; merge(baseWebpackConfig, &#123;</span><br><span class="line">  target: &#39;node&#39;,</span><br><span class="line">  devtool: false,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: resolve(&#39;..&#x2F;src&#x2F;entry-skeleton.js&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: Object.assign(&#123;&#125;, baseWebpackConfig.output, &#123;</span><br><span class="line">    libraryTarget: &#39;commonjs2&#39;</span><br><span class="line">  &#125;),</span><br><span class="line">  externals: nodeExternals(&#123;</span><br><span class="line">    whitelist: &#x2F;\.css$&#x2F;</span><br><span class="line">  &#125;),</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; important: enable extract-text-webpack-plugin</span><br><span class="line">skeletonWebpackConfig.module.rules[0].options.loaders &#x3D; utils.cssLoaders(&#123;</span><br><span class="line">  sourceMap: sourceMapEnabled,</span><br><span class="line">  extract: true</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; skeletonWebpackConfig</span><br></pre></td></tr></table></figure>



<h3 id="webpack-prod-conf-js-webpack-dev-conf-js"><a href="#webpack-prod-conf-js-webpack-dev-conf-js" class="headerlink" title="webpack.prod.conf.js/webpack.dev.conf.js"></a>webpack.prod.conf.js/webpack.dev.conf.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const SkeletonWebpackPlugin &#x3D; require(&#39;vue-skeleton-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">new SkeletonWebpackPlugin(&#123;</span><br><span class="line">      webpackConfig: require(&#39;.&#x2F;webpack.skeleton.conf&#39;),</span><br><span class="line">      quiet: true,</span><br><span class="line">      minimize: true,</span><br><span class="line">      router: &#123;</span><br><span class="line">        mode: &#39;hash&#39;,</span><br><span class="line">        routes: [</span><br><span class="line">            &#123;</span><br><span class="line">              path: &#39;&#x2F;page1&#39;,</span><br><span class="line">              skeletonId: &#39;skeleton1&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              path: &#39;&#x2F;Hello&#39;,</span><br><span class="line">              skeletonId: &#39;skeleton2&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              path: &#39;&#x2F;&#39;,</span><br><span class="line">              skeletonId: &#39;skeleton2&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数说明</span><br><span class="line">webpackConfig 必填，渲染 skeleton 的 webpack 配置对象</span><br><span class="line">insertAfter 选填，渲染 DOM 结果插入位置，默认值为字符串 &#39;&lt;div id&#x3D;&quot;app&quot;&gt;&#39;</span><br><span class="line">也可以传入 Function，方法签名为 insertAfter(entryKey: string): string，返回值为挂载点字符串</span><br><span class="line">quiet 选填，在服务端渲染时是否需要输出信息到控制台</span><br><span class="line">router 选填 SPA 下配置各个路由路径对应的 Skeleton</span><br><span class="line">mode 选填 路由模式，两个有效值 history|hash</span><br><span class="line">routes 选填 路由数组，其中每个路由对象包含两个属性：</span><br><span class="line">path 路由路径</span><br><span class="line">skeletonId Skeleton DOM 的 id</span><br><span class="line">minimize 选填 SPA 下是否需要压缩注入 HTML 的 JS 代码</span><br></pre></td></tr></table></figure>



<h3 id="src下新建entry-skeleton-js"><a href="#src下新建entry-skeleton-js" class="headerlink" title="src下新建entry-skeleton.js"></a>src下新建entry-skeleton.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import Skeleton1 from &#39;.&#x2F;Skeleton1&#39;;</span><br><span class="line">import Skeleton2 from &#39;.&#x2F;Skeleton2&#39;;</span><br><span class="line"></span><br><span class="line">export default new Vue(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        Skeleton1,</span><br><span class="line">        Skeleton2</span><br><span class="line">    &#125;,</span><br><span class="line">    template: &#96;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;skeleton1 id&#x3D;&quot;skeleton1&quot; style&#x3D;&quot;display:none&quot;&#x2F;&gt;</span><br><span class="line">            &lt;skeleton2 id&#x3D;&quot;skeleton2&quot; style&#x3D;&quot;display:none&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="src下新建Skeleton1-vue-Skeleton1-vue"><a href="#src下新建Skeleton1-vue-Skeleton1-vue" class="headerlink" title="src下新建Skeleton1.vue/Skeleton1.vue"></a>src下新建Skeleton1.vue/Skeleton1.vue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Skeleton1.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;</span><br><span class="line">    Skeleton For Home</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;Skeleton For Home&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;Skeleton For Home&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;Skeleton For Home&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;Skeleton For Home&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;skeleton2&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.skeleton-header &#123;</span><br><span class="line">  height: 152px;</span><br><span class="line">  background: grey;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">  width: 152px;</span><br><span class="line">  margin: 60px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.skeleton-block &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  padding-top: 8px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">Skeleton2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;skeleton-wrapper&quot;&gt;</span><br><span class="line">        &lt;header class&#x3D;&quot;skeleton-header&quot;&gt;&lt;&#x2F;header&gt;</span><br><span class="line">        &lt;section class&#x3D;&quot;skeleton-block&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;data:image&#x2F;svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTA4MCAyNjEiPjxkZWZzPjxwYXRoIGlkPSJiIiBkPSJNMCAwaDEwODB2MjYwSDB6Ii8+PGZpbHRlciBpZD0iYSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgeD0iLTUwJSIgeT0iLTUwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij48ZmVPZmZzZXQgZHk9Ii0xIiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIi8+PGZlQ29sb3JNYXRyaXggaW49InNoYWRvd09mZnNldE91dGVyMSIgdmFsdWVzPSIwIDAgMCAwIDAuOTMzMzMzMzMzIDAgMCAwIDAgMC45MzMzMzMzMzMgMCAwIDAgMCAwLjkzMzMzMzMzMyAwIDAgMCAxIDAiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDEpIj48dXNlIGZpbGw9IiMwMDAiIGZpbHRlcj0idXJsKCNhKSIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNiIi8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCA0NGg1MzN2NDZIMjMweiIvPjxyZWN0IHdpZHRoPSIxNzIiIGhlaWdodD0iMTcyIiB4PSIzMCIgeT0iNDQiIGZpbGw9IiNGNkY2RjYiIHJ4PSI0Ii8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCAxMThoMzY5djMwSDIzMHpNMjMwIDE4MmgzMjN2MzBIMjMwek04MTIgMTE1aDIzOHYzOUg4MTJ6TTgwOCAxODRoMjQydjMwSDgwOHpNOTE3IDQ4aDEzM3YzN0g5MTd6Ii8+PC9nPjwvc3ZnPg&#x3D;&#x3D;&quot;&gt;</span><br><span class="line">            &lt;img src&#x3D;&quot;data:image&#x2F;svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTA4MCAyNjEiPjxkZWZzPjxwYXRoIGlkPSJiIiBkPSJNMCAwaDEwODB2MjYwSDB6Ii8+PGZpbHRlciBpZD0iYSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgeD0iLTUwJSIgeT0iLTUwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij48ZmVPZmZzZXQgZHk9Ii0xIiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIi8+PGZlQ29sb3JNYXRyaXggaW49InNoYWRvd09mZnNldE91dGVyMSIgdmFsdWVzPSIwIDAgMCAwIDAuOTMzMzMzMzMzIDAgMCAwIDAgMC45MzMzMzMzMzMgMCAwIDAgMCAwLjkzMzMzMzMzMyAwIDAgMCAxIDAiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDEpIj48dXNlIGZpbGw9IiMwMDAiIGZpbHRlcj0idXJsKCNhKSIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNiIi8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCA0NGg1MzN2NDZIMjMweiIvPjxyZWN0IHdpZHRoPSIxNzIiIGhlaWdodD0iMTcyIiB4PSIzMCIgeT0iNDQiIGZpbGw9IiNGNkY2RjYiIHJ4PSI0Ii8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCAxMThoMzY5djMwSDIzMHpNMjMwIDE4MmgzMjN2MzBIMjMwek04MTIgMTE1aDIzOHYzOUg4MTJ6TTgwOCAxODRoMjQydjMwSDgwOHpNOTE3IDQ4aDEzM3YzN0g5MTd6Ii8+PC9nPjwvc3ZnPg&#x3D;&#x3D;&quot;&gt;</span><br><span class="line">        &lt;&#x2F;section&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;skeleton&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">.skeleton-header &#123;</span><br><span class="line">    height: 152px;</span><br><span class="line">    background: grey;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    width: 152px;</span><br><span class="line">    margin: 60px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.skeleton-block &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    padding-top: 8px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>



<p>attentions：项目需要重新启动，npm run build 打包</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-skeleton-webpack-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-slot</title>
    <url>/2020/08/04/vue-slot/</url>
    <content><![CDATA[<h2 id="什么是插槽？"><a href="#什么是插槽？" class="headerlink" title="什么是插槽？"></a>什么是插槽？</h2><ul>
<li>插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。</li>
<li>!!!插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</li>
</ul>
<a id="more"></a>

<h2 id="怎么用插槽？"><a href="#怎么用插槽？" class="headerlink" title="怎么用插槽？"></a>怎么用插槽？</h2><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slotOne1&gt;</span><br><span class="line">      &lt;p style&#x3D;&quot;color:red&quot;&gt;我是父组件插槽内容&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;slotOne1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在父组件引用的子组件中写入想要显示的内容（可以使用标签，也可以不用）</p>
</blockquote>
<p>子组件(slotOne1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;slotOne1&quot;&gt;</span><br><span class="line">    &lt;div&gt;我是slotOne1组件&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在子组件中写入slot，slot所在的位置就是父组件要显示的内容</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144105784-1098819459.png" alt="img"></p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;slottwo&quot;&gt;</span><br><span class="line">    &lt;div&gt;slottwo&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在子组件中定义了三个slot标签，其中有两个分别添加了name属性header和footer</p>
</blockquote>
<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slot-two&gt;</span><br><span class="line">      &lt;p&gt;啦啦啦，啦啦啦，我是卖报的小行家&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;template slot&#x3D;&quot;header&quot;&gt;</span><br><span class="line">          &lt;p&gt;我是name为header的slot&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;p slot&#x3D;&quot;footer&quot;&gt;我是name为footer的slot&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;slot-two&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在父组件中使用template并写入对应的slot值来指定该内容在子组件中现实的位置（当然也不用必须写到template），没有对应值的其他内容会被放到子组件中没有添加name属性的slot中</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144415380-998676771.png" alt="img"></p>
<h3 id="插槽的默认内容"><a href="#插槽的默认内容" class="headerlink" title="插槽的默认内容"></a>插槽的默认内容</h3><p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slot-two&gt;&lt;&#x2F;slot-two&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;slottwo&quot;&gt;</span><br><span class="line">    &lt;slot&gt;我不是卖报的小行家&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在子组件的slot标签中写入内容，当父组件没有写入内容时会显示子组件的默认内容，当父组件写入内容时，会替换子组件的默认内容</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144645560-431732801.png" alt="img"></p>
<h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slot-two&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;slot-two&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name： &#39;Jack&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;slottwo&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112145001679-568383132.png" alt="img"></p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是作用域插槽的子组件</span><br><span class="line">    &lt;slot :data&#x3D;&quot;user&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;slotthree&#39;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: [</span><br><span class="line">        &#123;name: &#39;Jack&#39;, sex: &#39;boy&#39;&#125;,</span><br><span class="line">        &#123;name: &#39;Jone&#39;, sex: &#39;girl&#39;&#125;,</span><br><span class="line">        &#123;name: &#39;Tom&#39;, sex: &#39;boy&#39;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在子组件的slot标签上绑定需要的值</p>
</blockquote>
<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是作用域插槽</span><br><span class="line">    &lt;slot-three&gt;</span><br><span class="line">      &lt;template slot-scope&#x3D;&quot;user&quot;&gt;</span><br><span class="line">        &lt;div v-for&#x3D;&quot;(item, index) in user.data&quot; :key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;slot-three&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在父组件上使用slot-scope属性，user.data就是子组件传过来的值</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_template标签相关</title>
    <url>/2020/07/30/vue-template%E6%A0%87%E7%AD%BE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v-on:keyup.enter--@dblclick(双击)</span><br><span class="line">v-on:dblclick--@dblclick(双击)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><p><a href="https://cn.vuejs.org/v2/guide/forms.html#lazy" target="_blank" rel="noopener">.lazy</a></p>
<p>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了<a href="https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip" target="_blank" rel="noopener">上述</a>输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change事件进行同步：</p>
<!-- 在“change”时而非“input”时更新 --><input v-model.lazy="msg">

<p><a href="https://cn.vuejs.org/v2/guide/forms.html#number" target="_blank" rel="noopener">.number</a></p>
<p>如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p>
<input v-model.number="age" type="number">

<p>这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。</p>
<p><a href="https://cn.vuejs.org/v2/guide/forms.html#trim" target="_blank" rel="noopener">.trim</a></p>
<p>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p>
<input v-model.trim="msg">



<h3 id="is的作用"><a href="#is的作用" class="headerlink" title=":is的作用"></a>:is的作用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动态切换不同组件</span><br><span class="line">&lt;div v-bind:is&#x3D;&quot;currentView&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">return &#123;</span><br><span class="line">    currentView:&#39;component1&#39;</span><br><span class="line">     &#x2F;&#x2F;当前组件</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">解析DOM模板 : 解除限制元素</span><br><span class="line">&lt;table&gt;</span><br><span class="line">      &lt;my-component&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">&lt;!-- 这个自定义组件&lt;my-component&gt;会被作为无效的内容提升到外部，并导致最终渲染结果出错。 --&gt;</span><br><span class="line">&lt;table&gt; &lt;tr is&#x3D;&quot;my-component&quot;&gt;&lt;&#x2F;tr&gt; &lt;&#x2F;table&gt;</span><br><span class="line">&lt;!--增加is特性来扩展，从而达到可以在这些受限制的html元素中使用 --&gt;</span><br></pre></td></tr></table></figure>



<h3 id="vue中’-native’修饰符的使用"><a href="#vue中’-native’修饰符的使用" class="headerlink" title="vue中’. native’修饰符的使用"></a>vue中’. native’修饰符的使用</h3><p>该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，并且该修饰符对普通HTML标签是没有任何作用的。(子组件直接调用父组件中的方法)</p>
<p><img src="https://img-blog.csdnimg.cn/20200305115116484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F3cTE1MDM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="class类名"><a href="#class类名" class="headerlink" title="class类名"></a>class类名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class类名</span><br><span class="line">&lt;!-- 第一种方式:对象的形式 --&gt;</span><br><span class="line">&lt;!-- 第一个参数 类名， 第二个参数：boolean值 --&gt;</span><br><span class="line">&lt;!-- 对象的形式: 用花括号包裹起来，类名用引号， --&gt;</span><br><span class="line">&lt;!-- 优点: 以对象的形式可以写多个，用逗号分开 --&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;&#123;&#39;p1&#39; : true&#125;&quot;&gt;对象的形式(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;&#123;&#39;p1&#39; : false, &#39;p&#39;: true&#125;&quot;&gt;对象的形式(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种方式:三元表达式 注意点：放在数组中，类名要用引号--&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;[ 1 &lt; 2 ? &#39;p1&#39; : &#39;p&#39; ]&quot; &gt;三元表示式(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第三种方式: 数组的形式 --&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;[isTrue, isFalse]&quot;&gt;数组的形式(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组中用对象 --&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;[&#123;&#39;p1&#39;: false&#125;, isFalse]&quot;&gt;数组中使用对象(文字的颜色)&lt;&#x2F;p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!--补充:  class中还可以传方法，在方法中返回类名--&gt;</span><br><span class="line">&lt;p :class&#x3D;&quot;setClass&quot;&gt;通过方法设置class类名&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>



<h3 id="引入less注意点"><a href="#引入less注意点" class="headerlink" title="引入less注意点"></a>引入less注意点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单文件组件引用css文件的方式</span><br><span class="line">1.script中引入</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import &#39;bulma&#x2F;css&#x2F;bulma.css&#39;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">2.style中引入</span><br><span class="line">&lt;style lang&#x3D;&quot;stylus&quot;&gt;</span><br><span class="line">	@import &#39;~bulma&#x2F;css&#x2F;bulma.css&#39;;这个分号一定要写，要不会报错</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"> </span><br><span class="line">3.全局引入</span><br><span class="line">将外部的css文件放到style文件下，引入外部文件只需在main.js文件中</span><br><span class="line">import &#39;.&#x2F;style&#x2F;reset.css&#39;</span><br></pre></td></tr></table></figure>



<h3 id="v-once-保持插值表达式值不变，无法在console里改变app的值非响应式"><a href="#v-once-保持插值表达式值不变，无法在console里改变app的值非响应式" class="headerlink" title="v-once(保持插值表达式值不变，无法在console里改变app的值非响应式 )"></a>v-once(保持插值表达式值不变，无法在console里改变app的值非响应式 )</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v-once&#x3D;&quot;&#123;&#123;messenger&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="v-pre（不要解析变量-v-pre-原样输出）"><a href="#v-pre（不要解析变量-v-pre-原样输出）" class="headerlink" title="v-pre（不要解析变量 v-pre 原样输出）"></a>v-pre（不要解析变量 v-pre 原样输出）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v-pre&#x3D;&quot;&#123;&#123;messenger&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt; </span><br><span class="line"></span><br><span class="line">   &lt;loading&gt;&lt;&#x2F;loading&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;keep-laive&gt;</span><br></pre></td></tr></table></figure>

<p>当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行</p>
<p>被包裹在keep-alive中的组件的状态将会被保留，例如我们将某个列表类组件内容滑动到第100条位置，那么我们在切换到一个组件后再次切换回到该组件，该组件的位置状态依旧会保持在第100条列表处</p>
<ul>
<li><p>回到顶部</p>
<p>在keep-alive激活会触发activated钩子函数，那么在该函数内设置scrollTop为0</p>
</li>
<li><p>强制刷新某些组件</p>
<ul>
<li>利用include、exclude属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include&#x3D;&quot;bookLists,bookLists&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive exclude&#x3D;&quot;indexLists&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>include属性表示只有name属性为bookLists，bookLists的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存exclude属性表示除了name属性为indexLists的组件不会被缓存，其它组件都会被缓存</p>
<ul>
<li><ul>
<li>利用meta属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export</span><br><span class="line">default[&#123;</span><br><span class="line">        path:</span><br><span class="line">        &#39;&#x2F;&#39;,</span><br><span class="line">        name: &#39;home&#39;,</span><br><span class="line">        components: Home,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            keepAlive: true &#x2F;&#x2F;需要被缓存的组件 </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        path: &#39;&#x2F;book&#39;,</span><br><span class="line">        name: &#39;book&#39;,</span><br><span class="line">        components: Book,</span><br><span class="line">        meta: &#123;</span><br><span class="line">        keepAlive: false &#x2F;&#x2F;不需要被缓存的组件 </span><br><span class="line">        &#125;</span><br><span class="line">       ]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt; </span><br><span class="line"> 	&lt;router-view v-if&#x3D;&quot;this.$route.meat.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"> 	&lt;!--这里是会被缓存的组件--&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line"> 	 &lt;router-view v-if&#x3D;&quot;!this.$route.meat.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  	&lt;!--这里是不会被缓存的组件--&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>



<h3 id="data-v-23d425f8-属性"><a href="#data-v-23d425f8-属性" class="headerlink" title="[data-v-23d425f8]属性"></a>[data-v-23d425f8]属性</h3><p> 这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的’data-v-xxx’标记</p>
<p>使用深度选择器/deep/可以改变第三方的样式，并且会又data-v属性，不会污染全局，只在当前作用域生效，相当于scoped</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.van-tabs &#x2F;deep&#x2F; .van-ellipsis &#123; color: blue&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>编译后的结果就是：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/nyQjSftfElZ8QI3e1icLryxdaRFq0iaHdytHUuoDluRyGKZsr2MicRaRLHKqD7sYaYhYSHKpI0rgF6ERUbGyzN2kA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>这样就不会给van-ellipsis也添加[data-v-23d425f8]属性了。至此你可以愉快的修改第三方组件的样式了。</p>
<p>当然了这里的深度选择器<code>/deep/</code>是因为我用的<code>less</code>语言，如果你没有使用<code>less/sass</code>等，可以用<code>&gt;&gt;&gt;</code>符号。</p>
<style scoped>
    .parent >>> .child { /* ... */ }
</style>



<h3 id="清除定时器的-once方法"><a href="#清除定时器的-once方法" class="headerlink" title="清除定时器的$once方法"></a>清除定时器的$once方法</h3><p>该方法是通过$once这个事件侦听器器在定义完定时器之后的位置来清除定时器。以下是完整代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const timer &#x3D; setInterval(() &#x3D;&gt;&#123;                    </span><br><span class="line">    &#x2F;&#x2F; 某些定时器操作                </span><br><span class="line">&#125;, 500);            </span><br><span class="line">&#x2F;&#x2F; 通过$once来监听定时器，在beforeDestroy钩子可以被清除。</span><br><span class="line">this.$once(&#39;hook:beforeDestroy&#39;, () &#x3D;&gt; &#123;            </span><br><span class="line">    clearInterval(timer);                                    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="rem文件的导入问题："><a href="#rem文件的导入问题：" class="headerlink" title="rem文件的导入问题："></a>rem文件的导入问题：</h3><p>我们在做手机端时，适配是必须要处理的一个问题。例如，我们处理适配的方案就是通过写一个rem.js，原理很简单，就是根据网页尺寸计算html的font-size大小，基本上小伙伴们都知道，这里直接附上代码，不多做介绍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(c, d) &#123;</span><br><span class="line">    var e &#x3D; document.documentElement || document.body,</span><br><span class="line">    a &#x3D; &quot;orientationchange&quot; in window ? &quot;orientationchange&quot;: &quot;resize&quot;,</span><br><span class="line">    b &#x3D; function() &#123;</span><br><span class="line">        var f &#x3D; e.clientWidth;</span><br><span class="line">        e.style.fontSize &#x3D; (f &gt;&#x3D; 750) ? &quot;100px&quot;: 100 * (f &#x2F; 750) + &quot;px&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    b();</span><br><span class="line">    c.addEventListener(a, b, false)</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<p>这里说下怎么引入的问题，很简单。在main.js中，直接<code>import &#39;./config/rem&#39;</code>导入即可。import的路径根据你的文件路径去填写。</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p><strong>方式一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;empty v-model&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;empty&gt;复制代码</span><br></pre></td></tr></table></figure>

<p>子组件写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击该按钮触发父子组件的数据同步</span><br><span class="line">&lt;div class&#x3D;&quot;share-btn&quot; @click&#x3D;&quot;confirm&quot;&gt;确定&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收父组件传递的value值</span><br><span class="line">&#x2F;&#x2F; 注意，这种实现方法，这里只能使用value属性名</span><br><span class="line">props: &#123;            </span><br><span class="line">    value: &#123;                </span><br><span class="line">        type: Boolean,                </span><br><span class="line">        default: false            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;            </span><br><span class="line">    confirm () &#123;                </span><br><span class="line">        &#x2F;&#x2F; 双向数据绑定父组件:value对应的值 </span><br><span class="line">        &#x2F;&#x2F; 通过$emit触发父组件input事件，第二个参数为传递给父组件的值，这里传递了一个false值 </span><br><span class="line">        &#x2F;&#x2F; 可以理解为最上面展示的@input&#x3D;&quot;msg &#x3D; $event.target.value&quot;这个事件</span><br><span class="line">        &#x2F;&#x2F; 即触发父组件的input事件，并将传递的值‘false’赋值给msg             </span><br><span class="line">        this.$emit(&#39;input&#39;, false)            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;empty v-model&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;empty&gt;复制代码</span><br></pre></td></tr></table></figure>

<p>子组件写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;share-btn&quot; @click&#x3D;&quot;confirm&quot;&gt;确定&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; model选项用来避免冲突</span><br><span class="line">&#x2F;&#x2F; prop属性用来指定props属性中的哪个值用来接收父组件v-model传递的值</span><br><span class="line">&#x2F;&#x2F; 例如这里用props中的show来接收父组件传递的v-model值</span><br><span class="line">&#x2F;&#x2F; event：为了方便理解，可以简单理解为父组件@input的别名，从而避免冲突</span><br><span class="line">&#x2F;&#x2F; event的值对应了你emit时要提交的事件名，你可以叫aa，也可以叫bb，但是要命名要有意义哦！！！</span><br><span class="line">model: &#123;            </span><br><span class="line">    prop: &#39;show&#39;,            </span><br><span class="line">    event: &#39;changed&#39;        </span><br><span class="line">&#125;,</span><br><span class="line">props: &#123;</span><br><span class="line">    &#x2F;&#x2F; 由于model选项中的prop属性指定了，所以show接收的是父组件v-model传递的值            </span><br><span class="line">    show: &#123;                </span><br><span class="line">        type: Boolean,                </span><br><span class="line">        default: false            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;,        </span><br><span class="line">methods: &#123;            </span><br><span class="line">    confirm () &#123;                </span><br><span class="line">        &#x2F;&#x2F; 双向数据绑定父组件传递的值</span><br><span class="line">        &#x2F;&#x2F; 第一个参数，对应model选项的event的值，你可以叫aa，bbb，ccc，起名随你 </span><br><span class="line">        this.$emit(&#39;changed&#39;, false)            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式三：.sync</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;empty :oneprop.sync&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;empty&gt;</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        msg: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;share-btn&quot; @click&#x3D;&quot;changeMsg&quot;&gt;改变msg值&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">props: &#123;            </span><br><span class="line">    oneprop: &#123;                </span><br><span class="line">        type: String,                </span><br><span class="line">        default: &#39;hello world&#39;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;,        </span><br><span class="line">methods: &#123;            </span><br><span class="line">    changeMsg () &#123;                </span><br><span class="line">        &#x2F;&#x2F; 双向数据流</span><br><span class="line">        this.$emit(&#39;update:msg&#39;, &#39;helow world&#39;)           </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="事件们"><a href="#事件们" class="headerlink" title="事件们"></a>事件们</h3><ul>
<li><code>vm.$emit(event ,[...args])</code>这个api，其主要作用就是用来触发当前实例上的事件。附加参数都会传给监听器回调。子组件也属于当前实例。第一个参数：要触发的事件名称。后续的参数可选：即作为参数传递给要触发的事件。文档</li>
<li>监听当前实例上的自定义事件，事件可以有$emit触发，也能<strong>通过hook监听到钩子函数，</strong></li>
</ul>
<p>vm.$on( event, callback )：一直监听；文档</p>
<p>vm.$once( event, callback )：监听一次；文档</p>
<p>vm.$off( [event, callback] )：移除监听；文档</p>
<p>监听$emit触发的自定义事件，上面已经有过用法了，监听钩子函数，在上面的定时器那块也有演示到。监听钩子函数的场景使用的不多，但是还是要知道的。</p>
<ul>
<li>vm.$attrs：可以获取到父组件传递的除class和style外的所有自定义属性。</li>
<li>vm.$listeners：可以获取到父组件传递的所有自定义事件</li>
</ul>
<p>例如：父组件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;empty</span><br><span class="line">    :msg&#x3D;&quot;message&quot;</span><br><span class="line">    :title&#x3D;&quot;articleTitle&quot;</span><br><span class="line">    @confirm&#x3D;&quot;func1&quot;</span><br><span class="line">    @cancel&#x3D;&quot;func2&quot;</span><br><span class="line">&gt;&lt;&#x2F;empty&gt;复制代码</span><br></pre></td></tr></table></figure>

<p>就可以在子组件中获取父组件传递的属性和事件，而不用在props中定义。子组件简单演示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created() &#123;            </span><br><span class="line">    const msg &#x3D; this.$attrs.msg; &#x2F;&#x2F; 获取父组件传递的msg</span><br><span class="line">    this.$listeners.confirm &amp;&amp; this.$listeners.confirm(); &#x2F;&#x2F;若组件传递事件confirm则执行</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-vuex</title>
    <url>/2020/08/05/vue-vuex/</url>
    <content><![CDATA[<h1 id="最全Vue状态管理模式"><a href="#最全Vue状态管理模式" class="headerlink" title="最全Vue状态管理模式"></a>最全Vue状态管理模式</h1><h2 id="一、初识VueX"><a href="#一、初识VueX" class="headerlink" title="一、初识VueX"></a>一、初识VueX</h2><h3 id="1-1-关于VueX"><a href="#1-1-关于VueX" class="headerlink" title="1.1 关于VueX"></a>1.1 关于<code>VueX</code></h3><p><code>VueX</code>是适用于在<code>Vue</code>项目开发时使用的状态管理工具。</p>
<p>试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步<code>data</code>中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。</p>
<p>为此，<code>Vue</code>为这些被多个组件频繁使用的值提供了一个统一管理的工具——<code>VueX</code>。</p>
<p>在具有<code>VueX</code>的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</p>
<h3 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h3><p>由于<code>VueX</code>是在学习<code>VueCli</code>后进行的，所以在下文出现的项目的目录请参照<code>VueCli 2.x</code>构建的目录。</p>
<p>以下步骤的前提是你已经完成了Vue项目构建，并且已转至该项目的文件目录下。</p>
<ul>
<li><p>Npm安装Vuex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vuex -s</span><br></pre></td></tr></table></figure>
</li>
<li><p>在项目的根目录下新增一个<code>store</code>文件夹，在该文件夹内创建index.js</p>
<p>此时你的项目的<code>src</code>文件夹应当是这样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">│  App.vue</span><br><span class="line">│  main.js</span><br><span class="line">│</span><br><span class="line">├─assets</span><br><span class="line">│      logo.png</span><br><span class="line">│</span><br><span class="line">├─components</span><br><span class="line">│      HelloWorld.vue</span><br><span class="line">│</span><br><span class="line">├─router</span><br><span class="line">│      index.js</span><br><span class="line">│</span><br><span class="line">└─store</span><br><span class="line">       index.js</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h3><h4 id="1-3-1-初始化store下index-js中的内容"><a href="#1-3-1-初始化store下index-js中的内容" class="headerlink" title="1.3.1 初始化store下index.js中的内容"></a>1.3.1 初始化<code>store</code>下<code>index.js</code>中的内容</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建VueX对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        <span class="comment">//存放的键值对就是所要管理的状态</span></span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>



<h4 id="1-3-2-将store挂载到当前项目的Vue实例当中去（官方提供了一种机制将状态从根组件-“注入”-到每一个子组件中）"><a href="#1-3-2-将store挂载到当前项目的Vue实例当中去（官方提供了一种机制将状态从根组件-“注入”-到每一个子组件中）" class="headerlink" title="1.3.2 将store挂载到当前项目的Vue实例当中去（官方提供了一种机制将状态从根组件 “注入” 到每一个子组件中）"></a>1.3.2 将store挂载到当前项目的Vue实例当中去（官方提供了一种机制将状态从根组件 “注入” 到每一个子组件中）</h4><p>打开main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,  <span class="comment">//store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="1-3-3-在组件中使用Vuex"><a href="#1-3-3-在组件中使用Vuex" class="headerlink" title="1.3.3 在组件中使用Vuex"></a>1.3.3 在组件中使用Vuex</h4><ul>
<li>原生写法</li>
</ul>
<p>那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在<a href="https://cn.vuejs.org/guide/computed.html" target="_blank" rel="noopener">计算属性</a>中返回某个状态，每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性，并刷新界面。如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.js</span><br><span class="line"><span class="keyword">import</span> Vue from <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export store</span><br><span class="line"></span><br><span class="line">.vue</span><br><span class="line"><span class="keyword">import</span> &#123;store&#125; from ./js</span><br><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123; <span class="keyword">return</span> &#123;&#125; &#125;,</span><br><span class="line">  template: `&lt;div&gt; count &lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果你把 <code>store.state.count</code> 放在 data 中， <code>store.state.count</code> 的变化是不会主动触发界面刷新的，当然，也不能直接这样：<code>&lt;div&gt; store.state.count &lt;/div&gt;</code> ，因为在模板中是无法直接访问到 store 对象的，所以这样写无疑会报错。</strong></p>
<ul>
<li>挂载全局写法</li>
</ul>
<p>例如在App.vue中，我们要将state中定义的name拿来在h1标签中显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        name:</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; $store.state.name &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者要在组件方法中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line">methods:&#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$store.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>注意，请不要在此处更改<code>state</code>中的状态的值，后文中将会说明</strong></p>
<h3 id="1-4-安装Vue开发工具VueDevtools"><a href="#1-4-安装Vue开发工具VueDevtools" class="headerlink" title="1.4 安装Vue开发工具VueDevtools"></a>1.4 安装Vue开发工具VueDevtools</h3><p>在Vue项目开发中，需要监控项目中得各种值，为了提高效率，Vue提供了一款浏览器扩展——VueDevtools。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/16550832-e1b684e312a9bd1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>在学习VueX时，更为需要使用该插件。关于该插件的使用可以移步官网，在此不再赘叙。</p>
<h2 id="二、VueX中的核心内容"><a href="#二、VueX中的核心内容" class="headerlink" title="二、VueX中的核心内容"></a>二、VueX中的核心内容</h2><p>在VueX对象中，其实不止有<code>state</code>,还有用来操作<code>state</code>中数据的方法集，以及当我们需要对<code>state</code>中的数据需要加工的方法集等等成员。</p>
<p>成员列表：</p>
<ul>
<li>state     存放状态</li>
<li>mutations   state成员操作</li>
<li>getters     加工state成员给外界</li>
<li>actions     异步操作</li>
<li>modules   模块化状态管理</li>
</ul>
<h3 id="2-1-VueX的工作流程"><a href="#2-1-VueX的工作流程" class="headerlink" title="2.1 VueX的工作流程"></a>2.1 VueX的工作流程</h3><p><img src="https:////upload-images.jianshu.io/upload_images/16550832-20d0ad3c60a99111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/701/format/webp" alt="img"></p>
<p>Vuex官网给出的流程图</p>
<p>首先，<code>Vue</code>组件如果调用某个<code>VueX</code>的方法过程中需要向后端请求时或者说出现异步操作时，需要<code>dispatch</code> VueX中<code>actions</code>的方法，以保证数据的同步。可以说，<code>action</code>的存在就是为了让<code>mutations</code>中的方法能在异步操作中起作用。</p>
<p>如果没有异步操作，那么我们就可以直接在组件内提交状态中的<code>Mutations</code>中自己编写的方法来达成对<code>state</code>成员的操作。注意，<code>1.3.3节</code>中有提到，不建议在组件中直接对<code>state</code>中的成员进行操作，这是因为直接修改(例如：<code>this.$store.state.name = &#39;hello&#39;</code>)的话不能被<code>VueDevtools</code>所监控到。</p>
<p>最后被修改后的state成员会被渲染到组件的原位置当中去。</p>
<h3 id="2-2-Mutations"><a href="#2-2-Mutations" class="headerlink" title="2.2 Mutations"></a>2.2 Mutations</h3><p><code>mutations</code>是操作<code>state</code>数据的方法的集合，比如对该数据的修改、增加、删除等等。</p>
<h4 id="2-2-1-Mutations使用方法"><a href="#2-2-1-Mutations使用方法" class="headerlink" title="2.2.1 Mutations使用方法"></a>2.2.1 Mutations使用方法</h4><p><code>mutations</code>方法都有默认的形参：</p>
<p>(<strong>[state]</strong> <strong>[,payload]</strong>)</p>
<ul>
<li><code>state</code>是当前<code>VueX</code>对象中的<code>state</code></li>
<li><code>payload</code>是该方法在被调用时传递参数使用的</li>
</ul>
<p>例如，我们编写一个方法，当被执行时，能把下例中的name值修改为<code>&quot;jack&quot;</code>,我们只需要这样做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.js</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        <span class="comment">//es6语法，等同edit:funcion()&#123;...&#125;</span></span><br><span class="line">        edit(state)&#123;</span><br><span class="line">            state.name = <span class="string">'jack'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>而在组件中，我们需要这样去调用这个<code>mutation</code>——例如在App.vue的某个<code>method</code>中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-Mutation传值"><a href="#2-2-2-Mutation传值" class="headerlink" title="2.2.2 Mutation传值"></a>2.2.2 Mutation传值</h4><p>在实际生产过程中，会遇到需要在提交某个<code>mutation</code>时需要携带一些参数给方法使用。</p>
<p>单个值提交时:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>当需要多参提交时，推荐把他们放在一个对象中来提交:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>,&#123;<span class="attr">age</span>:<span class="number">15</span>,<span class="attr">sex</span>:<span class="string">'男'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>接收挂载的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">edit(state,payload)&#123;</span><br><span class="line">    state.name = <span class="string">'jack'</span></span><br><span class="line">    <span class="built_in">console</span>.log(payload) <span class="comment">// 15或&#123;age:15,sex:'男'&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另一种提交方式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">    type:<span class="string">'edit'</span>,</span><br><span class="line">    payload:&#123;</span><br><span class="line">        age:<span class="number">15</span>,</span><br><span class="line">        sex:<span class="string">'男'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-3-增删state中的成员"><a href="#2-2-3-增删state中的成员" class="headerlink" title="2.2.3 增删state中的成员"></a>2.2.3 增删state中的成员</h4><p>为了配合Vue的响应式数据，我们在Mutations的方法中，应当使用Vue提供的方法来进行操作。如果使用<code>delete</code>或者<code>xx.xx = xx</code>的形式去删或增，则Vue不能对数据进行实时响应。</p>
<ul>
<li><p>Vue.set 为某个对象设置成员的值，若不存在则新增</p>
<p>例如对state对象中添加一个age成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.set(state,<span class="string">"age"</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.delete 删除成员</p>
<p>将刚刚添加的age成员删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.delete(state,<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2-2-4使用常量"><a href="#2-2-4使用常量" class="headerlink" title="2.2.4使用常量"></a>2.2.4使用常量</h4><p>就是使用常量来替代 mutation 事件的名字。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可能有人会有疑问啊，这样做到底有啥用，还得多创建个类型文件，用的时候还要导入进来，不嫌麻烦吗！</p>
<p>我们看看，mutation 是怎么调用的：<code>store.commit(&#39;increment&#39;)</code>，可以发现，这里 commit 提交的方法 <code>increment</code>，是以字符串的形式代入的。而定义成常量具有唯一性，不允许重复定义或覆盖。</p>
<h3 id="2-3-Getters"><a href="#2-3-Getters" class="headerlink" title="2.3 Getters"></a>2.3 Getters</h3><p>可以对state中的成员加工后传递给外界</p>
<p>Getters中的方法有两个默认参数</p>
<ul>
<li>state 当前VueX对象中的状态对象</li>
<li>getters 当前getters对象，用于将getters下的其他getter拿来用</li>
</ul>
<h4 id="粗说"><a href="#粗说" class="headerlink" title="粗说"></a>粗说</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">    nameInfo(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名:"</span>+state.name</span><br><span class="line">    &#125;,</span><br><span class="line">    fullInfo(state,getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> getters.nameInfo+<span class="string">'年龄:'</span>+state.age</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件中调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.getters.fullInfo</span><br></pre></td></tr></table></figure>



<h4 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h4><p>有时候，我们会发现 State 中的数据，并不是我们直接想要的，而是需要经过相应的处理后，才能满足我们的需求。</p>
<p>比如在一个组件中，我们需要把 state 中的日期 <code>date</code> 转换成星期几来展示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  weekDate () &#123;</span><br><span class="line">    <span class="keyword">return</span> moment(<span class="keyword">this</span>.$store.state.date).format(<span class="string">'dddd'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里的 <a href="http://momentjs.cn/" target="_blank" rel="noopener">moment</a> 是一个第三方日期处理类库，使用之前需要导入。</p>
<p>如果只有一个组件需要这样做还好，但如果在很多组件中，都需要这么转换的话，那就得在每一个组件中都需要把这个函数复制过去。而且，一旦产品经理心情不好，不想用星期几来显示，想直接用 <code>2018-10-30 11:12:23</code> 这种方式来显示日期，那你就得在所有用到它的组件中去更改日期格式化的方法，岂不难受至极。就算你把它单独抽取出来作为一个公共的函数，各种导入也麻烦，最重要的是不好统一管理。</p>
<p>所以，这个时候，Vuex 又引入了一个牛逼的玩意儿，<strong>Getter</strong>。我们可以把它当成 store 中的计算属性（computed）。</p>
<blockquote>
<p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
</blockquote>
<p>我们看看这两个例子，着重注意下里面的注释：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">// Getter 接受 state 作为其第一个参数</span></span><br><span class="line">    weekDate: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> moment(state.date).format(<span class="string">'dddd'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// Getter 还也可以接收 getters 作为第二个参数</span></span><br><span class="line">  dateLength: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.weekDate.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不但如此，Getter 还会将 store.getters 对象暴露出去，你可以以属性的形式访问这些值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">store</span><span class="selector-class">.getters</span><span class="selector-class">.weekDate</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以很容易地在任何组件中使用它：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  weekDate () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.weekDate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在需求又变了，每个模块要显示的 weekDate 的格式不一样，有的显示全部日期，有的需要显示星期几，怎么办？</p>
<p><strong>好办，那就给 Getter 传参呗，但是怎么传呢？</strong></p>
<p>因为 Getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的，所以是不能直接 <code>store.getters.weekDate(&#39;MM Do YY&#39;)</code>，因为 weekDate 并不是一个函数，它仅仅只是一个属性而已。</p>
<p>那么既然属性不能传参，怎么办呢？那我们就想办法把这个属性变成一个函数不就行了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// 返回一个函数，就可以传参了</span></span><br><span class="line">  weekDate: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">fm</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> moment(state.date).format(fm ? fm : <span class="string">'dddd'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">store.getters.weekDate(<span class="string">'MM Do YY'</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-4-Actions"><a href="#2-4-Actions" class="headerlink" title="2.4 Actions"></a>2.4 Actions</h3><h4 id="粗说-1"><a href="#粗说-1" class="headerlink" title="粗说"></a>粗说</h4><p>由于直接在<code>mutation</code>方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交<code>mutation</code>方法。</p>
<p><code>Actions</code>中的方法有两个默认参数</p>
<ul>
<li><code>context</code> 上下文(相当于箭头函数中的this)对象</li>
<li><code>payload</code> 挂载参数</li>
</ul>
<p>例如，我们在两秒中后执行<code>2.2.2</code>节中的<code>edit</code>方法</p>
<p>由于<code>setTimeout</code>是异步操作，所以需要使用<code>actions</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    aEdit(context,payload)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">'edit'</span>,payload)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中调用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'aEdit'</span>,&#123;<span class="attr">age</span>:<span class="number">15</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>改进:</strong></p>
<p>由于是异步操作，所以我们可以为我们的异步操作封装为一个<code>Promise</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">aEdit(context,payload)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">'edit'</span>,payload)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="细说-1"><a href="#细说-1" class="headerlink" title="细说"></a>细说</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Action 类似于 mutation，不同在于：</span><br><span class="line"></span><br><span class="line">1、Action 提交的是 mutation，而不是直接变更状态。</span><br><span class="line">2、Action 可以包含任意异步操作。</span><br></pre></td></tr></table></figure>

<p>看一个简单的 action 示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到，Action 函数接受一个 <code>context</code> 参数，注意，这个参数可不一般，它与 store 实例有着相同的方法和属性，但是他们并不是同一个实例，后面学习 Modules 的时候会介绍它们为什么不一样。</p>
<p>所以在这里可以使用 <code>context.commit</code> 来提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p>
<p>当然，为了代码简化，我们可以使用 ES2015 的 <a href="https://github.com/lukehoban/es6features#destructuring" target="_blank" rel="noopener">参数解构</a> 来直接展开，便于 <code>commit</code>、<code>state</code> 等多次调用。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Mutation 通过 <code>store.commit</code> 触发，那么 Action 则通过 <code>store.dispatch</code> 方法触发。</p>
<p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 Mutation 分发的方式异曲同工，这是注意这里是 <code>dispatch</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意示例中正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p>
</blockquote>
<h5 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h5><blockquote>
<p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>
</blockquote>
<p>不知道什么是 Promise 的，可以 <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="noopener">戳此了解下</a>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然，也可以这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以利用 <a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="noopener">async / await</a> 的方式组合 action ：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="keyword">async</span> <span class="title">actionA</span> (<span class="params">&#123; commit &#125;</span>)</span> &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">async</span> <span class="title">actionB</span> (<span class="params">&#123; dispatch, commit &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
</blockquote>
<p>我们在实际项目中经常的会遇到这种情况，比如说你现在想要处理 B 事件，但是 B 事件需要一种资源才能进行，而这种资源必须通过 A 事件来获得。这个时候，我们就需要组合 Action 来处理这些事件了。</p>
<h3 id="2-5mapState、mapGetters、mapActions、mapMutations的使用"><a href="#2-5mapState、mapGetters、mapActions、mapMutations的使用" class="headerlink" title="2.5mapState、mapGetters、mapActions、mapMutations的使用"></a>2.5mapState、mapGetters、mapActions、mapMutations的使用</h3><h4 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h4><p>通过前面的学习，我们知道，从 store 实例中读取状态最简单的方法就是在<a href="https://cn.vuejs.org/guide/computed.html" target="_blank" rel="noopener">计算属性</a>中返回某个状态。</p>
<p>那么，当一个组件需要获取多个状态的时候，怎么办？是不是这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">      a () &#123;</span><br><span class="line">        <span class="keyword">return</span> store.state.a</span><br><span class="line">      &#125;,</span><br><span class="line">      b () &#123;</span><br><span class="line">        <span class="keyword">return</span> store.state.b</span><br><span class="line">      &#125;,</span><br><span class="line">      c () &#123;</span><br><span class="line">        <span class="keyword">return</span> store.state.c</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这样是没问题的，但是总感觉写起来很难受，看起来更难受是吧！既然这么容易我们就感受到了，Vuex 能感受不到吗，能忍得了吗？</p>
<p>绝对不能忍，所以 <code>mapState</code> 辅助函数被创造了出来，用来搞定这个人人为之咬牙切齿的痛点。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.b,</span><br><span class="line">    c: <span class="function"><span class="params">state</span> =&gt;</span> state.c,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'b'</span></span><br><span class="line">    <span class="comment">// 等同于 `state =&gt; state.b`</span></span><br><span class="line">    bAlias: <span class="string">'b'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态</span></span><br><span class="line">    <span class="comment">// 必须使用常规函数</span></span><br><span class="line">    cInfo (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.c + <span class="keyword">this</span>.info</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的示例，可以了解到，我们可以直接把需要用到的状态全部存放在 <code>mapState</code> 里面进行统一管理，而且还可以取别名，做额外的操作等等。</p>
<p>如果所映射的计算属性名称与 state 的子节点名称相同时，我们还可以更加简化，给 <code>mapState</code> 传一个字符串数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.a 为 store.state.a</span></span><br><span class="line">  <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'b'</span>,</span><br><span class="line">  <span class="string">'c'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>因为 <code>computed</code> 这个计算属性接收的是一个对象，所以由上面的示例代码可以看出，<code>mapState</code> 函数返回的是一个对象，现在如果想要和局部的计算属性混合使用的话，可以使用 ES6 的语法这样写来大大简化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; </span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了 <code>mapState</code> 辅助函数后，接下来的几个辅助函数的用法也基本上都差不多了，我们继续往下看。</p>
<h4 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h4><p>这个和 <code>mapState</code> 基本上没啥区别，简单看下官方的例子，就懂了：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取个别名，那就用对象的形式，以下示例的意思就是把 <code>this.doneCount</code> 映射为 <code>this.$store.getters.doneTodosCount</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mapGetters</span>(&#123;</span><br><span class="line">  <span class="attribute">doneCount</span>: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h4><p>直接看示例代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="comment">// 将 `this.increment()` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store.commit('increment')`</span></span><br><span class="line">      <span class="string">'increment'</span>, </span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="comment">// 将 `this.incrementBy(amount)` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store.commit('incrementBy', amount)`</span></span><br><span class="line">      <span class="string">'incrementBy'</span> </span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      <span class="comment">// 将 `this.add()` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store.commit('increment')`</span></span><br><span class="line">      add: <span class="string">'increment'</span> </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简直不要太好用，连载荷也可以直接支持。</p>
<h4 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h4><p>和 <code>mapMutations</code> 用法一模一样，换个名字即可。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="comment">// 将 `this.increment()` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store. dispatch('increment')`</span></span><br><span class="line">      <span class="string">'increment'</span>, </span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="comment">// 将 `this.incrementBy(amount)` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store. dispatch('incrementBy', amount)`</span></span><br><span class="line">      <span class="string">'incrementBy'</span> </span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      <span class="comment">// 将 `this.add()` 映射为 </span></span><br><span class="line">      <span class="comment">// `this.$store. dispatch('increment')`</span></span><br><span class="line">      add: <span class="string">'increment'</span> </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要在组件中调用，直接 <code>this.xxx</code> 就完了。</p>
<h3 id="2-6-Models"><a href="#2-6-Models" class="headerlink" title="2.6 Models"></a>2.6 Models</h3><h4 id="粗说-2"><a href="#粗说-2" class="headerlink" title="粗说"></a>粗说</h4><p>当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 <code>state、mutation、action、getter</code>、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">models:&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        state:&#123;&#125;,</span><br><span class="line">        getters:&#123;&#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件内调用模块a的状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.a</span><br></pre></td></tr></table></figure>

<p>而提交或者<code>dispatch</code>某个方法和以前一样,会自动执行所有模块内的对应<code>type</code>的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'editKey'</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'aEditKey'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="细说-2"><a href="#细说-2" class="headerlink" title="细说"></a>细说</h4><p>在前言里面，我们已经了 Module 的基本职责，那么具体如何使用呢？</p>
<p>Vuex 允许我们将 store 分割成大大小小的对象，每个对象也都拥有自己的 state、getter、mutation、action，这个对象我们把它叫做 module（模块），在模块中还可以继续嵌套子模块、子子模块 ……</p>
<p>现在在 <code>src</code> 里面建个文件夹，命名为 <code>module</code>，然后再里面新建一个 <code>moduleA.js</code> 文件，并编写如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> &#123;</span><br><span class="line">    <span class="attribute">state</span>: &#123;</span><br><span class="line">        text: <span class="string">'moduleA'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">getters</span>: &#123;&#125;,</span><br><span class="line">    <span class="selector-tag">mutations</span>: &#123;&#125;,</span><br><span class="line">    <span class="selector-tag">actions</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，再建一个 <code>moduleB.js</code> 文件，这里就不重复了。</p>
<p>然后打开 <code>store.js</code> 文件，导入这两个 module ：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">'./module/moduleA'</span>;</span><br><span class="line"><span class="keyword">import</span> moduleB <span class="keyword">from</span> <span class="string">'./module/moduleB'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        moduleA, moduleB,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，store 中已经注入了两个子模块 <code>moduleA moduleB</code>，我们可以在 <code>App.vue</code> 中通过 <code>this.$store.state.moduleA.text</code> 这种方式来直接访问模块中的 state 数据。如下修改：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        name: <span class="function"><span class="params">state</span> =&gt;</span> state.moduleA.text</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>由此可知，模块内部的 state 是局部的，只属于模块本身所有，所以外部必须通过对应的模块名进行访问。</p>
<p><strong>但是</strong>注意了：</p>
<p>模块内部的 action、mutation 和 getter 默认可是注册在<strong>全局命名空间</strong>的，这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>这里以 mutation 的响应为例，给 moduleA 和 moduleB 分别新增一个 mutations，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    setText(state) &#123;</span><br><span class="line">        state.text = <span class="string">'A'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>moduleB 和上面一样，把文本名称修改一下即可，这里就不重复了。然后回到 <code>App.vue</code> 中，修改如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;mapState, mapMutations&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line">            ...mapState(&#123;</span><br><span class="line"><span class="javascript">                name: <span class="function"><span class="params">state</span> =&gt;</span> (state.moduleA.text + <span class="string">'和'</span> + state.moduleB.text)</span></span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            ...mapMutations([<span class="string">'setText'</span>]),</span></span><br><span class="line">            modifyNameAction() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.setText();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行然后点击修改，我们会发现模块 A 和 B 中的 <code>text</code> 值都改变了。当然，action 的用法一模一样，大家也可以试试。</p>
<p>如果模块之间的数据有交集的话，那么我们其实就可以通过这种方式，来同步更新模块之间的数据，虽然看起来非常的方便，但是用的时候可一定要谨慎，这种处理方式一旦没用好，遇到错误，排查起来还是比较有难度的。</p>
<h5 id="访问根节点"><a href="#访问根节点" class="headerlink" title="访问根节点"></a>访问根节点</h5><p>我们已经知晓，模块内部的 state 是局部的，只属于模块本身所有。那么如果我们要想在模块中访问 store 根节点的数据 state，怎么办呢？</p>
<p>很简单，我们可以在模块内部的 getter 和 action 中，通过 rootState 这个参数来获取。接下来，我们给 <code>modelA.js</code> 文件添加一点代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    getters: &#123;</span><br><span class="line">        <span class="comment">// 注意:rootState必须是第三个参数</span></span><br><span class="line">        detail(state, getters, rootState) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.text + <span class="string">'-'</span> + rootState.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        callAction(&#123;state, rootState&#125;) &#123;</span><br><span class="line">            alert(state.text + <span class="string">'-'</span> + rootState.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>App.vue</code> ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;mapActions, mapGetters&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line">            ...mapGetters(&#123;</span><br><span class="line"><span class="actionscript">                name: <span class="string">'detail'</span></span></span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            ...mapActions([<span class="string">'callAction'</span>]),</span></span><br><span class="line">            modifyNameAction() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.callAction();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后运行你会发现，根节点的数据已经被我们获取到了。这里需要注意的是在 getters 中，rootState 是以第三个参数暴露出来的，另外，还有第四个参数 rootGetters，用来获得根节点的 getters 信息，这里就不演示了，感兴趣自己可以去尝试。唯一要强调的就是千万不要弄错参数的位置了。</p>
<p>当然，action 中也能接收到 rootGetters，但是在 action 中，由于它接收过来的数据都被包在 <code>context</code> 对象中的，所以解包出来没有什么顺序的限制。</p>
<h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>前面我们已经知道了，模块内部的 action、mutation 和 getter 默认是注册在全局命名空间的。如果我们只想让他们在当前的模块中生效，应该怎么办呢？</p>
<p><strong>通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。</strong>当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<p>我们在 <code>moduleA.js</code> 中添加 <code>namespaced: true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候再去运行代码，你会发现如下错误：</p>
<blockquote>
<p>[vuex] unknown getter: detail</p>
</blockquote>
<p>在全局 getter 中已经找不到 <code>detail</code> 的这个方法了，因为它的路劲已经改变了，不再属于全局，仅仅只属于 moduleA 了。所以，这个时候，如果我们想要访问它，必须带上路劲才行。修改 <code>App.vue</code> 如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;mapActions, mapGetters&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        computed: &#123;</span><br><span class="line">            ...mapGetters(&#123;</span><br><span class="line"><span class="actionscript">                name: <span class="string">'moduleA/detail'</span></span></span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...mapActions(&#123;</span><br><span class="line"><span class="actionscript">                call: <span class="string">'moduleA/callAction'</span></span></span><br><span class="line">            &#125;),</span><br><span class="line">            modifyNameAction() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.call();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，如果一个模块启用了命名空间，那么它里面的 getter 和 action 中收到的 getter，dispatch 和 commit 也都是局部化的，不需要在同一模块内额外添加空间名前缀。也就是说，更改 <code>namespaced</code> 属性后不需要修改模块内的任何代码。</p>
<p>那么我们如何<strong>在带命名空间的模块内访问全局内容</strong>呢？</p>
<p>通过前面的学习，我们已经了解到：</p>
<blockquote>
<p>如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p>
</blockquote>
<p>现在如果想要在全局命名空间内分发 action 或提交 mutation 的话，那么我们只需要将 将 <code>{ root: true }</code> 作为第三参数传给 dispatch 或 commit 即可。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    namespaced: <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    actions: &#123;</span><br><span class="line">        callAction(&#123;state, commit, rootState&#125;) &#123;</span><br><span class="line">            commit(<span class="string">'setName'</span>, <span class="string">'改变'</span>, &#123;root: <span class="keyword">true</span>&#125;);</span><br><span class="line">            alert(state.text + <span class="string">'-'</span> + rootState.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看如何<strong>在带命名空间的模块内注册全局 action</strong>。</p>
<blockquote>
<p>若需要在带命名空间的模块注册全局 action，你可添加 <code>root: true</code>，并将这个 action 的定义放在函数 handler 中。</p>
</blockquote>
<p>写法稍微有点变化，我们来看看，修改 <code>moduleA.js</code>，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    actions: &#123;</span><br><span class="line">        callAction: &#123;</span><br><span class="line">            root: <span class="literal">true</span>,</span><br><span class="line">            handler (namespacedContext, payload) &#123;</span><br><span class="line">                <span class="keyword">let</span> &#123;state, commit&#125; = namespacedContext;</span><br><span class="line">                commit(<span class="string">'setText'</span>);</span><br><span class="line">                alert(state.text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单解释下，这里的 <code>namespacedContext</code> 就相当于当前模块的上下文对象，<code>payload</code> 是调用的时候所传入的参数，当然也叫载荷。</p>
<p>示例就讲到这里，接下来看看<strong>带命名空间的绑定函数</strong>。</p>
<p>关于 <code>mapState, mapGetters, mapActions</code> 和 <code>mapMutations</code> 这些函数如何来绑定带命名空间的模块，上面示例代码中其实已经都写过了，这里再看看另外几种更简便的写法，先看看之前的写法。</p>
<p>这里就用官方的示例代码举例说明：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">computed:</span> &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        <span class="symbol">a:</span> state =&gt; state.some.nested<span class="class">.<span class="keyword">module</span>.<span class="title">a</span>,</span></span><br><span class="line">        <span class="symbol">b:</span> state =&gt; state.some.nested<span class="class">.<span class="keyword">module</span>.<span class="title">b</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="symbol">methods:</span> &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">        /<span class="regexp">/ -&gt; this['some/nested</span><span class="regexp">/module/foo</span><span class="string">']()</span></span><br><span class="line"><span class="string">        '</span>some/nested/<span class="class"><span class="keyword">module</span>/<span class="title">foo</span>', </span></span><br><span class="line">        /<span class="regexp">/ -&gt; this['some/nested</span><span class="regexp">/module/bar</span><span class="string">']()</span></span><br><span class="line"><span class="string">        '</span>some/nested/<span class="class"><span class="keyword">module</span>/<span class="title">bar</span>' </span></span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更优雅的写法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">        a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">        b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">'some/nested/module'</span>, [</span><br><span class="line">        <span class="string">'foo'</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">        <span class="string">'bar'</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。</p>
<p>我们还可以通过使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">'some/nested/module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">      b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'foo'</span>,</span><br><span class="line">      <span class="string">'bar'</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="模块的动态注册"><a href="#模块的动态注册" class="headerlink" title="模块的动态注册"></a>模块的动态注册</h5><p>这一章节，官网讲得比较清楚，所以直接搬过来了。</p>
<blockquote>
<p>在 store 创建之后，可以使用 <code>store.registerModule</code> 方法动态的注册模块：</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p>
<p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，<a href="https://github.com/vuejs/vuex-router-sync" target="_blank" rel="noopener"><code>vuex-router-sync</code></a> 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p>
<p>你也可以使用 <code>store.unregisterModule(moduleName)</code> 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</p>
<p>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 <code>preserveState</code> 选项将其归档：<code>store.registerModule(&#39;a&#39;, module, { preserveState: true })</code>。</p>
</blockquote>
<h5 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h5><p>就一点，重用会导致模块中的数据 state 被污染，所以和 Vue 中的 data 一样，也使用一个函数来申明 state 即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyReusableModule = &#123;</span><br><span class="line">  state () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、规范目录结构"><a href="#三、规范目录结构" class="headerlink" title="三、规范目录结构"></a>三、规范目录结构</h2><p>如果把整个<code>store</code>都放在<code>index.js</code>中是不合理的，所以需要拆分。比较合适的目录格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">store:.</span><br><span class="line">│  actions.js</span><br><span class="line">│  getters.js</span><br><span class="line">│  index.js</span><br><span class="line">│  mutations.js</span><br><span class="line">│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入</span><br><span class="line">│</span><br><span class="line">└─modules</span><br><span class="line">        Astore.js</span><br></pre></td></tr></table></figure>

<p>对应的内容存放在对应的文件中，和以前一样，在<code>index.js</code>中存放并导出<code>store</code>。<code>state</code>中的数据尽量放在<code>index.js</code>中。而<code>modules</code>中的<code>Astore</code>局部模块状态如果多的话也可以进行细分。</p>
<p>参考链接：<a href="https://www.jianshu.com/p/2e5973fe1223" target="_blank" rel="noopener">https://www.jianshu.com/p/2e5973fe1223</a></p>
<p>参考链接：<a href="https://www.jianshu.com/p/83d5677b0928" target="_blank" rel="noopener">https://www.jianshu.com/p/83d5677b0928</a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-前进后退f动画</title>
    <url>/2020/07/30/vue-%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80f%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p><strong>一丶首先配置路由并且修改路由配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">路由配置就不讲了</span><br><span class="line">重点，给VueRoute添加一个goBack方法，用于记录路由的前进后退状态 this.isBack &#x3D; true </span><br><span class="line">VueRouter.prototype.goBack &#x3D; function () &#123; </span><br><span class="line">　　this.isBack &#x3D; true</span><br><span class="line">　　window.history.go(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="二丶监听路由变化（在路由变化时判断此时的路由状态是前进还是后退）"><a href="#二丶监听路由变化（在路由变化时判断此时的路由状态是前进还是后退）" class="headerlink" title="二丶监听路由变化（在路由变化时判断此时的路由状态是前进还是后退）**"></a>二丶监听路由变化（在路由变化时判断此时的路由状态是前进还是后退）**</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">　　&lt;div&gt;</span><br><span class="line">　　　　动态绑定路由动画，根据路由状态的不同绑定不同的路由动画分别为  ：‘slide-left’  和 &#39;slide-right&#39;</span><br><span class="line">　　　　&lt;transition :name&#x3D;&quot;transitionName&quot;&gt; </span><br><span class="line">　　　　　　&lt;router-view class&#x3D;&quot;Router&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">　　　　&lt;&#x2F;transition&gt;</span><br><span class="line">　　&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">　　data() &#123;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　transitionName: &#39;slide-right&#39;  &#x2F;&#x2F; 默认动态路由变化为slide-right</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;,</span><br><span class="line">　　watch: &#123;</span><br><span class="line">　　　&#39;$route&#39; (to, from) &#123;</span><br><span class="line">　　　     &#x2F;&#x2F;方法一</span><br><span class="line">　　　　   let isBack &#x3D; this.$router.isBack  &#x2F;&#x2F;  监听路由变化时的状态为前进还是后退**</span><br><span class="line">　　　　　　if(isBack) &#123;</span><br><span class="line">　　　　　　　　this.transitionName &#x3D; &#39;slide-right&#39;</span><br><span class="line">　　　　　　&#125; else &#123;</span><br><span class="line">　　　　　　   this.transitionName &#x3D; &#39;slide-left&#39;</span><br><span class="line">　　　　　  &#125;</span><br><span class="line">　　		this.$router.isBack &#x3D; false</span><br><span class="line">　　		</span><br><span class="line">　　		&#x2F;&#x2F;方法二在路由meta中设置index</span><br><span class="line">　　		&#x2F;&#x2F; 如果to索引大于from索引,判断为前进状态,反之则为后退状态 </span><br><span class="line">          if (to.meta.index &gt; from.meta.index)&#123;</span><br><span class="line">           &#x2F;&#x2F; 设置动画名称</span><br><span class="line">            this.transitionName &#x3D; &#39;slide-left&#39;;</span><br><span class="line">          &#125; else&#123;</span><br><span class="line">            this.transitionName &#x3D; &#39;slide-right&#39;;</span><br><span class="line">          &#125;</span><br><span class="line">　　  &#125;</span><br><span class="line">　&#125; </span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="三丶给前进后退动画添加不同的动画效果，具体代码如下："><a href="#三丶给前进后退动画添加不同的动画效果，具体代码如下：" class="headerlink" title="三丶给前进后退动画添加不同的动画效果，具体代码如下："></a>三丶给前进后退动画添加不同的动画效果，具体代码如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.Router &#123;</span><br><span class="line">     position: absolute;</span><br><span class="line">     width: 100%;</span><br><span class="line">     transition: all .8s ease;</span><br><span class="line">     top: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.slide-left-enter,</span><br><span class="line"> .slide-right-leave-active &#123;</span><br><span class="line">     opacity: 0;</span><br><span class="line">    -webkit-transform: translate(100%, 0);</span><br><span class="line">    transform: translate(100%, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.slide-left-leave-active,</span><br><span class="line">.slide-right-enter &#123;</span><br><span class="line">     opacity: 0;</span><br><span class="line">    -webkit-transform: translate(-100%, 0);</span><br><span class="line">    transform: translate(-100% 0);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>



<h3 id="四丶路由前进的时候按正常方法走就行了；"><a href="#四丶路由前进的时候按正常方法走就行了；" class="headerlink" title="四丶路由前进的时候按正常方法走就行了；"></a>四丶路由前进的时候按正常方法走就行了；</h3><h3 id="五丶后退的时候调用goBack方法就OK；"><a href="#五丶后退的时候调用goBack方法就OK；" class="headerlink" title="五丶后退的时候调用goBack方法就OK；"></a>五丶后退的时候调用<strong>goBack</strong>方法就OK；</h3><p>在需要点击返回的按钮中设置 goback</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    goback () &#123;</span><br><span class="line">      this.$router.goBack()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_方法相关</title>
    <url>/2020/07/30/vue-%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="匹配字体标红"><a href="#匹配字体标红" class="headerlink" title="匹配字体标红"></a>匹配字体标红</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brightenKeyword: function(val, keyword) &#123;</span><br><span class="line">    &#x2F;&#x2F;val &#x3D; val + &#39;&#39;;</span><br><span class="line">    &#x2F;&#x2F;if (val.indexOf(keyword) !&#x3D;&#x3D; -1 &amp;&amp; keyword !&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F;    return val.replace(keyword, &#39;&lt;font color&#x3D;&quot;#409EFF&quot;&gt;&#39; + keyword + &#39;&lt;&#x2F;font&gt;&#39;)</span><br><span class="line">    &#x2F;&#x2F;&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;    return val</span><br><span class="line">    &#x2F;&#x2F;&#125;</span><br><span class="line">    const Reg &#x3D; new RegExp(keyword, &#39;i&#39;);</span><br><span class="line">    if (val) &#123;</span><br><span class="line">        return val.replace(Reg, &#96; &lt; span class &#x3D; &quot;redColor zl-theme-price&quot; &gt; $ &#123;keyword&#125; &lt; &#x2F;span&gt;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&#x2F;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="图片的循环输出"><a href="#图片的循环输出" class="headerlink" title="图片的循环输出"></a>图片的循环输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;&lt;img :src&#x3D;&quot;imgIcon[index]&quot; width&#x3D;&quot;15px&quot; &gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line"> data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        imgIcon:[</span><br><span class="line">          require(&#39;@&#x2F;common&#x2F;img&#x2F;icon-search00.png&#39;),</span><br><span class="line">          require(&#39;@&#x2F;common&#x2F;img&#x2F;icon-search01.png&#39;),</span><br><span class="line">          require(&#39;@&#x2F;common&#x2F;img&#x2F;icon-search02.png&#39;),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="别名-需要重启vscode才能生效"><a href="#别名-需要重启vscode才能生效" class="headerlink" title="别名(需要重启vscode才能生效)"></a>别名(需要重启vscode才能生效)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;@&#39;: resolve(&#39;src&#39;),</span><br><span class="line">&#39;components&#39;: resolve(&#39;@&#x2F;components&#39;),</span><br><span class="line"></span><br><span class="line">在标签内必须使用~</span><br><span class="line">&lt;img src&#x3D;&quot;~asset&#x2F;image&#x2F;header.jpng&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app1&quot;,</span><br><span class="line">    data:&#123;that:this&#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        f:function()&#123;</span><br><span class="line">          console.log(this) &#x2F;&#x2F;vue实例</span><br><span class="line">        &#125;,</span><br><span class="line">        f1:()&#x3D;&gt;&#123;</span><br><span class="line">            console.log(this)&#x2F;&#x2F;window</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">建议使用es5的用法，用that定义</span><br></pre></td></tr></table></figure>



<h3 id="非父子组件通信–创建空实例"><a href="#非父子组件通信–创建空实例" class="headerlink" title="非父子组件通信–创建空实例"></a>非父子组件通信–创建空实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;foo&gt;&lt;&#x2F;foo&gt;</span><br><span class="line">    &lt;bar&gt;&lt;&#x2F;bar&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;使用一个空的实例来作为中央事件总线。</span><br><span class="line">    var eventBus&#x3D;new Vue(&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;foo组件</span><br><span class="line">    Vue.component(&#39;foo&#39;,&#123;</span><br><span class="line">        template:&#39;&lt;div&gt;&lt;p&gt;the count of foo is &#123;&#123;fooCount&#125;&#125;&lt;&#x2F;p&gt;&#39; +</span><br><span class="line">                &#39;&lt;button @click&#x3D;&quot;emitevent&quot;&gt;Add bar\&#39;s count&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">        data:function () &#123;</span><br><span class="line">            return &#123;fooCount:0&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            emitevent:function () &#123;</span><br><span class="line">			&#x2F;&#x2F;这里要使用中央事件发送信号。</span><br><span class="line">                eventBus.$emit(&#39;emitevent&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;bar组件</span><br><span class="line">    Vue.component(&#39;bar&#39;,&#123;</span><br><span class="line">        template:&#39;&lt;div&gt;&lt;p&gt;the count of bar is &#123;&#123;barCount&#125;&#125;&lt;&#x2F;p&gt;&#39; +</span><br><span class="line">                &#39;&lt;button &gt;B&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">        data:function () &#123;</span><br><span class="line">            return &#123;barCount:0&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted:function () &#123;</span><br><span class="line">		&#x2F;&#x2F;这里要使用中央事件接受信号。并且是在组件挂载完成后。</span><br><span class="line">            var _this&#x3D;this;</span><br><span class="line">            eventBus.$on(&#39;emitevent&#39;,function () &#123;</span><br><span class="line">                _this.barCount+&#x3D;1; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    var app&#x3D;new Vue(&#123;</span><br><span class="line">        el:&#39;#app&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="常用js库"><a href="#常用js库" class="headerlink" title="常用js库"></a>常用js库</h3><h4 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h4><p>一个著名的javascript原生库，不需要引入其他第三方依赖</p>
<h4 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h4><p>一个纯JavaScript图表库 –<a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener">echarts.apache.org</a></p>
<h3 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h3><p>vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<h3 id="static和assets"><a href="#static和assets" class="headerlink" title="static和assets"></a>static和assets</h3><p>1.static中的文件是不会经过webpack编译的，一般建议存放一些外部第三方（公用）的静态资源文件。</p>
<p>2.assets因为会经过webpack编译，建议是存放一些只有组件自己使用到的静态资源。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之flvjs</title>
    <url>/2021/03/19/vue%E4%B9%8Bflvjs/</url>
    <content><![CDATA[<p>参考链接 :<a href="https://blog.csdn.net/HJFQC/article/details/109626836" target="_blank" rel="noopener">https://blog.csdn.net/HJFQC/article/details/109626836</a><br>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save flv.js</span><br></pre></td></tr></table></figure>



<p>vue页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div class&#x3D;&quot;video&quot;&gt;</span><br><span class="line">      &lt;video</span><br><span class="line">       id&#x3D;&quot;vPull&quot;</span><br><span class="line">       controls</span><br><span class="line">       autoplay</span><br><span class="line">       muted</span><br><span class="line">       width&#x3D;&quot;100%&quot;</span><br><span class="line">       height&#x3D;&quot;100%&quot;&gt;</span><br><span class="line">      &lt;&#x2F;video&gt;</span><br><span class="line"> &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>js部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import flv from &quot;flv.js&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      player: null,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    play(urls) &#123;</span><br><span class="line">      let video &#x3D; document.getElementById(&quot;vPull&quot;); &#x2F;&#x2F;定义播放路径</span><br><span class="line">      if (flv.isSupported()) &#123;</span><br><span class="line">        this.player &#x3D; flv.createPlayer(</span><br><span class="line">          &#123;</span><br><span class="line">            type: &quot;flv&quot;,</span><br><span class="line">            isLive: true,</span><br><span class="line">            url: urls,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            enableWorker: false, &#x2F;&#x2F;不启用分离线程</span><br><span class="line">            enableStashBuffer: false, &#x2F;&#x2F;关闭IO隐藏缓冲区</span><br><span class="line">            isLive: true,</span><br><span class="line">            lazyLoad: false,</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(&quot;不支持的格式&quot;);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      this.player.attachMediaElement(video);</span><br><span class="line">      this.player.load();</span><br><span class="line">      this.player.play();</span><br><span class="line">    &#125;,</span><br><span class="line">    destruction() &#123;</span><br><span class="line">      &#x2F;&#x2F;销毁对象</span><br><span class="line">      if (this.player) &#123;</span><br><span class="line">        this.player.pause();</span><br><span class="line">        this.player.destroy();</span><br><span class="line">        this.player &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.play(&#39;http:&#x2F;&#x2F;1011.hlsplay.aodianyun.com&#x2F;demo&#x2F;game.flv&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><a href="https://github.com/bilibili/flv.js/blob/master/docs/api.md" target="_blank" rel="noopener">原文件（api.md）</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> flv <span class="keyword">from</span> <span class="string">"flv.js"</span>;</span><br></pre></td></tr></table></figure>

<p>功能类<br>创建flv播放器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let player &#x3D; flv.createPlayer(mediaDataSource: MediaDataSource, config?: Config);</span><br></pre></td></tr></table></figure>

<p>createPlayer()方法有两个参数，MediaDataSource和config两个参数，MediaDataSource必传，config可传可不传，返回值为player;</p>
<p><img src="/2021/03/19/vue%E4%B9%8Bflvjs/image-20210319104534115.png" alt="image-20210319104534115"></p>
<p>如果<code>segments</code>存在字段，则transmuxer会将其<code>MediaDataSource</code>视为<strong>多部分</strong>源。</p>
<p>在多部分模式下，结构中的<code>duration</code> <code>filesize</code> <code>url</code>字段<code>MediaDataSource</code>将被忽略。</p>
<p><img src="/2021/03/19/vue%E4%B9%8Bflvjs/image-20210319104556362.png" alt="image-20210319104556362"></p>
<p><img src="/2021/03/19/vue%E4%B9%8Bflvjs/image-20210319104639743.png" alt="image-20210319104639743"></p>
<p>flv.isSupported()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isSupported(): boolean;</span><br></pre></td></tr></table></figure>

<p>player实例存在返回true，否则返回fasle</p>
<p>flv.getFeatureList()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFeatureList(): FeatureList;</span><br></pre></td></tr></table></figure>

<p>返回 FeatureList 对象</p>
<p><img src="/2021/03/19/vue%E4%B9%8Bflvjs/image-20210319104707073.png" alt="image-20210319104707073"></p>
<h3 id="Player对象"><a href="#Player对象" class="headerlink" title="Player对象"></a>Player对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Player &#123;</span><br><span class="line">    constructor(mediaDataSource: MediaDataSource, config?: Config): Player;</span><br><span class="line">    destroy(): void;</span><br><span class="line">    on(event: string, listener: Function): void;</span><br><span class="line">    off(event: string, listener: Function): void;</span><br><span class="line">    attachMediaElement(mediaElement: HTMLMediaElement): void;</span><br><span class="line">    detachMediaElement(): void;</span><br><span class="line">    load(): void;&#x2F;&#x2F;加载</span><br><span class="line">    unload(): void;&#x2F;&#x2F;卸载</span><br><span class="line">    play(): Promise&lt;void&gt;;&#x2F;&#x2F;播放</span><br><span class="line">    pause(): void;&#x2F;&#x2F;暂停</span><br><span class="line">    type: string;</span><br><span class="line">    buffered: TimeRanges;</span><br><span class="line">    duration: number;</span><br><span class="line">    volume: number;</span><br><span class="line">    muted: boolean;</span><br><span class="line">    currentTime: number;</span><br><span class="line">    mediaInfo: Object;</span><br><span class="line">    statisticsInfo: Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="视频流延迟"><a href="#视频流延迟" class="headerlink" title="视频流延迟"></a>视频流延迟</h3><p>在普通的网络环境下,flv.js播放http-flv的视频流延迟大概在3~5秒左右,对于实时性要求比较高的场景,显然是不适用的,那么怎么才能降低延迟呢? 通过对buffered(缓冲区末尾)和currentTime(当前播放位置)的比较,发现差值大概在1.8秒左右,这时候就需要我们定时检测currentTime和buffered的差值,然后手动跳帧,使currentTime和buffered同步(PS:这两个值在Player对象中可以获取到,可以查看我的上一篇帖子:vue使用flv.js(bilibili)拉流),代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">      if (this.player.buffered.length) &#123;</span><br><span class="line">        let end &#x3D; this.player.buffered.end(0);&#x2F;&#x2F;获取当前buffered值</span><br><span class="line">        let diff &#x3D; end - this.player.currentTime;&#x2F;&#x2F;获取buffered与currentTime的差值</span><br><span class="line">        if (diff &gt;&#x3D; 0.5) &#123;&#x2F;&#x2F;如果差值大于等于0.5 手动跳帧 这里可根据自身需求来定</span><br><span class="line">          this.player.currentTime &#x3D; this.player.buffered.end(0);&#x2F;&#x2F;手动跳帧</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 2000); &#x2F;&#x2F;2000毫秒执行一次</span><br></pre></td></tr></table></figure>

<h3 id="断流重连"><a href="#断流重连" class="headerlink" title="断流重连"></a>断流重连</h3><p>视频直播时,有时候会遇到视频loading,卡顿,有可能是本地网络波动或者服务端流断开,我们可以通过监听<code>flvjs.Events.ERROR</code>来判断连接是否已经断开,继而进行断流重连,代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.player.on(flvjs.Events.ERROR, (errorType, errorDetail, errorInfo) &#x3D;&gt; &#123;</span><br><span class="line">		console.log(&quot;errorType:&quot;, errorType);</span><br><span class="line">        console.log(&quot;errorDetail:&quot;, errorDetail);</span><br><span class="line">        console.log(&quot;errorInfo:&quot;, errorInfo);</span><br><span class="line">        &#x2F;&#x2F;视频出错后销毁重新创建</span><br><span class="line">         if (this.player) &#123;</span><br><span class="line">          this.player.pause();</span><br><span class="line">          this.player.unload();</span><br><span class="line">          this.player.detachMediaElement();</span><br><span class="line">          this.player.destroy();</span><br><span class="line">          this.player&#x3D; null;</span><br><span class="line">          this.createPlayer(videoElement, this.url);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="画面卡死"><a href="#画面卡死" class="headerlink" title="画面卡死"></a>画面卡死</h3><p>如果控制台没有错误信息,而且查看network发现视频流没有断开,但是画面一直在loading或者卡住不动,我这边的原因是服务端推流突然断开,然后在很快的时间内继续推流,这个时候因为客户端的超时时间还没有结束,流会继续推送到原链接,这个时候我们的视频会卡在掉线的那个时间,不会继续播放.这个时候我们就需要监听推流的decodedFrame,如果decodedFrame不再发生变化,我们就销毁掉该实例并进行重新连接,代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.player.on(&quot;statistics_info&quot;, function (res) &#123;</span><br><span class="line">       if (this.lastDecodedFrame &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         this.lastDecodedFrame &#x3D; res.decodedFrames;</span><br><span class="line">         return;</span><br><span class="line">       &#125;</span><br><span class="line">       if (this.lastDecodedFrame !&#x3D; res.decodedFrames) &#123;</span><br><span class="line">         this.lastDecodedFrame &#x3D; res.decodedFrames;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.lastDecodedFrame &#x3D; 0;</span><br><span class="line">           if (this.player) &#123;</span><br><span class="line">             this.player.pause();</span><br><span class="line">             this.player.unload();</span><br><span class="line">             this.player.detachMediaElement();</span><br><span class="line">             this.player.destroy();</span><br><span class="line">             this.player&#x3D; null;</span><br><span class="line">             this.createPlayer(videoElement, this.url);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>flvjs</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之videojs的使用</title>
    <url>/2021/02/03/vue%E4%B9%8Bvideojs%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在vue中使用videojs</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;test&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;demo&quot;&gt;</span><br><span class="line">                &lt;!-- videojs的使用 --&gt;</span><br><span class="line">                &lt;video class&#x3D;&quot;video-js vjs-big-play-centered&quot; id&#x3D;&quot;myvideo&quot; ref&#x3D;&quot;videoRef&quot; data-setup&#x3D;&quot;&#123;&#125;&quot;&gt;&lt;&#x2F;video&gt;</span><br><span class="line">                &lt;Button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;clickMe&quot;&gt;12131&lt;&#x2F;Button&gt;</span><br><span class="line">                &lt;Button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;decrement&quot;&gt;reduce&lt;&#x2F;Button&gt;</span><br><span class="line">                &lt;Button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;increment&quot;&gt;add&lt;&#x2F;Button&gt;</span><br><span class="line">                &lt;!-- video-player插件的使用 --&gt;</span><br><span class="line">                &lt;video-player class&#x3D;&quot;video-player vjs-custom-skin&quot; ref&#x3D;&quot;videoPlayer&quot; :playsinline&#x3D;&quot;true&quot;</span><br><span class="line">                    :options&#x3D;&quot;playerOptions&quot;&gt;&lt;&#x2F;video-player&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import videojs from &#39;video.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;pie&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            myPlayer: null,</span><br><span class="line">            playerOptions: &#123;</span><br><span class="line">                playbackRates: [0.5, 1.0, 1.5, 2.0], &#x2F;&#x2F;可选择的播放速度</span><br><span class="line">                autoplay: true, &#x2F;&#x2F;如果true,浏览器准备好时开始回放。</span><br><span class="line">                muted: false, &#x2F;&#x2F; 默认情况下将会消除任何音频。</span><br><span class="line">                loop: false, &#x2F;&#x2F; 视频一结束就重新开始。</span><br><span class="line">                preload: &#39;auto&#39;, &#x2F;&#x2F; 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持）</span><br><span class="line">                language: &#39;zh-CN&#39;,</span><br><span class="line">                aspectRatio: &#39;16:9&#39;, &#x2F;&#x2F; 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;）</span><br><span class="line">                fluid: true, &#x2F;&#x2F; 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。</span><br><span class="line">                sources: [&#123;</span><br><span class="line">                    type: &quot;&quot;,</span><br><span class="line">                    src: &#39;&#x2F;static&#x2F;mp4&#x2F;myvideo.mp4&#39;&#x2F;&#x2F;url地址</span><br><span class="line">                &#125;],</span><br><span class="line">                poster: &quot;&#x2F;static&#x2F;imgs&#x2F;click.jpg&quot;, &#x2F;&#x2F;你的封面地址</span><br><span class="line">                &#x2F;&#x2F; width: document.documentElement.clientWidth,</span><br><span class="line">                notSupportedMessage: &#39;此视频暂无法播放，请稍后再试&#39;, &#x2F;&#x2F;允许覆盖Video.js无法播放媒体源时显示的默认信息。</span><br><span class="line">                controlBar: &#123;</span><br><span class="line">                    timeDivider: true,&#x2F;&#x2F;当前时间和持续时间的分隔符</span><br><span class="line">                    durationDisplay: true,&#x2F;&#x2F;显示持续时间</span><br><span class="line">                    remainingTimeDisplay: false,&#x2F;&#x2F;是否显示剩余时间功能</span><br><span class="line">                    fullscreenToggle: true  &#x2F;&#x2F;全屏按钮</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        this.myPlayer &#x3D; videojs(&#39;myvideo&#39;, &#123;</span><br><span class="line">            &#x2F;&#x2F;确定播放器是否具有用户可以与之交互的控件。没有控件，启动视频播放的唯一方法是使用autoplay属性或通过Player API。</span><br><span class="line">            controls: true,</span><br><span class="line">            &#x2F;&#x2F;自动播放属性,muted:静音播放</span><br><span class="line">            muted: true,</span><br><span class="line">            &#x2F;&#x2F;  autoplay: true,</span><br><span class="line">            &#x2F;&#x2F;建议浏览器是否应在&lt;video&gt;加载元素后立即开始下载视频数据。</span><br><span class="line">            preload: &quot;auto&quot;,</span><br><span class="line">            &#x2F;&#x2F;设置视频播放器的显示宽度（以像素为单位）</span><br><span class="line">            width: &quot;960px&quot;,</span><br><span class="line">            &#x2F;&#x2F;设置视频播放器的显示高度（以像素为单位）</span><br><span class="line">            height: &quot;522px&quot;,</span><br><span class="line">            &#x2F;&#x2F; url</span><br><span class="line">            poster: &#39;&#x2F;static&#x2F;imgs&#x2F;click.jpg&#39;, &#x2F;&#x2F; 封面图片</span><br><span class="line">            sources: [&#123;</span><br><span class="line">                src: &#39;&#x2F;static&#x2F;mp4&#x2F;myvideo.mp4&#39;</span><br><span class="line">            &#125;],</span><br><span class="line">            playbackRates: [0.5, 1, 1.5, 2, 3] &#x2F;&#x2F;倍速播放</span><br><span class="line"></span><br><span class="line">        &#125;, function onPlayerReady() &#123;</span><br><span class="line">            &#x2F;&#x2F;视频准备完毕</span><br><span class="line">            videojs.log(&#39;Your player is ready!&#39;); &#x2F;&#x2F; 比如： 播放量+1请求</span><br><span class="line">            &#x2F;&#x2F;视频播放完毕</span><br><span class="line">            this.on(&#39;ended&#39;, function () &#123;</span><br><span class="line">                videojs.log(&#39;Awww...over so soon?!&#39;);</span><br><span class="line">            &#125;);</span><br><span class="line">            &#x2F;&#x2F;视频开始播放</span><br><span class="line">            this.play();</span><br><span class="line">            &#x2F;&#x2F;视频总时长</span><br><span class="line">            console.log(this.duration());</span><br><span class="line">            &#x2F;&#x2F; 已经缓存了多久</span><br><span class="line">            console.log(this.buffered());</span><br><span class="line">            &#x2F;&#x2F;获取宽高</span><br><span class="line">            console.log(this.width());</span><br><span class="line">            console.log(this.height());</span><br><span class="line">            &#x2F;&#x2F;设置宽高</span><br><span class="line">            &#x2F;&#x2F; this.width(300);</span><br><span class="line">            &#x2F;&#x2F; this.height(200);</span><br><span class="line">            console.log(this.width());</span><br><span class="line">            console.log(this.height());</span><br><span class="line">            &#x2F;&#x2F;获取声音</span><br><span class="line">            console.log(this.volume(), &#39;volume&#39;);</span><br><span class="line">            &#x2F;&#x2F;设置声音大小，范围0~1</span><br><span class="line">            this.volume(0.9);</span><br><span class="line">            console.log(this.volume(), &#39;volume&#39;);</span><br><span class="line">            console.log(this, &#39;this&#39;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;视频播放出错</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;   &#x2F;&#x2F;延时确保能监听到视频源错误</span><br><span class="line">                var mediaError &#x3D; this.error();</span><br><span class="line">                if (mediaError !&#x3D; null &amp;&amp; mediaError.code) &#123;</span><br><span class="line">                    alert(&#39;啊哦，播放出错了。&lt;br&gt;请刷新重试，如无法播放建议您观看其它内容。&#39;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; this.myPlayer.on(&quot;ended&quot;, function () &#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;视频播放结束&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; this.myPlayer.on(&quot;pause&quot;, function () &#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;点击暂停&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; this.myPlayer.on(&quot;play&quot;, function () &#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;点击播放&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; this.myPlayer.on(&quot;volumechange&quot;, function () &#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;声音改变&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; this.myPlayer.on(&quot;timeupdate&quot;, function () &#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;视频播放中&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; this.myPlayer.on(&quot;seeked&quot;, function () &#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;视频跳转结束&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; this.myPlayer.on(&quot;seeking&quot;, function () &#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;视频跳转中&quot;);</span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line">        window.addEventListener(&#39;keyup&#39;, this.handleKeyup)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">        const videoDom &#x3D; this.$refs.videoRef;   &#x2F;&#x2F;不能用document 获取节点</span><br><span class="line">        videojs(videoDom).dispose();  &#x2F;&#x2F;销毁video实例，避免出现节点不存在 但是flash一直在执行,也避免重新进入页面video未重新声明</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        clickMe() &#123;</span><br><span class="line">            &#x2F;&#x2F;设置起始播放时间，单位是秒</span><br><span class="line">            this.myPlayer.currentTime(5)</span><br><span class="line">            console.log(this.myPlayer.currentTime(), &#39;this.myPlayer.currentTime()&#39;);</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;后退3s</span><br><span class="line">        decrement() &#123;</span><br><span class="line">            this.myPlayer.currentTime(this.myPlayer.currentTime() !&#x3D;&#x3D; 0 ? this.myPlayer.currentTime() - 2 : 1);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;前进3s</span><br><span class="line">        increment() &#123;</span><br><span class="line">            this.myPlayer.currentTime(this.myPlayer.volume !&#x3D;&#x3D; this.myPlayer.duration ? this.myPlayer.currentTime() + 2 : 1);</span><br><span class="line">        &#125;,</span><br><span class="line">        handleKeyup(event) &#123;</span><br><span class="line">            var vol &#x3D; 0.1;  &#x2F;&#x2F;1代表100%音量，每次增减0.1</span><br><span class="line">            var time &#x3D; 2; &#x2F;&#x2F;单位秒，每次增减10秒</span><br><span class="line">            console.log(&quot;keyCode:&quot; + event.keyCode);</span><br><span class="line">            var e &#x3D; event || window.event || arguments.callee.caller.arguments[0];</span><br><span class="line">            &#x2F;&#x2F;鼠标上下键控制视频音量</span><br><span class="line">            if (e &amp;&amp; e.keyCode &#x3D;&#x3D;&#x3D; 38) &#123;</span><br><span class="line">                &#x2F;&#x2F; 按 向上键</span><br><span class="line">                this.myPlayer.volume(this.myPlayer.volume() !&#x3D;&#x3D; 1 ? this.myPlayer.volume() + vol : 1);</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125; else if (e &amp;&amp; e.keyCode &#x3D;&#x3D;&#x3D; 40) &#123;</span><br><span class="line">                &#x2F;&#x2F; 按 向下键</span><br><span class="line">                this.myPlayer.volume(this.myPlayer.volume() !&#x3D;&#x3D; 1 ? this.myPlayer.volume() - vol : 1);</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125; else if (e &amp;&amp; e.keyCode &#x3D;&#x3D;&#x3D; 37) &#123;</span><br><span class="line">                &#x2F;&#x2F; 按 向左键</span><br><span class="line">                this.myPlayer.currentTime(this.myPlayer.currentTime() !&#x3D;&#x3D; 0 ? this.myPlayer.currentTime() - time : 1);</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125; else if (e &amp;&amp; e.keyCode &#x3D;&#x3D;&#x3D; 39) &#123;</span><br><span class="line">                &#x2F;&#x2F; 按 向右键</span><br><span class="line">                this.myPlayer.currentTime(this.myPlayer.volume !&#x3D;&#x3D; this.myPlayer.duration ? this.myPlayer.currentTime() + time : 1);</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125; else if (e &amp;&amp; e.keyCode &#x3D;&#x3D;&#x3D; 32) &#123;</span><br><span class="line">                &#x2F;&#x2F; 按空格键 判断当前是否暂停</span><br><span class="line">                this.myPlayer.paused() &#x3D;&#x3D;&#x3D; true ? this.myPlayer.play() : this.myPlayer.pause();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.test &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line">.test div &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">#pie &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.demo &#123;</span><br><span class="line">    width: 960px;</span><br><span class="line">    height: 522px;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    border: 1px solid transparent;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background: #fff;</span><br><span class="line">    position: relative;</span><br><span class="line">    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);</span><br><span class="line">    margin-right: 4px;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.demo:hover &#123;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>video</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之上拉加载原理</title>
    <url>/2020/09/16/vue%E4%B9%8B%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>贴上效果展示：<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8DicribgBBbuvZ13dRfOBLsInRicV51f90TJDiblOfwq1LuN27vTaqssPfF5NeQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>样式方面不多赘述，滚动区域是给固定高度，设置 <code>overflow-y: auto</code> 来实现。</p>
<p>接下来看看js方面的实现，其实也很简单，触发的条件是：<code>可视高度</code> + <code>滚动距离</code> &gt;= <code>实际高度</code> 。例子我会使用<code>vue</code>来实现，和原生实现是一样的。</p>
<ul>
<li>可视高度(offsetHeight)：通过 <code>dom</code> 的 <code>offsetHeight</code> 获得，表示区域固定的高度。这里我推荐通过 <code>getBoundingClientRect()</code> 来获取高度，因为使用前者会引起浏览器回流，造成一些性能问题。</li>
<li>滚动高度(scrollTop)：滚动事件中通过 <code>e.target.scrollTop</code> 获取，表示滚动条距离顶部的px</li>
<li>实际高度(scrollHeight)：通过 <code>dom</code> 的 <code>scrollHeight</code> 获得，表示区域内所有内容的高度（包括滚动距离），也就是实际高度</li>
</ul>
<a id="more"></a>

<h1 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onScroll(e) &#123;</span><br><span class="line">    let scrollTop &#x3D; e.target.scrollTop &#x2F;&#x2F;滚动高度</span><br><span class="line">    let scrollHeight &#x3D; e.target.scrollHeight &#x2F;&#x2F;实际高度</span><br><span class="line">    let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)&#x2F;&#x2F;可视高度</span><br><span class="line">    let currentHeight &#x3D; scrollTop + offsetHeight</span><br><span class="line">    if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">        console.log(&#39;触底&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8Dicribp9bOZENlSxoMU2MQtaNovYQXIb65qUPxKwWtTibqm9icMicOxXsFSUlMQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>so easy~</p>
<h1 id="加点细节"><a href="#加点细节" class="headerlink" title="加点细节"></a>加点细节</h1><p>加点细节，现在我们希望是离底部一定距离就触发事件，而不是等到完全触底。如果你做过小程序，这和<code>onReachBottom</code>差不多的意思。</p>
<p>声明一个离底部的距离变量<code>reachBottomDistance</code></p>
<p>这时候触发条件：<code>可视高度</code> + <code>滚动距离</code> + <code>reachBottomDistance</code> &gt;= <code>实际高度</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">        let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">        let currentHeight &#x3D; scrollTop + offsetHeight + this.reachBottomDistance</span><br><span class="line">        if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">            console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8DicribkC2ZSbcwoQfvEQdXUGzpzibj2IK0xQawxOm2q1t6L5N0Sj21Mmb2fJw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>在距离底部100px时成功触发事件，但由于100px往下的区域是符合条件的，会导致一直触发，这不是我们想要的。</p>
<p>接下来做一些处理，让其进入后只触发一次:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isReachBottom: false,</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">        let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">        let currentHeight &#x3D; scrollTop + offsetHeight + this.reachBottomDistance</span><br><span class="line"></span><br><span class="line">        if(currentHeight &lt; scrollHeight &amp;&amp; this.isReachBottom)&#123;</span><br><span class="line">          this.isReachBottom &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.isReachBottom)&#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">          this.isReachBottom &#x3D; true</span><br><span class="line">          console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8Dicribqic9sKlSTeB0CianJYNJMViaUdChLxbic397ItI3Gb0O8VhpoadpCSzAQA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>实时去获取位置信息稍微会损耗性能，我们应该把不变的缓存起来，只实时获取可变的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isReachBottom: false,</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">      scrollHeight: 0,</span><br><span class="line">      offsetHeight: 0,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    &#x2F;&#x2F; 页面加载完成后  将高度存储起来</span><br><span class="line">    let dom &#x3D; document.querySelector(&#39;.comment-area .comment-list&#39;)</span><br><span class="line">    this.scrollHeight &#x3D; dom.scrollHeight</span><br><span class="line">    this.offsetHeight &#x3D; Math.ceil(dom.getBoundingClientRect().height)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let currentHeight &#x3D; scrollTop + this.offsetHeight + this.reachBottomDistance</span><br><span class="line"></span><br><span class="line">        if(currentHeight &lt; this.scrollHeight &amp;&amp; this.isReachBottom)&#123;</span><br><span class="line">          this.isReachBottom &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.isReachBottom)&#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentHeight &gt;&#x3D; this.scrollHeight) &#123;</span><br><span class="line">          this.isReachBottom &#x3D; true</span><br><span class="line">          console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现到这里就告一段落，如果你有更好的思路和值得改进的地方，欢迎交流~</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>上拉加载</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之上拉加载原理</title>
    <url>/2020/09/16/vue%E4%B9%8B%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%89/</url>
    <content><![CDATA[<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>贴上效果展示：<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8DicribgBBbuvZ13dRfOBLsInRicV51f90TJDiblOfwq1LuN27vTaqssPfF5NeQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>样式方面不多赘述，滚动区域是给固定高度，设置 <code>overflow-y: auto</code> 来实现。</p>
<p>接下来看看js方面的实现，其实也很简单，触发的条件是：<code>可视高度</code> + <code>滚动距离</code> &gt;= <code>实际高度</code> 。例子我会使用<code>vue</code>来实现，和原生实现是一样的。</p>
<ul>
<li>可视高度(offsetHeight)：通过 <code>dom</code> 的 <code>offsetHeight</code> 获得，表示区域固定的高度。这里我推荐通过 <code>getBoundingClientRect()</code> 来获取高度，因为使用前者会引起浏览器回流，造成一些性能问题。</li>
<li>滚动高度(scrollTop)：滚动事件中通过 <code>e.target.scrollTop</code> 获取，表示滚动条距离顶部的px</li>
<li>实际高度(scrollHeight)：通过 <code>dom</code> 的 <code>scrollHeight</code> 获得，表示区域内所有内容的高度（包括滚动距离），也就是实际高度</li>
</ul>
<h1 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onScroll(e) &#123;</span><br><span class="line">    let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">    let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">    let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">    let currentHeight &#x3D; scrollTop + offsetHeight</span><br><span class="line">    if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">        console.log(&#39;触底&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8Dicribp9bOZENlSxoMU2MQtaNovYQXIb65qUPxKwWtTibqm9icMicOxXsFSUlMQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>so easy~</p>
<h1 id="加点细节"><a href="#加点细节" class="headerlink" title="加点细节"></a>加点细节</h1><p>加点细节，现在我们希望是离底部一定距离就触发事件，而不是等到完全触底。如果你做过小程序，这和<code>onReachBottom</code>差不多的意思。</p>
<p>声明一个离底部的距离变量<code>reachBottomDistance</code></p>
<p>这时候触发条件：<code>可视高度</code> + <code>滚动距离</code> + <code>reachBottomDistance</code> &gt;= <code>实际高度</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">        let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">        let currentHeight &#x3D; scrollTop + offsetHeight + this.reachBottomDistance</span><br><span class="line">        if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">            console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8DicribkC2ZSbcwoQfvEQdXUGzpzibj2IK0xQawxOm2q1t6L5N0Sj21Mmb2fJw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>在距离底部100px时成功触发事件，但由于100px往下的区域是符合条件的，会导致一直触发，这不是我们想要的。</p>
<p>接下来做一些处理，让其进入后只触发一次:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isReachBottom: false,</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let scrollHeight &#x3D; e.target.scrollHeight</span><br><span class="line">        let offsetHeight &#x3D; Math.ceil(e.target.getBoundingClientRect().height)</span><br><span class="line">        let currentHeight &#x3D; scrollTop + offsetHeight + this.reachBottomDistance</span><br><span class="line"></span><br><span class="line">        if(currentHeight &lt; scrollHeight &amp;&amp; this.isReachBottom)&#123;</span><br><span class="line">          this.isReachBottom &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.isReachBottom)&#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentHeight &gt;&#x3D; scrollHeight) &#123;</span><br><span class="line">          this.isReachBottom &#x3D; true</span><br><span class="line">          console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586usqMUQjWlJXNU83Pxk8Dicribqic9sKlSTeB0CianJYNJMViaUdChLxbic397ItI3Gb0O8VhpoadpCSzAQA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>实时去获取位置信息稍微会损耗性能，我们应该把不变的缓存起来，只实时获取可变的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isReachBottom: false,</span><br><span class="line">      reachBottomDistance: 100</span><br><span class="line">      scrollHeight: 0,</span><br><span class="line">      offsetHeight: 0,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    &#x2F;&#x2F; 页面加载完成后  将高度存储起来</span><br><span class="line">    let dom &#x3D; document.querySelector(&#39;.comment-area .comment-list&#39;)</span><br><span class="line">    this.scrollHeight &#x3D; dom.scrollHeight</span><br><span class="line">    this.offsetHeight &#x3D; Math.ceil(dom.getBoundingClientRect().height)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        let scrollTop &#x3D; e.target.scrollTop</span><br><span class="line">        let currentHeight &#x3D; scrollTop + this.offsetHeight + this.reachBottomDistance</span><br><span class="line"></span><br><span class="line">        if(currentHeight &lt; this.scrollHeight &amp;&amp; this.isReachBottom)&#123;</span><br><span class="line">          this.isReachBottom &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.isReachBottom)&#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentHeight &gt;&#x3D; this.scrollHeight) &#123;</span><br><span class="line">          this.isReachBottom &#x3D; true</span><br><span class="line">          console.log(&#39;触底&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现到这里就告一段落，如果你有更好的思路和值得改进的地方，欢迎交流~</p>
]]></content>
  </entry>
  <entry>
    <title>vue之实现一个6个输入框的验证码输入组件</title>
    <url>/2021/03/04/vue%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA6%E4%B8%AA%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>要实现的功能：</p>
<p>完全和单输入框一样的操作，甚至可以插入覆盖：<br>1，限制输入数字<br>2，正常输入<br>3，backspace删除<br>4，paste任意位置粘贴输入<br>5，光标选中一个数字，滚轮可以微调数字大小，限制0-9<br>6，123|456 自动覆盖光标后输入的字符，此时光标在3后，继续输入111，会得到123111，而不用手动删除456<br>7，封装成vue单文件组件，方便任意调用。</p>
<p>最终效果如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbLW2rcSXrkU3CUXfoWZQLvFvY0icKjdEfJBRsjVVqxYYiceb3DeiaVXbkkn3b8CbEnicBMXfM4Mvoabw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>模板代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;input-box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;input-content&quot; @keydown&#x3D;&quot;keydown&quot; @keyup&#x3D;&quot;keyup&quot; @paste&#x3D;&quot;paste&quot; @mousewheel&#x3D;&quot;mousewheel&quot;</span><br><span class="line">        @input&#x3D;&quot;inputEvent&quot;&gt;</span><br><span class="line">      &lt;input max&#x3D;&quot;9&quot; min&#x3D;&quot;0&quot; maxlength&#x3D;&quot;1&quot; data-index&#x3D;&quot;0&quot; v-model.trim.number&#x3D;&quot;input[0]&quot; type&#x3D;&quot;number&quot;</span><br><span class="line">          ref&#x3D;&quot;firstinput&quot;&#x2F;&gt;</span><br><span class="line">      &lt;input max&#x3D;&quot;9&quot; min&#x3D;&quot;0&quot; maxlength&#x3D;&quot;1&quot; data-index&#x3D;&quot;1&quot; v-model.trim.number&#x3D;&quot;input[1]&quot; type&#x3D;&quot;number&quot;&#x2F;&gt;</span><br><span class="line">      &lt;input max&#x3D;&quot;9&quot; min&#x3D;&quot;0&quot; maxlength&#x3D;&quot;1&quot; data-index&#x3D;&quot;2&quot; v-model.trim.number&#x3D;&quot;input[2]&quot; type&#x3D;&quot;number&quot;&#x2F;&gt;</span><br><span class="line">      &lt;input max&#x3D;&quot;9&quot; min&#x3D;&quot;0&quot; maxlength&#x3D;&quot;1&quot; data-index&#x3D;&quot;3&quot; v-model.trim.number&#x3D;&quot;input[3]&quot; type&#x3D;&quot;number&quot;&#x2F;&gt;</span><br><span class="line">      &lt;input max&#x3D;&quot;9&quot; min&#x3D;&quot;0&quot; maxlength&#x3D;&quot;1&quot; data-index&#x3D;&quot;4&quot; v-model.trim.number&#x3D;&quot;input[4]&quot; type&#x3D;&quot;number&quot;&#x2F;&gt;</span><br><span class="line">      &lt;input max&#x3D;&quot;9&quot; min&#x3D;&quot;0&quot; maxlength&#x3D;&quot;1&quot; data-index&#x3D;&quot;5&quot; v-model.trim.number&#x3D;&quot;input[5]&quot; type&#x3D;&quot;number&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>实现了键盘的keydown/keyup/paste/input和鼠标滚轮mousewheel事件<br>使用了6个输入框的方案来实现。</p>
<p>样式部分：使用了scss模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .input-box &#123;</span><br><span class="line">    .input-content &#123;</span><br><span class="line">      width: 512px;</span><br><span class="line">      height: 60px;</span><br><span class="line">      display: flex;</span><br><span class="line">      align-items: center;</span><br><span class="line">      justify-content: space-between;</span><br><span class="line"></span><br><span class="line">      input &#123;</span><br><span class="line">        color: inherit;</span><br><span class="line">        font-family: inherit;</span><br><span class="line">        border: 0;</span><br><span class="line">        outline: 0;</span><br><span class="line">        border-bottom: 1px solid #919191;</span><br><span class="line">        height: 60px;</span><br><span class="line">        width: 60px;</span><br><span class="line">        font-size: 44px;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input::-webkit-outer-spin-button,</span><br><span class="line">    input::-webkit-inner-spin-button &#123;</span><br><span class="line">      appearance: none;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>具体实现逻辑：主要实现以上几个键盘事件操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放粘贴进来的数字</span><br><span class="line">        pasteResult: [],</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: [&#39;code&#39;],</span><br><span class="line">    computed: &#123;</span><br><span class="line">      input() &#123;</span><br><span class="line">        &#x2F;&#x2F; code 是父组件传进来的默认值，必须是6位长度的数组，这里就不再做容错判断处理</span><br><span class="line">        &#x2F;&#x2F; 最后空数组是默认值</span><br><span class="line">        return this.code || this.pasteResult.length &#x3D;&#x3D;&#x3D; 6 ? this.pasteResult : [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      &#x2F;&#x2F; 解决一个输入框输入多个字符</span><br><span class="line">      inputEvent(e) &#123;</span><br><span class="line">        var index &#x3D; e.target.dataset.index * 1;</span><br><span class="line">        var el &#x3D; e.target;</span><br><span class="line">        this.$set(this.input, index, el.value.slice(0, 1))</span><br><span class="line">      &#125;,</span><br><span class="line">      keydown(e) &#123;</span><br><span class="line">        var index &#x3D; e.target.dataset.index * 1;</span><br><span class="line">        var el &#x3D; e.target;</span><br><span class="line">        if (e.key &#x3D;&#x3D;&#x3D; &#39;Backspace&#39;) &#123;</span><br><span class="line">          if (this.input[index].length &gt; 0) &#123;</span><br><span class="line">            this.$set(this.input, index, &#39;&#39;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if (el.previousElementSibling) &#123;</span><br><span class="line">              el.previousElementSibling.focus()</span><br><span class="line">              this.$set(this.input, index - 1, &#39;&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (e.key &#x3D;&#x3D;&#x3D; &#39;Delete&#39;) &#123;</span><br><span class="line">          if (this.input[index].length &gt; 0) &#123;</span><br><span class="line">            this.$set(this.input, index, &#39;&#39;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if (el.nextElementSibling) &#123;</span><br><span class="line">              this.$set(this.input, index &#x3D; 1, &#39;&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (el.nextElementSibling) &#123;</span><br><span class="line">            el.nextElementSibling.focus()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (e.key &#x3D;&#x3D;&#x3D; &#39;Home&#39;) &#123;</span><br><span class="line">          el.parentElement.children[0] &amp;&amp; el.parentElement.children[0].focus()</span><br><span class="line">        &#125; else if (e.key &#x3D;&#x3D;&#x3D; &#39;End&#39;) &#123;</span><br><span class="line">          el.parentElement.children[this.input.length - 1] &amp;&amp; el.parentElement.children[this.input.length - 1].focus()</span><br><span class="line">        &#125; else if (e.key &#x3D;&#x3D;&#x3D; &#39;ArrowLeft&#39;) &#123;</span><br><span class="line">          if (el.previousElementSibling) &#123;</span><br><span class="line">            el.previousElementSibling.focus()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (e.key &#x3D;&#x3D;&#x3D; &#39;ArrowRight&#39;) &#123;</span><br><span class="line">          if (el.nextElementSibling) &#123;</span><br><span class="line">            el.nextElementSibling.focus()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (e.key &#x3D;&#x3D;&#x3D; &#39;ArrowUp&#39;) &#123;</span><br><span class="line">          if (this.input[index] * 1 &lt; 9) &#123;</span><br><span class="line">            this.$set(this.input, index, (this.input[index] * 1 + 1).toString());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (e.key &#x3D;&#x3D;&#x3D; &#39;ArrowDown&#39;) &#123;</span><br><span class="line">          if (this.input[index] * 1 &gt; 0) &#123;</span><br><span class="line">            this.$set(this.input, index, (this.input[index] * 1 - 1).toString());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      keyup(e) &#123;</span><br><span class="line">        var index &#x3D; e.target.dataset.index * 1;</span><br><span class="line">        var el &#x3D; e.target;</span><br><span class="line">        if (&#x2F;Digit|Numpad&#x2F;i.test(e.code)) &#123;</span><br><span class="line">          this.$set(this.input, index, e.code.replace(&#x2F;Digit|Numpad&#x2F;i, &#39;&#39;));</span><br><span class="line">          el.nextElementSibling &amp;&amp; el.nextElementSibling.focus();</span><br><span class="line">          if (index &#x3D;&#x3D;&#x3D; 5) &#123;</span><br><span class="line">            if (this.input.join(&#39;&#39;).length &#x3D;&#x3D;&#x3D; 6) &#123;</span><br><span class="line">              document.activeElement.blur();</span><br><span class="line">              this.$emit(&#39;complete&#39;, this.input);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          if (this.input[index] &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">            this.$set(this.input, index, &#39;&#39;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      mousewheel(e) &#123;</span><br><span class="line">        var index &#x3D; e.target.dataset.index;</span><br><span class="line">        if (e.wheelDelta &gt; 0) &#123;</span><br><span class="line">          if (this.input[index] * 1 &lt; 9) &#123;</span><br><span class="line">            this.$set(this.input, index, (this.input[index] * 1 + 1).toString());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (e.wheelDelta &lt; 0) &#123;</span><br><span class="line">          if (this.input[index] * 1 &gt; 0) &#123;</span><br><span class="line">            this.$set(this.input, index, (this.input[index] * 1 - 1).toString());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (e.key &#x3D;&#x3D;&#x3D; &#39;Enter&#39;) &#123;</span><br><span class="line">          if (this.input.join(&#39;&#39;).length &#x3D;&#x3D;&#x3D; 6) &#123;</span><br><span class="line">            document.activeElement.blur();</span><br><span class="line">            this.$emit(&#39;complete&#39;, this.input);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      paste(e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当进行粘贴时</span><br><span class="line">        e.clipboardData.items[0].getAsString(str &#x3D;&gt; &#123;</span><br><span class="line">          if (str.toString().length &#x3D;&#x3D;&#x3D; 6) &#123;</span><br><span class="line">            this.pasteResult &#x3D; str.split(&#39;&#39;);</span><br><span class="line">            document.activeElement.blur();</span><br><span class="line">            this.$emit(&#39;complete&#39;, this.input);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      &#x2F;&#x2F; 等待dom渲染完成，在执行focus,否则无法获取到焦点</span><br><span class="line">      this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">        this.$refs.firstinput.focus()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之引入svg矢量图标</title>
    <url>/2021/03/01/vue%E4%B9%8B%E5%BC%95%E5%85%A5svg%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="Vue项目中使用svg图标-需要重新npm-run-dev"><a href="#Vue项目中使用svg图标-需要重新npm-run-dev" class="headerlink" title="Vue项目中使用svg图标(需要重新npm run dev)"></a>Vue项目中使用svg图标(需要重新npm run dev)</h2><h4 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h4><p>1.安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install svg-sprite-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>2.配置build文件夹中的webpack.base.conf.js，主要在两个地方添加代码，如下图所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exclude: [resolve(&#39;src&#x2F;icons&#39;)],</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: &#x2F;\.svg$&#x2F;,</span><br><span class="line">        loader: &#39;svg-sprite-loader&#39;,</span><br><span class="line">        include: [resolve(&#39;src&#x2F;icons&#39;)],</span><br><span class="line">        options: &#123;</span><br><span class="line">          symbolId: &#39;icon-[name]&#39;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p> <img src="https://img2018.cnblogs.com/blog/1320274/201902/1320274-20190213172248614-856859048.png" alt="img"></p>
<p>3.在src/components下新建文件夹及文件SvgIcon/index.vue，index.vue中内容如下</p>
<p><img src="https://img2018.cnblogs.com/blog/1320274/201902/1320274-20190213172446241-453546490.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;svg :class&#x3D;&quot;svgClass&quot; aria-hidden&#x3D;&quot;true&quot; v-on&#x3D;&quot;$listeners&quot;&gt;</span><br><span class="line">    &lt;use :xlink:href&#x3D;&quot;iconName&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;svg&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;SvgIcon&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      iconClass: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        required: true</span><br><span class="line">      &#125;,</span><br><span class="line">      className: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      iconName() &#123;</span><br><span class="line">        return &#96;#icon-$&#123;this.iconClass&#125;&#96;</span><br><span class="line">      &#125;,</span><br><span class="line">      svgClass() &#123;</span><br><span class="line">        if (this.className) &#123;</span><br><span class="line">          return &#39;svg-icon &#39; + this.className</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return &#39;svg-icon&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .svg-icon &#123;</span><br><span class="line">    width: 1em;</span><br><span class="line">    height: 1em;</span><br><span class="line">    vertical-align: -0.15em;</span><br><span class="line">    fill: currentColor;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>4.在src下新建icons文件夹，及icons文件夹下svg文件夹、index.js文件， index.js文件内容如下</p>
<p><img src="https://img2018.cnblogs.com/blog/1320274/201902/1320274-20190213172928086-1928999179.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import SvgIcon from &#39;@&#x2F;components&#x2F;SvgIcon&#39;&#x2F;&#x2F; svg组件</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; register globally</span><br><span class="line">Vue.component(&#39;svg-icon&#39;, SvgIcon)</span><br><span class="line"> </span><br><span class="line">const req &#x3D; require.context(&#39;.&#x2F;svg&#39;, false, &#x2F;\.svg$&#x2F;)</span><br><span class="line">const requireAll &#x3D; requireContext &#x3D;&gt; requireContext.keys().map(requireContext)</span><br><span class="line">requireAll(req)</span><br></pre></td></tr></table></figure>

<p>5.在main.js中引入svg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;.&#x2F;icons&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1320274/201902/1320274-20190213173418873-138542214.png" alt="img"></p>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>1.下载svg图片，这里使用阿里云提供的iconfont：<a href="https://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.4&amp;type=1" target="_blank" rel="noopener">https://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.4&amp;type=1</a></p>
<p>2.点击图片，下载svg格式即可，将下载下来的图片放置到到项目中的svg文件夹下</p>
<p><img src="https://img2018.cnblogs.com/blog/1320274/201902/1320274-20190214084831123-802190607.png" alt="img"></p>
<p>3.在页面中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;svg-icon icon-class&#x3D;&quot;test&quot;&gt;&lt;&#x2F;svg-icon&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1320274/201902/1320274-20190214084923686-260663094.png" alt="img"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之性能优化</title>
    <url>/2021/03/17/vue%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>参考链接：<a href="https://mp.weixin.qq.com/s/uJ5-O4d4DqR2sIQzDqKVQw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uJ5-O4d4DqR2sIQzDqKVQw</a></p>
<h2 id="一、代码层面的优化"><a href="#一、代码层面的优化" class="headerlink" title="一、代码层面的优化"></a>一、代码层面的优化</h2><h3 id="1-1、v-if-和-v-show-区分使用场景"><a href="#1-1、v-if-和-v-show-区分使用场景" class="headerlink" title="1.1、v-if 和 v-show 区分使用场景"></a>1.1、v-if 和 v-show 区分使用场景</h3><p><strong>v-if</strong> 是 <strong>真正</strong> 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p><strong>v-show</strong> 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<a id="more"></a> 

<h3 id="1-2、computed-和-watch-区分使用场景"><a href="#1-2、computed-和-watch-区分使用场景" class="headerlink" title="1.2、computed 和 watch 区分使用场景"></a>1.2、computed 和 watch 区分使用场景</h3><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h3><p><strong>（1）v-for 遍历必须为 item 添加 key</strong></p>
<p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p>
<p><strong>（2）v-for 遍历避免同时使用 v-if</strong></p>
<p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p>
<p><strong>推荐：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-for&#x3D;&quot;user in activeUsers&quot;</span><br><span class="line">    :key&#x3D;&quot;user.id&quot;&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">computed: &#123;</span><br><span class="line">  activeUsers: function () &#123;</span><br><span class="line">    return this.users.filter(function (user) &#123;</span><br><span class="line"> return user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>不推荐：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">    v-if&#x3D;&quot;user.isActive&quot;</span><br><span class="line">    :key&#x3D;&quot;user.id&quot;&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="1-4、长列表性能优化"><a href="#1-4、长列表性能优化" class="headerlink" title="1.4、长列表性能优化"></a>1.4、长列表性能优化</h3><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data: () &#x3D;&gt; (&#123;</span><br><span class="line">    users: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  async created() &#123;</span><br><span class="line">    const users &#x3D; await axios.get(&quot;&#x2F;api&#x2F;users&quot;);</span><br><span class="line">    this.users &#x3D; Object.freeze(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="1-5、事件的销毁"><a href="#1-5、事件的销毁" class="headerlink" title="1.5、事件的销毁"></a>1.5、事件的销毁</h3><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  addEventListener(&#39;click&#39;, this.click, false)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  removeEventListener(&#39;click&#39;, this.click, false)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="1-6、图片资源懒加载"><a href="#1-6、图片资源懒加载" class="headerlink" title="1.6、图片资源懒加载"></a>1.6、图片资源懒加载</h3><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</p>
<p>（1）安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-lazyload --save-dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>（2）在入口文件 man.js 中引入并使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueLazyload from &#39;vue-lazyload&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后再 vue 中直接使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.use(VueLazyload)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>或者添加自定义选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">preLoad: 1.3,</span><br><span class="line">error: &#39;dist&#x2F;error.png&#39;,</span><br><span class="line">loading: &#39;dist&#x2F;loading.gif&#39;,</span><br><span class="line">attempt: 1</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img v-lazy&#x3D;&quot;&#x2F;static&#x2F;img&#x2F;1.png&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。</p>
<h3 id="1-7、路由懒加载"><a href="#1-7、路由懒加载" class="headerlink" title="1.7、路由懒加载"></a>1.7、路由懒加载</h3><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p>
<p><strong>路由懒加载：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo &#x3D; () &#x3D;&gt; import(&#39;.&#x2F;Foo.vue&#39;)</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;foo&#39;, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="1-8、第三方插件的按需引入"><a href="#1-8、第三方插件的按需引入" class="headerlink" title="1.8、第三方插件的按需引入"></a>1.8、第三方插件的按需引入</h3><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 <code>babel-plugin-component</code> ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：</p>
<p>（1）首先，安装 <code>babel-plugin-component</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>（2）然后，将 .babelrc 修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class="line">        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>（3）在 main.js 中引入部分组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import &#123; Button, Select &#125; from &#39;element-ui&#39;;</span><br><span class="line"></span><br><span class="line"> Vue.use(Button)</span><br><span class="line"> Vue.use(Select)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="1-9、优化无限列表性能"><a href="#1-9、优化无限列表性能" class="headerlink" title="1.9、优化无限列表性能"></a>1.9、优化无限列表性能</h3><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的。</p>
<h3 id="1-10、服务端渲染-SSR-or-预渲染"><a href="#1-10、服务端渲染-SSR-or-预渲染" class="headerlink" title="1.10、服务端渲染 SSR or 预渲染"></a>1.10、服务端渲染 SSR or 预渲染</h3><p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
<p><strong>（1）服务端渲染的优点：</strong></p>
<ul>
<li>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p><strong>（2）服务端渲染的缺点：</strong></p>
<ul>
<li>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<p>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如  <code>/， /about， /contac</code>t 等）的 SEO，那么你可能需要<strong>预渲染</strong>，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</p>
<h2 id="二、Webpack-层面的优化"><a href="#二、Webpack-层面的优化" class="headerlink" title="二、Webpack 层面的优化"></a>二、Webpack 层面的优化</h2><h3 id="2-1、Webpack-对图片进行压缩"><a href="#2-1、Webpack-对图片进行压缩" class="headerlink" title="2.1、Webpack 对图片进行压缩"></a>2.1、Webpack 对图片进行压缩</h3><p>在 vue 项目中除了可以在 <code>webpack.base.conf.js</code> 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 <code>image-webpack-loader</code>来压缩图片：</p>
<p>（1）首先，安装 image-webpack-loader ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install image-webpack-loader --save-dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>（2）然后，在 webpack.base.conf.js 中进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.(png|jpe?g|gif|svg)(\?.*)?$&#x2F;,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: &#39;url-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: 10000,</span><br><span class="line">      name: utils.assetsPath(&#39;img&#x2F;[name].[hash:7].[ext]&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#39;image-webpack-loader&#39;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: true,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="2-2、减少-ES6-转为-ES5-的冗余代码"><a href="#2-2、减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="2.2、减少 ES6 转为 ES5 的冗余代码"></a>2.2、减少 ES6 转为 ES5 的冗余代码</h3><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HelloWebpack extends Component&#123;...&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">babel-runtime&#x2F;helpers&#x2F;createClass  &#x2F;&#x2F; 用于实现 class 语法</span><br><span class="line">babel-runtime&#x2F;helpers&#x2F;inherits  &#x2F;&#x2F; 用于实现 extends 语法</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 <code>require(&#39;babel-runtime/helpers/createClass&#39;)</code> 的方式导入，这样就能做到只让它们出现一次。<code>babel-plugin-transform-runtime</code> 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p>
<p>（1）首先，安装 <code>babel-plugin-transform-runtime</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-transform-runtime --save-dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>（2）然后，修改 .babelrc 配置文件为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime 的 详细介绍。</p>
<h3 id="2-3、提取公共代码"><a href="#2-3、提取公共代码" class="headerlink" title="2.3、提取公共代码"></a>2.3、提取公共代码</h3><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p>
<ul>
<li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li>
<li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</li>
</ul>
<p>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &#39;vendor&#39;,</span><br><span class="line">  minChunks: function(module, count) &#123;</span><br><span class="line">    return (</span><br><span class="line">      module.resource &amp;&amp;</span><br><span class="line">      &#x2F;\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class="line">      module.resource.indexOf(</span><br><span class="line">        path.join(__dirname, &#39;..&#x2F;node_modules&#39;)</span><br><span class="line">      ) &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line">&#x2F;&#x2F; 抽取出代码模块的映射关系</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &#39;manifest&#39;,</span><br><span class="line">  chunks: [&#39;vendor&#39;]</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。</p>
<h3 id="2-4、模板预编译"><a href="#2-4、模板预编译" class="headerlink" title="2.4、模板预编译"></a>2.4、模板预编译</h3><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p>
<p>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。</p>
<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>
<h3 id="2-5、提取组件的-CSS"><a href="#2-5、提取组件的-CSS" class="headerlink" title="2.5、提取组件的 CSS"></a>2.5、提取组件的 CSS</h3><p>当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</p>
<p>查阅这个构建工具各自的文档来了解更多：</p>
<ul>
<li>webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)</li>
<li>Browserify + vueify</li>
<li>Rollup + rollup-plugin-vue</li>
</ul>
<h3 id="2-6、优化-SourceMap"><a href="#2-6、优化-SourceMap" class="headerlink" title="2.6、优化 SourceMap"></a>2.6、优化 SourceMap</h3><p>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。</p>
<p>SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uuZnAApLr38mFVUApdS1l7pxWJBXQWCcpo02gia9Py9xx27CvQOnOmVEkJtKXibzcCCtJuRl9Ujwx3Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">1.png</p>
<p><strong>开发环境推荐：cheap-module-eval-source-map</strong></p>
<p><strong>生产环境推荐：cheap-module-source-map</strong></p>
<p>原因如下：</p>
<ul>
<li><strong>cheap</strong>：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</li>
<li><strong>module</strong> ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</li>
<li><strong>soure-map</strong> ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</li>
<li><strong>eval-source-map</strong>：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</li>
</ul>
<h3 id="2-7、构建结果输出分析"><a href="#2-7、构建结果输出分析" class="headerlink" title="2.7、构建结果输出分析"></a>2.7、构建结果输出分析</h3><p>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：<code>webpack-bundle-analyzer</code> 。</p>
<p>我们在项目中 <code>webpack.prod.conf.js</code> 进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  var BundleAnalyzerPlugin &#x3D;   require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;</span><br><span class="line">  webpackConfig.plugins.push(new BundleAnalyzerPlugin());</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>执行 <code>$ npm run build \--report</code> 后生成分析报告如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586uuZnAApLr38mFVUApdS1l7pTU6eP6ic6c4IT4h26QO5h8jkiaiajylBbRAuqyMtjs7zbGWOvoC1E2icEQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片">1.png</p>
<h3 id="2-8、Vue-项目的编译优化"><a href="#2-8、Vue-项目的编译优化" class="headerlink" title="2.8、Vue 项目的编译优化"></a>2.8、Vue 项目的编译优化</h3><p>如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。具体如何进行 Vue 项目的 Webpack 构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》</p>
<h2 id="三、基础的-Web-技术优化"><a href="#三、基础的-Web-技术优化" class="headerlink" title="三、基础的 Web 技术优化"></a>三、基础的 Web 技术优化</h2><h3 id="3-1、开启-gzip-压缩"><a href="#3-1、开启-gzip-压缩" class="headerlink" title="3.1、开启 gzip 压缩"></a>3.1、开启 gzip 压缩</h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右</p>
<p>以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下：</p>
<ul>
<li>安装：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install compression --save</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>添加代码逻辑：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var compression &#x3D; require(&#39;compression&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line">app.use(compression())</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uuZnAApLr38mFVUApdS1l7p2GGE5klNlnnqE31bjibxSzmcrVe6HDXVILuicMUC0rycY4T8smKNXNvw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">1.png</p>
</li>
</ul>
<h3 id="3-2、浏览器缓存"><a href="#3-2、浏览器缓存" class="headerlink" title="3.2、浏览器缓存"></a>3.2、浏览器缓存</h3><p>为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解HTTP缓存机制及原理》，这里不再赘述。</p>
<h3 id="3-3、CDN-的使用"><a href="#3-3、CDN-的使用" class="headerlink" title="3.3、CDN 的使用"></a>3.3、CDN 的使用</h3><p>浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p>
<h3 id="3-4、使用-Chrome-Performance-查找性能瓶颈"><a href="#3-4、使用-Chrome-Performance-查找性能瓶颈" class="headerlink" title="3.4、使用 Chrome Performance 查找性能瓶颈"></a>3.4、使用 Chrome Performance 查找性能瓶颈</h3><p>Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。</p>
<ol>
<li>打开 Chrome 开发者工具，切换到 Performance 面板</li>
<li>点击 Record 开始录制</li>
<li>刷新页面或展开某个节点</li>
<li>点击 Stop 停止录制</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz/1NOXMW586uuZnAApLr38mFVUApdS1l7pVB8h36MDeQMVnx3KGEjjCoP2aY0YmichWEED4z9rYpurYL3zwQjS2gA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之惯性滚动动效</title>
    <url>/2020/09/23/vue%E4%B9%8B%E6%83%AF%E6%80%A7%E6%BB%9A%E5%8A%A8%E5%8A%A8%E6%95%88/</url>
    <content><![CDATA[<p>见下文</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ref</span>=<span class="string">"wrapper"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchstart.prevent</span>=<span class="string">"onStart"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchmove.prevent</span>=<span class="string">"onMove"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchend.prevent</span>=<span class="string">"onEnd"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">touchcancel.prevent</span>=<span class="string">"onEnd"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">transitionend</span>=<span class="string">"onTransitionEnd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">ref</span>=<span class="string">"scroller"</span> <span class="attr">:style</span>=<span class="string">"scrollerStyle"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">        template: <span class="string">'#tpl'</span>,</span></span><br><span class="line">        computed: &#123;</span><br><span class="line">          list() &#123;&#125;,</span><br><span class="line">          scrollerStyle() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="string">'transform'</span>: <span class="string">`translate3d(0, <span class="subst">$&#123;<span class="keyword">this</span>.offsetY&#125;</span>px, 0)`</span>,</span></span><br><span class="line"><span class="javascript">              <span class="string">'transition-duration'</span>: <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.duration&#125;</span>ms`</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'transition-timing-function'</span>: <span class="keyword">this</span>.bezier,</span></span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line">            minY: 0,</span><br><span class="line">            maxY: 0,</span><br><span class="line">            wrapperHeight: 0,</span><br><span class="line">            duration: 0,</span><br><span class="line"><span class="actionscript">            bezier: <span class="string">'linear'</span>,</span></span><br><span class="line"><span class="actionscript">            pointY: <span class="number">0</span>,                    <span class="comment">// touchStart 手势 y 坐标</span></span></span><br><span class="line"><span class="actionscript">            startY: <span class="number">0</span>,                    <span class="comment">// touchStart 元素 y 偏移值</span></span></span><br><span class="line"><span class="actionscript">            offsetY: <span class="number">0</span>,                   <span class="comment">// 元素实时 y 偏移值</span></span></span><br><span class="line"><span class="actionscript">            startTime: <span class="number">0</span>,                 <span class="comment">// 惯性滑动范围内的 startTime</span></span></span><br><span class="line"><span class="actionscript">            momentumStartY: <span class="number">0</span>,            <span class="comment">// 惯性滑动范围内的 startY</span></span></span><br><span class="line"><span class="actionscript">            momentumTimeThreshold: <span class="number">300</span>,   <span class="comment">// 惯性滑动的启动 时间阈值</span></span></span><br><span class="line"><span class="actionscript">            momentumYThreshold: <span class="number">15</span>,       <span class="comment">// 惯性滑动的启动 距离阈值</span></span></span><br><span class="line"><span class="actionscript">            isStarted: <span class="literal">false</span>,             <span class="comment">// start锁</span></span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.wrapperHeight = <span class="keyword">this</span>.$refs.wrapper.getBoundingClientRect().height;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.minY = <span class="keyword">this</span>.wrapperHeight - <span class="keyword">this</span>.$refs.scroller.getBoundingClientRect().height;</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          onStart(e) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> point = e.touches ? e.touches[<span class="number">0</span>] : e;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.isStarted = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.duration = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.stop();</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.pointY = point.pageY;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.momentumStartY = <span class="keyword">this</span>.startY = <span class="keyword">this</span>.offsetY;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line">          &#125;,</span><br><span class="line">          onMove(e) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isStarted) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> point = e.touches ? e.touches[<span class="number">0</span>] : e;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> deltaY = point.pageY - <span class="keyword">this</span>.pointY;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.offsetY = <span class="built_in">Math</span>.round(<span class="keyword">this</span>.startY + deltaY);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 记录在触发惯性滑动条件下的偏移值和时间</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (now - <span class="keyword">this</span>.startTime &gt; <span class="keyword">this</span>.momentumTimeThreshold) &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.momentumStartY = <span class="keyword">this</span>.offsetY;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.startTime = now;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onEnd(e) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isStarted) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.isStarted = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.isNeedReset()) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> absDeltaY = <span class="built_in">Math</span>.abs(<span class="keyword">this</span>.offsetY - <span class="keyword">this</span>.momentumStartY);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> duration = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - <span class="keyword">this</span>.startTime;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 启动惯性滑动</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (duration &lt; <span class="keyword">this</span>.momentumTimeThreshold &amp;&amp; absDeltaY &gt; <span class="keyword">this</span>.momentumYThreshold) &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">const</span> momentum = <span class="keyword">this</span>.momentum(<span class="keyword">this</span>.offsetY, <span class="keyword">this</span>.momentumStartY, duration);</span></span><br><span class="line"><span class="javascript">              <span class="keyword">this</span>.offsetY = <span class="built_in">Math</span>.round(momentum.destination);</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.duration = momentum.duration;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.bezier = momentum.bezier;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onTransitionEnd() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.isNeedReset();</span></span><br><span class="line">          &#125;,</span><br><span class="line">          momentum(current, start, duration) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> durationMap = &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="string">'noBounce'</span>: <span class="number">2500</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'weekBounce'</span>: <span class="number">800</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'strongBounce'</span>: <span class="number">400</span>,</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> bezierMap = &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="string">'noBounce'</span>: <span class="string">'cubic-bezier(.17, .89, .45, 1)'</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'weekBounce'</span>: <span class="string">'cubic-bezier(.25, .46, .45, .94)'</span>,</span></span><br><span class="line"><span class="actionscript">              <span class="string">'strongBounce'</span>: <span class="string">'cubic-bezier(.25, .46, .45, .94)'</span>,</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> type = <span class="string">'noBounce'</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 惯性滑动加速度</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> deceleration = <span class="number">0.003</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 回弹阻力</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> bounceRate = <span class="number">10</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 强弱回弹的分割值</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> bounceThreshold = <span class="number">300</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 回弹的最大限度</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> maxOverflowY = <span class="keyword">this</span>.wrapperHeight / <span class="number">6</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> overflowY;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> distance = current - start;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> speed = <span class="number">2</span> * <span class="built_in">Math</span>.abs(distance) / duration;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> destination = current + speed / deceleration * (distance &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (destination &lt; <span class="keyword">this</span>.minY) &#123;</span></span><br><span class="line"><span class="actionscript">              overflowY = <span class="keyword">this</span>.minY - destination;</span></span><br><span class="line"><span class="actionscript">              type = overflowY &gt; bounceThreshold ? <span class="string">'strongBounce'</span> : <span class="string">'weekBounce'</span>;</span></span><br><span class="line"><span class="javascript">              destination = <span class="built_in">Math</span>.max(<span class="keyword">this</span>.minY - maxOverflowY, <span class="keyword">this</span>.minY - overflowY / bounceRate);</span></span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (destination &gt; <span class="keyword">this</span>.maxY) &#123;</span></span><br><span class="line"><span class="actionscript">              overflowY = destination - <span class="keyword">this</span>.maxY;</span></span><br><span class="line"><span class="actionscript">              type = overflowY &gt; bounceThreshold ? <span class="string">'strongBounce'</span> : <span class="string">'weekBounce'</span>;</span></span><br><span class="line"><span class="javascript">              destination = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.maxY + maxOverflowY, <span class="keyword">this</span>.maxY + overflowY / bounceRate);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">              destination,</span><br><span class="line">              duration: durationMap[type],</span><br><span class="line">              bezier: bezierMap[type],</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          <span class="comment">// 超出边界时需要重置位置</span></span></span><br><span class="line">          isNeedReset() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> offsetY;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.offsetY &lt; <span class="keyword">this</span>.minY) &#123;</span></span><br><span class="line"><span class="actionscript">              offsetY = <span class="keyword">this</span>.minY;</span></span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.offsetY &gt; <span class="keyword">this</span>.maxY) &#123;</span></span><br><span class="line"><span class="actionscript">              offsetY = <span class="keyword">this</span>.maxY;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">typeof</span> offsetY !== <span class="string">'undefined'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.offsetY = offsetY;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.duration = <span class="number">500</span>;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.bezier = <span class="string">'cubic-bezier(.165, .84, .44, 1)'</span>;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          <span class="comment">// 停止滚动</span></span></span><br><span class="line">          stop() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> matrix = <span class="built_in">window</span>.getComputedStyle(<span class="keyword">this</span>.$refs.scroller).getPropertyValue(<span class="string">'transform'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.offsetY = <span class="built_in">Math</span>.round(+matrix.split(<span class="string">')'</span>)[<span class="number">0</span>].split(<span class="string">', '</span>)[<span class="number">5</span>]);</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>滚动</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之解决vue-cli打包后单个文件过大的问题</title>
    <url>/2021/03/16/vue%E4%B9%8B%E8%A7%A3%E5%86%B3vue-cli%E6%89%93%E5%8C%85%E5%90%8E%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="0-如何打包后在本地打开dist下的index-html"><a href="#0-如何打包后在本地打开dist下的index-html" class="headerlink" title="0.如何打包后在本地打开dist下的index.html"></a>0.如何打包后在本地打开dist下的index.html</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g serve</span><br><span class="line"></span><br><span class="line">serve -s dist</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-借助webpack-bundle-analyzer帮助分析"><a href="#1-借助webpack-bundle-analyzer帮助分析" class="headerlink" title="1.借助webpack-bundle-analyzer帮助分析"></a>1.借助webpack-bundle-analyzer帮助分析</h2><p>tips: 在cli3.0中该插件已经配置好了，如下是cli4.0的配置方法</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>首先安装webpack-bundle-analyzer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure>

<p>然后在项目根目录创建vue.config.js，然后在文件中写入以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const WebpackBundleAnalyzerPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">        plugins: [new WebpackBundleAnalyzerPlugin()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>yarn build</code> 在浏览器会自动打开我们的使用包分析文件</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer --save-dev</span><br></pre></td></tr></table></figure>

<p>vue.config.js配置</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config</span><br><span class="line">            .plugin(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">            .use(<span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-打包时排除Vue和ElementUI"><a href="#2-打包时排除Vue和ElementUI" class="headerlink" title="2.打包时排除Vue和ElementUI"></a>2.打包时排除Vue和ElementUI</h2><p>第一步：<br>在vue.config.js 中添加 externals来告诉webpack我们这些第三方库不需要打包</p>
<p><img src="/2021/03/16/vue%E4%B9%8B%E8%A7%A3%E5%86%B3vue-cli%E6%89%93%E5%8C%85%E5%90%8E%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98/C:%5CUsers%5Cdali%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210316181612158.png" alt="image-20210316181612158"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.set(&#39;externals&#39;,&#123;</span><br><span class="line">	&#39;element-ui&#39;: &#39;Eleme	</span><br><span class="line">	&#39;vue&#39;: &#39;Vue&#39;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>修改 main.js 注释掉 Vue 和 ElementUI</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; import Vue from &#39;vue&#39;</span><br><span class="line">&#x2F;&#x2F; import ElementUI from &#39;element-ui&#39;</span><br><span class="line">&#x2F;&#x2F; import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br></pre></td></tr></table></figure>



<p><strong>修改 index.html CDN引入 Vue 和 ElementUI<br>注意，一定要锁版本，使用@来指定引入第三方js的版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入样式 --&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui@2.4.6&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;!-- 引入js --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.6.10&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui@2.4.6&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="3-解决在首页加载的时候依然会把其他页面需要的组件的js文件和css文件进行请求加载"><a href="#3-解决在首页加载的时候依然会把其他页面需要的组件的js文件和css文件进行请求加载" class="headerlink" title="3.解决在首页加载的时候依然会把其他页面需要的组件的js文件和css文件进行请求加载"></a>3.解决在首页加载的时候依然会把其他页面需要的组件的js文件和css文件进行请求加载</h2><p>tips：按需加载如果不更改prefetch，仍然会将所有的js在首页一次性全部加载结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    chainWebpack(config) &#123;</span><br><span class="line">        &#x2F;&#x2F; 移除 prefetch 插件（解决首次进入页面所有资源预加载）</span><br><span class="line">        config.plugins.delete(&#39;prefetch&#39;);</span><br><span class="line">        &#x2F;&#x2F;  或者 &#x2F;&#x2F; 修改prefetch：</span><br><span class="line">        &#x2F;&#x2F; config.plugin(&#39;prefetch&#39;).tap(options &#x3D;&gt; &#123; </span><br><span class="line">        &#x2F;&#x2F;   options[0].fileBlacklist &#x3D; options[0].fileBlacklist || [] </span><br><span class="line">        &#x2F;&#x2F;   options[0].fileBlacklist.push(&#x2F;myasyncRoute(.)+?\.js$&#x2F;) </span><br><span class="line">        &#x2F;&#x2F;   return options </span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">第一种方法比较好用</span><br></pre></td></tr></table></figure>



<h2 id="4-隐藏-放开js-map或者css-map文件"><a href="#4-隐藏-放开js-map或者css-map文件" class="headerlink" title="4.隐藏/放开js.map或者css.map文件"></a>4.隐藏/放开js.map或者css.map文件</h2><p>在vue.config.js 中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    productionSourceMap: false,</span><br><span class="line">    css: &#123;</span><br><span class="line">        extract: false, &#x2F;&#x2F; 是否使用css分离插件 ExtractTextPlugin</span><br><span class="line">        sourceMap: true &#x2F;&#x2F; 开启 CSS source maps?</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-使用路由懒加载的不同写法"><a href="#5-使用路由懒加载的不同写法" class="headerlink" title="5.使用路由懒加载的不同写法"></a>5.使用路由懒加载的不同写法</h2><p>写法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo &#x3D; () &#x3D;&gt; import(&#39;.&#x2F;Foo.vue&#39;)</span><br><span class="line"></span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;foo&#39;, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>写法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo &#x3D; (resolve) &#x3D;&gt; &#123;</span><br><span class="line">  import(&#39;components&#x2F;Foo.vue&#39;).then((module) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(module)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;foo&#39;, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>写法三 (最简单)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;foo&#39;, component: ()&#x3D;&gt;import(&#39;components&#x2F;Foo.vue&#39;) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6-关于process-env-NODE-ENV"><a href="#6-关于process-env-NODE-ENV" class="headerlink" title="6.关于process.env.NODE_ENV"></a>6.关于process.env.NODE_ENV</h2><p>相信大家在开发的时候一定会有跟多个开发环境，比如development/feature/sandbox/production，因为这玩意我真是吃了大亏，刚开始没看文档， 直接在执行package.json的script命令的时候通过cross-env NODE_ENV=xxx 来修改环境变量，导致无法使用vue-cli工具为我们提供的代码优化功能</p>
<p>注意: process.env_NODE_ENV的值只能为<code>development</code>、<code>production</code>，不要修改为其他值，不然可能会出现其他问题，如果你真的想在不同的环境使用不同的接口地址或者、其他的内容我们可以用vue-cli为我们提供的<code>--mode</code>达到目的，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;build:sanbox&quot;: &quot;vue-cli-service build --mode sanbox&quot;,</span><br><span class="line">    &quot;build:feature&quot;: &quot;vue-cli-service build --mode feature&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;,</span><br><span class="line">    &quot;precommit&quot;: &quot;yarn lint&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里vue-cli会读取项目根目录下的.env.xxx相关文件，–mode会修改process.env.NODE_ENV的值，我们需要再对应的env里面把NODE_ENV改写回来，比如一个<code>.env.sanbox</code>环境代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_ENV&#x3D;&#39;production&#39;</span><br><span class="line">VUE_APP_ENV&#x3D;&#39;sanbox&#39;</span><br></pre></td></tr></table></figure>

<p>当我们执行<code>yarn build:sanbox</code>的时候就会加载这个文件，我们可以通过<code>process.env.VUE_APP_ENV</code>来访问对应设置的值，注意只有<code>VIE_APP_</code>前缀的环境变量才会被<code>webpack.DefinePlugin</code>静态嵌入到客户端侧的包中。</p>
<p>比如我们需要不同的构建命令构建不同的的publicPath的时候我们可以这样做</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = &#123;</span><br><span class="line">    production: <span class="string">'/'</span>,</span><br><span class="line">    feature: <span class="string">'/feature'</span>,</span><br><span class="line">    sanbox: <span class="string">'/sanbox'</span>,</span><br><span class="line">    development: <span class="string">'/development'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> env = process.env.VUE_APP_ENV</span><br><span class="line"><span class="keyword">const</span> publicPath =  map[env]</span><br><span class="line"><span class="keyword">const</span> PATH = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> WebpackBundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    publicPath,</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">        externals: &#123;</span><br><span class="line">            <span class="string">"lodash"</span>: <span class="string">'_'</span>,</span><br><span class="line">            <span class="string">"qiniu"</span>: <span class="string">'qiniu'</span>,</span><br><span class="line">            <span class="string">"vue"</span>: <span class="string">'Vue'</span>,</span><br><span class="line">            <span class="string">"echarts"</span>: <span class="string">'echarts'</span>,</span><br><span class="line">            <span class="string">"element-ui"</span>: <span class="string">'ELEMENT'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        resolve: &#123;</span><br><span class="line">            extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>, <span class="string">'.ts'</span>, <span class="string">'.tsx'</span>],</span><br><span class="line">            alias: &#123;</span><br><span class="line">                <span class="string">'$root'</span>: PATH.resolve(__dirname)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        plugins: [<span class="keyword">new</span> WebpackBundleAnalyzerPlugin()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>打包</tag>
        <tag>webpack-bundle-analyzer</tag>
      </tags>
  </entry>
  <entry>
    <title>vue更改打包路径</title>
    <url>/2020/08/10/vue%E6%9B%B4%E6%94%B9%E6%89%93%E5%8C%85%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="根目录新建-env-local"><a href="#根目录新建-env-local" class="headerlink" title="根目录新建.env.local"></a>根目录新建.env.local</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VUE_APP_assetsRoot &#x3D; D:\zhenlvProject\webtouch\TC.itravel.WebFly\fly2.0\dist  （目标路径）</span><br><span class="line">VUE_APP_USER &#x3D; dali</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="build下新建readEnv-js"><a href="#build下新建readEnv-js" class="headerlink" title="build下新建readEnv.js"></a>build下新建readEnv.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读取环境变量的文件把它转化成对象</span><br><span class="line"></span><br><span class="line">const readEnv &#x3D; (file) &#x3D;&gt; &#123; &#x2F;&#x2F; flie为文件路径</span><br><span class="line">  let fileName &#x3D; path.join(__dirname, file);</span><br><span class="line">  let envParams &#x3D; &#123;&#125;</span><br><span class="line">  try&#123;</span><br><span class="line">    let fileData &#x3D; fs.readFileSync(fileName, &#123; encoding: &#39;utf8&#39; &#125;)</span><br><span class="line">    let deleteBlankData &#x3D; fileData.replace(&#x2F;\r&#x2F;g, &#39;,&#39;).replace(&#x2F;\s+&#x2F;g, &quot;&quot;) &#x2F;&#x2F; 把换行和回车替换并删除空格</span><br><span class="line">    let arr &#x3D; deleteBlankData.split(&#39;,&#39;).map(item &#x3D;&gt; &#123;</span><br><span class="line">      return item.split(&#39;&#x3D;&#39;)</span><br><span class="line">    &#125;) &#x2F;&#x2F; [ [ &#39;a&#39;, &#39;1&#39; ], [ &#39;b&#39;, &#39;2&#39; ] ]</span><br><span class="line">    arr.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">      if (item[1])&#123;</span><br><span class="line">        envParams[item[0]] &#x3D; &#96;&quot;$&#123;item[1]&#125;&quot;&#96;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;catch&#123;</span><br><span class="line">    fs.appendFileSync(fileName, &#39;&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  return envParams &#x2F;&#x2F;&#123; a: &#39;1&#39;, b: &#39;2&#39; &#125;</span><br><span class="line">  &#x2F;&#x2F; 可以接着处理</span><br><span class="line">  &#x2F;* 像vue-cli3 新版create-react-app 一样规定环境变量的Key必须以(VUE_APP_)  (REACT_APP_) 开头 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; readEnv</span><br></pre></td></tr></table></figure>



<h3 id="config下index-js"><a href="#config下index-js" class="headerlink" title="config下index.js"></a>config下index.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引入</span><br><span class="line">const readEnv &#x3D; require(&#39;..&#x2F;build&#x2F;readEnv&#39;)</span><br><span class="line">const localEnv &#x3D; readEnv(&#39;..&#x2F;.env.local&#39;)</span><br><span class="line">&#x2F;&#x2F; VUE_APP_assetsRoot 请设置成绝对路径</span><br><span class="line">const assetsRoot &#x3D;</span><br><span class="line">  localEnv.VUE_APP_assetsRoot ?</span><br><span class="line">    localEnv.VUE_APP_assetsRoot.replace(&#x2F;\&quot;&#x2F;g, &quot;&quot;) :</span><br><span class="line">    path.resolve(__dirname, &quot;..&#x2F;dist&quot;)</span><br><span class="line"></span><br><span class="line">应用</span><br><span class="line">改变前</span><br><span class="line">build: &#123;</span><br><span class="line">    &#x2F;&#x2F; Template for index.html</span><br><span class="line">    index: path.resolve(__dirname, &quot;..&#x2F;dist&#x2F;index.html&quot;),</span><br><span class="line">    &#x2F;&#x2F; index: path.resolve(__dirname, &#39;..&#x2F;..&#x2F;Views&#x2F;Home&#x2F;Hotel.cshtml&#39;),</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Paths</span><br><span class="line">    assetsRoot: path.resolve(__dirname, &quot;..&#x2F;dist&quot;),</span><br><span class="line">    assetsSubDirectory: &quot;static&quot;,</span><br><span class="line">    assetsPublicPath: &quot;&#x2F;vtravel&#x2F;fly2.0&#x2F;dist&#x2F;&quot;,</span><br><span class="line">&#125;</span><br><span class="line">改变后</span><br><span class="line">  build: &#123;</span><br><span class="line">    &#x2F;&#x2F; Template for index.html</span><br><span class="line">    index: &#96;$&#123;assetsRoot&#125;&#x2F;index.html&#96;,</span><br><span class="line">    &#x2F;&#x2F; index: path.resolve(__dirname, &#39;..&#x2F;..&#x2F;Views&#x2F;Home&#x2F;Hotel.cshtml&#39;),</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Paths</span><br><span class="line">    assetsRoot: assetsRoot,</span><br><span class="line">    assetsSubDirectory: &quot;static&quot;,</span><br><span class="line">    assetsPublicPath: &quot;&#x2F;vtravel&#x2F;fly2.0&#x2F;dist&#x2F;&quot;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>打包路径</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之顶部进度条</title>
    <url>/2021/01/19/vue%E4%B9%8B%E9%A1%B6%E9%83%A8%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    <content><![CDATA[<h3 id="Vue-页面加载进度条nprogress的使用"><a href="#Vue-页面加载进度条nprogress的使用" class="headerlink" title="Vue 页面加载进度条nprogress的使用"></a>Vue 页面加载进度条nprogress的使用</h3><p><a href="https://blog.csdn.net/qq_42540989/article/details/109220608" target="_blank" rel="noopener">https://blog.csdn.net/qq_42540989/article/details/109220608</a></p>
<p>前言：客户在访问网页的时候想要看到网页加载的进度，所以使用 <strong>nprogress</strong> 来实现当页面跳转是出现在浏览器顶部的进度条，它是轻量级的进度条组件，使用简便，可以很方便集成到应用中来。</p>
<a id="more"></a>

<p>效果：</p>
<p><img src="https://img-blog.csdnimg.cn/20201022151816265.gif" alt="img"></p>
<p>一、参考资料</p>
<p>官网：<a href="https://ricostacruz.com/nprogress/" target="_blank" rel="noopener">https://ricostacruz.com/nprogress/</a><br>github：<a href="https://github.com/rstacruz/nprogress" target="_blank" rel="noopener">https://github.com/rstacruz/nprogress</a></p>
<p>二 、安装 <strong>nprogress</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用npm 或者yarn 安装</span><br><span class="line"></span><br><span class="line">npm install --save nprogress </span><br><span class="line">yarn add nprogress</span><br></pre></td></tr></table></figure>

<p>三、使用(2种方式引入)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用script 和link 引入对应文件</span><br><span class="line">&lt;script src&#x3D;&#39;nprogress.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;nprogress.css&#39;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全局引入 在main.js中引入nprogress插件和样式，</span><br><span class="line">import NProgress from ‘nprogress’ </span><br><span class="line">import ‘nprogress&#x2F;nprogress.css’</span><br></pre></td></tr></table></figure>

<p>四、在路由中添加 <strong>nprogress</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">NProgress.configure(&#123; <span class="attr">showSpinner</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"><span class="comment">//在路由跳转前用NProgress.start()标记下进度条开始</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"> NProgress.start()</span><br><span class="line"> next()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在路由跳转后用NProgress.done()标记下结束</span></span><br><span class="line">router.afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> NProgress.done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>五、进度条样式修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在app.vue中</span><br><span class="line">#nprogress .bar &#123;</span><br><span class="line"> height: 10rpx !important;        &#x2F;&#x2F;高度</span><br><span class="line"> background: red !important;  &#x2F;&#x2F;颜色</span><br><span class="line"> &#125;</span><br><span class="line">#nprogress .peg&#123;</span><br><span class="line">    box-shadow: 0px 0px 10px 0px red !important;&#x2F;&#x2F;投影</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>六、其他参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以通过调用 .set(n)来设置进度，n是0-1的数字。</span><br><span class="line">NProgress.set(0.0);     &#x2F;&#x2F; Sorta same as .start()</span><br><span class="line">NProgress.set(0.4);</span><br><span class="line">NProgress.set(1.0);     &#x2F;&#x2F; Sorta same as .done()</span><br><span class="line">可以使用inc()随机增长进度条，注意，这个方法永远不会让进度条达到100%。</span><br><span class="line">NProgress.inc();</span><br><span class="line">NProgress.configure(&#123; showSpinner: false &#125;) &#x2F;&#x2F;禁用进度环</span><br><span class="line">NProgress.configure(&#123; trickle : false &#125;)    &#x2F;&#x2F;关闭进度条步进</span><br><span class="line">NProgress.configure(&#123; trickleRate : 10&#125;)    &#x2F;&#x2F;每次步进增长多少</span><br><span class="line">NProgress.configure(&#123; trickleSpeed : 200&#125;)  &#x2F;&#x2F;每次步进间隔，单位毫秒ms</span><br><span class="line">NProgress.configure(&#123; easing: &#39;linear&#39;&#125;)    &#x2F;&#x2F;动画方向</span><br><span class="line">NProgress.configure(&#123; speed : 10&#125;)          &#x2F;&#x2F;动画速度，单位毫秒ms</span><br><span class="line">NProgress.configure(&#123; minimum : 0.08&#125;)      &#x2F;&#x2F;最小百分比</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自动回复案例</title>
    <url>/2020/07/30/vue%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>用户提问题的自动回答案例（_.debounce、 _.capitalize、https:<span class="comment">//lodash.com/docs#debounce --特殊方法演示）</span></span><br><span class="line">&lt;div id=<span class="string">"watch-example"</span>&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            Ask a yes/no question:  </span><br><span class="line">            &lt;input v-model=<span class="string">"question"</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; answer &lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/axios@<span class="number">0.12</span><span class="number">.0</span>/dist/axios.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>https:<span class="comment">//cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">'#watch-example'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            question: <span class="string">''</span>,</span><br><span class="line">            answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">            question: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span><br><span class="line">                <span class="keyword">this</span>.debouncedGetAnswer()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="line">            <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="line">            <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="line">            <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="line">            <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="line">            <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            getAnswer: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span><br><span class="line">                <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">                axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">                    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">                        vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">                        vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>vue面试题记录</title>
    <url>/2020/09/14/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Vue 实例的 data 属性，可以在哪些生命周期中获取到？bcd</span><br><span class="line">A. beforeCreate</span><br><span class="line">B. created</span><br><span class="line">C. beforeMount</span><br><span class="line">D. mounted</span><br><span class="line"></span><br><span class="line">2. 下列对 Vue 原理的叙述，哪些是正确的？abcd</span><br><span class="line">A. Vue 中的数组变更通知，通过拦截数组操作方法而实现</span><br><span class="line">B. 编译器目标是创建渲染函数，渲染函数执行后将得到 VNode 树</span><br><span class="line">C. 组件内 data 发生变化时会通知其对应 watcher，执行异步更新</span><br><span class="line">D. patching 算法首先进行同层级比较，可能执行的操作是节点的增加、删除和更新</span><br><span class="line"></span><br><span class="line">3. 对于 Vue 中响应式数据原理的说法，下列哪项是不正确的？bd</span><br><span class="line">A. 采用数据劫持方式，即 Object.defineProperty() 劫持 data 中各属性，实现响应式数据</span><br><span class="line">B. 视图中的变化会通过 watcher 更新 data 中的数据</span><br><span class="line">C. 若 data 中某属性多次发生变化，watcher 仅会进入更新队列一次</span><br><span class="line">D. 通过编译过程进行依赖收集</span><br><span class="line"></span><br><span class="line">4. 下列说法不正确的是哪项？b</span><br><span class="line">A. key 的作用主要是为了高效地更新虚拟 DOM</span><br><span class="line">B. 若指定了组件的 template 选项，render 函数不会执行</span><br><span class="line">C. 使用 vm.$nextTick 可以确保获得 DOM 异步更新的结果</span><br><span class="line">D. 若没有 el 选项，vm.$mount(dom) 可将 Vue 实例挂载于指定元素上</span><br><span class="line"></span><br><span class="line">5. 下列关于 Vuex 的描述，不正确的是哪项？c</span><br><span class="line">A. Vuex 通过 Vue 实现响应式状态，因此只能用于 Vue</span><br><span class="line">B. Vuex 是一个状态管理模式</span><br><span class="line">C. Vuex 主要用于多视图间状态全局共享与管理</span><br><span class="line">D. 在 Vuex 中改变状态，可以通过 mutations 和 actions</span><br><span class="line"></span><br><span class="line">6. 关于 Vue 组件间的参数传递，下列哪项是不正确的？b</span><br><span class="line">A. 若子组件给父组件传值，可使用 $emit 方法</span><br><span class="line">B. 祖孙组件之间可以使用 provide 和 inject 方式跨层级相互传值</span><br><span class="line">C. 若子组件使用 $emit(&#39;say&#39;) 派发事件，父组件可使用 @say 监听</span><br><span class="line">D. 若父组件给子组件传值，子组件可通过 props 接受数据</span><br><span class="line"></span><br><span class="line">7. 下列关于 vue-router 的描述，不正确的是哪项？c</span><br><span class="line">A. vue-router 的常用模式有 hash 和 history 两种</span><br><span class="line">B. 可通过 addRoutes 方法动态添加路由</span><br><span class="line">C. 可通过 beforeEnter 对单个组件进行路由守卫</span><br><span class="line">D. vue-router 借助 Vue 实现响应式的路由，因此只能用于 Vue</span><br><span class="line"></span><br><span class="line">8. 下列说法不正确的是哪项？c</span><br><span class="line">A. 可通过 this.$parent 查找当前组件的父组件</span><br><span class="line">B. 可使用 this.$refs 查找命名子组件</span><br><span class="line">C. 可使用 this.$children 按顺序查找当前组件的直接子组件</span><br><span class="line">D. 可使用 $root 查找根组件，并可配合 children 遍历全部组件</span><br><span class="line"></span><br><span class="line">9. 下列关于 v-model 的说法，哪项是不正确的？c</span><br><span class="line">A. v-model 能实现双向绑定</span><br><span class="line">B. v-model 本质上是语法糖，它负责监听用户的输入事件以更新数据</span><br><span class="line">C. v-model 是内置指令，不能用在自定义组件上</span><br><span class="line">D. 对 input 使用 v-model，实际上是指定其 :value 和 :input</span><br><span class="line"></span><br><span class="line">10. 关于 Vue 的生命周期，下列哪项是不正确的？d</span><br><span class="line">A. DOM 渲染在 mounted 中就已经完成了</span><br><span class="line">B. Vue 实例从创建到销毁的过程，就是生命周期</span><br><span class="line">C. created 表示完成数据观测、属性和方法的运算和初始化事件，此时 $el 属性还未显示出来</span><br><span class="line">D. 页面首次加载过程中，会依次触发 beforeCreate，created，beforeMount，mounted，beforeUpdate，updated</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>好在拜天哥所赐，我们还是刷出了「权威的」参考答案，请查收：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. BCD</span><br><span class="line">2. ABCD</span><br><span class="line">3. BD</span><br><span class="line">4. B</span><br><span class="line">5. C</span><br><span class="line">6. B</span><br><span class="line">7. C</span><br><span class="line">8. C</span><br><span class="line">9. C</span><br><span class="line">10. D</span><br></pre></td></tr></table></figure>

<p>plus: <a href="https://mp.weixin.qq.com/s/a1mnUief7w9SqSRC8jlDEQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/a1mnUief7w9SqSRC8jlDEQ</a></p>
<h3 id="生命周期注意点："><a href="#生命周期注意点：" class="headerlink" title="生命周期注意点："></a>生命周期注意点：</h3><p>一些应用钩子函数的想法</p>
<ul>
<li><p>在created钩子中可以对data数据进行操作，这个时候可以进行ajax请求将返回的数据赋给data。</p>
</li>
<li><p>虽然updated函数会在数据变化时被触发，但却不能准确的判断是那个属性值被改变，所以在实际情况中用computed或match函数来监听属性的变化，并做一些其他的操作。</p>
</li>
<li><p>在mounted钩子对挂载的dom进行操作，此时，DOM已经被渲染到页面上。</p>
</li>
<li><p>在使用vue-router时有时需要使用<keep-alive></keep-alive>来缓存组件状态，这个时候created钩子就不会被重复调用了，如果我们的子组件需要在每次加载或切换状态的时候进行某些操作，可以使用activated钩子触发。</p>
</li>
<li><p>所有的生命周期钩子自动绑定 this 上下文到实例中，所以不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是导致this指向父级。</p>
<p>小结</p>
</li>
<li><p>加载渲染过程</p>
</li>
</ul>
<blockquote>
<p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p>
</blockquote>
<ul>
<li>子组件更新过程</li>
</ul>
<blockquote>
<p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p>
</blockquote>
<ul>
<li>父组件更新过程</li>
</ul>
<blockquote>
<p>父beforeUpdate-&gt;父updated</p>
</blockquote>
<ul>
<li>销毁过程</li>
</ul>
<blockquote>
<p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>
</blockquote>
<h3 id="路由篇"><a href="#路由篇" class="headerlink" title="路由篇"></a>路由篇</h3><h4 id="vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？"><a href="#vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？" class="headerlink" title="vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？"></a>vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？</h4><ul>
<li><p>hash 模式：</p>
</li>
<li><ul>
<li>#后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面</li>
<li>通过监听 <strong>hashchange</strong> 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。</li>
</ul>
</li>
<li><p>history 模式：</p>
</li>
<li><ul>
<li>history 模式的实现，主要是 HTML5 标准发布的两个 API，<strong>pushState</strong> 和 <strong>replaceState</strong>，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作</li>
</ul>
</li>
<li><p>区别</p>
</li>
<li><ul>
<li>url 展示上，hash 模式有“#”，history 模式没有</li>
<li>刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由</li>
<li>兼容性，hash 可以支持低版本浏览器和 IE。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自定义指令</title>
    <url>/2020/08/05/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-focus&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 注册一个全局自定义指令 v-focus</span><br><span class="line">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class="line">  &#x2F;&#x2F; 当绑定元素插入到 DOM 中。</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    &#x2F;&#x2F; 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="局部自定义指令"><a href="#局部自定义指令" class="headerlink" title="局部自定义指令"></a>局部自定义指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;input v-focus&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    &#x2F;&#x2F; 注册一个局部的自定义指令 v-focus</span><br><span class="line">    focus: &#123;</span><br><span class="line">      &#x2F;&#x2F; 指令的定义</span><br><span class="line">      inserted: function (el) &#123;</span><br><span class="line">        &#x2F;&#x2F; 聚焦元素</span><br><span class="line">        el.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><h5 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h5><p>指令定义函数提供了几个钩子函数（可选）：</p>
<ul>
<li><code>bind</code>: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li>
<li><code>inserted</code>: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li><code>update</code>: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li>
<li><code>componentUpdated</code>: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li><code>unbind</code>: 只调用一次， 指令与元素解绑时调用。</li>
</ul>
<h5 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h5><p>钩子函数的参数有：</p>
<ul>
<li><p><strong>el</strong>: 指令所绑定的元素，可以用来直接操作 DOM 。</p>
</li>
<li><p>binding</p>
<p>: 一个对象，包含以下属性：</p>
<ul>
<li><strong>name</strong>: 指令名，不包括 <code>v-</code> 前缀。</li>
<li><strong>value</strong>: 指令的绑定值， 例如： <code>v-my-directive=&quot;1 + 1&quot;</code>, value 的值是 <code>2</code>。</li>
<li><strong>oldValue</strong>: 指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><strong>expression</strong>: 绑定值的表达式或变量名。 例如 <code>v-my-directive=&quot;1 + 1&quot;</code> ， expression 的值是 <code>&quot;1 + 1&quot;</code>。</li>
<li><strong>arg</strong>: 传给指令的参数。例如 <code>v-my-directive:foo</code>， arg 的值是 <code>&quot;foo&quot;</code>。</li>
<li><strong>modifiers</strong>: 一个包含修饰符的对象。 例如： <code>v-my-directive.foo.bar</code>, 修饰符对象 modifiers 的值是 <code>{ foo: true, bar: true }</code>。</li>
</ul>
</li>
<li><p><strong>vnode</strong>: Vue 编译生成的虚拟节点。</p>
</li>
<li><p><strong>oldVnode</strong>: 上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p>
</li>
</ul>
<p>  以下实例演示了这些参数的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;  v-runoob:hello.a.b&#x3D;&quot;message&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.directive(&#39;runoob&#39;, &#123;</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    var s &#x3D; JSON.stringify</span><br><span class="line">    el.innerHTML &#x3D;</span><br><span class="line">      &#39;name: &#39;       + s(binding.name) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;value: &#39;      + s(binding.value) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;expression: &#39; + s(binding.expression) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;argument: &#39;   + s(binding.arg) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;modifiers: &#39;  + s(binding.modifiers) + &#39;&lt;br&gt;&#39; +</span><br><span class="line">      &#39;vnode keys: &#39; + Object.keys(vnode).join(&#39;, &#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;菜鸟教程!&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p>有时候我们不需要其他钩子函数，我们可以简写函数，如下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-runoob&#x3D;&quot;red&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.directive(&#39;runoob&#39;, function (el, binding) &#123;</span><br><span class="line">  &#x2F;&#x2F; 设置指令的背景颜色</span><br><span class="line">  el.style.backgroundColor &#x3D; binding.value.color</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p>指令函数可接受所有合法的 JavaScript 表达式，以下实例传入了 JavaScript 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-runoob&#x3D;&quot;&#123; color: &#39;green&#39;, text: &#39;菜鸟教程!&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.directive(&#39;runoob&#39;, function (el, binding) &#123;</span><br><span class="line">    &#x2F;&#x2F; 简写方式设置文本及背景颜色</span><br><span class="line">    el.innerHTML &#x3D; binding.value.text</span><br><span class="line">    el.style.backgroundColor &#x3D; binding.value.color</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目搭建</title>
    <url>/2020/08/05/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="从无到有搭建"><a href="#从无到有搭建" class="headerlink" title="从无到有搭建"></a>从无到有搭建</h3><ol>
<li><p>首先下载node.js要求版本在8.9以上        官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fzh-cn%2F" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p>
<p>下载完可检查在windows任务命令行里输入node -v</p>
</li>
</ol>
<ol start="2">
<li>使用淘宝NPM镜像源下载比较快    命令：npm install -g cnpm –registry=<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fregistry.npm.taobao.org%2F" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li>
</ol>
<ol start="3">
<li><p>安装vue-cli（全局安装vue-cli）    命令：cnpm install vue-cli -g</p>
<p>检查环境是否安装上：vue -V</p>
</li>
</ol>
<p>创建vue项目：</p>
<h5 id="vue-cli2-0安装"><a href="#vue-cli2-0安装" class="headerlink" title="vue-cli2.0安装"></a>vue-cli2.0安装</h5><p>vue init webpack vuecli_2.0(名称)</p>
<a id="more"></a>

<h5 id="vue-cli3-0创建项目"><a href="#vue-cli3-0创建项目" class="headerlink" title="vue-cli3.0创建项目"></a>vue-cli3.0创建项目</h5><p>1、vue create vuecli_3.0(名称)<br>2、默认选择default方式即可</p>
<h5 id="vue2-0和vue3-0的区别"><a href="#vue2-0和vue3-0的区别" class="headerlink" title="vue2.0和vue3.0的区别"></a>vue2.0和vue3.0的区别</h5><p>1.打包方式：<br>​    2.0是通过:npm run dev<br>​    3.0是：npm run serve<br>​    至于为什么会变，来看一下package.json</p>
<p>2.文件夹目录：<br>​    3.0取消掉了config目录、build目录、static目录 ,还有最重要的一点，3.0的安装项目时自动下载node-model<br>​    vue.config.js也没了，需要手动添加。</p>
<p>vue create 是vue-cli3.x的初始化方式，目前模板是固定的，模板选项可自由配置，创建出来的是vue-cli3的项目，与cue-cli2项目结构不同，配置方法不同，具体配置方法参考官方文档。vue init 是vue-cli2.x的初始化方式，可以使用github上面的一些模板来初始化项目，webpack是官方推荐的标准模板名。vue-cli2.x项目向3.x迁移只需要把static目录复制到public目录下，老项目的src目录覆盖3.x的src目录(如果修改了配置，可以查看文档，用cli3的方法进行配置)</p>
<h5 id="vue-cli2升级到vue-cli3"><a href="#vue-cli2升级到vue-cli3" class="headerlink" title="vue cli2升级到vue cli3"></a>vue cli2升级到vue cli3</h5><p>1.先升级npm的版本</p>
<p>​    npm install -g npm</p>
<p>2.再卸载之前的vue cli 2.9.6</p>
<p>​    npm uninstall -g @vue/cli</p>
<p>3.下载最新的vue cli版本</p>
<p>​    npm install -g @vue/cli</p>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p> 进入此文件夹：cd vuecli_2.0/vuecli_3.0</p>
<p>运行：npm install（’webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。）</p>
<p>运行：npm run dev        </p>
<p>运行之后会导出网址：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p>
<p>在网页上输入上面的网址即可</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4最全解析</title>
    <url>/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="命令合集"><a href="#命令合集" class="headerlink" title="命令合集"></a>命令合集</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-cli可以让我们在命令行里输入webpack相关命令</span><br><span class="line"></span><br><span class="line">本地安装webpack webpack-cli</span><br><span class="line">npm webpack webpack-cli -D </span><br><span class="line"></span><br><span class="line">生成默认的packpage.json</span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">查看旧的版本号</span><br><span class="line">npm info webpack</span><br><span class="line"></span><br><span class="line">全局安装翻译某个js</span><br><span class="line">webpack index.js</span><br><span class="line"></span><br><span class="line">本地安装翻译某个js</span><br><span class="line">npx webpack index.js</span><br><span class="line"></span><br><span class="line">查看本地安装的webpack</span><br><span class="line">npx webpack -v </span><br><span class="line"></span><br><span class="line">更改配置文件(由默认的webpack.config.js改成webpackconfig.js)</span><br><span class="line">npx webpack --config webpackconfig.js</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="配置解释"><a href="#配置解释" class="headerlink" title="配置解释"></a>配置解释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">	mode:&quot;production&quot;,&#x2F;&#x2F;默认模式，打包出的js是被压缩过的</span><br><span class="line">	&#x2F;&#x2F;mode:&quot;development&quot;,&#x2F;&#x2F;开发模式，打包出的js是原生</span><br><span class="line">	devtool:&quot;cheap-inline-module-source-map&quot;,</span><br><span class="line">	&#x2F;&#x2F;development devtool:&quot;cheap-module-eval-source-map&quot;</span><br><span class="line">	&#x2F;&#x2F;production devtool:&quot;cheap-module-source-map&quot;</span><br><span class="line">	&#x2F;&#x2F;source-map--会生成一个map的映射文件，inline-映射关系放进bundle.js去，cheap-只提示多少行错误，不提示列，提高打包速度，并且只检查自己的业务代码，module-也检查第三方的代码，eval使用eval函数生成映射关系</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="手写模拟webpack-dev-server-webpack-dev-middleware"><a href="#手写模拟webpack-dev-server-webpack-dev-middleware" class="headerlink" title="手写模拟webpack-dev-server(webpack-dev-middleware)"></a>手写模拟webpack-dev-server(webpack-dev-middleware)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-middleware express -D</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924160201890.png" alt="image-20200924160201890"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924160033781.png" alt="image-20200924160033781"></p>
<h4 id="babel-polyfill（注入es6的语法）"><a href="#babel-polyfill（注入es6的语法）" class="headerlink" title="@babel/polyfill（注入es6的语法）"></a>@babel/polyfill（注入es6的语法）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @babel&#x2F;pollyfill --save</span><br></pre></td></tr></table></figure>

<h5 id="main-js引入-babel-polyfill"><a href="#main-js引入-babel-polyfill" class="headerlink" title="main.js引入@babel/polyfill"></a>main.js引入@babel/polyfill</h5><p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924164534979.png" alt="image-20200924164534979"></p>
<h5 id="属性（targets：什么条件下需要引入，useBuiltIns：按需引入）"><a href="#属性（targets：什么条件下需要引入，useBuiltIns：按需引入）" class="headerlink" title="属性（targets：什么条件下需要引入，useBuiltIns：按需引入）"></a>属性（targets：什么条件下需要引入，useBuiltIns：按需引入）</h5><p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924164800345.png" alt="image-20200924164800345"></p>
<h5 id="书写第三方库的时候，上面的写法会污染全局，建议使用下面的方式"><a href="#书写第三方库的时候，上面的写法会污染全局，建议使用下面的方式" class="headerlink" title="书写第三方库的时候，上面的写法会污染全局，建议使用下面的方式"></a>书写第三方库的时候，上面的写法会污染全局，建议使用下面的方式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @babel&#x2F;plugin-transform-runtime --save-dev</span><br><span class="line">npm install @babel&#x2F;runtime --save</span><br><span class="line">&#x2F;&#x2F;corejs从false改成2需要下载corejs2</span><br><span class="line">npm install @babel&#x2F;runtime-corejs2 --save</span><br></pre></td></tr></table></figure>

<p><strong>注释引入</strong></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924165956498.png" alt="image-20200924165956498"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924171225161.png" alt="image-20200924171225161"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924165725570.png" alt="image-20200924165725570"></p>
<h4 id="使用webpack中的babel打包react"><a href="#使用webpack中的babel打包react" class="headerlink" title="使用webpack中的babel打包react"></a>使用webpack中的babel打包react</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @bable&#x2F;preset-react --save-dev</span><br><span class="line">npm install react react-dom --save</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924172440951.png" alt="image-20200924172440951"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924171913293.png" alt="image-20200924171913293"></p>
<h4 id="Tree-Shaking-只支持ES-module"><a href="#Tree-Shaking-只支持ES-module" class="headerlink" title="Tree Shaking(只支持ES module)"></a>Tree Shaking(只支持ES module)</h4><p>development模式下需要配置optimization</p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924174545413.png" alt="image-20200924174545413"></p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924174650855.png" alt="image-20200924174650855"></p>
<p>production模式下不需要配置optimization</p>
<p>sideEffects的值为false，意味着所有文件都需要使用tree shaking</p>
<p>sideEffects:[“*.css”,”@bable/polyfill”],意味着这两个文件不需要tree shaking</p>
<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924174438221.png" alt="image-20200924174438221"></p>
<h4 id="区分development和production环境"><a href="#区分development和production环境" class="headerlink" title="区分development和production环境"></a>区分development和production环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev(dev)</span><br><span class="line">npm run build(prod)</span><br></pre></td></tr></table></figure>



<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924175922131.png" alt="image-20200924175922131"></p>
<h4 id="分离基础webpack的config"><a href="#分离基础webpack的config" class="headerlink" title="分离基础webpack的config"></a>分离基础webpack的config</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm intall webpack-merge -D</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/23/webpack4%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/image-20200924180246753.png" alt="image-20200924180246753"></p>
]]></content>
      <categories>
        <category>webpack4</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack3最全解析</title>
    <url>/2020/09/21/webpack3%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="开始（以3-X版本为例，内容有过时的还没更新）"><a href="#开始（以3-X版本为例，内容有过时的还没更新）" class="headerlink" title="开始（以3.X版本为例，内容有过时的还没更新）"></a>开始（以3.X版本为例，内容有过时的还没更新）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;新建文件夹</span><br><span class="line">mkdir webpack_demo</span><br><span class="line">cd webpack_demo</span><br><span class="line">&#x2F;&#x2F;全局安装webpack</span><br><span class="line">npm install -g webpack@3.6.0</span><br><span class="line">&#x2F;&#x2F;初始化生成package.json</span><br><span class="line">npm init </span><br><span class="line">&#x2F;&#x2F;开发时依赖</span><br><span class="line">npm install --save-dev webpack@3.6.0</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>首先进入上节课我们建立的webpack_demo目录。进入后在根目录建立两个文件夹，分别是src文件夹和dist文件夹：</p>
<ul>
<li>src文件夹：用来存放我们编写的javascript代码，可以简单的理解为用JavaScript编写的模块。</li>
<li>dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包成的文件。</li>
</ul>
<p>你可以理解成src是源码文件，dist是我们编译打包好的文件；一个用于开发环境，一个用于生产环境。</p>
<h4 id="新建文件目录-编写程序文件"><a href="#新建文件目录-编写程序文件" class="headerlink" title="新建文件目录-编写程序文件"></a>新建文件目录-编写程序文件</h4><p>/dist/index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;jspang webpack&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;title&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;.&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>这里引入了一个JavaScript的bundle.js文件。这个文件现在还没有，这是用webpack执行打包命令后生产的文件。我们的index.html写好后，接下来在src文件夹下建立entry.js的文件，用于编写我们的JavaScript代码，也是我们的入口文件。</p>
<p>src/entry.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&#39;title&#39;).innerHTML&#x3D;&#39;Hello Webpack&#39;;</span><br></pre></td></tr></table></figure>

<p>这个文件的代码很简单，就是在</p>
<p>标签里写入Hello Webpack这句话。</p>
<h4 id="第一次Webpack打包"><a href="#第一次Webpack打包" class="headerlink" title="第一次Webpack打包"></a><strong>第一次Webpack打包</strong></h4><p>Webpack其实是可以在终端（命令行）中使用的，基本使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack &#123;entry file&#125; &#123;destination for bundled file&#125;</span><br><span class="line">&#x2F;&#x2F;本例中</span><br><span class="line">webpack src&#x2F;entry.js dist&#x2F;bundle.js</span><br></pre></td></tr></table></figure>

<ul>
<li>{entery file}:入口文件的路径，本文中就是src/entery.js的路径；</li>
<li>{destination for bundled file}:填写打包后存放的路径。</li>
<li>注意：在命令行中是不需要写{ }的。</li>
</ul>
<p>命令执行成功后，会在dist目录下出现bundle.js文件，这时我们就可以在浏览器中预览结果了，网页中显示出了Hello Webpack的信息。</p>
<h4 id="配置文件：入口和出口-配置文件webpack-config-js"><a href="#配置文件：入口和出口-配置文件webpack-config-js" class="headerlink" title="配置文件：入口和出口-配置文件webpack.config.js"></a>配置文件：入口和出口-配置文件webpack.config.js</h4><p>上节课通过一个小Demo我们对Webpack有了初步了解，但是上节课的终端打包方案，在实际开发中并不使用，而是使用Webpack的配置文件的方式进行设置。这节课我们就学一下配置文件的大体结构和入口出口文件的配置。</p>
<p>webpack.config.js就是Webpack的配置文件，这个文件需要自己在项目根目录下手动建立。建立好后我们对其进行配置，先看下面的代码（webpack.config.js的基本结构），这是一个没有内容的标准webpack配置模版。</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>entry：配置入口文件的地址，可以是单一入口，也可以是多入口。</li>
<li>output：配置出口文件的地址，在webpack2.X版本后，支持多出口配置。</li>
<li>module：配置模块，主要是解析CSS和图片转换压缩等功能。</li>
<li>plugins：配置插件，根据你的需要配置不同功能的插件。</li>
<li>devServer：配置开发服务功能，后期我们会详细讲解。</li>
</ul>
<p>entry选项（入口配置）</p>
<p>这个选项就是配置我们要压缩的文件一般是JavaScript文件（当然也可以是CSS…..）。按照上节课的代码(如果你上节课的代码还没作，那你可以返回去重新作一下)，这里要填写的是src目录下的entery.js文件。</p>
<p>wepback.config.js中的entry选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;入口文件的配置项</span><br><span class="line">entry:&#123;</span><br><span class="line">    &#x2F;&#x2F;里面的entery是可以随便写的</span><br><span class="line">    entry:&#39;.&#x2F;src&#x2F;entry.js&#39;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>output选项（出口配置）</strong></p>
<p>出口配置是用来告诉webpack最后打包文件的地址和文件名称的。按照上节课的操作，应该打包到dist目录下。在编写出口文件时，我们需要用到一点Node的知识，如果你还不会Node也没有 关系，就简单的两句代码，你记住就可以了（在视频中我还有详细的讲解）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;出口文件的配置项</span><br><span class="line">output:&#123;</span><br><span class="line">    &#x2F;&#x2F;打包的路径文职</span><br><span class="line">    path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">    &#x2F;&#x2F;打包的文件名称</span><br><span class="line">    filename:&#39;bundle.js&#39;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如果你只这样写，是会报错的：找不到path这个东西。所以我们要在webpack.config.js的头部引入path，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  path  &#x3D;  require(&#39;path&#39;);</span><br></pre></td></tr></table></figure>

<p>其实path.resolve(__dirname,’dist’)就是获取了项目的绝对路径。</p>
<p>filename:是打包后的文件名称，这里我们起名为bundle.js。</p>
<p>现在webpack.config.js的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;</span><br><span class="line">        entry:&#39;.&#x2F;src&#x2F;entry.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;</span><br><span class="line">        &#x2F;&#x2F;输出的路径，用了Node语法</span><br><span class="line">        path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F;输出的文件名称</span><br><span class="line">        filename:&#39;bundle.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码写完后，可以在终端中直接输入webpack就会进行打包。</p>
<p>在实际开发中我们都是通过配置文件进行打包的，所以必须要掌握好。</p>
<p><strong>多入口、多出口配置</strong></p>
<p>Webpack在版本1的时候很难设置多出口文件，但是在2版本开始就变的很方便了。直接看多入口和多出口的文件配置，然后可以和单一出口对比一下，你会发现这种设置非常简单（只需改动两点配置就可以）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; &#96;require&#96;(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;</span><br><span class="line">        entry:&#39;.&#x2F;src&#x2F;entry.js&#39;,</span><br><span class="line">        &#x2F;&#x2F;这里我们又引入了一个入口文件</span><br><span class="line">        entry2:&#39;.&#x2F;src&#x2F;entry2.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;</span><br><span class="line">        &#x2F;&#x2F;输出的路径，用了Node语法</span><br><span class="line">        path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F;输出的文件名称</span><br><span class="line">        &#x2F;&#x2F;filename:&#39;[name].js&#39;打包到dist文件夹下</span><br><span class="line">        filename:&#39;js&#x2F;[name].js&#39;&#x2F;&#x2F;打包到dist&#x2F;js文件夹下</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到代码的第7和14行进行了增加和修改，在入口文件配置中，增加了一个entry2.js的入口文件（这个文件你需要自己手动建立），这时候要打包的就有了两个入口文件。在代码14行我们把原来的bundle.js修改成了<code>[name].js</code>。</p>
<p><code>[name]</code>的意思是根据入口文件的名称，打包成相同的名称，有几个入口文件，就可以打包出几个文件。</p>
<h4 id="配置文件：-服务和热更新-webpack-dev-server"><a href="#配置文件：-服务和热更新-webpack-dev-server" class="headerlink" title="配置文件： 服务和热更新-webpack-dev-server"></a>配置文件： 服务和热更新-webpack-dev-server</h4><p>作为一个前端工程师，最大的编程需求之一就是所见即所得的工具，也就是常说的热更新。这节课就学习用webpack3.6版本实现热更新效果。</p>
<p><strong>设置webpack-dev-server</strong></p>
<p>要执行<code>webpack-dev-server</code>是要先用<code>npm install webpack-dev-server –save-dev</code>来进行下载的。下载好后，需要配置一下devServer。最简单的devServer配置项只有四个。先看一下代码，然后我再作解释。</p>
<p>/webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">        &#x2F;&#x2F;设置基本目录结构</span><br><span class="line">        contentBase:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F;服务器的IP地址，可以使用IP也可以使用localhost</span><br><span class="line">        host:&#39;localhost&#39;,</span><br><span class="line">        &#x2F;&#x2F;服务端压缩是否开启</span><br><span class="line">        compress:true,</span><br><span class="line">        &#x2F;&#x2F;配置服务端口号</span><br><span class="line">        port:1717</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>contentBase:配置服务器基本运行路径，用于找到程序打包地址。</li>
<li>host：服务运行地址，建议使用本机IP，这里为了讲解方便，所以用localhost。</li>
<li>compress：服务器端压缩选型，一般设置为开启，如果你对服务器压缩感兴趣，可以自行学习。</li>
<li>port：服务运行端口，建议不使用80，很容易被占用，这里使用了1717.</li>
</ul>
<p><strong>注意：</strong>这里需要使用npm 来进行安装<code>webpack-dev-server</code>了， 命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server@2.9.1 --save-dev</span><br></pre></td></tr></table></figure>

<p>这是本地安装，所以使用了–save-dev。</p>
<p>配置好后，你可以试着在终端中输入webpack-dev-server,如果可以执行成功，但是往往提示下面的错误（或者是无法找到内部或外部命令）。</p>
<p>出现下面的错误不用慌张，我们只要在package.json里配置一下scripts选项就可以执行了。</p>
<p>/package.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;:&quot;webpack-dev-server&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>配置好保存后，在终端里输入 <code>npm run server</code> 打开服务器。然后在浏览器地址栏输入<a href="http://localhost:1717就可以看到结果了。/">http://localhost:1717就可以看到结果了。</a></p>
<p><strong>支持热更新</strong></p>
<p>在npm run server 启动后，它是有一种监控机制的（也叫watch）。它可以监控到我们修改源码，并立即在浏览器里给我们更新。</p>
<p>注意：这里只是我们的webpack3.6版本支持，在3.5版本时要支持热更新还需要一些其他的操作。因为已经有了成熟的3.6版本，我就不再介绍低版本的操作方法。还有一种情况。如果你都设置好了，但是不进行热更新，可能是你系统的问题，在Linux和Ma上支持良好，在Windows上有时会出现问题。</p>
<h4 id="模块：CSS文件打包"><a href="#模块：CSS文件打包" class="headerlink" title="模块：CSS文件打包"></a>模块：CSS文件打包</h4><p>Webpack在生产环境中有一个重要的作用就是减少http的请求数，就是把多个文件打包到一个js里，这样请求数就可以减少好多。这节课我们就学习一个重要的知识，把我们的CSS文件打包。在学习CSS打包之前，需要先对webpack.config.js里的Loaders配置项进行了解。</p>
<p><strong>Loaders</strong></p>
<p>Loaders是Webpack最重要的功能之一，他也是Webpack如此盛行的原因。通过使用不同的Loader，Webpack可以的脚本和工具，从而对不同的文件格式进行特定处理。</p>
<p>简单的举几个Loaders使用例子：</p>
<ul>
<li>可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。</li>
<li>可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。</li>
<li>可以把React中的JSX转换成JavaScript代码。</li>
</ul>
<p>注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。下面我们对Loaders的配置型简单梳理一下。</p>
<ul>
<li>test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；</li>
<li>use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；</li>
<li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li>
<li>query：为loaders提供额外的设置选项（可选）。</li>
</ul>
<p>明白了Loader是什么后，就开始这节课的正题，如何打包CSS文件。</p>
<p><strong>打包CSS文件：</strong></p>
<p>建立index.css文件</p>
<p>要打包CSS你必须先要有个CSS文件，在/src目录下，我们建立一个css文件夹，在文件夹里建立index.css文件。代码内容如下。</p>
<p>./src/css/index.css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">    color: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSS文件建立好后，需要引入到入口文件中，才可以打包到，这里我们引入到entry.js中。</p>
<p><code>/src/entery.js</code>中在首行加入代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;.&#x2F;css&#x2F;index.css&quot;;</span><br><span class="line">或者 require(&quot;.&#x2F;css&#x2F;index.css&quot;)</span><br></pre></td></tr></table></figure>

<p>CSS和引入做好后，我们就需要使用loader来解析CSS文件了，这里我们需要两个解析用的loader，分别是style-loader和css-loader。</p>
<p><strong>style-loader:</strong></p>
<p>它是用来处理css文件中的url()等，npm中的网址：<code>https://www.npmjs.com/package/style-loader</code></p>
<p>用npm install 进行项目安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install style-loader@0.13.1 --save-dev</span><br></pre></td></tr></table></figure>

<p><strong>css-loader：</strong></p>
<p>它是用来将css插入到页面的style标签。npm中的网址：<a href="https://www.npmjs.com/package/css-loader" target="_blank" rel="noopener">https://www.npmjs.com/package/css-loader</a></p>
<p>用npm install 进行项目安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install css-loader@0.25.0 --save-dev</span><br></pre></td></tr></table></figure>

<p>一起下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install style-loader@0.13.1 css-loader@0.25.0 --save-dev</span><br></pre></td></tr></table></figure>

<p>两个loader都下载安装好后，我们就可以配置我们loaders了。</p>
<p><strong>loaders配置：</strong></p>
<p>修改webpack.config.js中module属性中的配置代码如下：</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: &#x2F;\.css$&#x2F;,</span><br><span class="line">              use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>webpack的loader的配置是从右往左的，从上面代码看的话，就是先使用css-loader之后使用style-loader。</p>
<p>同理，如果你使用less来写样式的话，则需要先用less-loader来编译样式文件为css文件，再继续使用css-loader与style-loader。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123; test: &#x2F;\.$&#x2F;, loader: &quot;style-loader!css-loader!less-loader&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JS压缩插件"><a href="#JS压缩插件" class="headerlink" title="JS压缩插件"></a>JS压缩插件</h4><p><strong>压缩JS代码：</strong></p>
<p>在Webpack中可以很轻松的实现JS代码的压缩，它是通过插件的方式实现的，这里我们就先来引入一个uglifyjs-webpack-plugin(JS压缩插件，简称uglify)。</p>
<p><strong>注意：</strong>虽然uglifyjs是插件，但是webpack版本里默认已经集成，不需要再次安装。</p>
<p><strong>引入：</strong></p>
<p>我们需要在webpack.config.js中引入uglifyjs-webpack-glugin插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const uglify &#x3D; &#96;require&#96;(&#39;uglifyjs-webpack-plugin&#39;);</span><br></pre></td></tr></table></figure>

<p>引入后在plugins配置里new一个 uglify对象就可以了，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">       new uglify()</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>

<p>这时候在终端中使用webpack进行打包，你会发现JS代码已经被压缩了。如果你用的VSCode的话，可以按Alt+Z让他文件自动换行，查看效果。</p>
<p>贴出通过6节课学习，现在webpack.config.js文件中的所有代码，这样大家可以对照学习。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path&#x3D;&#96;require&#96;(&#39;path&#39;);</span><br><span class="line">const uglify &#x3D; &#96;require&#96;(&#39;uglifyjs-webpack-plugin&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        entry:&#39;.&#x2F;src&#x2F;entry.js&#39;,</span><br><span class="line">        entry2:&#39;.&#x2F;src&#x2F;entry2.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        filename:&#39;[name].js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [&quot;style-loader&quot;, &quot;css-loader&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new uglify()</span><br><span class="line">    ],</span><br><span class="line">    devServer:&#123;</span><br><span class="line">       contentBase:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">       host:&#39;192.168.0.104&#39;,</span><br><span class="line">       compress:true,</span><br><span class="line">       port:1717</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="HTML文件的发布"><a href="#HTML文件的发布" class="headerlink" title="HTML文件的发布"></a>HTML文件的发布</h4><p>有经验的小伙伴其实一眼就可以看出，现在我们的项目结构是有问题的，我们把index.html直接放到了dist文件夹下，这肯定是不正确的，应该放到我们src目录下。但是前期我们为了循序渐进的学习，所以把index.html放到了dist目录下。这节课我们就学习如何把html文件打包到我们的生产路径下。</p>
<p><strong>devServer和JS压缩的冲突</strong></p>
<p>上节课学习了JS压缩，在视频中我使用了webpack进行打包，而没有使用npm run server 进行预览，也就是说没有启用devServer里的配置。那有些小伙伴在学习完视频后，在终端中输入了npm run server进行了预览，发现终端中报错了。</p>
<p>要弄明白这个问题，我们先要弄清楚什么是开发环境，什么是生产环境。开发环境中是基本不会对js进行压缩的，在开发预览时我们需要明确的报错行数和错误信息，所以完全没有必要压缩JavasScript代码。而生产环境中才会压缩JS代码，用于加快程序的工作效率。devServer用于开发环境，而压缩JS用于生产环境，在开发环境中作生产环境的事情所以Webpack设置了冲突报错。</p>
<p>在实际开发中，webpack配置文件是分开的，开发环境一个文件，生产环境一个文件。</p>
<p><strong>打包HTML文件</strong></p>
<p>我们先把dist中的html文件剪切到src目录中，并去掉我们的JS引入代码（webpack会自动为我们引入JS），因为这才是我们真实工作的目录文件结构。</p>
<p>然后我们配置webpack.config.js文件，先引入我们的html-webpack-plugin插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const htmlPlugin&#x3D; &#96;require&#96;(&#39;html-webpack-plugin&#39;);</span><br></pre></td></tr></table></figure>

<p>引入后使用npm进行安装包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>最后在webpack.config.js里的plugins里进行插件配置，配置代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new htmlPlugin(&#123;</span><br><span class="line">           minify:&#123;</span><br><span class="line">               removeAttributeQuotes:true</span><br><span class="line">           &#125;,</span><br><span class="line">           hash:true,</span><br><span class="line">           template:&#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line"></span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。</li>
<li>hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。</li>
<li>template：是要打包的html模版路径和文件名称。</li>
</ul>
<p>上边的都配置完成后，我们就可以在终端中使用webpack，进行打包。你会看到index.html文件已经被打包到我们的dist目录下了，并且自动为我们引入了路口的JS文件。</p>
<p><strong>总结：</strong></p>
<p>html文件的打包可以有效的区分开发目录和生产目录，在webpack的配置中也要搞清楚哪些配置用于生产环境，哪些配置用于开发环境，避免两种环境的配置冲突。</p>
<h4 id="图片迈坑：CSS中的图片处理（采用file-loader、url-loader）"><a href="#图片迈坑：CSS中的图片处理（采用file-loader、url-loader）" class="headerlink" title="图片迈坑：CSS中的图片处理（采用file-loader、url-loader）"></a>图片迈坑：CSS中的图片处理（采用file-loader、url-loader）</h4><p>在学习Webapck过程中你可能遇到的第一个坑就是CSS中的图片处理。很多webpack新手都在图片的坑中无法自拔（有的小伙伴在开发环境中是可以找到图片的，但是一打包后就找不到图片了，有的小伙伴是不知道如何正确引入html或者css中的图片，导致程序出错），我们将用三节课时间搞彻底走出webpack图片的坑。</p>
<p><strong>图片写入CSS</strong></p>
<p>你可以先在网上找一个图片，我这里就自恋的使用了我的头像，如果你需要下载，也可以下载（当然你可以完全自己找一个自己喜欢的）。</p>
<p>找到图片后在src目录下新建一个images文件夹，把图片放入images文件夹。</p>
<p>在index.html文件中增加一个放置div的标签（需要注意的是这里修改的是src下的index.html文件，不是dist下的，这点新手很容易弄混，要格外注意），代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;tupian&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>编写css文件，把你用的图片作为背景显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#tupian&#123;</span><br><span class="line">   background-image: url(..&#x2F;images&#x2F;manhua.png);</span><br><span class="line">   width:466px;</span><br><span class="line">   height:453px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写完成后，我们可以试着用webpack去打包一下。你会发现终端中是报错的，具体错误可以看下图。 <img src="http://7xjyw1.com1.z0.glb.clouddn.com/webpack_aadd.png" alt="alt"></p>
<p><strong>file-loader、url-loader</strong></p>
<p>上面的错误是由于缺少loader的解析，对loader其实我们并不陌生，因为前边已经学习了CSS打包的loader。我们先安装两个解析图片用的loader。</p>
<p>安装file-loader和url-loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure>

<p>安装好后我们需要对两个loader进行基本的了解，学习尽量做到知其然知其所以然。</p>
<p><strong>file-loader：</strong>解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。</p>
<p><strong>url-loader：</strong>如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。</p>
<p>配置url-loader</p>
<p>我们安装好后，就可以使用这个loader了，记得在loader使用时不需要用require引入，在plugins才需要使用require引入。</p>
<p>webpack.config.js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">   module:&#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">             test: &#x2F;\.css$&#x2F;,</span><br><span class="line">             use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">              test:&#x2F;\.(png|jpg|gif)&#x2F; ,</span><br><span class="line">              use:[&#123;</span><br><span class="line">                  loader:&#39;url-loader&#39;,</span><br><span class="line">                  options:&#123;</span><br><span class="line">                      limit:5000</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;]</span><br><span class="line">           &#125;</span><br><span class="line">         ]</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>test:/.(png|jpg|gif)/是匹配图片文件后缀名称。</li>
<li>use：是指定使用的loader和loader的配置参数。</li>
<li>limit：是把小于5000的图片打成Base64的格式，写入JS，大于5000的图片使用原来的格式</li>
</ul>
<p>写好后就可以使用webpack进行打包了，这回你会发现打包很顺利的完成了。具体的Base64的格式，你可以查看视频中的样子。</p>
<p><strong>为什么只使用了url-loader</strong></p>
<p>有的小伙伴会发现我们并没有在webpack.config.js中使用file-loader，但是依然打包成功了。我们需要了解file-loader和url-loader的关系。url-loader和file-loader是什么关系呢？简答地说，url-loader封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。通过上面的介绍，我们可以看到，url-loader工作分两种情况：</p>
<p>1.文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）；</p>
<p>2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。</p>
<p>也就是说，其实我们只安装一个url-loader就可以了。但是为了以后的操作方便，我们这里就顺便安装上file-loader。</p>
<h4 id="CSS分离与图片路径处理（extract-text-webpack-plugin插件-）"><a href="#CSS分离与图片路径处理（extract-text-webpack-plugin插件-）" class="headerlink" title="CSS分离与图片路径处理（extract-text-webpack-plugin插件/）"></a>CSS<strong>分离与图片路径处理</strong>（extract-text-webpack-plugin插件/）</h4><p>通过上节课的学习已经能把小图片打包成Base64格式，也对webpack对图片的打包有个基本了解。这节课主要学习两个知识：第一个是把CSS从JavasScript代码中分离出来，第二个是如何处理分离出来后CSS中的图片路径不对问题。</p>
<p><strong>CSS分离:extract-text-webpack-plugin</strong></p>
<p>有些简单的交互页面中，你的JavasScript页面代码会非常少，而大部分代码都在CSS中，这时候项目组长会要求把CSS单独提取出来，方便以后更改。遇到这个需求你不要惊慌，已经有大神为我们准备好了对象的插件（plugin）。</p>
<p>extract-text-webpack-plugin</p>
<p>这个插件就可以完美的解决我们提取CSS的需求，但是webpack官方其实并不建议这样作，他们认为CSS就应该打包到JavasScript当中以减少http的请求数。但现实中的需求往往不是我们前端能控制的，有些需求是我们不能控制的，分离CSS就是这样一个既合理由不合理的需求。</p>
<p><strong>安装：</strong>录制课程时的版本是3.0.0版本，直接使用npm install 就可以安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure>

<p><strong>引入：</strong>安装完成后，需要先用require引入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const extractTextPlugin &#x3D; &#96;require&#96;(&quot;extract-text-webpack-plugin&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>设置Plugins：</strong>引入成功后需要在plugins属性中进行配置。这里只要new一下这个对象就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new extractTextPlugin(&quot;&#x2F;css&#x2F;index.css&quot;)</span><br></pre></td></tr></table></figure>

<p>这里的/css/index.css是分离后的路径位置。这部配置完成后，包装代码：还要修改原来我们的style-loader和css-loader。</p>
<p>修改代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: &#x2F;\.css$&#x2F;,</span><br><span class="line">              use: extractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: &quot;style-loader&quot;,</span><br><span class="line">                use: &quot;css-loader&quot;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">               test:&#x2F;\.(png|jpg|gif)&#x2F; ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:&#39;url-loader&#39;,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:500000</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>作完上边这四部后，就可以使用webpack进行打包了。</p>
<p><strong>图片路径问题：</strong></p>
<p>利用extract-text-webpack-plugin插件很轻松的就把CSS文件分离了出来，但是CSS路径并不正确，很多小伙伴就在这里搞个几天还是没有头绪，网上也给出了很多的解决方案，我觉的最好的解决方案是使用publicPath解决，我也一直在用。</p>
<p>publicPath：是在webpack.config.js文件的output选项中，主要作用就是处理静态文件路径的。</p>
<p>在处理前，我们在webpack.config.js 上方声明一个对象，叫website。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var website &#x3D;&#123;</span><br><span class="line">    publicPath:&quot;http:&#x2F;&#x2F;192.168.1.108:1717&#x2F;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。</p>
<p>然后在output选项中引用这个对象的publicPath属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;</span><br><span class="line">        &#x2F;&#x2F;输出的路径，用了Node语法</span><br><span class="line">        path:path.resolve(__dirname,&#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F;输出的文件名称</span><br><span class="line">        filename:&#39;[name].js&#39;,</span><br><span class="line">        publicPath:website.publicPath</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>配置完成后，你再使用webpack命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。</p>
<p><strong>总结：</strong>这节课我们实现了CSS的分离，并在分离后处理了图片路径不对的问题。处理路径的方法一定要充分理解，因为这在工作中经常用到。</p>
<h4 id="图片迈坑：处理HTML中的图片-html-withimg-loader"><a href="#图片迈坑：处理HTML中的图片-html-withimg-loader" class="headerlink" title="图片迈坑：处理HTML中的图片(html-withimg-loader)"></a>图片迈坑：处理HTML中的图片(html-withimg-loader)</h4><p>有的小伙伴在学习视频时，并没有全局安装webpack，而是使用了项目安装。首先我要说的是，这种做法是webpack推崇的，webpack并不鼓励全局安装webpack。但是小伙伴看我视频中直接在终端用webpack进行打包项目，他使用时会出现不是内部命令或者外部命令。</p>
<p>这时候需要配置package.json里的scripts选项，我们以前的课程已经学习了配置 webpack-dev-server命令，在这个命令下面我们再加一个build命令进行打包项目使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">    &quot;build&quot;:&quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>配置完成后，可以在控制台输入npm run build 进行打包。</p>
<p><strong>如何把图片放到指定的文件夹下</strong></p>
<p>前边两节课程，打包后的图片并没有放到images文件夹下，要放到images文件夹下，其实只需要配置我们的url-loader选项就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: &#x2F;\.css$&#x2F;,</span><br><span class="line">              use: extractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: &quot;style-loader&quot;,</span><br><span class="line">                use: &quot;css-loader&quot;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">               test:&#x2F;\.(png|jpg|gif)&#x2F; ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:&#39;url-loader&#39;,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:5000,</span><br><span class="line">                       name:[name]_[hash:7].[ext]&#x2F;&#x2F;占位符，name引用原来图片的名字，hash打包的时候的hash值，ext引用原来图片的后缀</span><br><span class="line">                       outputPath:&#39;images&#x2F;&#39;,&#x2F;&#x2F;输入文件夹</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这回你再执行打包就可以把图片打包到images文件夹里了。</p>
<p><strong>html-withimg-loader</strong></p>
<p>html-withimg-loader就是我们今天的重点了，这个插件并不是很火，也是我个人喜欢的一个小loader。解决的问题就是在hmtl文件中引入图片标签的问题。</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure>

<p><strong>配置loader</strong></p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.(htm|html)$&#x2F;i,</span><br><span class="line">     use:[ &#39;html-withimg-loader&#39;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在终端中可以进行打包了。你会发现images被很好的打包了。并且路径也完全正确。</p>
<p>总结：我们通过三节课的时间讲了webpack图片中的坑，这些坑在我初学webpack初期给我带来了不少的麻烦，我也算是倾囊相教了，希望小伙伴们有所收获。在你工作中遇到图片的问题，也可以返回文章里进行对比查找问题。</p>
<h4 id="CSS进阶：Less文件的打包和分离"><a href="#CSS进阶：Less文件的打包和分离" class="headerlink" title="CSS进阶：Less文件的打包和分离"></a>CSS进阶：Less文件的打包和分离</h4><p>第05节中已经讲过CSS文件的打包，后来又讲了CSS分离。这节我们讲解一下Less文件如何打包和分离。Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。也就是说Less给我们枯燥单一的样式文件加入了编程机制，这让我们这些前端程序员很受用，所以在工作中大部分程序员都使用了Leess开发。</p>
<p><strong>打包Less文件</strong></p>
<p>安装:</p>
<p>要使用Less，我们要首先安装Less的服务，当然也是用npm来进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev less</span><br></pre></td></tr></table></figure>

<p>还需要安装Less-loader用来打包使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install --save-dev less-loader</span><br></pre></td></tr></table></figure>

<p>写loader配置：</p>
<p>安装好后，需要在webpack.config.js里编写loader配置，当然要想正确解析成CSS，还是需要style-loader和css-loader的帮助，但是这两个loader前边已经讲过了，所以在这里就不重复了，如果你还对这两个loader不熟悉，那自行回去补前边的第五节吧。</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.less$&#x2F;,</span><br><span class="line">    use: [&#123;</span><br><span class="line">           loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">        , &#123;</span><br><span class="line">            loader: &quot;less-loader&quot; &#x2F;&#x2F; compiles Less to CSS</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写一个less文件</strong></p>
<p>现在webpack的配置好了，我们还需要编写一个less文件，这里明文为black.less.里边只做一件是就是把一个层的背景设置成黑色。</p>
<p>black.less</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@base :#000;</span><br><span class="line">#gogo&#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:300px;</span><br><span class="line">    background-color:@base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里#gogo是层的ID名称。@base是我们设置的变量名称。</p>
<p><strong>引入到我们entery.js文件中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import less from &#39;.&#x2F;css&#x2F;black.less&#39;;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以把less文件进行打包了。我们可以使用webpack命令打包试一试。</p>
<p><strong>把Lees文件分离。</strong></p>
<p>我们之前讲了extract-text-webpack-plugin这个插件，想把Less文件分离出来的方法跟这个几乎一样，之前的我们在第09节中讲过，这里我们就只讲less的loader配置方法。（此处建议收看视频）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;less-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">                &#x2F;&#x2F; use style-loader in development</span><br><span class="line">                fallback: &quot;style-loader&quot;</span><br><span class="line">            &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>配置好后，你会发现less被分离到了index.css文件里。</p>
<p>总结：Less是非常好的CSS扩展，但是Less得转换稍显麻烦，好的是webpack为我们提供了简单轻松的转换方法。希望小伙伴可以学好这一课，在你们的工作中都开始使用Less编写你们css代码。</p>
<h4 id="CSS进阶：SASS文件的打包和分离"><a href="#CSS进阶：SASS文件的打包和分离" class="headerlink" title="CSS进阶：SASS文件的打包和分离"></a>CSS进阶：SASS文件的打包和分离</h4><p>上节课学习了Less的打包和分离，群里使用SASS的小伙伴马上就不干了，要求讲一下SASS的配置，其实你会了Less得配置，SASS的配置可以很轻松的学会，为了公平公正，那我们就用一节课的时间学一下SASS的配置的。</p>
<p><strong>安装SASS打包的loader</strong></p>
<p>这里需要 在项目目录下用npm安装两个包。node-sass和sass-loader</p>
<p>node-sass：因为sass-loader依赖于node-sass，所以需要先安装node-sass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install --save-dev node-sass</span><br></pre></td></tr></table></figure>

<p>sass-loader:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev sass-loader</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在用npm安装时，这个loader很容易安装失败，最好使用cnpm来进行安装。如果你安装一直报错，最好是把node_modules文件夹删除后，再重新安装。</p>
<p>编写loader配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">                test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;sass-loader&quot; &#x2F;&#x2F; compiles Sass to CSS</span><br><span class="line">                &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Sass文件的编写</strong></p>
<p>写好loader配置后，就可以愉快的编写sass文件拉，但是不要忘记把sass文件引入到entery.js中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$nav-color: #FFF;</span><br><span class="line">#nav &#123;</span><br><span class="line">  $width: 100%;</span><br><span class="line">  width: $width;</span><br><span class="line">  height:30px;</span><br><span class="line">  background-color: $nav-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都完成后，你就可以启动我们npm run server 来查看效果了。</p>
<p><strong>把SASS文件分离。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;sass-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">                &#x2F;&#x2F; use style-loader in development</span><br><span class="line">                fallback: &quot;style-loader&quot;</span><br><span class="line">            &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这节课算是专门为sass使用者录制的吧，其实整体过程和less的使用差不多，希望你能在工作中开始使用sass，并写出漂亮的css代码。</p>
<h4 id="CSS进阶：自动处理css前缀，兼容浏览器"><a href="#CSS进阶：自动处理css前缀，兼容浏览器" class="headerlink" title="CSS进阶：自动处理css前缀，兼容浏览器"></a>CSS进阶：自动处理css前缀，兼容浏览器</h4><p>这节课我们就学习一下如何通过postcss-loader给css3属性自动添加前缀。</p>
<p><strong>什么是属性前缀</strong></p>
<p>我们先来看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-webkit-transform: rotate(45deg);</span><br><span class="line">        transform: rotate(45deg);</span><br></pre></td></tr></table></figure>

<p>为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz这些前缀。目的就是让我们写的页面在每个浏览器中都可以顺利运行。</p>
<p><strong>PostCSS</strong></p>
<p>PostCSS是一个CSS的处理平台，它可以帮助你的CSS实现更多的功能，但是今天我们就通过其中的一个加前缀的功能，初步了解一下PostCSS。</p>
<p><strong>安装</strong></p>
<p>需要安装两个包postcss-loader 和autoprefixer（自动添加前缀的插件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br></pre></td></tr></table></figure>

<p>postcss.config.js</p>
<p>postCSS推荐在项目根目录（和webpack.config.js同级），建立一个postcss.config.js文件。</p>
<p>postcss.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: &#123;  </span><br><span class="line">        &#39;autoprefixer&#39;: &#123;browsers: &#39;last 5 version&#39;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        require(&#39;autoprefixer&#39;)</span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是对postCSS一个简单的配置，引入了autoprefixer插件。让postCSS拥有添加前缀的能力，它会根据 can i use 来增加相应的css3属性前缀。</p>
<p><strong>编写loader</strong></p>
<p>对postcss.config.js配置完成后，我们还需要编写我们的loader配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      test: &#x2F;\.css$&#x2F;,</span><br><span class="line">      use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &quot;style-loader&quot;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: &quot;css-loader&quot;,</span><br><span class="line">              options: &#123;</span><br><span class="line">                 modules: true</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: &quot;postcss-loader&quot;</span><br><span class="line">            &#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提取CSS</strong></p>
<p>配置提取CSS的loader配置.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &#39;style-loader&#39;,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; loader: &#39;css-loader&#39;, options: &#123; importLoaders: 1 &#125; &#125;,</span><br><span class="line">            &#39;postcss-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:postcss还有很多功能，我希望小伙伴学会自学。这里给出postcss-loader的github地址：<a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">https://github.com/postcss/postcss-loader</a></p>
<h4 id="CSS进阶：消除未使用的CSS"><a href="#CSS进阶：消除未使用的CSS" class="headerlink" title="CSS进阶：消除未使用的CSS"></a>CSS进阶：消除未使用的CSS</h4><p>像Bootstrap这样的框架往往会带有很多CSS。在项目中通常我们只使用它的一小部分。就算我们自己写CSS，随着项目的进展，CSS也会越来越多，有时候需求更改，带来了DOM结构的更改，这时候我们可能无暇关注CSS样式，造成很多CSS的冗余。这节课就学习用webpack消除未使用的CSS。</p>
<p><strong>PurifyCSS</strong></p>
<p>使用PurifyCSS可以大大减少CSS冗余，比如我们经常使用的BootStrap(140KB)就可以减少到只有35KB大小。这在实际开发当中是非常有用的。</p>
<p><strong>安装PurifyCSS-webpack</strong></p>
<p>从名字你就可以看出这是一个插件，而不是loader。所以这个需要安装还需要引入。 PurifyCSS-webpack要以来于purify-css这个包，所以这两个都需要安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npmn  i -D purifycss-webpack purify-css</span><br></pre></td></tr></table></figure>

<p>这里的-D代表的是–save-dev ,只是一个简写。</p>
<p><strong>引入glob</strong></p>
<p>因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。在webpack.config.js文件头部引入glob。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const glob &#x3D; &#96;require&#96;(&#39;glob&#39;);</span><br></pre></td></tr></table></figure>

<p>引入purifycss-webpack</p>
<p>同样在webpack.config.js文件头部引入purifycss-webpack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PurifyCSSPlugin &#x3D; &#96;require&#96;(&quot;purifycss-webpack&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>配置plugins</strong></p>
<p>引入完成后我们需要在webpack.config.js里配置plugins。代码如下，重点看标黄部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    &#x2F;&#x2F;new uglify() </span><br><span class="line">    new htmlPlugin(&#123;</span><br><span class="line">        minify:&#123;</span><br><span class="line">            removeAttrubuteQuotes:true</span><br><span class="line">        &#125;,</span><br><span class="line">        hash:true,</span><br><span class="line">        template:&#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line"></span><br><span class="line">    &#125;),</span><br><span class="line">    new extractTextPlugin(&quot;css&#x2F;index.css&quot;),</span><br><span class="line">    new PurifyCSSPlugin(&#123;</span><br><span class="line">        &#x2F;&#x2F; Give paths to parse for rules. These should be absolute!</span><br><span class="line">        paths: glob.sync(path.join(__dirname, &#39;src&#x2F;*.html&#39;)),</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这里配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了。</p>
<p><strong>注意：</strong>使用这个插件必须配合extract-text-webpack-plugin这个插件，这个插件在前边的课程已经讲解过了。如果你还不会请自学一下。</p>
<p>配置好上边的代码，我们可以故意在css文件里写一些用不到的属性，然后用webpack打包，你会发现没用的CSS已经自动给你删除掉了。在工作中记得一定要配置这个plugins，因为这决定你代码的质量，非常有用。</p>
<h4 id="打包iconfont字体文件"><a href="#打包iconfont字体文件" class="headerlink" title="打包iconfont字体文件"></a>打包iconfont字体文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: &#x2F;\.(woff2?|eot|ttf|otf)(\?.*)?$&#x2F;,</span><br><span class="line">        loader: &quot;url-loader&quot;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&quot;fonts&#x2F;[name].[hash:7].[ext]&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="给webpack增加bable支持（es6转es5）"><a href="#给webpack增加bable支持（es6转es5）" class="headerlink" title="给webpack增加bable支持（es6转es5）"></a>给webpack增加bable支持（es6转es5）</h4><p>在前端开发中都开始使用ES6的语法了，虽然说webpack3增加了一些ES6的转换支持，但是实际效果不是很好，也可能是本人技术有限，没发挥出真正的功能。所以我在开发中还是喜欢添加Babel-loader的，我也查看了一些别人的webpack配置也都增加了babel-loader，所以这节课我们学习一下如何增加Babel支持。（此节文章部分内容引用了zhangwang大神的文章内容）</p>
<p>Babel是什么？ Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过便宜帮你达到以下目的：</p>
<p>使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。</p>
<p>使用基于JavaScript进行了扩展的语言，比如React的JSX。</p>
<p><strong>Babel的安装与配置</strong></p>
<p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。</p>
<p>我们先一次性安装这些依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm c install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</span><br></pre></td></tr></table></figure>

<p>在webpack中配置Babel的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:&#39;babel-loader&#39;,</span><br><span class="line">        options:&#123;</span><br><span class="line">            presets:[</span><br><span class="line">                &quot;es2015&quot;,&quot;react&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你已经可以用webapck转换ES6的语法兼容各个浏览器了，我们可以修改一下entry.js的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import css from &#39;.&#x2F;css&#x2F;index.css&#39;;</span><br><span class="line">&#123;</span><br><span class="line">    let jspangString &#x3D; &#39;Hello Webpack&#39;</span><br><span class="line">    document.getElementById(&#39;title&#39;).innerHTML&#x3D;jspangString; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用了ES6的let声明方法。如果你不使用Babel来进行转换，你会发现打包出来的js代码没有作兼容处理，使用了Babel转换的代码是进行处理过的。</p>
<p><strong>.babelrc配置</strong></p>
<p>虽然Babel可以直接在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，如果卸载webapck.config.js中会非常的雍长不可阅读，所以我们经常把配置卸载.babelrc文件里。</p>
<p>在项目根目录新建.babelrc文件，并把配置写到文件里。</p>
<p>.babelrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;react&quot;,&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.webpack.config.js里的loader配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:&#39;babel-loader&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ENV：</strong></p>
<p>现在网络上已经不流行babel-preset-es2015，现在官方推荐使用的是babel-preset-env,那我们为了紧跟潮流，我们在讲一下env的配置方法。</p>
<p>首先需要下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install --save-dev babel-preset-env</span><br></pre></td></tr></table></figure>

<p>然后修改.babelrc里的配置文件。其实只要把之前的es2015换成env就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：对于在React中Babel的使用，如何解析JSX，我会在后边的课程作详细了解，大家不要着急。在实际工作中还是要安装Babel的，这样能更好的兼容每种浏览器，而把Babel的配置文件分解出来是最好的选择。</p>
<h4 id="打包后如何调试"><a href="#打包后如何调试" class="headerlink" title="打包后如何调试"></a>打包后如何调试</h4><p>作为一个程序员每天的大部分工作就是调试自己写的程序，那我们使用了webpack后，所以代码都打包到了一起，给调试带来了麻烦，但是webpack已经为我们充分考虑好了这点，它支持生产Source Maps来方便我们的调试。（敲黑板，这节可能偏理论一点。）</p>
<p>在使用webpack时只要通过简单的devtool配置，webapck就会自动给我们生产source maps 文件，map文件是一种对应编译文件和源文件的方法，让我们调试起来更简单。</p>
<p>四种选项</p>
<p>在配置devtool时，webpack给我们提供了四种选项。</p>
<ul>
<li>source-map:在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的source map,但是它会减慢打包速度；</li>
<li>cheap-module-source-map:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。</li>
<li>eval-source-map:使用eval打包源文件模块，在同一个文件中生产干净的完整版的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</li>
<li>cheap-module-eval-source-map:这是在打包文件时最快的生产source map的方法，生产的 Source map 会和打包后的JavaScript文件同行显示，没有影射列，和eval-source-map选项具有相似的缺点。</li>
</ul>
<p>四种打包模式，有上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对执行和调试有一定的影响。</p>
<p>个人意见是，如果大型项目可以使用source-map，如果是中小型项目使用eval-source-map就完全可以应对，需要强调说明的是，source map只适用于开发阶段，上线前记得修改这些调试设置。</p>
<p>简单的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  devtool: &#39;eval-source-map&#39;,</span><br><span class="line">  entry:  __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;&#x2F;public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：调试在开发中也是必不可少的，但是一定要记得在上线前一定要修改webpack配置，在打出上线包。</p>
<h4 id="实战技巧：开发和生产并行设置"><a href="#实战技巧：开发和生产并行设置" class="headerlink" title="实战技巧：开发和生产并行设置"></a>实战技巧：开发和生产并行设置</h4><p><strong>依赖不同</strong></p>
<p>一个项目中是有开发环境和生产环境的，这两个环境的依赖也是不同的。</p>
<ul>
<li>开发依赖：只在开发中用来帮助你进行开发，简化代码或者生成兼容设置的以来包。你可以打开package.json来查看，devDependencies的下面的这些包为开发使用的包。这些包在生产环境中并没有用处。</li>
<li>生产依赖：就是比如我们的js使用了jquery，jquery的程序要在浏览器端起作用，也就是说我们最终的程序也需要这个包，这就是生产依赖。这些包在dependencies中。</li>
</ul>
<p>npm安装</p>
<p>假如我们要在项目中使用jquery库，这时候我们一般有三种安装方法，每种我都详细讲解一下。</p>
<p><strong>第一种：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install jquery</span><br></pre></td></tr></table></figure>

<p>安装完成后，你会发现在package.json中并不存在这个包的依赖。如果你项目拷贝给别人继续开发，或者别人和你git合作，再次下载项目npm install时就会缺少这个jquery包。项目就会无法正常运行，所以这也是我们最不赞成的安装方法。</p>
<p><strong>第二种：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install jquery --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，它存在于package.json的dependencies中，也就是说它是生产环境需要依赖的包（上线时需要的以来包）。</p>
<p><strong>第三种：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install jquery --save-dev</span><br></pre></td></tr></table></figure>

<p>安装完成后，它存在于package.json的devDependencies中，也就是说它是开发环境中需要的，上线并不需要这个包的依赖。</p>
<p><strong>安装全部项目依赖包：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>安装生产环境依赖包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --production</span><br></pre></td></tr></table></figure>

<p><strong>配置生产和开发并行</strong></p>
<p>我们在以前的配置中设置了一个变量website，用于静态资源正确找到路径。那如果生产环境和开发环境不一样，而且我们需要来回切换，这时候我们需要更好的设置方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var website&#x3D;&#123;</span><br><span class="line">    publicPath:&quot;http:&#x2F;&#x2F;192.168.0.104:1717&#x2F;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>采用插件的形式设置环境变量的值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">       new webpack.DefinePlugin(&#123;</span><br><span class="line">           &#39;process.env&#39;: &#123;</span><br><span class="line">               NODE_ENV: &#39;&quot;production&quot;&#39;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>

<p><strong>修改package.json命令</strong></p>
<p>其实就是添加一个dev设置，并通过环境变量来进行区分，下面是package.json里的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">    &quot;dev&quot;:&quot;set NODE_ENV&#x3D;dev&amp;webapck&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;set NODE_ENV&#x3D;build&amp;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><strong>修改webpack.config.js文件</strong></p>
<p>可以利用node的语法来读取NODE_ENV的值，然后根据NODE_ENV的值用if–else判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(process.env.NODE_ENV&#x3D;&#x3D; &quot;build&quot;)&#123;</span><br><span class="line">    var website&#x3D;&#123;</span><br><span class="line">        publicPath:&quot;http:&#x2F;&#x2F;192.168.0.104:1717&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    var website&#x3D;&#123;</span><br><span class="line">        publicPath:&quot;http:&#x2F;&#x2F;cdn.jspang.com&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你说我想看一下传过来的值到底是什么？可以用下面的输出语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log( encodeURIComponent(process.env.NODE_ENV) );</span><br></pre></td></tr></table></figure>

<p><strong>Mac下的package.json设置</strong></p>
<p>MAC电脑下需要把set换成export，并且要多加一个&amp;符，具体代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">    &quot;dev&quot;:&quot;export NODE_ENV&#x3D;dev&amp;&amp;webpack&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;export NODE_ENV&#x3D;build&amp;&amp;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="实战技巧：webpack模块化配置"><a href="#实战技巧：webpack模块化配置" class="headerlink" title="实战技巧：webpack模块化配置"></a>实战技巧：webpack模块化配置</h4><p>现在的前端开发随着ES6的普及已经大面积使用模块化进行开发了，那在webpack.config.js配置文件中，如何进行模块化开发那？例如把开发环境的写到一个模块中，把生产环境的写到一个模块中。这节课我们就用一节课的时间学习一下webpack模块化配置的技巧。</p>
<p><strong>JS中的模块化实现</strong></p>
<p>先来看一下JavaScript如何实现模块话开发。其实很多小伙伴都会这种操作，那我们就当复习了，再预习一遍知识。看下面ES6中的模块化代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function jspang()&#123;</span><br><span class="line">    alert(&#39;jspang.com:&#39;+&#39;webpack&#39;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports&#x3D;jspang;</span><br></pre></td></tr></table></figure>

<p>上面的代码是一个最简单的es6模块化写法，我们声明了一个jspang方法，并且把这个方法用module.exports进行暴露出去。然后我们在入口文件中用import进行引入，并进行使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import jspang from &#39;.&#x2F;jspang.js&#39;;</span><br><span class="line">jspang();</span><br></pre></td></tr></table></figure>

<p>我们了解如何作Javascript的模块化后，其实webpack的模块化和上边的过程很类似。</p>
<p><strong>webpack模块</strong></p>
<p>为了让大家容易看懂，我把webpack.config.js中的entry入口文件进行模块化设置，单独拿出来制作成一个模块。</p>
<p>首先在根目录，新建一个webpack_config文件夹，然后新建entry_webpack.js文件，代码如下：</p>
<p>entry_webpack.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明entry变量</span><br><span class="line">const entry &#x3D;&#123;&#125;;  </span><br><span class="line">&#x2F;&#x2F;声明路径属性</span><br><span class="line">entry.path&#x3D;&#123;</span><br><span class="line">    entry:&#39;.&#x2F;src&#x2F;entry.js&#39;  </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;进行模块化</span><br><span class="line">module.exports &#x3D;entry;</span><br></pre></td></tr></table></figure>

<p>配置的模块化代码编写好以后，需要在webpack.config.js中引入，注意这里的引入只能使用require的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const entry &#x3D; require(&quot;.&#x2F;webpack_config&#x2F;entry_webpack.js&quot;)</span><br></pre></td></tr></table></figure>

<p>然后在入口文件部分，修改成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry:entry.path,</span><br></pre></td></tr></table></figure>

<p>这时候你可以再次使用npm run dev 进行测试，你会发现模块化成功了。</p>
<p><strong>总结：</strong>模块化在实际工作中是必不可少的操作，但是现在的webpack教程还很少讲到，大家一定要重视这节，因为如果你搞不清这节的内容，可能你看别人的配置也会看不明白。记得一定要动手练习操作，否则你下面的课程也没办法学习。</p>
<h4 id="实战技巧：优雅打包第三方类库（JQuery）"><a href="#实战技巧：优雅打包第三方类库（JQuery）" class="headerlink" title="实战技巧：优雅打包第三方类库（JQuery）"></a>实战技巧：优雅打包第三方类库（JQuery）</h4><p>在工作中引用第三方的框架是必不可少的，比如引入JQuery或者Vue，但是很多小伙伴一遇到引入第三方的类库时就不知道如何操作了。这节课就学习一下如何优雅并正确的用webpack引入第三方库。（本节建议收看视频学习）我们讲两种打包的方法，小伙伴们可以根据自己的喜好选择，个人认为两种都是比较不错的。</p>
<p><strong>引入JQuery</strong></p>
<p>其实引用第三方库的方法有很多种，但是有些并不是很优雅，还有些方法会出现打包问题，技术胖在这里介绍一下自己工作中引入第三方模块的方法，我们就拿JQuery为例。小伙伴们要举一反三，学会后试着自己引入Vue试试。</p>
<p>安装JQuery</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save jquery</span><br></pre></td></tr></table></figure>

<p>安装时需要注意的时Jquery最终要在生产环境中使用，所以我们这里要使用–save进行安装。</p>
<p><strong>修改entry.js文件</strong></p>
<p>安装好后，还需要引入到我们的entry.js中，这里直接使用import进行引入就可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &#39;jquery&#39;;</span><br></pre></td></tr></table></figure>

<p>这里引入是不需要我们写相对路径的，因为jquery的包是在node_modules里的，只要写一个包名jquery，系统会自动为我们查找的。</p>
<p>引入好后我们就可以在entry.js里使用jquery，我们可以加入下面的代码，然后进行测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;#title&#39;).html(&#39;Hello JSpang&#39;);</span><br></pre></td></tr></table></figure>

<p>可以看到上面是标准的jquery代码，你可以使用npm run server 进行测试，现在代码顺利运行了，这说明我们引用的JQuery库成功了。需要说的是你不仅可以在入口中进行引入，你还可以在任何你需要的js中引入，webpack并不会重复打包，它只给我们打包一次。</p>
<p><strong>用plugin引入</strong></p>
<p>如果你觉的上面的方法和webpack没什么关系，只是普通的引入，webpack只是负责了一下打包，这样并没有全局感。那再学习一种在webapck.config.js中配置的方法，这种不需要你在入口文件中引入，而是webpack给你作了全局引入。这个插件就是ProvidePlugin。</p>
<p>ProvidePlugin是一个webpack自带的插件，Provide的意思就是装备、提供。因为ProvidePlugin是webpack自带的插件，所以要先再webpack.config.js中引入webpack。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constc  webpack &#x3D; require(&#39;webpack&#39;);</span><br></pre></td></tr></table></figure>

<p>在webpack.config.js里引入必须使用require，否则会报错的，这点小伙伴们一定要注意。</p>
<p>引入成功后配置我们的plugins模块，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    new webpack.ProvidePlugin(&#123;</span><br><span class="line">        $:&quot;jquery&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>配置好后，就可以在你的入口文件中使用了，而不用再次引入了。这是一种全局的引入，在实际工作中也可以很好的规范项目所使用的第三方库。</p>
<p><strong>总结：</strong>每一个项目都可能引入第三方类库，而像Vue和Angular这样的成熟框架都推出了自己的webpack框架，比如vue-cli。但是很多情况还是需要我们手动更改这些配置好的webpack来适用于我们的公司项目，所以这节课的知识也是在工作中经常使用的，希望小伙伴们一定要重视并进行练习。</p>
<h3 id="打包多个文件"><a href="#打包多个文件" class="headerlink" title="打包多个文件"></a>打包多个文件</h3><p><strong>1.多个js文件不合并打包(分别打包)</strong></p>
<p>配置文件./conf/webpack.dev.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>, <span class="comment">//打包为开发模式</span></span><br><span class="line">    <span class="comment">// 入口配置的对象中，属性为输出的js文件名，属性值为入口文件</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">    	main1:<span class="string">"./src/main1"</span>,</span><br><span class="line">    	main2:<span class="string">"./src/main2"</span></span><br><span class="line">    &#125;, <span class="comment">//入口文件,从项目根目录指定</span></span><br><span class="line">    output: &#123; <span class="comment">//输出路径和文件名，使用path模块resolve方法将输出路径解析为绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"../dist/js"</span>), <span class="comment">//将js文件打包到dist/js的目录</span></span><br><span class="line">        filename: <span class="string">"[name].js"</span> <span class="comment">//使用[name]打包出来的js文件会分别按照入口文件配置的属性来命名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包过程：</p>
<p><img src="https://img-blog.csdn.net/20180719162034769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjE4NTAyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>打包结果：</p>
<p><img src="https://img-blog.csdn.net/20180719162218590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjE4NTAyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>2.多个js中部分合并打包成一个js文件</strong></p>
<p>配置文件./conf/webpack.dev.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>, <span class="comment">//打包为开发模式</span></span><br><span class="line">    <span class="comment">// 出口对象中，属性为输出的js文件名，属性值为入口文件</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">    	main1:<span class="string">"./src/main1"</span>,</span><br><span class="line">    	main:[<span class="string">"./src/main2"</span>,<span class="string">"./src/main3"</span>]</span><br><span class="line">    &#125;, <span class="comment">//入口文件,从项目根目录指定</span></span><br><span class="line">    output: &#123; <span class="comment">//输出路径和文件名，使用path模块resolve方法将输出路径解析为绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"../dist/js"</span>), <span class="comment">//将js文件打包到dist/js的目录</span></span><br><span class="line">        filename: <span class="string">"[name].js"</span> <span class="comment">//使用[name]打包出来的js文件会分别按照入口文件配置的属性来命名</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.多个js全部打包成一个js文件</strong></p>
<p>配置文件./conf/webpack.dev.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>, <span class="comment">//打包为开发模式</span></span><br><span class="line">    <span class="comment">// 出口对象中，属性为输出的js文件名，属性值为入口文件</span></span><br><span class="line">    entry: [<span class="string">"./src/main1"</span>,<span class="string">"./src/main2"</span>,<span class="string">"./src/main3"</span>], <span class="comment">//入口文件,从项目根目录指定</span></span><br><span class="line">    output: &#123; <span class="comment">//输出路径和文件名，使用path模块resolve方法将输出路径解析为绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"../dist/js"</span>), <span class="comment">//将js文件打包到dist/js的目录</span></span><br><span class="line">        filename: <span class="string">"main.js"</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>webpack3</category>
      </categories>
      <tags>
        <tag>webpack3</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack常见loader和plugins</title>
    <url>/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/</url>
    <content><![CDATA[<h3 id="常用webpack插件"><a href="#常用webpack插件" class="headerlink" title="常用webpack插件"></a>常用webpack插件</h3><p><strong>注意：插件的引入都在webpack.config.js中</strong></p>
<h4 id="live-server-必须全局安装，命令直接使用"><a href="#live-server-必须全局安装，命令直接使用" class="headerlink" title="live-server (必须全局安装，命令直接使用)"></a>live-server (必须全局安装，命令直接使用)</h4><p>一款npm工具，全局npm i -g live-server后，项目目录使用live-server命令行命令便可直接在浏览器中预览（默认找index.html，其他请自行带上文件名空格后跟在后面），并且自动全局监听实时更新</p>
<p>1.新建一个文件夹（最好英文），执行npm init命令；</p>
<p>2.生成package.json文件后，执行npm install -g live-server命令；</p>
<p>3.安装完成后，就可以执行live-server命令启动；</p>
<p>设置快捷方式如下：</p>
<p>1.找到package.json文件，然后找到”script”，写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;:&quot;live-server .&#x2F;port&#x3D;9090&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<a id="more"></a>



<p><img src="https:////upload-images.jianshu.io/upload_images/15484248-5c9d169a4fcb77da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488/format/webp" alt="img"></p>
<p>2.启动如下：npm run server。</p>
<h4 id="uglifyjs-webpack-plugin（js压缩插件）"><a href="#uglifyjs-webpack-plugin（js压缩插件）" class="headerlink" title="uglifyjs-webpack-plugin（js压缩插件）"></a>uglifyjs-webpack-plugin（js压缩插件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npmn  i -D uglifyjs-webpack-plugin</span><br><span class="line"></span><br><span class="line">const uglify &#x3D; &#96;require&#96;(&#39;uglifyjs-webpack-plugin&#39;);</span><br><span class="line">plugins:[</span><br><span class="line">        new uglify(&#123;</span><br><span class="line">            uglifyOptions: &#123;</span><br><span class="line">                compress: &#123;</span><br><span class="line">                    warnings: true,&#x2F;&#x2F;移除警告</span><br><span class="line">                    drop_debugger: true,&#x2F;&#x2F;移除debugger</span><br><span class="line">                    drop_console: true,&#x2F;&#x2F;移除console</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sourceMap: config.build.productionSourceMap,</span><br><span class="line">            test: &#x2F;\.js(\?.*)?$&#x2F;i,  &#x2F;&#x2F;测试匹配文件,</span><br><span class="line">            include: &#x2F;\&#x2F;includes&#x2F;, &#x2F;&#x2F;包含哪些文件</span><br><span class="line">            excluce: &#x2F;\&#x2F;excludes&#x2F;, &#x2F;&#x2F;不包含哪些文件</span><br><span class="line">            &#x2F;&#x2F;允许过滤哪些块应该被uglified（默认情况下，所有块都是uglified）。 </span><br><span class="line">            &#x2F;&#x2F;返回true以uglify块，否则返回false。</span><br><span class="line">            chunkFilter: (chunk) &#x3D;&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F; &#96;vendor&#96; 模块不压缩</span><br><span class="line">                if (chunk.name &#x3D;&#x3D;&#x3D; &#39;vendor&#39;) &#123;</span><br><span class="line">                  return false;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">            cache: false,   &#x2F;&#x2F;是否启用文件缓存，默认缓存在node_modules&#x2F;.cache&#x2F;uglifyjs-webpack-plugin.目录</span><br><span class="line">        	parallel: true,  &#x2F;&#x2F;使用多进程并行运行来提高构建速度</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>



<h4 id="html-webpack-plugin（打包HTML文件）"><a href="#html-webpack-plugin（打包HTML文件）" class="headerlink" title="html-webpack-plugin（打包HTML文件）"></a>html-webpack-plugin（<strong>打包HTML文件</strong>）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line"></span><br><span class="line">const htmlPlugin&#x3D; &#96;require&#96;(&#39;html-webpack-plugin&#39;);</span><br><span class="line">plugins:[</span><br><span class="line">         new htmlPlugin(&#123;</span><br><span class="line">            minify:&#123;</span><br><span class="line">                removeAttributeQuotes:true</span><br><span class="line">            &#125;,</span><br><span class="line">            hash:true,</span><br><span class="line">            template:&#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#x2F;&#x2F;打包结束后生成一个html文件，并且自动引入打包的js</span><br></pre></td></tr></table></figure>



<h4 id="clean-webpack-plugin（打包前删除dist文件）"><a href="#clean-webpack-plugin（打包前删除dist文件）" class="headerlink" title="clean-webpack-plugin（打包前删除dist文件）"></a>clean-webpack-plugin（打包前删除dist文件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br><span class="line"></span><br><span class="line">const CleanWebpackPlugin&#x3D; &#96;require&#96;(&#39;clean-webpack-plugin&#39;);</span><br><span class="line">plugins:[</span><br><span class="line">         new CleanWebpackPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure>



<h4 id="hot-module-replacement-热更新"><a href="#hot-module-replacement-热更新" class="headerlink" title="hot-module-replacement(热更新)"></a>hot-module-replacement(热更新)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br></pre></td></tr></table></figure>

<p>开启热更新</p>
<p><img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200924162419801.png" alt="image-20200924162419801"></p>
<p><img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200924162037602.png" alt="image-20200924162037602"></p>
<p>判断哪个文件做了修改，重新调用</p>
<p><img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200924162359826.png" alt="image-20200924162359826"></p>
<h4 id="extract-text-webpack-plugin（分离css插件）"><a href="#extract-text-webpack-plugin（分离css插件）" class="headerlink" title="extract-text-webpack-plugin（分离css插件）"></a>extract-text-webpack-plugin（分离css插件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br><span class="line"></span><br><span class="line">const extractTextPlugin &#x3D; &#96;require&#96;(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line">plugins:[</span><br><span class="line">        new extractTextPlugin(&quot;&#x2F;css&#x2F;index.css&quot;)</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>



<h4 id="PurifyCSS-webpack（消除未使用的css，必须配合extract-text-webpack-plugin插件）"><a href="#PurifyCSS-webpack（消除未使用的css，必须配合extract-text-webpack-plugin插件）" class="headerlink" title="PurifyCSS-webpack（消除未使用的css，必须配合extract-text-webpack-plugin插件）"></a>PurifyCSS-webpack（消除未使用的css，必须配合extract-text-webpack-plugin插件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npmn  i -D purifycss-webpack purify-css</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">onst PurifyCSSPlugin &#x3D; require(&quot;purifycss-webpack&quot;);</span><br><span class="line">new PurifyCSSPlugin(&#123;</span><br><span class="line">        &#x2F;&#x2F; Give paths to parse for rules. These should be absolute!</span><br><span class="line">        paths: glob.sync(path.join(__dirname, &#39;src&#x2F;*.html&#39;)),</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>



<p>骨架屏的插件见：vue-skeleton-webpack-plugin.md</p>
<h3 id="常见Loader"><a href="#常见Loader" class="headerlink" title="常见Loader"></a>常见Loader</h3><ul>
<li>可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。</li>
<li>可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。</li>
<li>可以把React中的JSX转换成JavaScript代码。</li>
</ul>
<p>注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。下面我们对Loaders的配置型简单梳理一下。</p>
<ul>
<li>test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；</li>
<li>use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；</li>
<li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li>
<li>query：为loaders提供额外的设置选项（可选）。</li>
</ul>
<h4 id="px2rem-loader-px单位转成rem"><a href="#px2rem-loader-px单位转成rem" class="headerlink" title="px2rem-loader(px单位转成rem)"></a>px2rem-loader(px单位转成rem)</h4><p>1.首先下载 lib-flexible</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install lib-flexible --save</span><br></pre></td></tr></table></figure>

<p>2.在main.js中引用 lib-flexible</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1544063/201912/1544063-20191203165101027-1706123685.png" alt="img"></p>
<p> 3.安装px2rem-loader(将px转换成rem)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install px2rem-loader</span><br></pre></td></tr></table></figure>

<p>4.配置px2rem</p>
<p>在build/utils.js中配置px2rem</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1544063/201912/1544063-20191203165921076-1993510106.png" alt="img"></p>
<p> <img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200927173555497.png" alt="image-20200927173555497"></p>
<p>我这边是根据 iphone6的设计图尺寸来的，所以用37.5能方便把设计图上的px直接写在代码里面。</p>
<p>最后重新 npm run dev 就可以使用了</p>
<p>　</p>
<h4 id="cssLoader（style-loader和css-loader）"><a href="#cssLoader（style-loader和css-loader）" class="headerlink" title="cssLoader（style-loader和css-loader）"></a>cssLoader（<strong>style-loader和</strong>css-loader）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install style-loader@0.13.1 css-loader@0.25.0 --save-dev</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: &#x2F;\.css$&#x2F;,</span><br><span class="line">              use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="图片Loader（file-loader和url-loader）"><a href="#图片Loader（file-loader和url-loader）" class="headerlink" title="图片Loader（file-loader和url-loader）"></a>图片Loader（<strong>file-loader</strong>和<strong>url-loader</strong>）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line"> module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">               test:&#x2F;\.(png|jpg|gif)&#x2F; ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:&#39;url-loader&#39;,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:500000,</span><br><span class="line">                       outputPath:&#39;images&#x2F;&#39;,&#x2F;&#x2F;打包后的路径</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br><span class="line">test:&#x2F;.(png|jpg|gif)&#x2F;是匹配图片文件后缀名称。</span><br><span class="line">use：是指定使用的loader和loader的配置参数。</span><br><span class="line">limit：是把小于500000B的文件打成Base64的格式，写入JS。</span><br><span class="line">url-loader和file-loader的区别在于url-loader有limit这个参数</span><br></pre></td></tr></table></figure>



<h4 id="hmtl文件中引入图片标签的Loader（html-withimg-loader）"><a href="#hmtl文件中引入图片标签的Loader（html-withimg-loader）" class="headerlink" title="hmtl文件中引入图片标签的Loader（html-withimg-loader）"></a>hmtl文件中引入图片标签的Loader（html-withimg-loader）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">    test: &#x2F;\.(htm|html)$&#x2F;i,</span><br><span class="line">     use:[ &#39;html-withimg-loader&#39;] </span><br><span class="line">&#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="less-Loader"><a href="#less-Loader" class="headerlink" title="less-Loader"></a>less-Loader</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev less</span><br><span class="line">npm n install --save-dev less-loader</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">       &#123;</span><br><span class="line">    test: &#x2F;\.less$&#x2F;,</span><br><span class="line">    use: [&#123;</span><br><span class="line">           loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">        , &#123;</span><br><span class="line">            loader: &quot;less-loader&quot; &#x2F;&#x2F; compiles Less to CSS</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">使用extract-text-webpack-plugin插件分离</span><br><span class="line">module:&#123;</span><br><span class="line">&#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;less-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">                &#x2F;&#x2F; use style-loader in development</span><br><span class="line">                fallback: &quot;style-loader&quot;</span><br><span class="line">            &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="SASS-Loader"><a href="#SASS-Loader" class="headerlink" title="SASS-Loader"></a>SASS-Loader</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm n install --save-dev node-sass</span><br><span class="line">cnpm install --save-dev sass-loader</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">       &#123;</span><br><span class="line">                test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;sass-loader&quot; &#x2F;&#x2F; compiles Sass to CSS</span><br><span class="line">                &#125;]</span><br><span class="line">&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    使用extract-text-webpack-plugin插件分离</span><br><span class="line">module:&#123;</span><br><span class="line">&#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;sass-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">                &#x2F;&#x2F; use style-loader in development</span><br><span class="line">                fallback: &quot;style-loader&quot;</span><br><span class="line">            &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="css3属性前缀postcss-loader"><a href="#css3属性前缀postcss-loader" class="headerlink" title="css3属性前缀postcss-loader"></a>css3属性前缀postcss-loader</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br><span class="line"></span><br><span class="line">和webpack.config.js同级，建立一个postcss.config.js文件。</span><br><span class="line">postcss.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: &#123;  </span><br><span class="line">        &#39;autoprefixer&#39;: &#123;browsers: &#39;last 5 version&#39;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对postcss.config.js配置完成后，我们还需要编写我们的loader配置。</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">      test: &#x2F;\.css$&#x2F;,</span><br><span class="line">      use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &quot;style-loader&quot;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: &quot;css-loader&quot;,</span><br><span class="line">              options: &#123;</span><br><span class="line">                 modules: true</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: &quot;postcss-loader&quot;</span><br><span class="line">            &#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br><span class="line">提取CSS</span><br><span class="line">配置提取CSS的loader配置.</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &#39;style-loader&#39;,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; </span><br><span class="line">            	loader: &#39;css-loader&#39;,</span><br><span class="line">            	options: &#123; </span><br><span class="line">            		importLoaders: 1 ,</span><br><span class="line">            		module:true</span><br><span class="line">            	&#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            &#x2F;&#x2F;importLoader：在使用css-loader之前必须先走下面的1个loader，importLoaders: 2使用css-loader之前必须先走下面的2个loader，以此类推</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            &#39;postcss-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="css-loader的模块化使用，只作用于当前文件"><a href="#css-loader的模块化使用，只作用于当前文件" class="headerlink" title="css-loader的模块化使用，只作用于当前文件"></a>css-loader的模块化使用，只作用于当前文件</h4><p><img src="/2020/09/22/webpack%E5%B8%B8%E8%A7%81loader%E5%92%8Cplugins/image-20200924143827807.png" alt="image-20200924143827807"></p>
<h3 id="loader的三种写法："><a href="#loader的三种写法：" class="headerlink" title="loader的三种写法："></a><strong>loader的三种写法：</strong></h3><p>上节课学习了如何把CSS文件进行打包到JS当中去，有小伙伴就提问，我看到别人的CSS打包的写法和你的写法不太一样，是不是他们写错了，loader还有几种写法，这里我们就看两种另外的写法。</p>
<p><strong>第一种写法：直接用use。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.css$&#x2F;,</span><br><span class="line">                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p><strong>第二种写法：把use换成loader。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.css$&#x2F;,</span><br><span class="line">                loader:[&#39;style-loader&#39;,&#39;css-loader&#39;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>*<em>第三种写法：用use+loader的写法： *</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>由此看出，webpack的扩展和灵活性是非常强的，你习惯于那种写法都可以。最重要的是，你看见别人项目的其他写法也不要慌张，自己去试一试，有可能就可以Get到新知识。</p>
<h3 id="Babel的安装与配置"><a href="#Babel的安装与配置" class="headerlink" title="Babel的安装与配置"></a>Babel的安装与配置</h3><p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。</p>
<p>我们先一次性安装这些依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm c install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</span><br></pre></td></tr></table></figure>

<p>在webpack中配置Babel的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:&#39;babel-loader&#39;,</span><br><span class="line">        options:&#123;</span><br><span class="line">            presets:[</span><br><span class="line">                &quot;es2015&quot;,&quot;react&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你已经可以用webapck转换ES6的语法兼容各个浏览器了，我们可以修改一下entry.js的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import css from &#39;.&#x2F;css&#x2F;index.css&#39;;</span><br><span class="line">&#123;</span><br><span class="line">    let jspangString &#x3D; &#39;Hello Webpack&#39;</span><br><span class="line">    document.getElementById(&#39;title&#39;).innerHTML&#x3D;jspangString; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用了ES6的let声明方法。如果你不使用Babel来进行转换，你会发现打包出来的js代码没有作兼容处理，使用了Babel转换的代码是进行处理过的。</p>
<p><strong>.babelrc配置</strong></p>
<p>虽然Babel可以直接在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，如果卸载webapck.config.js中会非常的雍长不可阅读，所以我们经常把配置卸载.babelrc文件里。</p>
<p>在项目根目录新建.babelrc文件，并把配置写到文件里。</p>
<p>.babelrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;react&quot;,&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.webpack.config.js里的loader配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:&#39;babel-loader&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ENV：</strong></p>
<p>现在网络上已经不流行babel-preset-es2015，现在官方推荐使用的是babel-preset-env,那我们为了紧跟潮流，我们在讲一下env的配置方法。</p>
<p>首先需要下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm n install --save-dev babel-preset-env</span><br></pre></td></tr></table></figure>

<p>然后修改.babelrc里的配置文件。其实只要把之前的es2015换成env就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>plugins</tag>
        <tag>loader</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell之初见</title>
    <url>/2020/10/30/xshell%E4%B9%8B%E5%88%9D%E8%A7%81/</url>
    <content><![CDATA[<h3 id="Xshell概述"><a href="#Xshell概述" class="headerlink" title="Xshell概述"></a>Xshell概述</h3><p>Xshell软件的介绍百度上太多，也凸显不出重点，大家不能很好地理解，这里简要概况一下。</p>
<p>Xshell是一个强大的安全终端模拟软件，可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的，比如说用Xshell（地点在上海）连接远程Linux服务器系统（地点在北京），只需要在Xshell中输入Linux服务器系统的IP地址，这样就可以将远程（北京）的Linux服务器系统连接到Xshell（上海）了，实现了远程的模拟控制。直白点说，就是在上海的Xshell可以控制远在北京的Linux服务器系统，通过Linux命令实现需要完成的功能。</p>
<a id="more"></a>

<h3 id="1-Xshell下载与安装"><a href="#1-Xshell下载与安装" class="headerlink" title="1.Xshell下载与安装"></a>1.Xshell下载与安装</h3><p>进入<a href="https://link.jianshu.com?t=https%3A%2F%2Fwww.netsarang.com%2Fdownload%2Fmain.html" target="_blank" rel="noopener">xshell官网下载页面</a>，找到xshell5，点击后面的download</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-ee15b04539696d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688/format/webp" alt="img"></p>
<p>它会跳转到另一个页面，选择Evaluation user / Home &amp; School user， license type要选择home and school use，这种是可以免费使用的，其他的按要求填好即可。填好之后再点submit</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-0c785451af551b83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/607/format/webp" alt="img"></p>
<p>发送成功后会有提示</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-294c4b8a251cc988.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/681/format/webp" alt="img"></p>
<p>然后进入到你的前文填写的邮箱，会收到一个邮件，里面有一个下载链接，直接点开就可以下载XSHELL软件了。</p>
<p>下载完以后，点击安装，一直点下一步即可，需要注意这一步要选择免费为家庭/学校。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-5859bb07a65fff00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp" alt="img"></p>
<h3 id="2-在xshell里添加会话"><a href="#2-在xshell里添加会话" class="headerlink" title="2. 在xshell里添加会话"></a>2. 在xshell里添加会话</h3><p>新安装的xshell会自动提示你需要添加一个会话，点击新建</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-f2fe9a106583f6c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt="img"></p>
<p>在弹出的窗口中依次填上如下数据</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-698e0fec8715d6da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/573/format/webp" alt="img"></p>
<p><strong>名称</strong>：就是会话的名字，随便写，方便记住就行</p>
<p><strong>协议</strong>：默认就是SSH，不用管它</p>
<p><strong>主机</strong>：就是你的空间的IP</p>
<p><strong>端口号</strong>：就是你空间的端口号ssh port</p>
<p>其他不填，然后点击确定，添加成功。</p>
<p>如果要添加多个会话，就点击文件 - 新建，再填上相应的参数即可</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-9934c6a56b3ddbd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/237/format/webp" alt="img"></p>
<h3 id="3-通过xshell连接空间服务器"><a href="#3-通过xshell连接空间服务器" class="headerlink" title="3. 通过xshell连接空间服务器"></a>3. 通过xshell连接空间服务器</h3><p>点击文件-打开，在会话面板中，选中你要链接的会话，然后点击连接</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-4c0a5c8f73e898c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/547/format/webp" alt="img"></p>
<p>第一次进入的时候，会出现以下提示，点击接受并保存</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-6db92986719dd757.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/489/format/webp" alt="img"></p>
<p>接下来会提示输入ssh 用户名，直接输入root，这个是任何VPS或主机默认的用户名，如果有其他的用户名，就输入其他的。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-edf892e8763d2866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/362/format/webp" alt="img"></p>
<p>然后在记住用户名前面打勾，再点击确定</p>
<p>接下来会提示让你输入root的密码，复制密码后，在框中-右键-粘贴为纯文本，并勾选记住密码，再点击确定。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-8e9254efc020c0ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/458/format/webp" alt="img"></p>
<p>如果xshell面板中出现以下提示，则表示连接成功。如果提示密码不对，就要检查密码，必要时手动输入密码。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-fa29bc736ab7f24f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/548/format/webp" alt="img"></p>
<h3 id="4-Xshell上指令操作步骤"><a href="#4-Xshell上指令操作步骤" class="headerlink" title="4. Xshell上指令操作步骤"></a>4. Xshell上指令操作步骤</h3><p>首先要保证XSHELL跟空间是连通的状态，如下图所示，就是已经连接上</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-e2d4ee8ecf3aee91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp" alt="img"></p>
<p>如果是下图所示这种情况，就是没有连接上，或者退出了，一定要重新连接成功才能继续操作。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-a8389c4daa229bc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/474/format/webp" alt="img"></p>
<p>XSHELL上面跟远程的VPS空间通信是用指令来完成的，下面是在xshell上面跟linux通信流程</p>
<p><strong>1）输入指令</strong>： 复制好指令，在面板上-右键-粘贴即可输入，也可以手动输入。注意只支持英文字符半角</p>
<p>如下图所示，我们以nginx -t这个指令来演示</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-917d296d6f0c80e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/459/format/webp" alt="img"></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-62050f6ef3743c77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/299/format/webp" alt="img"></p>
<p><strong>2）回车</strong>：在上一步输入指令后，直接回车</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-cd776ec8747a01ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/593/format/webp" alt="img"></p>
<p><strong>3）服务器执行指令</strong></p>
<p>有些指令是有反馈结果的，会提示做了哪些事情，花了多少时间或者是提示结果等。如上图，nginx -t是测试nginx软件服务器的状态的，显示状态OK，有两条结果。</p>
<p>而有些指令又是没有结果的，像service nginx restart，重启nginx服务器，是没有任何结果提示的。无论指令有没有结果提示，最后都会回到新的命令指示符，如下图所示。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-63784f8ac598b076.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/445/format/webp" alt="img"></p>
<h3 id="5-常见ubuntu指令简单介绍"><a href="#5-常见ubuntu指令简单介绍" class="headerlink" title="5. 常见ubuntu指令简单介绍"></a>5. 常见ubuntu指令简单介绍</h3><p>nano 文件编辑命令，后面接你要编辑的文件名带格式 ，如 nano  php.ini</p>
<p>cd 进入目录命令，后面接你要进入的目录（对应电脑上的文件夹），如cd /etc/nginx/</p>
<p>cp 复制命令，后面接你要复制的源文件和新文件名， 如 cp php.ini new-php.ini</p>
<p>ls 列出当前目录下所有的文件及文件夹 ，ls -a 表示加上隐藏文件全部列出</p>
<p>wget 下载文件到当前目录，后面一般接文件的URL地址， 如</p>
<p>wget –no-check-certificate <a href="http://wordpress.org/latest.tar.gz" target="_blank" rel="noopener">http://wordpress.org/latest.tar.gz</a> 下载wp最新版本文件的意思</p>
<p>mv 移动命令，后面接源文件和目的目录 ， 如 mv  wp-config.php  /var/www</p>
<p>rm 删除命名，后面接文件名， rm -r 删除文件夹的命令</p>
<p><strong>命令使用注意</strong>：执行命令时一定要慎重，一定要知道自己在做什么，否则就有可能造成无法恢复的trouble!</p>
<h3 id="6-Xshell使用常见问题"><a href="#6-Xshell使用常见问题" class="headerlink" title="6. Xshell使用常见问题"></a>6. Xshell使用常见问题</h3><p>1）最常见的问题应该是连接不上的问题，这个主要出现在连接国外空间的时候，主要原因是被墙了。如下图所示</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-02980fa7810c5aa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/586/format/webp" alt="img"></p>
<p>不用担心，可以用添加代理的方式解决，方法如下</p>
<p>1）首先你要有一个能上GOOGLE的SS账号，（SSR应该也可以），如果没有可以自己搭建一个，参考<a href="https://link.jianshu.com?t=https%3A%2F%2Fwww.imhunk.com%2Fvisit-google-freely%2F" target="_blank" rel="noopener">自己动手搭建科学上网工具（V+P+N）</a></p>
<p>2）然后点击 文件 -打开 -选择连不上的那个会话，然后右键 -点击属性</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-7dba8a32f5d9533f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/532/format/webp" alt="img"></p>
<p>点击左侧的代理，然后点击右侧代理服务器后面的浏览</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-d893db1510cc101c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/553/format/webp" alt="img"></p>
<p>在弹出的窗口中，点击添加</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-71d2e35bb6cd01f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/390/format/webp" alt="img"></p>
<p>然后依次下图填写相应的值，密码填上你的SS的密码，再点击确定</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-e416369a916e2af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/341/format/webp" alt="img"></p>
<p>然后在把代理服务器选择ss，再点击确定</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-19168210f42717bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/526/format/webp" alt="img"></p>
<p>3）再重新连接对话，就可以发现成功连上了！ YEAH!</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7940255-b72e646b718428e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/612/format/webp" alt="img"></p>
<p>2）快捷键的问题</p>
<p>很多我们日常使用的快捷键是不能用或者意思不同，比如CTRL+C，这个在XSHELL中是强制退出运行程序的意思。一定要注意。</p>
<p>如果需要复制，就先选中，然后右键-复制。如果需要粘贴，那么先选中，然后右键-粘贴。</p>
<p>链接：<a href="https://www.jianshu.com/p/20f59a08158b" target="_blank" rel="noopener">https://www.jianshu.com/p/20f59a08158b</a></p>
]]></content>
      <categories>
        <category>Xshell</category>
      </categories>
      <tags>
        <tag>Xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试复习</title>
    <url>/2020/09/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>参考：<a href="https://mp.weixin.qq.com/s/QX0HL1tCAGU70zEb-HJQlQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QX0HL1tCAGU70zEb-HJQlQ</a></p>
<p>手写函数合集</p>
<p><a href="https://mp.weixin.qq.com/s/5mlf4yo6v4gRJnePAluqgg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5mlf4yo6v4gRJnePAluqgg</a></p>
<p>proxy代理简介</p>
<p><a href="https://mp.weixin.qq.com/s/Nvp_N4Sj0PlBqXjTis7UCQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nvp_N4Sj0PlBqXjTis7UCQ</a></p>
<p>输入URL到渲染全面梳理</p>
<p><a href="https://blog.csdn.net/qq_43430453/article/details/107421120" target="_blank" rel="noopener">https://blog.csdn.net/qq_43430453/article/details/107421120</a></p>
<p>常用的前端JavaScript方法封装</p>
<p><a href="https://mp.weixin.qq.com/s/faO3jszPOezv-XVuV11SXQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/faO3jszPOezv-XVuV11SXQ</a></p>
<p>遍历A节点的父节点下的所有子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var b&#x3D;document.getElementById(&quot;a&quot;).parentNode.children;</span><br><span class="line">    console.log(b)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>target、currentTarget的区别？</p>
<p>currentTarget当前所绑定事件的元素（指向出发事件的函数，始终不变）</p>
<p>target当前被点击的元素</p>
<p>在浏览器地址栏中输入URL后发生了什么</p>
<h4 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h4><p>①查询ip地址</p>
<p>②建立tcp连接，接入服务器</p>
<p>③浏览器发起http请求</p>
<p>④服务器后台操作并做出http响应</p>
<p>⑤网页的解析与渲染</p>
<p>优化：</p>
<h5 id="从此可以得出网站的一些优化的方法"><a href="#从此可以得出网站的一些优化的方法" class="headerlink" title="从此可以得出网站的一些优化的方法:"></a>从此可以得出网站的一些优化的方法:</h5><p>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p>
<p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p>
<p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p>
<p>④提前渲染开始时间：将css链接放在html头部。</p>
<p>⑤减轻解析器的阻塞：将js链接放在body尾部。</p>
<p>参考：<a href="https://www.cnblogs.com/yanruizhe/p/11462462.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanruizhe/p/11462462.html</a></p>
<p>页面渲染html的过程？</p>
<blockquote>
<p>不需要死记硬背，理解整个过程即可</p>
</blockquote>
<p>浏览器渲染页面的一般过程：</p>
<p>1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。</p>
<p>2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</p>
<p>3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。</p>
<p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</p>
<p>4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p>
<p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。</p>
<p>说一下CORS？</p>
<p>CORS是一种新标准，支持同源通信，也支持跨域通信。fetch是实现CORS通信的</p>
<p>如何中断ajax请求？</p>
<p>一种是设置超时时间让ajax自动断开，另一种是手动停止ajax请求，其核心是调用XML对象的abort方法，ajax.abort()</p>
<p>用js递归的方式写1到100求和？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function num(n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1) return 1;</span><br><span class="line">    return num(n-1)+n;</span><br><span class="line">&#125;</span><br><span class="line">num(100);    </span><br><span class="line">延申：</span><br><span class="line">var sum &#x3D; 0;</span><br><span class="line">for(var i &#x3D; 1 ; i &lt;&#x3D; 100; i++)&#123;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">document.writeln(&quot;1~100以内的和为：&quot;+ sum);</span><br></pre></td></tr></table></figure>



<p>数组去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种：</span><br><span class="line">var arr&#x3D;[&#39;12&#39;,&#39;32&#39;,&#39;89&#39;,&#39;12&#39;,&#39;12&#39;,&#39;78&#39;,&#39;12&#39;,&#39;32&#39;];</span><br><span class="line">    &#x2F;&#x2F; 最简单数组去重法</span><br><span class="line">    function unique1(array)&#123;</span><br><span class="line">        var n &#x3D; []; &#x2F;&#x2F;一个新的临时数组</span><br><span class="line">        for(var i &#x3D; 0; i &lt; array.length; i++)&#123; &#x2F;&#x2F;遍历当前数组</span><br><span class="line">            if (n.indexOf(array[i]) &#x3D;&#x3D; -1)</span><br><span class="line">                n.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">arr&#x3D;unique1(arr);</span><br><span class="line"></span><br><span class="line">第二种</span><br><span class="line">es6方法数组去重</span><br><span class="line">arr&#x3D;[...new Set(arr)];</span><br><span class="line"></span><br><span class="line">第三种</span><br><span class="line">es6方法数组去重，第二种方法</span><br><span class="line">function dedupe(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));       &#x2F;&#x2F;Array.from()能把set结构转换为数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>变量提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a);  &#x2F;&#x2F;undefined</span><br><span class="line">var a &#x3D; 123;</span><br><span class="line"></span><br><span class="line">经典案例</span><br><span class="line">console.log(v1);</span><br><span class="line">var v1 &#x3D; 100;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(v1);</span><br><span class="line">    var v1 &#x3D; 200;</span><br><span class="line">    console.log(v1);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">console.log(v1);</span><br><span class="line">&#x2F;&#x2F; undefined  undefined 200  100</span><br></pre></td></tr></table></figure>

<p>函数提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数字面量式</span><br><span class="line">bar()</span><br><span class="line">var bar &#x3D; function() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 报错：TypeError: bar is not a function</span><br><span class="line"></span><br><span class="line">函数声明式</span><br><span class="line">bar()</span><br><span class="line">function bar() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果1</span><br></pre></td></tr></table></figure>



<p>虚拟dom的产生</p>
<p>改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树。</p>
<p>如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小</p>
<p>vue </p>
<p>采用的是虚拟 dom 通过重写 setter ， getter 实现观察者监听 data 属性的变化生成新的虚拟 dom 通过 h 函数创建真实 dom 替换掉dom树上对应的旧 dom。</p>
<p>react</p>
<p>react 也是通过虚拟 dom 和 setState 更改 data 生成新的虚拟 dom 以及 diff 算法来计算和生成需要替换的 dom 做到局部更新的。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串方法</title>
    <url>/2020/07/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="charAt-方法"><a href="#charAt-方法" class="headerlink" title="charAt()方法"></a>charAt()方法</h3><p>charAt()返回字符串中x位置的字符，下标从 0 开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;charAt(x)返回字符串中x位置的字符，下标从 0 开始。</span><br><span class="line"></span><br><span class="line">    var myString &#x3D; &#39;wangxiaoting&#39;;</span><br><span class="line"></span><br><span class="line">    console.log(myString.charAt(7)); &#x2F;&#x2F; o</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat() 方法"></a>concat() 方法</h3><p>concat() 方法用于连接两个或多个字符串，此方法不改变现有的字符串，返回拼接后的新的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">     var name&#x3D;&quot;wnagxiaoting&quot;</span><br><span class="line"></span><br><span class="line">     var singel &#x3D; name.concat(&quot; is a&quot;,&quot;beautiful  girls&quot;)</span><br><span class="line"></span><br><span class="line">     console.log(singel) &#x2F;&#x2F; wnagxiaoting is abeautiful  girls</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>slice() 提取字符串的一部分片段，并返回一个新的字符串</p>
<p>接收起始位置但不接收末尾位置，俗称留头不留尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;slice() 方法可提取字符串的某个部分，返回一个新的字符串。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;包括字符串从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符。</span><br><span class="line">	&#x2F;&#x2F;start和end都可以是负数，如果是负数，就从字符串的尾部开始算起，例如-1就是最后一个字符，-2就是倒数第二个字符，一次类推</span><br><span class="line">    &#x2F;&#x2F;如果未指定end参数，则截取从 start 到原字符串结尾的字符串</span><br><span class="line">    </span><br><span class="line">    var myString&#x3D;&quot;wangxiaoting&quot;</span><br><span class="line"></span><br><span class="line">    console.log(myString.slice(0,5) ) &#x2F;&#x2F;打印结果 &quot;wangx&quot;</span><br><span class="line"></span><br><span class="line">    console.log( myString.slice(1,6)) &#x2F;&#x2F;打印结果 &quot;angxi&quot;</span><br><span class="line"></span><br><span class="line">	从后向前获取数组元素</span><br><span class="line">	var arr &#x3D; [1, 2, 3, 4]</span><br><span class="line">	console.log(arr.slice(-1)) &#x2F;&#x2F; [4]</span><br><span class="line">	console.log(arr.slice(-2)) &#x2F;&#x2F; [3, 4]</span><br><span class="line">	console.log(arr.slice(-3)) &#x2F;&#x2F; [2, 3, 4]</span><br><span class="line">	console.log(arr.slice(-4)) &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>





<h3 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h3><p>返回位于String对象中指定位置的子字符串，作用是提取字符串的子串，和slice一样也是留头不留尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;substring() 方法用于提取字符串中介于两个指定下标之间的字符，</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方返回的子串包括 start 处的字符，但不包括 stop 处的字符，to 可选，如果省略该参数，那么返回的子串会一直到字符串的结尾。</span><br><span class="line"></span><br><span class="line">    var myString &#x3D; &#39;wangxiaoting&#39;;</span><br><span class="line"></span><br><span class="line">    myString &#x3D; myString.substring(0,4);</span><br><span class="line"></span><br><span class="line">    console.log(myString)&#x2F;&#x2F;打印结果  wang</span><br><span class="line">    </span><br><span class="line">    截取字符串最后几位</span><br><span class="line">    var test&#x3D;&#39;123456789&#39;</span><br><span class="line">    console.log(test.substring(test.length-4))</span><br><span class="line">    </span><br><span class="line">    截取到字符倒数第二个</span><br><span class="line">	infoString &#x3D; infoString.substr(0, infoString.length - 1)</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="substr-方法"><a href="#substr-方法" class="headerlink" title="substr 方法"></a>substr 方法</h3><p>返回一个从指定位置开始到指定长度的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;substring() 方法用于提取字符串中介于两个指定下标之间的字符，</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方返回的子串包括 start 处的字符，但不包括 stop 处的字符，to 可选，如果省略该参数，那么返回的子串会一直到字符串的结尾。</span><br><span class="line"></span><br><span class="line">    var myString &#x3D; &#39;wangxiaoting&#39;;</span><br><span class="line"></span><br><span class="line">    myString &#x3D; myString.substr(0,4);</span><br><span class="line"></span><br><span class="line">    console.log(myString)&#x2F;&#x2F;打印结果  wang</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;从0位置开始搜索，返回第一个匹配的字符串的位置;搜索不到返回-1</span><br><span class="line"></span><br><span class="line">       var str&#x3D;&quot;ab cd efg&quot;;</span><br><span class="line"></span><br><span class="line">       console.log(str.indexOf(&quot;cd&quot;)); &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">       var str1&#x3D;&quot;my name is wangxiaoting &quot;;</span><br><span class="line"></span><br><span class="line">       console.log(str1.indexOf(&quot;is&quot;)); &#x2F;&#x2F;8</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;indexOf(&quot;要搜索的字符串&quot;,开始搜索的位置);</span><br><span class="line"></span><br><span class="line">       var str2&#x3D;&quot;abcedfghighdckkccccc&quot;;</span><br><span class="line"></span><br><span class="line">       console.log(str2.indexOf(&quot;c&quot;,13)); &#x2F;&#x2F;15</span><br><span class="line">		&#x2F;&#x2F;从下标是15的位置开始搜索，返回第一个匹配的字符串的位置;搜索不到返回-1</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>





<h3 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h3><p>split() 方法用于把一个字符串分割成字符串数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;把一个字符串分割成字符串数组。</span><br><span class="line"></span><br><span class="line">  var myString&#x3D;&quot;my name is wangxiaoting&quot;;</span><br><span class="line"></span><br><span class="line">  console.log(myString.split(&quot; &quot;));  &#x2F;&#x2F; [&quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;wangxiaoting&quot;]</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/2020/07/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/file" alt="img"></p>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>trim() 方法会从一个字符串的两端删除空白字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var myString &#x3D; &quot;     wang  xiao  ting     &quot;;</span><br><span class="line"></span><br><span class="line">    console.log(myString.trim());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;打印结果  wang  xiao  ting</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="lastIndexOf-string"><a href="#lastIndexOf-string" class="headerlink" title="lastIndexOf(string)"></a>lastIndexOf(string)</h3><p>返回String对象内最后一次出现子字符串位置。如果没有找到子字符串，则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">        var myString &#x3D; &quot;wangxiaoting&quot;</span><br><span class="line"></span><br><span class="line">        console.log(myString.lastIndexOf(&quot;a&quot;)) &#x2F;&#x2F;6</span><br><span class="line"></span><br><span class="line">        console.log(myString.lastIndexOf(&quot;g&quot;)) &#x2F;&#x2F;11</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="toUpperCase方法和toLowerCase方法"><a href="#toUpperCase方法和toLowerCase方法" class="headerlink" title="toUpperCase方法和toLowerCase方法"></a>toUpperCase方法和toLowerCase方法</h3><p>toUpperCase方法返回一个字符串，该字符串中的所有字母都被转换为大写字母。</p>
<p>toLowerCase:方法返回一个字符串，该字符串中的字母被转换成小写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">        var myString &#x3D; &quot;wangxiaoting&quot;</span><br><span class="line"></span><br><span class="line">        console.log(myString.toLowerCase());&#x2F;&#x2F;wangxiaoting</span><br><span class="line"></span><br><span class="line">        console.log(myString.toUpperCase());&#x2F;&#x2F;WANGXIAOTING</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="换行字符串-n"><a href="#换行字符串-n" class="headerlink" title="换行字符串\n"></a>换行字符串\n</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;\r&#39; 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖；</span><br><span class="line">&#39;\n&#39; 换行，换到当前位置的下一行，而不会回到行首；</span><br><span class="line"></span><br><span class="line">页面替换所有的‘&#x2F;’</span><br><span class="line">.replace(&#x2F;\|&#x2F;g,&#39; | &#39;)</span><br><span class="line">.replace(&#x2F;\n&#x2F;g,&#39;&lt;br&gt;&#39;)</span><br><span class="line"></span><br><span class="line">换行符号转义</span><br><span class="line">.split(&#39;\n&#39;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序wxParse解析html</title>
    <url>/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8FwxParse%E8%A7%A3%E6%9E%90html/</url>
    <content><![CDATA[<h3 id="wxParse解析html"><a href="#wxParse解析html" class="headerlink" title="wxParse解析html"></a>wxParse解析html</h3><p>最近项目上遇到在微信小程序里需要显示新闻内容，新闻内容是通过接口读取的服务器中的富文本内容，是html格式的，小程序默认是不支持html格式的内容显示的，那我们需要显示html内容的时候，就可以通过wxParse来实现。<br>首先我们在github上下载wxParse<br><a href="https://link.jianshu.com?t=https://github.com/icindy/wxParse" target="_blank" rel="noopener">https://github.com/icindy/wxParse</a></p>
<a id="more"></a>

<p><img src="http://upload-images.jianshu.io/upload_images/1749555-763e71fafa8b7d21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1006/format/webp" alt="img"></p>
<p>wxParse</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1749555-607f09905e3f1ffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt="img"></p>
<p>下面是具体的使用步骤</p>
<blockquote>
<p>1.在app.wxss全局样式文件中，需要引入wxParse的样式表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;&#x2F;page&#x2F;wxParse&#x2F;wxParse.wxss&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.在需要加载html内容的页面对应的js文件里引入wxParse</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var WxParse &#x3D; require(&#39;..&#x2F;..&#x2F;wxParse&#x2F;wxParse.js&#39;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.通过调用WxParse.wxParse方法来设置html内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* WxParse.wxParse(bindName , type, data, target,imagePadding)</span><br><span class="line">* 1.bindName绑定的数据名(必填)</span><br><span class="line">* 2.type可以为html或者md(必填)</span><br><span class="line">* 3.data为传入的具体数据(必填)</span><br><span class="line">* 4.target为Page对象,一般为this(必填)</span><br><span class="line">* 5.imagePadding为当图片自适应是左右的单一padding(默认为0,可选)</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    var that &#x3D; this;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">        url: &#39;&#39;, </span><br><span class="line">        method: &#39;POST&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            &#39;id&#39;:13</span><br><span class="line">        &#125;,</span><br><span class="line">        header: &#123;</span><br><span class="line">            &#39;content-type&#39;: &#39;application&#x2F;json&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        success: function(res) &#123;</span><br><span class="line">            var article &#x3D; res.data[0].post;</span><br><span class="line">            WxParse.wxParse(&#39;article&#39;, &#39;html&#39;, article, that,5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4.在页面中引用模板</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;import src&#x3D;&quot;..&#x2F;..&#x2F;wxParse&#x2F;wxParse.wxml&quot;&#x2F;&gt;</span><br><span class="line">&lt;template is&#x3D;&quot;wxParse&quot; data&#x3D;&quot;&#123;&#123;wxParseData:article.nodes&#125;&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以在微信小程序中嵌入html内容了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1749555-fc2cdae17f35c2e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/463/format/webp" alt="img"></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>wxParse</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序上传删除图片封装</title>
    <url>/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E4%BC%A0%E5%88%A0%E9%99%A4%E5%9B%BE%E7%89%87%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h3 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"img-model"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"img-item"</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;uploaderList&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"item"</span> <span class="attr">data-index</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">icon</span> <span class="attr">class</span>=<span class="string">'ui_uploader_item_icon'</span> <span class="attr">bindtap</span>=<span class="string">'clearImg'</span> <span class="attr">data-index</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">type</span>=<span class="string">"clear"</span> <span class="attr">size</span>=<span class="string">"20"</span> <span class="attr">color</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">image</span> <span class="attr">id</span>=<span class="string">"seal"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;item.path&#125;&#125;"</span>  <span class="attr">bindtap</span>=<span class="string">"showImg"</span> <span class="attr">data-item</span>=<span class="string">"&#123;&#123;item&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;item.upload_percent&gt;1&amp;&amp;item.upload_percent&lt;100&#125;&#125;"</span>&gt;</span>&#123;&#123;item.upload_percent&#125;&#125;%<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;item.upload_percent==100&#125;&#125;"</span>&gt;</span>上传成功<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:else</span>&gt;</span>上传失败<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"img-click"</span> <span class="attr">bindtap</span>=<span class="string">"goChooseImage"</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;showUpload&#125;&#125;"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">image</span> <span class="attr">id</span>=<span class="string">"seal"</span> <span class="attr">src</span>=<span class="string">"./img/seal.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    uploaderNum: <span class="number">0</span>,<span class="comment">//已经上传的数量</span></span><br><span class="line">    uploaderList:[],</span><br><span class="line">    showUpload: <span class="literal">true</span>,</span><br><span class="line">    maxLength: <span class="number">4</span> <span class="comment">//允许上传的最大数量</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">//选择图片 </span></span><br><span class="line">  goChooseImage(e) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> uploaderList = that.data.uploaderList;</span><br><span class="line">    <span class="keyword">let</span> maxSize = <span class="number">102</span> * <span class="number">1024</span>;</span><br><span class="line">    wx.chooseImage(&#123;</span><br><span class="line">      <span class="comment">//每次最多选择的个数，多余自动去除</span></span><br><span class="line">      count: that.data.maxLength - that.data.uploaderList.length,</span><br><span class="line">      sizeType: [<span class="string">'original'</span>, <span class="string">'compressed'</span>],</span><br><span class="line">      sourceType: [<span class="string">'album'</span>, <span class="string">'camera'</span>],</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          title: <span class="string">'正在上传...'</span>,</span><br><span class="line">          icon: <span class="string">'loading'</span>,</span><br><span class="line">          mask: <span class="literal">true</span>,</span><br><span class="line">          duration: <span class="number">500</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//上传个数限制</span></span><br><span class="line">        <span class="keyword">if</span> ((res.tempFiles.length + that.data.uploaderList.length) &gt; that.data.maxLength) &#123;</span><br><span class="line">          wx.showModal(&#123;</span><br><span class="line">            content: <span class="string">'最多能上传'</span> + that.data.maxLength + <span class="string">'张图片'</span>,</span><br><span class="line">            showCancel: <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断图片大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.tempFiles.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.tempFiles[i].size &gt; maxSize) &#123;</span><br><span class="line">            wx.showModal(&#123;</span><br><span class="line">              content: <span class="string">'图片太大，不允许上传'</span>,</span><br><span class="line">              showCancel: <span class="literal">false</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            uploaderList = that.data.uploaderList.concat(res.tempFiles[i])</span><br><span class="line">            that.setData(&#123;</span><br><span class="line">              uploaderList,</span><br><span class="line">              uploaderNum: that.data.uploaderList.length</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//隐藏点击上传图片</span></span><br><span class="line">        <span class="keyword">if</span> (uploaderList.length == that.data.maxLength) &#123;</span><br><span class="line">          that.setData(&#123;</span><br><span class="line">            showUpload: <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上传图片</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; uploaderList.length; i++) &#123;</span><br><span class="line">          <span class="comment">//that.upLoadImg(uploaderList[i],i)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 图片上传</span></span><br><span class="line">  upLoadImg(upImg,idx) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> uploadTask = wx.uploadFile(&#123;</span><br><span class="line">      url: config.itravel_api + <span class="string">'TravelCard/tcUploadPicture.mini'</span>,</span><br><span class="line">      filePath: upImg.path,</span><br><span class="line">      header: &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">      &#125;, <span class="comment">// 设置请求的 header</span></span><br><span class="line">      name: <span class="string">'idCard'</span>,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx === that.data.uploaderList.length<span class="number">-1</span>)&#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title: <span class="string">"上传成功"</span>,</span><br><span class="line">            icon: <span class="string">'none'</span>,</span><br><span class="line">            mask: <span class="literal">true</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(res) &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          title: <span class="string">"上传失败"</span>,</span><br><span class="line">          icon: <span class="string">'none'</span>,</span><br><span class="line">          mask: <span class="literal">true</span>,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//进度条属性置为0显示上传失败</span></span><br><span class="line">        upImg[<span class="string">'upload_percent'</span>] = <span class="number">0</span></span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          uploaderList: that.data.uploaderList</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 上传进度条</span></span><br><span class="line">    uploadTask &amp;&amp; uploadTask.onProgressUpdate(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//增加进度条属性</span></span><br><span class="line">      upImg[<span class="string">'upload_percent'</span>] = res.progress</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        uploaderList: that.data.uploaderList</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//展示图片</span></span><br><span class="line">  showImg: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> path = e.currentTarget.dataset.item.path</span><br><span class="line">    <span class="keyword">let</span> images = <span class="keyword">this</span>.data.uploaderList</span><br><span class="line">    <span class="keyword">let</span> allImages = [];</span><br><span class="line">    images.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      allImages.push(item.path)</span><br><span class="line">    &#125;)</span><br><span class="line">    wx.previewImage(&#123;</span><br><span class="line">      urls: allImages,</span><br><span class="line">      current: path</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 删除图片</span></span><br><span class="line">  clearImg: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    wx.showModal(&#123;</span><br><span class="line">      title: <span class="string">'提示'</span>,</span><br><span class="line">      content: <span class="string">'确定删除图片吗？'</span>,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.confirm) &#123;</span><br><span class="line">          <span class="comment">//删除start</span></span><br><span class="line">          <span class="keyword">let</span> uploaderList = that.data.uploaderList;<span class="comment">//原数据</span></span><br><span class="line">          <span class="keyword">let</span> index = e.currentTarget.dataset.index;</span><br><span class="line">          uploaderList.splice(index, <span class="number">1</span>);</span><br><span class="line">          that.setData(&#123;</span><br><span class="line">            uploaderNum: that.data.uploaderNum - <span class="number">1</span>,</span><br><span class="line">            showUpload: <span class="literal">true</span>,</span><br><span class="line">            uploaderList: uploaderList,</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">//删除end</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序之wx-request封装</title>
    <url>/2020/09/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bwx-request%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h2 id="微信请求-Promise-化"><a href="#微信请求-Promise-化" class="headerlink" title="微信请求 Promise 化"></a>微信请求 Promise 化</h2><h3 id="2-1-使用现成的库"><a href="#2-1-使用现成的库" class="headerlink" title="2.1 使用现成的库"></a>2.1 使用现成的库</h3><a id="more"></a>

<p>安装 Promise 库 wx-promise-pro，记得一定要带 <code>-s</code> 或 <code>--production</code>，要不然无法构建成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -S wx-promise-pro</span><br></pre></td></tr></table></figure>

<p>然后在 <code>app.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; promisifyAll &#125; from &#39;wx-promise-pro&#39;</span><br><span class="line"></span><br><span class="line">promisifyAll()  &#x2F;&#x2F; promisify all wx api</span><br><span class="line"></span><br><span class="line">App(&#123; ... &#125;)</span><br></pre></td></tr></table></figure>

<p>之后就可以正常使用了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.pro.showLoading(&#123;</span><br><span class="line">    title: &#39;加载中&#39;,</span><br><span class="line">    mask: true</span><br><span class="line">&#125;)</span><br><span class="line">  .then(() &#x3D;&gt; console.log(&#39;in promise ~&#39;))</span><br></pre></td></tr></table></figure>

<h3 id="2-2-自己实现"><a href="#2-2-自己实现" class="headerlink" title="2.2 自己实现"></a>2.2 自己实现</h3><p>其实我们可以自己来实现一个这样的库，原理很简单，以原生 API 的 wx.request 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 原生 API 使用方式</span><br><span class="line">wx.request(&#123;</span><br><span class="line">    url: &#39;&#39;,     &#x2F;&#x2F; 请求的 url</span><br><span class="line">    data: &#123;&#125;,    &#x2F;&#x2F; 参数</span><br><span class="line">    method: &#39;&#39;,  &#x2F;&#x2F; post、get</span><br><span class="line">    success: res &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 请求成功回调函数，res为回调参数</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: res &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 请求失败回调函数，res为回调参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们将其 Promise 化，应该的调用方式希望是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise 化后的期望使用方式</span><br><span class="line">wx.pro.request(&#123;</span><br><span class="line">    url: &#39;&#39;,     &#x2F;&#x2F; 请求的 url</span><br><span class="line">    data: &#123;&#125;,    &#x2F;&#x2F; 参数</span><br><span class="line">    method: &#39;&#39;   &#x2F;&#x2F; post、get</span><br><span class="line">&#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 请求成功回调函数，res为回调参数</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(res &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 请求失败回调函数，res为回调参数</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>并且 <code>then</code> 函数返回的是一个 Promise 对象，让这个函数可以不断链式调用下去，所以首先需要 <code>new</code> 出来一个 Promise 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function request(opt) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">            ...opt,</span><br><span class="line">            success: res &#x3D;&gt; &#123; resolve(res)&#125;,</span><br><span class="line">            fail: res &#x3D;&gt; &#123;reject(res)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码我们可以进一步改进，由于 <code>success</code>、<code>fail</code> 这里传入的参数只是由<code>resolve</code>、<code>reject</code> 方法执行了下，所以可以直接传入 <code>resolve</code>、<code>reject</code> 方法即可。</p>
<p>另外，由于其他小程序原生 API 格式一致，所以我们可以使用柯里化方法，来将其他需要进行 Promise 化的 API 进行处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function promisify(api) &#123;</span><br><span class="line">    return (opt &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            api(&#123;</span><br><span class="line">                ...opt,</span><br><span class="line">                fail: reject,</span><br><span class="line">                success: resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将柯里化方法执行的结果作为新的 Promise 化的 API 挂载到 <code>wx.pro</code> 对象上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将指定 API 进行 Promise 化</span><br><span class="line">wx.pro.request &#x3D; promisify(wx.request)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">wx.pro.request(&#123;...&#125;)</span><br><span class="line">    .then(...)</span><br></pre></td></tr></table></figure>

<p>然后为了方便我们使用其他方法，可以循环将 <code>wx</code> 对象上可以被 Promise 化的方法比如 <code>request</code>、<code>scanCode</code>、<code>showToast</code>、<code>getUserInfo</code> 等一一挂载到 <code>wx.pro</code> 对象上，使用时可以直接<code>wx.pro.xx</code>，由于这个方法执行返回的是一个 Promise 对象，因此可以像其它 Promise 化的对象那样使用。</p>
<p>事实上，不知不觉，我们就自己实现了 <code>wx-promise-pro</code> 的源码，这个库的核心代码也就是上面那这几行 🥳</p>
<h3 id="2-3-在项目中使用"><a href="#2-3-在项目中使用" class="headerlink" title="2.3 在项目中使用"></a>2.3 在项目中使用</h3><p>有了上面的工具后，我们可以将其使用在项目中，为了不在项目中遍布 <code>wx.request</code> 或 <code>wx.pro.request</code> 这里可以简单进行封装，新建两个文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; utils&#x2F;api&#x2F;fetch.js 封装请求方法、请求拦截器</span><br><span class="line"></span><br><span class="line">const app &#x3D; getApp()</span><br><span class="line"></span><br><span class="line">const BaseUrl &#x3D; &#39;http:&#x2F;&#x2F;172.0.0.1:7300&#x2F;mock&#39;</span><br><span class="line"></span><br><span class="line">const TokenWhiteList &#x3D; [</span><br><span class="line">    &#39;&#x2F;app&#x2F;user&#x2F;get-by-code&#39;     &#x2F;&#x2F; 不需要鉴权的api手动添加到这里</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 设置请求拦截器</span><br><span class="line"> * @param params 请求参数</span><br><span class="line"> *&#x2F;</span><br><span class="line">const fetch &#x3D; (params &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 拦截器逻辑</span><br><span class="line">    if (!TokenWhiteList.includes(params.url)) &#123;</span><br><span class="line">        params.header &#x3D; &#123;</span><br><span class="line">            &#39;content-type&#39;: &#39;application&#x2F;json&#39;,             &#x2F;&#x2F; 默认值</span><br><span class="line">            &#39;token&#39;: app.globalData.token || &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (params.url.startsWith(&#39;&#x2F;&#39;)) &#123;    &#x2F;&#x2F; 拼接完整URL</span><br><span class="line">        params.url &#x3D; BaseUrl + params.url</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回promise</span><br><span class="line">    return wx.pro.request(&#123; ...params &#125;)</span><br><span class="line">      .then((&#123; data: &#123; code, message, data &#125; &#125;) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; ... 各种异常情况的逻辑处理</span><br><span class="line">          &#x2F;&#x2F; 与后端约定 code 20000 时正常返回</span><br><span class="line">          if (code &#x3D;&#x3D;&#x3D; 20000) return Promise.resolve(data)</span><br><span class="line">          return Promise.reject(message)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; fetch &#125;</span><br></pre></td></tr></table></figure>

<p>然后再将所有 API 封装到单独的文件中集中管理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; utils&#x2F;api&#x2F;apis.js 封装所有请求 API</span><br><span class="line"></span><br><span class="line">import &#123; fetch &#125; from &#39;.&#x2F;fetch&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;* 根据微信code获取用户信息 *&#x2F;</span><br><span class="line">const appUserGetByCode &#x3D; (&#123; code &#125; &#x3D; &#123;&#125;) &#x3D;&gt; fetch(&#123;</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;user&#x2F;get-by-code&#39;,</span><br><span class="line">    data: &#123; code &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;* 扫码登录 *&#x2F;</span><br><span class="line">const appUserQrLogin &#x3D; (&#123; qrCode &#125; &#x3D; &#123;&#125;) &#x3D;&gt; fetch(&#123;</span><br><span class="line">    method: &#39;POST&#39;,</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;user&#x2F;qr-login&#39;,</span><br><span class="line">    data: &#123; qrCode &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;* 个人信息 *&#x2F;</span><br><span class="line">const appUserInfo &#x3D; () &#x3D;&gt; fetch(&#123;</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;user&#x2F;info&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;* 系统参数获取，数据字典 *&#x2F;</span><br><span class="line">const appSysParamListByParam &#x3D; () &#x3D;&gt; fetch(&#123;</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;sys-param&#x2F;list-by-param&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;* 数据字典所有 *&#x2F;</span><br><span class="line">const appSysParamListAll &#x3D; () &#x3D;&gt; fetch(&#123;</span><br><span class="line">    url: &#39;&#x2F;app&#x2F;sys-param&#x2F;list-all&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    appSysParamListAll,   &#x2F;&#x2F; 数据字典所有</span><br><span class="line">    appSysParamListByParam,   &#x2F;&#x2F; 系统参数获取，数据字典</span><br><span class="line">    appUserGetByCode,   &#x2F;&#x2F; 根据微信code获取用户信息</span><br><span class="line">    appUserQrLogin,   &#x2F;&#x2F; 扫码登录</span><br><span class="line">    appUserInfo   &#x2F;&#x2F; 个人信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在要使用 API 的地方就可以这样引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Api from &#39;..&#x2F;..&#x2F;utils&#x2F;api&#x2F;apis.js&#39;   &#x2F;&#x2F; 相对路径</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方式</span><br><span class="line">Api.appSysParamListAll()</span><br><span class="line">  .then((&#123; dataList &#125;) &#x3D;&gt; this.upData(&#123; sysParamList: dataList &#125;))</span><br><span class="line">  .then(() &#x3D;&gt; &#123;</span><br><span class="line">      const keyList &#x3D; this.data.sysParamList.map(T &#x3D;&gt; T.key)</span><br><span class="line">      this.upData(&#123;</span><br><span class="line">          keyList,</span><br><span class="line">          formData: &#123; keys: keyList &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://mp.weixin.qq.com/s/PqSlKWOaWXLdEJ7SvrIy0Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PqSlKWOaWXLdEJ7SvrIy0Q</a></p>
]]></content>
  </entry>
  <entry>
    <title>小程序之wx-upData</title>
    <url>/2020/09/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bwx-upData/</url>
    <content><![CDATA[<p>鉴于在下使用微信小程序开发时使用 <code>setData</code> 的蹩脚体验，开发了个库函数 <code>wx-updata</code>，项目上线之后，我把这个自用的库函数整理放到 Github 上开源出来 wx-updata，这个库函数在开发的时候对我很有帮助，希望也可以帮到大家 ????</p>
<p>如果大家在使用中遇到了问题，可以给我提 pr，提 issue，一起来改善小程序开发体验加油～</p>
<ol>
<li><code>wx-updata</code> 版本 0.0.10</li>
<li>Github 地址：<a href="https://github.com/SHERlocked93/wx-updata" target="_blank" rel="noopener">https://github.com/SHERlocked93/wx-updata</a></li>
<li>小程序代码片段预览地址：<a href="https://developers.weixin.qq.com/s/CcXdO1mc73jD" target="_blank" rel="noopener">https://developers.weixin.qq.com/s/CcXdO1mc73jD</a></li>
<li>小程序代码片段代码地址：<a href="https://github.com/SHERlocked93/wx-updata-demo" target="_blank" rel="noopener">https://github.com/SHERlocked93/wx-updata-demo</a></li>
</ol>
<h2 id="1-setData-不方便的地方"><a href="#1-setData-不方便的地方" class="headerlink" title="1. setData 不方便的地方"></a><strong>1. setData 不方便的地方</strong></h2><p>你在使用 <code>setData</code> 的时候，是不是有时候觉得很难受，举个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你的 data</span></span><br><span class="line">data: &#123;</span><br><span class="line">    name: <span class="string">'蜡笔小新'</span>,</span><br><span class="line">    info: &#123; height: <span class="number">140</span>, color: <span class="string">'黄色'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果要修改 <code>info.height</code> 为 155，使用 <code>setData</code> 要怎么做呢：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样会把 info 里其他属性整不见了</span></span><br><span class="line">this.setData(&#123; info: &#123; height: <span class="number">155</span> &#125; &#125;)</span><br><span class="line"><span class="comment">// 你需要取出 info 对象，修改后整个 setData</span></span><br><span class="line"><span class="keyword">const</span> &#123; info &#125; = this.data</span><br><span class="line">info.height = <span class="number">155</span></span><br><span class="line">this.setData(&#123; info &#125;)</span><br></pre></td></tr></table></figure>

<p>似乎并不太复杂，但如果 <code>data</code> 是个很大的对象，要把比较深且不同的对象、数组项挨个改变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    name: <span class="string">'蜡笔小新'</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">        height: <span class="number">140</span>, color: <span class="string">'黄色'</span>,</span><br><span class="line">        desc: [&#123; age: <span class="number">8</span> &#125;, <span class="string">'最喜欢大象之歌'</span>, <span class="string">'靓仔'</span>, &#123; dog: <span class="string">'小白'</span>, color: <span class="string">'白色'</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如某个需求，需要把 <code>info.height</code> 改为 155，同时改变 <code>info.desc</code> 数组的第 0 项的 <code>age</code> 为 12，第 3 项的 <code>color</code> 为灰色呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先取出要改变的对象，改变数字后 setData 回去</span></span><br><span class="line"><span class="keyword">const</span> &#123; info &#125; = this.data</span><br><span class="line">info.height = <span class="number">155</span></span><br><span class="line">info.desc[<span class="number">0</span>].age = <span class="number">12</span></span><br><span class="line">info.desc[<span class="number">3</span>].color = <span class="string">'灰色'</span></span><br><span class="line">this.setData(&#123; info &#125;)</span><br><span class="line"><span class="comment">// 或者像某些文章里介绍的，这样可读性差，也不太实用</span></span><br><span class="line">this.setData(&#123;</span><br><span class="line">    <span class="string">'info.height'</span>: <span class="number">155</span>,</span><br><span class="line">    <span class="string">'info.desc[0].age'</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">'info.desc[3].color'</span>: <span class="string">'灰色'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面这两种方法，是我们平常小程序里经常用的，和其他 Web 端的框架相比，就很蹩脚，一种浓浓的半成品感扑面而来，有没有这样一个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">this.upData(&#123;</span><br><span class="line">    info: &#123;</span><br><span class="line">        height: <span class="number">155</span>,</span><br><span class="line">        desc: [&#123; age: <span class="number">12</span> &#125;, , , &#123; color: <span class="string">'灰色'</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个方法会帮我们深度改变嵌套对象里对应的属性值，跳过数组项里不想改变的，只设置我们提供了的属性值、数组项，岂不是省略了一大堆蹩脚的代码，而且可读性也极佳呢。</p>
<p>这就是为什么我在上线的项目中使用 wx-updata，而不是 <code>setData</code></p>
<h2 id="2-wx-updata-的优点"><a href="#2-wx-updata-的优点" class="headerlink" title="2. wx-updata 的优点"></a><strong>2. wx-updata 的优点</strong></h2><ol>
<li>支持 <code>setData</code> 对象自动合并，不用写蹩脚的对象路径了 ????</li>
<li>支持对象中嵌套数组，数组中嵌套对象；</li>
<li>如果数组的某个值你不希望覆盖，请使用数组空位来跳过这个数组项，比如 <code>[1,,3]</code> 这个数组中间就是数组空位；</li>
<li>如果数组空位你的 <code>Eslint</code> 报错，可以使用 <code>wx-updata</code> 提供的 Empty 来代替：<code>[1, Empty, 3]</code></li>
</ol>
<h2 id="3-wx-updata-安装"><a href="#3-wx-updata-安装" class="headerlink" title="3. wx-updata 安装"></a><strong>3. wx-updata 安装</strong></h2><blockquote>
<p>你也可以直接把 <code>dist</code> 目录下的 <code>wx-updata.js</code> 拷贝到项目里使用</p>
</blockquote>
<p>使用 <code>npm</code>、<code>yarn</code> 安装方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ npm i -S wx-updata</span><br><span class="line"># or</span><br><span class="line">$ yarn add wx-updata</span><br></pre></td></tr></table></figure>

<p>然后：</p>
<ol>
<li>把微信开发者工具面板右侧的 <code>详情 - 本地设置 - 使用npm模块</code> 按钮打开；</li>
<li>点击微信开发者工具面板工具栏的 <code>工具 - 构建npm</code>；</li>
</ol>
<p>构建后成功生成 <code>miniprogram_npm</code> 文件夹就可以正常使用了</p>
<h2 id="4-wx-updata-使用方法"><a href="#4-wx-updata-使用方法" class="headerlink" title="4. wx-updata 使用方法"></a><strong>4. wx-updata 使用方法</strong></h2><h3 id="使用方式一"><a href="#使用方式一" class="headerlink" title="使用方式一"></a><strong>使用方式一</strong></h3><p>可以使用直接挂载到 <code>Page</code> 上的方式，这样就可以在 <code>Page</code> 实例中像使用 <code>setData</code> 一样使用 <code>upData</code> 了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; updataInit &#125; from <span class="string">'./miniprogram_npm/wx-updata/index'</span>  <span class="comment">// 你的库文件路径</span></span><br><span class="line">App(&#123;</span><br><span class="line">    onLaunch() &#123;</span><br><span class="line">        Page = updataInit(Page, &#123; debug: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 页面代码中</span></span><br><span class="line">this.upData(&#123;</span><br><span class="line">    info: &#123; height: <span class="number">155</span> &#125;,</span><br><span class="line">    desc: [&#123; age: <span class="number">13</span> &#125;, <span class="string">'帅哥'</span>],</span><br><span class="line">    family: [, , [, , , &#123; color: <span class="string">'灰色'</span> &#125;]]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用方式二"><a href="#使用方式二" class="headerlink" title="使用方式二"></a><strong>使用方式二</strong></h3><p>有的框架可能在 <code>Page</code> 对象上进行了进一步修改，直接替换 <code>Page</code> 的方式可能就不太好了，<code>wx-updata</code> 同样暴露了工具方法，用户可以在页面代码中直接使用工具方法进行处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面代码中</span></span><br><span class="line"><span class="keyword">import</span> &#123; objToPath &#125; from <span class="string">'./miniprogram_npm/wx-updata/index'</span>  <span class="comment">// 你的库文件路径</span></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123; a: &#123; b: <span class="number">2</span>&#125;, c: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;,</span><br><span class="line">    <span class="comment">// 自己封装一下</span></span><br><span class="line">    upData(data) &#123;</span><br><span class="line">        <span class="keyword">return</span> this.setData(objToPath(data))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 你的方法中或生命周期函数</span></span><br><span class="line">    yourMethod() &#123;</span><br><span class="line">        this.upData(&#123; a: &#123; b: <span class="number">7</span>&#125;, c: [<span class="number">8</span>,,<span class="number">9</span>]&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用-Empty-代替数组空位"><a href="#使用-Empty-代替数组空位" class="headerlink" title="使用 Empty 代替数组空位"></a><strong>使用 Empty 代替数组空位</strong></h3><p>可以使用 <code>wx-updata</code> 提供的 Empty 来代替数组空位，由于 Empty 本质上是一个 Symbol，所以只能使用 <code>wx-updata</code> 导出的，而不能自己新建。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面代码中</span></span><br><span class="line"><span class="keyword">import</span> &#123; Empty &#125; from <span class="string">'./miniprogram_npm/wx-updata/index'</span></span><br><span class="line">this.upData(&#123;</span><br><span class="line">    info: &#123; height: <span class="number">155</span> &#125;,</span><br><span class="line">    desc: [&#123; age: <span class="number">13</span> &#125;, <span class="string">'帅哥'</span>],</span><br><span class="line">    family: [Empty, Empty, [Empty, Empty, Empty, &#123; color: <span class="string">'灰色'</span> &#125;]]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-wx-updata-相关-API"><a href="#5-wx-updata-相关-API" class="headerlink" title="5. wx-updata 相关 API"></a><strong>5. wx-updata 相关 API</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page.prototype.upData(Object data, Function callback)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>data</code>：你希望设置的 data</li>
<li><code>callback</code>：跟 setData 第二个参数一样，引起界面更新渲染完毕后的回调函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updataInit(Page, config)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Page</code>：页面对象，需要在 <code>app.js</code> 中调用；</li>
<li><code>config</code>：若提供配置参数 <code>{ debug: true }</code>，会将路径化后的 data 打印出来，帮助用户进行调试；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objToPath(Object data)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>data</code>：你希望设置的 data 对象</li>
</ol>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>wx-updata</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序之骨架屏的使用</title>
    <url>/2020/09/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%AA%A8%E6%9E%B6%E5%B1%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="自定义骨架屏"><a href="#自定义骨架屏" class="headerlink" title="自定义骨架屏"></a>自定义骨架屏</h3><p>index.wxml:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作为组件在页面中使用 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">skeleton</span> <span class="attr">selector</span>=<span class="string">"skeleton"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">loading</span>=<span class="string">"spin"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">bgcolor</span>=<span class="string">"#FFF"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">wx:if</span>=<span class="string">"&#123;&#123;showSkeleton&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">skeleton</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--index.wxml--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染的根节点，加上 .skeleton --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container skeleton"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"userinfo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">block</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 要渲染的圆形节点，加上 .skeleton-radius --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">"userinfo-avatar skeleton-radius"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;userInfo.avatarUrl&#125;&#125;"</span> <span class="attr">mode</span>=<span class="string">"cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 要渲染的矩形节点，加上 .skeleton-rect --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"userinfo-nickname skeleton-rect"</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"margin: 20px 0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;lists&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"lists"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">"success"</span> <span class="attr">size</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"list skeleton-radius"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"skeleton-rect"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"usermotto"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"user-motto skeleton-rect"</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"margin-top: 200px;"</span>&gt;</span>aaaaaaaaaaa<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>index.json:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 引入骨架屏组件</span></span><br><span class="line">  <span class="string">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="string">"skeleton"</span>: <span class="string">"/component/skeleton/skeleton"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后来探索一下骨架屏组件的实现</strong></p>
<p>skeleton.wxml:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 最外层的view绑定了js中定义的宽、高以及背景颜色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"width: &#123;systemInfo.width&#125;&#125;px; height: &#123;systemInfo.height&#125;&#125;px; background-color: &#123;bgcolor&#125;&#125;; position: absolute; left:0; top:0; z-index:9998; overflow: hidden;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 循环，遍历绘制矩形节点，宽高参照js获取到的节点宽高，以绝对定位的方式定位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;skeletonRectLists&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"&#123;loading == 'chiaroscuro' ? 'chiaroscuro' : ''&#125;&#125;"</span> <span class="attr">style</span>=<span class="string">"width: &#123;item.width&#125;&#125;px; height: &#123;item.height&#125;&#125;px; background-color: rgb(194, 207, 214); position: absolute; left: &#123;item.left&#125;&#125;px; top: &#123;item.top&#125;&#125;px"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 循环，遍历绘制矩形节点，宽高参照js获取到的节点宽高，以绝对定位的方式定位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;skeletonCircleLists&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"&#123;loading == 'chiaroscuro' ? 'chiaroscuro' : ''&#125;&#125;"</span> <span class="attr">style</span>=<span class="string">"width: &#123;item.width&#125;&#125;px; height: &#123;item.height&#125;&#125;px; background-color: rgb(194, 207, 214); border-radius: &#123;item.width&#125;&#125;px; position: absolute; left: &#123;item.left&#125;&#125;px; top: &#123;item.top&#125;&#125;px"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"spinbox"</span> <span class="attr">wx:if</span>=<span class="string">"&#123;loading == 'spin'&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"spin"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>skeleton.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    bgcolor: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">'#fff'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    selector: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">'skeleton'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">'spin'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    loadingAni: [<span class="string">'spin'</span>, <span class="string">'chiaroscuro'</span>],</span><br><span class="line">    systemInfo: &#123;&#125;,</span><br><span class="line">    skeletonRectLists: [],</span><br><span class="line">    skeletonCircleLists: []</span><br><span class="line">  &#125;,</span><br><span class="line">  attached: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//默认的首屏宽高，防止内容闪现</span></span><br><span class="line">    <span class="keyword">const</span> systemInfo = wx.getSystemInfoSync();</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      systemInfo: &#123;</span><br><span class="line">        width: systemInfo.windowWidth,</span><br><span class="line">        height: systemInfo.windowHeight</span><br><span class="line">      &#125;,</span><br><span class="line">      loading: <span class="keyword">this</span>.data.loadingAni.includes(<span class="keyword">this</span>.data.loading) ? <span class="keyword">this</span>.data.loading : <span class="string">'spin'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  ready: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//绘制背景</span></span><br><span class="line">    wx.createSelectorQuery().selectAll(<span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span>`</span>).boundingClientRect().exec(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        <span class="string">'systemInfo.height'</span>: res[<span class="number">0</span>][<span class="number">0</span>].height + res[<span class="number">0</span>][<span class="number">0</span>].top</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="keyword">this</span>.rectHandle();</span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="keyword">this</span>.radiusHandle();</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    rectHandle: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">//绘制不带样式的节点</span></span><br><span class="line">      wx.createSelectorQuery().selectAll(<span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span> &gt;&gt;&gt; .<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span>-rect`</span>).boundingClientRect().exec(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          skeletonRectLists: res[<span class="number">0</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    radiusHandle: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">      wx.createSelectorQuery().selectAll(<span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span> &gt;&gt;&gt; .<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span>-radius`</span>).boundingClientRect().exec(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          skeletonCircleLists: res[<span class="number">0</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">备注：也可以使用下面这种方式来选择节点</span><br><span class="line">wx.createSelectorQuery().selectAll(<span class="string">`.<span class="subst">$&#123;<span class="keyword">this</span>.data.selector&#125;</span>-rect`</span>).boundingClientRect().exec...</span><br></pre></td></tr></table></figure>



<h3 id="使用npm包"><a href="#使用npm包" class="headerlink" title="使用npm包"></a>使用npm包</h3><p><a href="https://github.com/jayZOU/skeleton" target="_blank" rel="noopener">https://github.com/jayZOU/skeleton</a></p>
<h3 id="一、安装和引入"><a href="#一、安装和引入" class="headerlink" title="一、安装和引入"></a>一、安装和引入</h3><h4 id="1-安装组件："><a href="#1-安装组件：" class="headerlink" title="1.安装组件："></a>1.安装组件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save miniprogram-skeleton</span><br></pre></td></tr></table></figure>

<h4 id="2-引入skeleton自定义组件"><a href="#2-引入skeleton自定义组件" class="headerlink" title="2.引入skeleton自定义组件"></a>2.引入skeleton自定义组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;skeleton&quot;: &quot;..&#x2F;miniprogram_npm&#x2F;miniprogram-skeleton&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小程序中npm的配置及使用：</strong></p>
<ul>
<li>在微信开发者工具中，设置 —&gt; 项目设置—&gt; 勾选使用npm模块。</li>
<li>在微信开发者工具中，工具 —&gt; 构建npm，构建完成会生成 <code>miniprogram_npm</code> 文件夹，项目用到的npm包都在这里。</li>
<li>按照页面的使用路径，从 <code>miniprogram_npm</code> 引入需要的包。</li>
</ul>
<h4 id="二、使用方式与自定义使用方式一样"><a href="#二、使用方式与自定义使用方式一样" class="headerlink" title="二、使用方式与自定义使用方式一样"></a>二、使用方式与自定义使用方式一样</h4><p>。。。</p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>骨架屏</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序如何生成海报分享朋友圈</title>
    <url>/2020/09/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E6%B5%B7%E6%8A%A5%E5%88%86%E4%BA%AB%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>利用微信强大的社交能力通过小程序达到裂变的目的，拉取新用户。<br>生成的海报如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvu1YtvSoiajLEyawsNz1JTxLpJb1T6GDwktsib3UBrOEz9KYatzRbhE9fIxjYGteosUh33C4Ysq2icw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<a id="more"></a>

<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>1、利用小程序官方提供的api可以直接分享转发到微信群打开小程序<br>2、利用小程序生成海报保存图片到相册分享到朋友圈，用户长按识别二维码关注公众号或者打开小程序来达到裂变的目的</p>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><h4 id="一、分析如何实现"><a href="#一、分析如何实现" class="headerlink" title="一、分析如何实现"></a>一、分析如何实现</h4><p>相信大家应该都会有类似的迷惑，就是如何按照产品设计的那样绘制成海报，其实当时我也是不知道如何下手，认真想了下得通过canvas绘制成图片，这样用户保存这个图片到相册，就可以分享到朋友圈了。但是要绘制的图片上面不仅有文字还有数字、图片、二维码等且都是活的，这个要怎么动态生成呢。认真想了下，需要一点一点的将文字和数字，背景图绘制到画布上去，这样通过api最终合成一个图片导出到手机相册中。</p>
<h4 id="二、需要解决的问题"><a href="#二、需要解决的问题" class="headerlink" title="二、需要解决的问题"></a>二、需要解决的问题</h4><p>1、二维码的动态获取和绘制（包括如何生成小程序二维码、公众号二维码、打开网页二维码）<br>2、背景图如何绘制，获取图片信息<br>3、将绘制完成的图片保存到本地相册<br>4、处理用户是否取消授权保存到相册</p>
<h4 id="三、实现步骤"><a href="#三、实现步骤" class="headerlink" title="三、实现步骤"></a>三、实现步骤</h4><p><strong>这里我具体写下围绕上面所提出的问题，描述大概实现的过程</strong></p>
<p>①首先创建canvas画布,我把画布定位设成负的,是为了不让它显示在页面上,是因为我尝试把canvas通过判断条件动态的显示和隐藏,在绘制的时候会出现问题,所以采用了这种方法，这里还有一定要设置画布的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas canvas-id&#x3D;&quot;myCanvas&quot; style&#x3D;&quot;width: 690px;height:1085px;position: fixed;top: -10000px;&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure>

<p>②创建好画布之后，先绘制背景图，因为背景图我是放在本地，所以获取 <canvas> 组件 canvas-id 属性，通过createCanvasContext创建canvas的绘图上下文 CanvasContext 对象。使用drawImage绘制图像到画布，第一个参数是图片的本地地址，后面两个参数是图像相对画布左上角位置的x轴和y轴，最后两个参数是设置图像的宽高。</canvas></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ctx &#x3D; wx.createCanvasContext(&#39;myCanvas&#39;)</span><br><span class="line"></span><br><span class="line">ctx.drawImage(&#39;&#x2F;img&#x2F;study&#x2F;shareimg.png&#39;, 0, 0, 690, 1085)</span><br></pre></td></tr></table></figure>

<p>③创建好背景图后，在背景图上绘制头像，文字和数字。通过getImageInfo获取头像的信息，这里需要注意下在获取的网络图片要先配置download域名才能生效，具体在小程序后台设置里配置。</p>
<p>获取头像地址，首先量取头像在画布中的大小，和x轴Y轴的坐标，这里的result[0]是我用promise封装返回的一个图片地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> headImg = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        wx.getImageInfo(&#123;</span><br><span class="line">          src: <span class="string">`<span class="subst">$&#123;app.globalData.baseUrl2&#125;</span><span class="subst">$&#123;that.data.currentChildren.headImg&#125;</span>`</span>,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            resolve(res.path)</span><br><span class="line">          &#125;,</span><br><span class="line">          fail: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">              title: <span class="string">'网络错误请重试'</span>,</span><br><span class="line">              icon: <span class="string">'loading'</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">let</span> avatarurl_width = <span class="number">60</span>, <span class="comment">//绘制的头像宽度</span></span><br><span class="line">    avatarurl_heigth = <span class="number">60</span>, <span class="comment">//绘制的头像高度</span></span><br><span class="line">    avatarurl_x = <span class="number">28</span>, <span class="comment">//绘制的头像在画布上的位置</span></span><br><span class="line">    avatarurl_y = <span class="number">36</span>; <span class="comment">//绘制的头像在画布上的位置</span></span><br><span class="line">    </span><br><span class="line">    ctx.save(); <span class="comment">// 先保存状态 已便于画完圆再用</span></span><br><span class="line">    ctx.beginPath(); <span class="comment">//开始绘制</span></span><br><span class="line">    <span class="comment">//先画个圆   前两个参数确定了圆心 （x,y） 坐标  第三个参数是圆的半径  四参数是绘图方向  默认是false，即顺时针</span></span><br><span class="line">    ctx.arc(avatarurl_width / <span class="number">2</span> + avatarurl_x, avatarurl_heigth / <span class="number">2</span> + avatarurl_y, avatarurl_width / <span class="number">2</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">    ctx.clip(); <span class="comment">//画了圆 再剪切  原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内</span></span><br><span class="line">    ctx.drawImage(result[<span class="number">0</span>], avatarurl_x, avatarurl_y, avatarurl_width, avatarurl_heigth); <span class="comment">// 推进去图片</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里举个例子说下如何绘制文字，比如我要绘制如下这个“字”，需要动态获取前面字数的总宽度，这样才能设置“字”的x轴坐标，这里我本来是想通过measureText来测量字体的宽度，但是在iOS端第一次获取的宽度值不对，关于这个问题，我还在微信开发者社区提了bug，所以我想用另一个方法来实现，就是先获取正常情况下一个字的宽度值，然后乘以总字数就获得了总宽度，亲试是可以的。</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvu1YtvSoiajLEyawsNz1JTxgNlzticcibNAObP0F6iaFVPAjbziauHKauUX5yQJFTXGO5HkMa2cIDOpqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let allReading &#x3D; 97 &#x2F; 6 &#x2F; app.globalData.ratio * wordNumber.toString().length + 325;</span><br><span class="line">ctx.font &#x3D; &#39;normal normal 30px sans-serif&#39;;</span><br><span class="line">ctx.setFillStyle(&#39;#ffffff&#39;)</span><br><span class="line">ctx.fillText(&#39;字&#39;, allReading, 150);</span><br></pre></td></tr></table></figure>

<p>④绘制公众号二维码，和获取头像是一样的，也是先通过接口返回图片网络地址，然后再通过getImageInfo获取公众号二维码图片信息</p>
<p>⑤如何绘制小程序码，具体官网文档也给出生成无限小程序码接口，通过生成的小程序可以打开任意一个小程序页面，并且二维码永久有效，具体调用哪个小程序二维码接口有不同的应用场景，具体可以看下官方文档怎么说的，也就是说前端通过传递参数调取后端接口返回的小程序码，然后绘制在画布上（和上面写的绘制头像和公众号二维码一样的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.drawImage(&#39;小程序码的本地地址&#39;, x轴, Y轴, 宽, 高)</span><br></pre></td></tr></table></figure>

<p>⑥最终绘制完把canvas画布转成图片并返回图片地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.canvasToTempFilePath(&#123;</span><br><span class="line">    canvasId: &#39;myCanvas&#39;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">      canvasToTempFilePath &#x3D; res.tempFilePath &#x2F;&#x2F; 返回的图片地址保存到一个全局变量里</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        showShareImg: true</span><br><span class="line">      &#125;)</span><br><span class="line">      wx.showToast(&#123;</span><br><span class="line">        title: &#39;绘制成功&#39;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function () &#123;</span><br><span class="line">      wx.showToast(&#123;</span><br><span class="line">        title: &#39;绘制失败&#39;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: function () &#123;</span><br><span class="line">      wx.hideLoading()</span><br><span class="line">      wx.hideToast()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>⑦保存到系统相册；先判断用户是否开启用户授权相册，处理不同情况下的结果。比如用户如果按照正常逻辑授权是没问题的，但是有的用户如果点击了取消授权该如何处理，如果不处理会出现一定的问题。所以当用户点击取消授权之后，来个弹框提示，当它再次点击的时候，主动跳到设置引导用户去开启授权，从而达到保存到相册分享朋友圈的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取用户是否开启用户授权相册</span><br><span class="line">    if (!openStatus) &#123;</span><br><span class="line">      wx.openSetting(&#123;</span><br><span class="line">        success: (result) &#x3D;&gt; &#123;</span><br><span class="line">          if (result) &#123;</span><br><span class="line">            if (result.authSetting[&quot;scope.writePhotosAlbum&quot;] &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">              openStatus &#x3D; true;</span><br><span class="line">              wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">                filePath: canvasToTempFilePath,</span><br><span class="line">                success() &#123;</span><br><span class="line">                  that.setData(&#123;</span><br><span class="line">                    showShareImg: false</span><br><span class="line">                  &#125;)</span><br><span class="line">                  wx.showToast(&#123;</span><br><span class="line">                    title: &#39;图片保存成功，快去分享到朋友圈吧~&#39;,</span><br><span class="line">                    icon: &#39;none&#39;,</span><br><span class="line">                    duration: 2000</span><br><span class="line">                  &#125;)</span><br><span class="line">                &#125;,</span><br><span class="line">                fail() &#123;</span><br><span class="line">                  wx.showToast(&#123;</span><br><span class="line">                    title: &#39;保存失败&#39;,</span><br><span class="line">                    icon: &#39;none&#39;</span><br><span class="line">                  &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: () &#x3D;&gt; &#123; &#125;,</span><br><span class="line">        complete: () &#x3D;&gt; &#123; &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      wx.getSetting(&#123;</span><br><span class="line">        success(res) &#123;</span><br><span class="line">          &#x2F;&#x2F; 如果没有则获取授权</span><br><span class="line">          if (!res.authSetting[&#39;scope.writePhotosAlbum&#39;]) &#123;</span><br><span class="line">            wx.authorize(&#123;</span><br><span class="line">              scope: &#39;scope.writePhotosAlbum&#39;,</span><br><span class="line">              success() &#123;</span><br><span class="line">                openStatus &#x3D; true</span><br><span class="line">                wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">                  filePath: canvasToTempFilePath,</span><br><span class="line">                  success() &#123;</span><br><span class="line">                    that.setData(&#123;</span><br><span class="line">                      showShareImg: false</span><br><span class="line">                    &#125;)</span><br><span class="line">                    wx.showToast(&#123;</span><br><span class="line">                      title: &#39;图片保存成功，快去分享到朋友圈吧~&#39;,</span><br><span class="line">                      icon: &#39;none&#39;,</span><br><span class="line">                      duration: 2000</span><br><span class="line">                    &#125;)</span><br><span class="line">                  &#125;,</span><br><span class="line">                  fail() &#123;</span><br><span class="line">                    wx.showToast(&#123;</span><br><span class="line">                      title: &#39;保存失败&#39;,</span><br><span class="line">                      icon: &#39;none&#39;</span><br><span class="line">                    &#125;)</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;,</span><br><span class="line">              fail() &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果用户拒绝过或没有授权，则再次打开授权窗口</span><br><span class="line">                openStatus &#x3D; false</span><br><span class="line">                console.log(&#39;请设置允许访问相册&#39;)</span><br><span class="line">                wx.showToast(&#123;</span><br><span class="line">                  title: &#39;请设置允许访问相册&#39;,</span><br><span class="line">                  icon: &#39;none&#39;</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 有则直接保存</span><br><span class="line">            openStatus &#x3D; true</span><br><span class="line">            wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">              filePath: canvasToTempFilePath,</span><br><span class="line">              success() &#123;</span><br><span class="line">                that.setData(&#123;</span><br><span class="line">                  showShareImg: false</span><br><span class="line">                &#125;)</span><br><span class="line">                wx.showToast(&#123;</span><br><span class="line">                  title: &#39;图片保存成功，快去分享到朋友圈吧~&#39;,</span><br><span class="line">                  icon: &#39;none&#39;,</span><br><span class="line">                  duration: 2000</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;,</span><br><span class="line">              fail() &#123;</span><br><span class="line">                wx.showToast(&#123;</span><br><span class="line">                  title: &#39;保存失败&#39;,</span><br><span class="line">                  icon: &#39;none&#39;</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        fail(err) &#123;</span><br><span class="line">          console.log(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此所有的步骤都已实现，在绘制的时候会遇到一些异步请求后台返回的数据，所以我用promise和async和await进行了封装，确保导出的图片信息是完整的。在绘制的过程确实遇到一些坑的地方。比如初开始导出的图片比例大小不对，还有用measureText测量文字宽度不对，多次绘制（可能受网络原因）有时导出的图片上的文字颜色会有误差等。如果你也遇到一些比较坑的地方可以一起探讨下做个记录</p>
<p>参考链接：<a href="https://mp.weixin.qq.com/s/Dsc81YRD5WrI6V105ci4hg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Dsc81YRD5WrI6V105ci4hg</a></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>海报</tag>
        <tag>分享朋友圈</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之下载保存图片</title>
    <url>/2020/10/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E4%B8%8B%E8%BD%BD%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="下载pdf"><a href="#下载pdf" class="headerlink" title="下载pdf"></a>下载pdf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">downloadFile: function(e) &#123;</span><br><span class="line">    let url &#x3D; e.currentTarget.dataset.url;</span><br><span class="line">    wx.downloadFile(&#123;</span><br><span class="line">        url: url,</span><br><span class="line">        success: function(res) &#123;</span><br><span class="line">            var filePath &#x3D; res.tempFilePath;</span><br><span class="line">            wx.openDocument(&#123;</span><br><span class="line">                filePath: filePath,</span><br><span class="line">                fileType:&quot;pdf&quot;,&#x2F;&#x2F;必填</span><br><span class="line">                success: function(res) &#123;</span><br><span class="line">                    console.log(&#39;打开文档成功&#39;)</span><br><span class="line">                &#125;,</span><br><span class="line">                fail: function(res) &#123;</span><br><span class="line">                    console.log(res);</span><br><span class="line">                &#125;,</span><br><span class="line">                complete: function(res) &#123;</span><br><span class="line">                    console.log(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: function(res) &#123;</span><br><span class="line">            console.log(&#39;文件下载失败&#39;);</span><br><span class="line">        &#125;,</span><br><span class="line">        complete: function(res) &#123;&#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="长按保存图片"><a href="#长按保存图片" class="headerlink" title="长按保存图片"></a>长按保存图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;image src&#x3D;&quot;&#123;&#123;url&#125;&#125;&quot; data-url&#x3D;&quot;&#123;&#123;url&#125;&#125;&quot; bindlongpress&#x3D;&quot;saveImage&quot;&gt;&lt;&#x2F;image&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"> data: &#123;</span><br><span class="line">   			     url:&quot;https:&#x2F;&#x2F;wechat.weixinzjit.com&#x2F;costa&#x2F;public&#x2F;uploads&#x2F;images&#x2F;20190109&#x2F;67b16149693920598435315fd0d5ab3e.jpg&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#x2F;&#x2F; 长按保存图片</span><br><span class="line"> saveImg(e)&#123;</span><br><span class="line">  let url &#x3D; e.currentTarget.dataset.url;</span><br><span class="line">  &#x2F;&#x2F;用户需要授权</span><br><span class="line">  wx.getSetting(&#123;</span><br><span class="line">   success: (res) &#x3D;&gt; &#123;</span><br><span class="line">    if (!res.authSetting[&#39;scope.writePhotosAlbum&#39;]) &#123;</span><br><span class="line">     wx.authorize(&#123;</span><br><span class="line">      scope: &#39;scope.writePhotosAlbum&#39;,</span><br><span class="line">      success:()&#x3D;&gt; &#123;</span><br><span class="line">       &#x2F;&#x2F; 同意授权</span><br><span class="line">       this.saveImg1(url);</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: (res) &#x3D;&gt;&#123;</span><br><span class="line">       console.log(res);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">     &#x2F;&#x2F; 已经授权了</span><br><span class="line">     this.saveImg1(url);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   fail: (res) &#x3D;&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)  </span><br><span class="line"> &#125;,</span><br><span class="line"> saveImg1(url)&#123;</span><br><span class="line">  wx.getImageInfo(&#123;</span><br><span class="line">   src: url,</span><br><span class="line">   success:(res)&#x3D;&gt; &#123;</span><br><span class="line">    let path &#x3D; res.path;</span><br><span class="line">    wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">     filePath:path,</span><br><span class="line">     success:(res)&#x3D;&gt; &#123; </span><br><span class="line">      console.log(res);</span><br><span class="line">     &#125;,</span><br><span class="line">     fail:(res)&#x3D;&gt;&#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;,</span><br><span class="line">   fail:(res)&#x3D;&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之互相跳转</title>
    <url>/2020/10/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BA%92%E7%9B%B8%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/wangmaoling/p/11764651.html" target="_blank" rel="noopener">微信小程序与内嵌webview之间来回跳转的几点总结，以及二维码的使用</a></p>
<p>截止到发稿小程序支持的功能，后续如果小程序更新在完善文稿。</p>
<h3 id="小程序可以内嵌组件跳转到h5页面"><a href="#小程序可以内嵌组件跳转到h5页面" class="headerlink" title="小程序可以内嵌组件跳转到h5页面"></a>小程序可以内嵌组件跳转到h5页面</h3><p>\1. 小程序可以内嵌组件跳转到h5页面，前提是在小程序后台配置相应的业务域名。新打开的h5页面会替代小程序组件内的其它组件，即为h5不能与小程序组件共存显示在屏幕上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;web-view src&#x3D;&quot;&#123;&#123;content&#125;&#125;&quot;&gt;&lt;&#x2F;web-view&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="打开的h5页面可以通过触发某事件可以跳转到本小程序"><a href="#打开的h5页面可以通过触发某事件可以跳转到本小程序" class="headerlink" title="打开的h5页面可以通过触发某事件可以跳转到本小程序"></a>打开的h5页面可以通过触发某事件可以跳转到本小程序</h3><p>\2. 打开的h5页面可以通过触发某事件可以跳转到<strong>本小程序(不能是其它小程序)</strong>的任意页面，并且可以携带参数。前提是在h5页面引入相应jssdk。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;user-scalable&#x3D;no, width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;res.wx.qq.com&#x2F;open&#x2F;js&#x2F;jweixin-1.3.0.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p id&#x3D;&quot;app&quot;&gt;点我跳转此小程序&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var app &#x3D; document.getElementById(&#39;app&#39;);</span><br><span class="line">        app.onclick &#x3D; function () &#123;</span><br><span class="line">            wx.miniProgram.redirectTo(&#123;url:&#39;&#x2F;pages&#x2F;index&#x2F;index?id&#x3D;111&#39;&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="本小程序可以跳转到其它小程序"><a href="#本小程序可以跳转到其它小程序" class="headerlink" title="本小程序可以跳转到其它小程序"></a>本小程序可以跳转到其它小程序</h3><p>\3. 本小程序可以跳转到其它小程序，前提要知道对方APPID。并且要在app.json文件配置下，这里也可以通过path跳转到其它子页面,不填默认主页。</p>
<p><img src="https://img2018.cnblogs.com/blog/1105103/201910/1105103-20191030135932605-1838988117.png" alt="img"></p>
<p>详情参考小程序文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html</a></p>
<p><strong>跳转方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.navigateToMiniProgram(&#123;</span><br><span class="line">  appId: &#39;&#39;,&#x2F;&#x2F;要打开的小程序 appId</span><br><span class="line">  path: &#39;page&#x2F;index&#x2F;index?id&#x3D;123&#39;,&#x2F;&#x2F;打开的页面路径，如果为空则打开首页</span><br><span class="line">  extraData: &#123;</span><br><span class="line">    foo: &#39;bar&#39;&#x2F;&#x2F;需要传递给目标小程序的数据，目标小程序可在 App.onLaunch，App.onShow 中获取到这份数据</span><br><span class="line">  &#125;,</span><br><span class="line">  envVersion: &#39;develop&#39;,&#x2F;&#x2F;要打开的小程序版本。仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    &#x2F;&#x2F; 打开成功</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>跳转方法二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;小程序代码</span><br><span class="line">&lt;navigator target&#x3D;&quot;miniProgram&quot; open-type&#x3D;&quot;navigate&quot; app-id&#x3D;&quot;对方APPID必填&quot; path&#x3D;&quot;&quot; extra-data&#x3D;&quot;&quot; version&#x3D;&quot;release&quot; hover-class&#x3D;&quot;none&quot;&gt;&lt;&#x2F;navigator&gt;</span><br></pre></td></tr></table></figure>

<p><strong>返回本小程序</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.navigateBackMiniProgram(&#123;</span><br><span class="line">    extraData: &#123;&#125;,</span><br><span class="line">    success(res) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回成功</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="两个小程序间的相互跳转传参"><a href="#两个小程序间的相互跳转传参" class="headerlink" title="两个小程序间的相互跳转传参"></a>两个小程序间的相互跳转传参</h3><p>小程序a代码： 跳转到小程序b并传id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.navigateToMiniProgram(&#123;</span><br><span class="line">appId: &#39;&#39;,</span><br><span class="line">path: &#39;pages&#x2F;index&#x2F;index?id&#x3D;123&#39;,</span><br><span class="line">extraData: &#123;&#125;,</span><br><span class="line">envVersion: &#39;develop&#39;,</span><br><span class="line">success(res) &#123;</span><br><span class="line">&#x2F;&#x2F; 打开成功</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>小程序b代码：</p>
<p>//index.js 接收并打印小程序a传递过来的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">onLoad: function (options) &#123;</span><br><span class="line">console.log(options)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="webview内嵌的h5页面，跳转到其它小程序"><a href="#webview内嵌的h5页面，跳转到其它小程序" class="headerlink" title="webview内嵌的h5页面，跳转到其它小程序"></a>webview内嵌的h5页面，跳转到其它小程序</h3><p>\4. 如果想要在webview内嵌的h5页面，跳转到其它小程序的实现途径。</p>
<p>　　a. 内嵌h5是不支持跳转到其它外部小程序，即便用上面2里面的触发事件也不能。</p>
<p>　　b. 实现方法只能是在内嵌的h5页面里面插入要跳转的小程序的二维码，可以通过长按识别的方法跳转过去。（</p>
<p>　　  <strong>小程序只识别嵌入h5里面的其它的小程序的二维码，不会识别其它二维码，这个二维吗还必须是菊花码</strong>）</p>
<p>　　c. 菊花二维码可以通过微信小程序后台生成，可以生成子页面的菊花二维码，也可以用外部工具来实现这个菊花二维码的生成。</p>
<p>　　  草料二维码可以实现实现菊花二维码，并且可以有参数：<a href="https://cli.im/mina/home" target="_blank" rel="noopener">https://cli.im/mina/home</a></p>
<p>　　d. 小程序二维码只能有一个参数，如果设置了多个参数就会被拼接。如果想要传多个参数，需要自定义分割符，以及获取。</p>
<h3 id="app和小程序互相跳转"><a href="#app和小程序互相跳转" class="headerlink" title="app和小程序互相跳转"></a>app和小程序互相跳转</h3><p>app和小程序互相跳转：</p>
<p>1、App主动发起小程序卡片分享到微信，微信点击打开小程序，这时的小程序可以打开App</p>
<p>2、App主动发起打开小程序，这时的小程序可以打开App</p>
<p>目前主要就这两种方式吧，说是互相跳转好像不太妥当，毕竟App才是主动一方，小程序只能被动返回，类似于分享，App如果不发起分享到微信，微信是不能返回你的App的。说到这里大家应该都有一个印象了吧。</p>
<p>至于上面两种方式的实现方法也简单，只要把微信官网的代码复制过来就能用了。</p>
<p>App主动分享小程序卡片（<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317340&token=ae4e632e7dcc175a183ce11346e0dfcd98399d82&lang=zh_CN" target="_blank" rel="noopener">微信官网</a>）：小程序测试版不能分享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WXMiniProgramObject miniProgramObj = <span class="keyword">new</span> WXMiniProgramObject();</span><br><span class="line">miniProgramObj.webpageUrl = <span class="string">"http://www.qq.com"</span>; <span class="comment">// 兼容低版本的网页链接</span></span><br><span class="line">miniProgramObj.miniprogramType = WXMiniProgramObject.MINIPTOGRAM_TYPE_RELEASE;<span class="comment">// 正式版:0，测试版:1，体验版:2</span></span><br><span class="line">miniProgramObj.userName = <span class="string">"gh_d43f693ca31f"</span>;     <span class="comment">// 小程序原始id</span></span><br><span class="line">miniProgramObj.path = <span class="string">"/pages/media"</span>;            <span class="comment">//小程序页面路径</span></span><br><span class="line">WXMediaMessage msg = <span class="keyword">new</span> WXMediaMessage(miniProgramObj);</span><br><span class="line">msg.title = <span class="string">"小程序消息Title"</span>;                    <span class="comment">// 小程序消息title</span></span><br><span class="line">msg.description = <span class="string">"小程序消息Desc"</span>;               <span class="comment">// 小程序消息desc</span></span><br><span class="line">msg.thumbData = getThumb();                      <span class="comment">// 小程序消息封面图片，小于128k</span></span><br><span class="line"> </span><br><span class="line">SendMessageToWX.Req req = <span class="keyword">new</span> SendMessageToWX.Req();</span><br><span class="line">req.transaction = buildTransaction(<span class="string">"webpage"</span>);</span><br><span class="line">req.message = msg;</span><br><span class="line">req.scene = SendMessageToWX.Req.WXSceneSession;  <span class="comment">// 目前支持会话</span></span><br><span class="line">api.sendReq(req);</span><br></pre></td></tr></table></figure>

<p>App主动打开小程序（<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=21526646437Y6nEC&token=ae4e632e7dcc175a183ce11346e0dfcd98399d82&lang=zh_CN" target="_blank" rel="noopener">微信官网</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String appId = <span class="string">"wxd930ea5d5a258f4f"</span>; <span class="comment">// 填应用AppId</span></span><br><span class="line">IWXAPI api = WXAPIFactory.createWXAPI(context, appId);</span><br><span class="line">WXLaunchMiniProgram.Req req = <span class="keyword">new</span> WXLaunchMiniProgram.Req();</span><br><span class="line">req.userName = <span class="string">"gh_d43f693ca31f"</span>; <span class="comment">// 填小程序原始id</span></span><br><span class="line">req.path = path;                  <span class="comment">//拉起小程序页面的可带参路径，不填默认拉起小程序首页</span></span><br><span class="line">req.miniprogramType = WXLaunchMiniProgram.Req.MINIPTOGRAM_TYPE_RELEASE;<span class="comment">// 可选打开 开发版，体验版和正式版</span></span><br><span class="line">api.sendReq(req);</span><br><span class="line"></span><br><span class="line">WXEntryActivity中</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResp</span><span class="params">(BaseResp resp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resp.getType() == ConstantsAPI.COMMAND_LAUNCH_WX_MINIPROGRAM) &#123;</span><br><span class="line">        WXLaunchMiniProgram.Resp launchMiniProResp = (WXLaunchMiniProgram.Resp) resp;</span><br><span class="line">        String extraData =launchMiniProResp.extMsg; <span class="comment">// 对应JsApi navigateBackApplication中的extraData字段数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小程序返回App就更简单了（<a href="https://developers.weixin.qq.com/miniprogram/dev/api/launchApp.html" target="_blank" rel="noopener">微信官网</a>）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">"launchApp"</span> <span class="attr">app-parameter</span>=<span class="string">"wechat"</span> <span class="attr">binderror</span>=<span class="string">"launchAppError"</span>&gt;</span>打开APP<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另附：微信分享打开App：使用魔窗SDK实现，实际是网页打开App，苹果倒是可以直接打开App，安卓只能用网页打开分享再打开App。具体实现可以查看<a href="http://www.magicwindow.cn/doc/" target="_blank" rel="noopener">官网文档</a>。</p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>webview</tag>
        <tag>跳转</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之分享</title>
    <url>/2020/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>在小程序开发API中，发送给好友/群，可以有两种实现方式：</p>
<p>1）入口</p>
<p>a.小程序右上角自带的分享功能（…）：</p>
<p>如果在当前页面调用wx.hideShareMenu()方法，那么右上角的分享功能将被隐藏，当然，隐藏方法与现实方法是成对出现的，调用wx.showShareMenu()方法，可以显示该功能。</p>
<p>b.自定义分享按钮：<butto n open-type="share">分享&lt;/butto n&gt;</butto></p>
<p>以上两种方式均可实现分享功能</p>
<a id="more"></a>

<p>2）分享数据类型</p>
<p>不管采用以上何种方法，转发给好友的数据总归有它的数据模型，该数据模型是通过onShareAppMessage(options)返回的，也就是return一个object即可。其中，options.from可以用来判断是从自定义button打开的转发页面，还是从右上角的打开的转发页面。</p>
<p>以下是该object的数据模型：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6901201-5e4dd35c86bc518a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/873/format/webp" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 用户点击右上角分享</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onShareAppMessage: function () &#123;</span><br><span class="line">    let url &#x3D; encodeURIComponent(&#39;&#x2F;pages&#x2F;navMain&#39;); </span><br><span class="line">    return &#123;</span><br><span class="line">      title: &quot;热点详情&quot;, &#x2F;&#x2F;转发标题</span><br><span class="line">      path:&#96;&#x2F;pages&#x2F;test&#x2F;index&#96; , &#x2F;&#x2F;转发路径</span><br><span class="line">      imageUrl:&#39;&#x2F;pages&#x2F;img&#x2F;header.jpg&#39; &#x2F;&#x2F;自定义分享图片路径</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>如上所示，如果开发人员在onShareAppMessage(options)不进行任何处理，那么微信将会有一个默认的数据转发出去，title为当前小程序名称，path为当前页面的路径，imageUrl为当前页面的截图。根据imageUrl的定义，开发人员可以上传自定义图片。</p>
<h3 id="封装一个分享的组件"><a href="#封装一个分享的组件" class="headerlink" title="封装一个分享的组件"></a>封装一个分享的组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&#39;share&#39;&gt;</span><br><span class="line">   &lt;view class&#x3D;&#39;like&#39;&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;iconfont icon-aixin&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">   &lt;&#x2F;view&gt;</span><br><span class="line">   &lt;view class&#x3D;&#39;weixin&#39;&gt;</span><br><span class="line">       &lt;button open-type&#x3D;&quot;share&quot; class&#x3D;&#39;iconfont icon-weixin&#39;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">   &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>页面效果如下:</p>
<p>​                      <img src="https://img-blog.csdnimg.cn/20190725150933355.png" alt="img"></p>
<p>说明:</p>
<p>  如果想在页面上实现点击按钮分享,那么这个点击的按钮必须使用button标签,并且open-type置为share</p>
<p>2.在想要分享的页面中引入上面组件,并在页面的js中Page所包含的对象里增加一个方法onShareAppMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 用户点击右上角分享</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  onShareAppMessage: function () &#123;</span><br><span class="line">    let url &#x3D; encodeURIComponent(&#39;&#x2F;packageNews&#x2F;pages&#x2F;news_detail&#x2F;news_detail?news_id&#x3D;&#39; + this.data.news_id);</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &quot;热点详情&quot;,</span><br><span class="line">      path:&#96;&#x2F;pages&#x2F;index&#x2F;index?url&#x3D;$&#123;url&#125;&#96; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 说明:</p>
<p> 将当前页面的路径包括参数使用encodeURIComponent进行编码并作为url的参数,path设置为小程序的首页.当我们将该页面</p>
<p>分享给其他人时,他们打开的首先是首页,然后跳转到我们分享的这个页面.</p>
<p>3.要想分享后的页面打开先进入首页再跳转到分享的页面,首页的js要做如下设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;index.js</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line">    if(options.url)&#123;</span><br><span class="line">      let url &#x3D; decodeURIComponent(options.url);</span><br><span class="line">      wx.navigateTo(&#123;</span><br><span class="line">        url</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之定位</title>
    <url>/2020/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h4 id="结合腾讯地图sdk"><a href="#结合腾讯地图sdk" class="headerlink" title="结合腾讯地图sdk"></a>结合腾讯地图sdk</h4><p>腾讯地图提供了供小程序使用的SDK，可结合地图组件和api进行快速调用。首次使用需要申请秘钥，下载sdk文件qqmap-wx-jssdk.js。需要设置安全域名<a href="https://apis.map.qq.com" target="_blank" rel="noopener">https://apis.map.qq.com</a></p>
<p>sdk使用方法及js链接：</p>
<p><a href="https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview" target="_blank" rel="noopener">https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview</a></p>
<p>核心方法：</p>
<p><a href="https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/qqMapwx" target="_blank" rel="noopener">https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/qqMapwx</a></p>
<a id="more"></a>

<p>具体实现参考：</p>
<h4 id="app-json-不知道具体位置可以看这里-这里有整个app-json的配置"><a href="#app-json-不知道具体位置可以看这里-这里有整个app-json的配置" class="headerlink" title="app.json:  (不知道具体位置可以看这里,这里有整个app.json的配置)"></a>app.json:  (<a href="https://blog.csdn.net/guochanof/article/details/89669839" target="_blank" rel="noopener">不知道具体位置可以看这里,这里有整个app.json的配置</a>)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;permission&quot;: &#123;</span><br><span class="line">   &quot;scope.userLocation&quot;: &#123;</span><br><span class="line">     &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="wxml"><a href="#wxml" class="headerlink" title="wxml:"></a>wxml:</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pages/map/map.wxml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是地图部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"map_container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">map</span> <span class="attr">class</span>=<span class="string">'map'</span> <span class="attr">longitude</span>=<span class="string">'&#123;&#123;longitude&#125;&#125;'</span> <span class="attr">latitude</span>=<span class="string">'&#123;&#123;latitude&#125;&#125;'</span> <span class="attr">scale</span>=<span class="string">'&#123;&#123;scale&#125;&#125;'</span> <span class="attr">markers</span>=<span class="string">'&#123;&#123;markers&#125;&#125;'</span> <span class="attr">controls</span>=<span class="string">"&#123;&#123;controls&#125;&#125;"</span> <span class="attr">bindcontroltap</span>=<span class="string">"bindcontroltap"</span> <span class="attr">polyline</span>=<span class="string">'&#123;&#123;polyline&#125;&#125;'</span> <span class="attr">circles</span>=<span class="string">"&#123;&#123;circles&#125;&#125;"</span> <span class="attr">bindmarkertap</span>=<span class="string">'bindmarkertap'</span> <span class="attr">bindcontroltap</span>=<span class="string">'bindcontroltap'</span></span></span><br><span class="line"><span class="tag">    <span class="attr">show-location</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下是导航部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'list-guide'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里的坐标本应该是从服务器获取数据的,这时丈先写死在页面上了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">"onGuideTap"</span> <span class="attr">data-latitude</span>=<span class="string">'39.92392'</span> <span class="attr">data-longitude</span>=<span class="string">'116.411885'</span> <span class="attr">data-bankName</span>=<span class="string">'最高人民检察院'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">'/images/banklist/daohang.png'</span> <span class="attr">class</span>=<span class="string">'list-guide-imgae'</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">'list-guide-text'</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">'onbankTap'</span> <span class="attr">data-bankId</span>=<span class="string">"&#123;&#123;item.BANK_ID&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">'/images/banklist/xiangqing.png'</span> <span class="attr">class</span>=<span class="string">'list-guide-imgae'</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">'list-guide-text'</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>宽度不是满屏,所以加个样式</p>
<h4 id="wxss"><a href="#wxss" class="headerlink" title="wxss:"></a>wxss:</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* pages/map/map.wxss */</span></span><br><span class="line"><span class="selector-class">.map_container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">260px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.map</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.list-guide</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;  </span><br><span class="line">  <span class="attribute">flex-direction</span>: row; </span><br><span class="line">  <span class="attribute">justify-content</span>:space-around;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#ededed</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-guide-imgae</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">70</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70</span>rpx;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-guide-text</span>&#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">90</span>rpx;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">35</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是最重要的JS部分了()</p>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS:"></a>JS:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/map/map.js</span></span><br><span class="line">varQQMapWX= <span class="built_in">require</span>(<span class="string">'../libs/qqmap-wx-jssdk.js'</span>);</span><br><span class="line"><span class="keyword">var</span> qqmapsdk;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    addmissage: <span class="string">'选的位置'</span>,</span><br><span class="line">    <span class="comment">// markers	 Array	标记点</span></span><br><span class="line">    stitle:<span class="string">'故宫'</span>,</span><br><span class="line">    latitude: <span class="string">""</span>,</span><br><span class="line">    longitude: <span class="string">""</span>,</span><br><span class="line">    scale: <span class="number">14</span>,</span><br><span class="line">    markers: [],</span><br><span class="line">    <span class="comment">//controls控件 是左下角圆圈小图标,用户无论放大多少,点这里可以立刻回到当前定位(控件（更新一下,即将废弃，建议使用 cover-view 代替）)</span></span><br><span class="line">    controls: [&#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      iconPath: <span class="string">'../../images/img/controls.png'</span>,</span><br><span class="line">      position: &#123;</span><br><span class="line">        left: <span class="number">15</span>,</span><br><span class="line">        top: <span class="number">260</span> - <span class="number">50</span>,</span><br><span class="line">        width: <span class="number">40</span>,</span><br><span class="line">        height: <span class="number">40</span></span><br><span class="line">      &#125;,</span><br><span class="line">      clickable: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    distanceArr: []</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">//new 地图对象</span></span><br><span class="line">    qqmapsdk =<span class="keyword">new</span> QQMapWX(&#123;</span><br><span class="line">     key:<span class="string">'22VBZ-REEK5-WVSI7-QKCOP-QPM6E-W7BPO'</span></span><br><span class="line">   &#125;);</span><br><span class="line">    <span class="comment">//小程序api获取当前的地理位置、速度</span></span><br><span class="line">    wx.getLocation(&#123;</span><br><span class="line">      type: <span class="string">'wgs84'</span>, <span class="comment">// 默认为 wgs84 返回 gps 坐标，gcj02 返回可用于 wx.openLocation 的坐标</span></span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//赋值经纬度</span></span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          latitude: res.latitude,</span><br><span class="line">          longitude: res.longitude,</span><br><span class="line"> </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//在这里调用了逆地理解析reverseGeocoder，对地理解析结果读取获取当前位置。</span></span><br><span class="line">        qqmapsdk.reverseGeocoder(&#123;</span><br><span class="line">           location:&#123;</span><br><span class="line">             latitude: res.latitude1,</span><br><span class="line">             longitude: res.longitude1</span><br><span class="line">           &#125;,</span><br><span class="line">           success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(res);</span><br><span class="line">             <span class="keyword">var</span> add= res.result.address</span><br><span class="line">             that.setData(&#123;</span><br><span class="line">               wd: latitude1,</span><br><span class="line">               jd: longitude1,</span><br><span class="line">               address: add</span><br><span class="line">             &#125;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//controls控件的点击事件</span></span><br><span class="line">  bindcontroltap(e) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (e.controlId == <span class="number">1</span>) &#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        latitude: <span class="keyword">this</span>.data.latitude,</span><br><span class="line">        longitude: <span class="keyword">this</span>.data.longitude,</span><br><span class="line">        scale: <span class="number">14</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//导航</span></span><br><span class="line">  onGuideTap: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lat = <span class="built_in">Number</span>(event.currentTarget.dataset.latitude);</span><br><span class="line">    <span class="keyword">var</span> lon = <span class="built_in">Number</span>(event.currentTarget.dataset.longitude);</span><br><span class="line">    <span class="keyword">var</span> bankName = event.currentTarget.dataset.bankname;</span><br><span class="line">    <span class="built_in">console</span>.log(lat);</span><br><span class="line">    <span class="built_in">console</span>.log(lon);</span><br><span class="line">    wx.openLocation(&#123;</span><br><span class="line">      type: <span class="string">'gcj02'</span>,</span><br><span class="line">      latitude: lat,</span><br><span class="line">      longitude: lon,</span><br><span class="line">      name: bankName,</span><br><span class="line">      scale: <span class="number">28</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="type参数"><a href="#type参数" class="headerlink" title="type参数"></a>type参数</h4><h5 id="WGS84，GCJ02之间的区别"><a href="#WGS84，GCJ02之间的区别" class="headerlink" title="WGS84，GCJ02之间的区别"></a>WGS84，GCJ02之间的区别</h5><p>84坐标系可以理解为是真实坐标系，是一个地点的实际坐标值。02坐标系是加密后的坐标系，是为了国家安全考虑。对应的不是实际的坐标值，但是在加密的坐标下，进行导航、定位等操作是完全不受影响的，只不过坐标不是真实的坐标而已。我国的各个地图软件，均使用02坐标系进行街景地图测绘和卫星地图测绘，因此可以看到我国的地图应用上均不会标注经纬坐标信息。</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>wgs84：GPS坐标系<br>gcj02：火星坐标系，国测局02年发布的坐标体系，高德，腾讯等使用（<em>火星坐标指的就是实际坐标经过GCJ02算法得到的坐标</em>）。<br>BD-09：百度坐标系，百度自研，百度地图使用（<em>百度坐标指的就是实际坐标经过BD-09算法得到的坐标</em>）。</p>
<h4 id="sdk和api"><a href="#sdk和api" class="headerlink" title="sdk和api"></a>sdk和api</h4><h6 id="1-SDK是什么？"><a href="#1-SDK是什么？" class="headerlink" title="1.SDK是什么？"></a>1.SDK是什么？</h6><p>SDK：<br>概念：软件开发工具包（SDK，全称：Software Development Kit）<br>一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。</p>
<p>通俗点是指由第三方服务商提供的实现软件产品某项功能的工具包。</p>
<p>就相当于很多API和其他文件的集合体，你可以用这个完成某一个事情。</p>
<p>举例子：<br>整个计算器产品可以看做是一个SDK，它里面有API集合（计算器），说明文档（说明书），以及一些其他文件。<br>这个SDK的功能就是计算，可能要算什么不确定，但是你可以通过这个SDK中的某个方法完成，实现你的目的。</p>
<h6 id="2-API是什么？"><a href="#2-API是什么？" class="headerlink" title="2.API是什么？"></a>2.API是什么？</h6><p>API：<br>概念：API（Application Programming Interface,应用程序编程接口）<br>一般是指一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p>
<p>其实就是别人已经写好的可以实现特定功能的函数，而你只需要根据他提供好的接口，也就是调用他的方法，传入他规定的参数，然后这个函数就会帮你实现这些功能。</p>
<p>举例子：</p>
<p>比如别人写好了一个数字求和的方法sum(int a, int b)。<br>提供给你一个API接口——你只需要调用它这个sum()函数，然后传入这个a，b的值，然后就可以得到计算的结果，你不需要知道这个方法是怎么实现的，知道该怎么调用即可。</p>
<p>如果别人又写了一个两数相乘的方法Mul(int a, int b)，那这又称为另一个API。</p>
<h6 id="3-SDK和API的区别"><a href="#3-SDK和API的区别" class="headerlink" title="3.SDK和API的区别"></a>3.SDK和API的区别</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.API是一个具体的函数，一个确定的功能，已经明确了它的作用（比如做加法）。</span><br><span class="line"> </span><br><span class="line">2.SDK就像是很多方法的集合体，是一个工具包。</span><br><span class="line"></span><br><span class="line">3.SDK相当于开发集成工具环境，API就是数据接口。在SDK环境下调用API数据。（而这个SDK你可以自己配置或者下载第三方提供的）</span><br><span class="line"> </span><br><span class="line">4.SDK除了他提供的完善的接口，他还会给你提供相关的开发环境，而API需要的环境你得自己提供（比如传参）</span><br></pre></td></tr></table></figure>



<p>参考链接：<a href="https://blog.csdn.net/guochanof/article/details/90130871" target="_blank" rel="noopener">https://blog.csdn.net/guochanof/article/details/90130871</a></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之阿拉丁统计平台</title>
    <url>/2020/10/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E9%98%BF%E6%8B%89%E4%B8%81%E7%BB%9F%E8%AE%A1%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h3 id="关键步骤："><a href="#关键步骤：" class="headerlink" title="关键步骤："></a><strong>关键步骤：</strong></h3><ul>
<li>注册/登录统计平台</li>
<li>创建小程序</li>
<li>接入SDK</li>
<li>检测SDK</li>
<li>集成成功</li>
</ul>
<a id="more"></a>

<h2 id="第一步：注册-登录-阿拉丁统计平台"><a href="#第一步：注册-登录-阿拉丁统计平台" class="headerlink" title="第一步：注册/登录 阿拉丁统计平台"></a><strong>第一步：注册/登录 阿拉丁统计平台</strong></h2><p>阿拉丁统计平台注册可以通过 PC 访问：<a href="http://link.zhihu.com/?target=http%3A//tj.aldwx.com">tj.aldwx.com</a>，通过「微信扫码+手机号」的方式即可完成注册。注册流程大约只需要 19s。</p>
<p><img src="https://pic2.zhimg.com/v2-9668fef89e4cd797290ec2c4c6c28898_b.jpg" alt="img">)<img src="https://pic2.zhimg.com/80/v2-9668fef89e4cd797290ec2c4c6c28898_720w.jpg" alt="img"></p>
<p>如果您已经注册过阿拉丁统计平台，可以直接通过微信扫码的方式登录，方便快捷。</p>
<h2 id="第二步：-创建阿拉丁小程序"><a href="#第二步：-创建阿拉丁小程序" class="headerlink" title="第二步： 创建阿拉丁小程序"></a><strong>第二步： 创建阿拉丁小程序</strong></h2><p>登录阿拉丁统计平台后，会默认跳转到阿拉丁统计后台的主页。方便您了解所有小程序的数据变化。</p>
<p><img src="https://pic2.zhimg.com/v2-3b07e92e7e9d502f8e794542369aeb97_b.jpg" alt="img">)<img src="https://pic2.zhimg.com/80/v2-3b07e92e7e9d502f8e794542369aeb97_720w.jpg" alt="img"></p>
<p>我们通过右上角「创建应用」可以进入小程序的创建页面，开始我们小程序的创建工作。</p>
<p><img src="https://pic3.zhimg.com/v2-0b62994983a194e435507e94d3ad2600_b.jpg" alt="img">)<img src="https://pic3.zhimg.com/80/v2-0b62994983a194e435507e94d3ad2600_720w.jpg" alt="img"></p>
<p>创建小程序需要填写：<strong>小程序名称</strong>，选择<strong>小程序的类型</strong>（小程序、小游戏），选择<strong>小程序的分类</strong>（小程序对应的是小程序类型，小游戏对应的是小游戏类型）。</p>
<p>填写信息后，提交就可以获取AppKey，然后就开始SDK接入了。</p>
<h2 id="第三步：接入阿拉丁统计SDK（重点）"><a href="#第三步：接入阿拉丁统计SDK（重点）" class="headerlink" title="第三步：接入阿拉丁统计SDK（重点）"></a><strong>第三步：接入阿拉丁统计SDK（重点）</strong></h2><p>接入SDK一直以来都是大家最关心的部分，也是接入阿拉丁统计最重要的一个步骤。所以这部分要认真看哦。提交信息后可以看到下面的截图：</p>
<p><img src="https://pic1.zhimg.com/v2-ed664367f737309b65ae3f58afbc4269_b.jpg" alt="img">)<img src="https://pic1.zhimg.com/80/v2-ed664367f737309b65ae3f58afbc4269_720w.jpg" alt="img"></p>
<blockquote>
<p>注：阅读此部分的内容需要和开发人员一起，欢迎分享给自己本公司的小程序开发人员。</p>
</blockquote>
<p>首先，这个部分的流程需要小程序的技术人员（一般是前端）来协助完成。在此过程中需要了解 阿拉丁Key、统计平台SDK、帮助文档以及数据检测。</p>
<p>阿拉丁Key（又称“AppKey”）是我们为大家创建小程序后生成的唯一凭证，开发者在集成SDK的时候需要将其填写到代码中（具体的操作见后文）。</p>
<p>其次，我们在接入的时候需要充分了解自己的小程序是否采用了框架（wepy、mpvue、Taro）或者插件（最好是和小程序的开发人员沟通确认），如果都没有的话就是标准的小程序类型。</p>
<p>不同的框架、插件接入流程会有细微的变化，但是阿拉丁Key和阿拉丁SDK是一样的。</p>
<p><a href="http://doc.aldwx.com/mini-program/join/wx-sdk/plugin" target="_blank" rel="noopener">阿拉丁帮助文档</a></p>
<p><img src="https://pic4.zhimg.com/v2-346337e2cb6a71de0c5757415b3a38d8_b.jpg" alt="img">)<img src="https://pic4.zhimg.com/80/v2-346337e2cb6a71de0c5757415b3a38d8_720w.jpg" alt="img"></p>
<p>接着，我们了解了阿拉丁Key和小程序类型后，我们可以下载SDK进行代码集成工作了。由于本文篇幅问题，本文的集成案例以「<strong>标准版小程序</strong>」演示。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>1、设置域名</p>
<p>登录<a href="http://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/">微信公众平台</a>(mp.weixin.qq.com)，在 <strong>开发→开发设置-&gt;服务器域名</strong> 找到「 <strong>request 合法域名</strong>」，点击「修改」，将<strong><code>log.aldwx.com</code></strong> 添加 <strong>request 合法域名</strong>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log.aldwx.com</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/v2-cd5e478a31d7facc7b7763dd524581d8_b.jpg" alt="img">)<img src="https://pic4.zhimg.com/80/v2-cd5e478a31d7facc7b7763dd524581d8_720w.jpg" alt="img"></p>
<p>2、配置SDK</p>
<p><strong><a href="http://link.zhihu.com/?target=http%3A//tongji.aldwx.com/tool/ald-stat.zip">点击下载</a></strong> 微信小程序SDK，并将下载的文件解压，将解压后的文件 <strong>ald-stat.js</strong> 和 <strong>ald-stat-conf.js</strong> 复制到小程序根目录的 <strong>utils 文件夹</strong>中。</p>
<blockquote>
<p>如果没有 <strong>utils</strong> 文件夹请在小程序项目的根目录下创建；</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/v2-d4cb4a63766df8d586e96509af489c14_b.jpg" alt="img">)<img src="https://pic1.zhimg.com/80/v2-d4cb4a63766df8d586e96509af489c14_720w.jpg" alt="img"></p>
<p>使用微信开发者工具打开小程序根目录 <strong>utils 文件夹</strong>下的 <strong>ald-stat-conf.js</strong> 文件，在浏览器<strong>登录<a href="http://link.zhihu.com/?target=http%3A//tongji.aldwx.com/">阿拉丁小程序平台</a>-管理-小程序列表-找到需要集成的小程序</strong>，复制对应小程序的 AppKey 到  <code>exports.app_key = &quot;&quot;</code>的双引号中间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引号前后不能有空格；其他配置项请勿随意更改。</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/v2-422b54fb7647447b1dac1da247c310a2_b.jpg" alt="img">)<img src="https://pic3.zhimg.com/80/v2-422b54fb7647447b1dac1da247c310a2_720w.jpg" alt="img"></p>
<p>使用微信开发者工具打开小程序根目录下的 <strong>app.js</strong> 文件，复制下段代码到 <strong>app.js</strong> 文件的第一行粘贴，完成后通过 <strong>菜单栏-文件-保存</strong>（快捷键 Ctrl+S ）修改的代码；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; app.js </span><br><span class="line">const ald &#x3D; require(&#39;.&#x2F;utils&#x2F;ald-stat.js&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/v2-84098f5dea9e38ef386963dfc4f68563_b.jpg" alt="img">)<img src="https://pic3.zhimg.com/80/v2-84098f5dea9e38ef386963dfc4f68563_720w.jpg" alt="img"></p>
<p>3、检测上报状态</p>
<p>在微信开发者工具中，查看控制台中的 Network 是否存在 <strong>d.html</strong> 开头的请求，点击后可看到 <strong><a href="http://link.zhihu.com/?target=http%3A//log.aldwx.com">http://log.aldwx.com</a></strong> 的域名信息，且 <strong>status</strong> 状态为 <strong>200</strong>。</p>
<p><img src="https://pic2.zhimg.com/v2-61ca010cd343e84a71c2ed0c55d76884_b.jpg" alt="img">)<img src="https://pic2.zhimg.com/80/v2-61ca010cd343e84a71c2ed0c55d76884_720w.jpg" alt="img"></p>
<p>验证成功后，将所有代码提交至微信审核，审核通过后需<strong>发布版本</strong>。</p>
<p>以上流程全部配置完成后了，表示小程序已经成功接入了阿拉丁统计平台。</p>
<p>如果遇到问题可以咨询您的同事（前端技术人员）或者咨询阿拉丁统计平台客服（微信ID：alddandan)。</p>
<h2 id="增加统计埋点"><a href="#增加统计埋点" class="headerlink" title="增加统计埋点"></a>增加统计埋点</h2><h3 id="一、自定义事件上报方法"><a href="#一、自定义事件上报方法" class="headerlink" title="一、自定义事件上报方法"></a>一、自定义事件上报方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.aldstat.sendEvent( key, value )</span><br></pre></td></tr></table></figure>

<p>定义：该方法接收两个参数，第一个参数key为事件名称。第二个参数vaule为事件本身的参数，该参数可以为一个字符串( String )或者一个JavaScript对象 ( Object )。</p>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key ： string</span><br><span class="line">value： &#123;  string | object &#125;</span><br></pre></td></tr></table></figure>

<p>规则：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>事件名称</td>
<td>string</td>
<td>描述用户的动作名称，不超过255个字符，支持特殊字符</td>
</tr>
<tr>
<td>参数</td>
<td>string</td>
<td>动作的参数，不超过255个字符，支持特殊字符但不包括（英文逗号 , 英文冒号 : 点 .）</td>
</tr>
<tr>
<td>参数值</td>
<td>string</td>
<td>动作的参数值，不超过255个字符，支持特殊字符但不包括（英文逗号 , 英文冒号 : 点 .）</td>
</tr>
</tbody></table>
<p>满足上述规则时，SDK才会上报事件及其参数。否则SDK 不会上报。</p>
<h3 id="二、自定义事件成功检测"><a href="#二、自定义事件成功检测" class="headerlink" title="二、自定义事件成功检测"></a>二、自定义事件成功检测</h3><p>例如，以<strong>获取用户昵称</strong>为例，进行事件上报，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.aldstat.sendEvent(&#39;获取用户昵称&#39;, &#123;</span><br><span class="line">        &quot;用户昵称&quot;: &quot;DemoChen&quot;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>上报成功后如下图所示：</p>
<p><img src="https://aldpicsh-1252823355.cossh.myqcloud.com/ueditor/1578224507.jpg" alt="img"></p>
<p>埋点验证成功后，将所有代码提交至微信审核，审核通过后需<strong>发布版本</strong></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>阿拉丁</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发之自定义导航栏</title>
    <url>/2020/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
    <content><![CDATA[<h1 id="微信小程序-自定义头部导航栏-navigationStyle"><a href="#微信小程序-自定义头部导航栏-navigationStyle" class="headerlink" title="微信小程序 自定义头部导航栏 navigationStyle"></a>微信小程序 自定义头部导航栏 navigationStyle</h1><p><img src="https://upload-images.jianshu.io/upload_images/8198580-8401274f1a9f6607.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/389/format/webp" alt="img"></p>
<a id="more"></a>

<p>navigationStyle</p>
<p>要用自定义的导航栏只需要在app.json中配置</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8198580-11a5485516f3abc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/422/format/webp" alt="img"></p>
<p>app.json</p>
<blockquote>
<p>目前微信小程序不支持单个页面设置(现在支持了，本文章仅供参考)，一旦在要决定使用自定义导航栏，那么每个页面都需要设置，为了方便我就将其写成了一个组件：</p>
</blockquote>
<p>组件目录：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8198580-1e0091fc766021d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/269/format/webp" alt="img"></p>
<p>组件目录</p>
<p>index.wxml文件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">'nav-wrap'</span> style=<span class="string">'height: &#123;height*2 + 20&#125;px;'</span>&gt;</span><br><span class="line">    <span class="comment">// 导航栏 中间的标题</span></span><br><span class="line">  &lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">'nav-title'</span> style=<span class="string">'line-height: &#123;height*2 + 44&#125;px;'</span>&gt;&#123;&#123;navbarData.title&#125;&#125;&lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">  &lt;view style='display: flex; justify-content: space-around;flex-direction: column'&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 导航栏  左上角的返回按钮 和home按钮</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/  其中wx:if='&#123;navbarData.showCapsule&#125;' 是控制左上角按钮的显示隐藏，首页不显示</span></span><br><span class="line"><span class="regexp">    &lt;view class='nav-capsule' style='height: &#123;height*2 + 44&#125;px;' wx:if='&#123;navbarData.showCapsule&#125;'&gt;</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/左上角的返回按钮，wx:if='&#123;!share&#125;'空制返回按钮显示</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/从分享进入小程序时 返回上一级按钮不应该存在</span></span><br><span class="line"><span class="regexp">      &lt;view bindtap='_navback' wx:if='&#123;!share&#125;'&gt;</span></span><br><span class="line"><span class="regexp">        &lt;image src='/img</span>s/back-pre.png<span class="string">' mode='</span>aspectFill<span class="string">' class='</span>back-pre<span class="string">'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="string">      &lt;/view&gt;</span></span><br><span class="line"><span class="string">      &lt;view class='</span>navbar-v-line<span class="string">' wx:if='</span>&#123;!share&#125;<span class="string">'&gt;&lt;/view&gt;</span></span><br><span class="line"><span class="string">      &lt;view bindtap='</span>_backhome<span class="string">'&gt;</span></span><br><span class="line"><span class="string">        &lt;image src='</span>/imgs/back-home.png<span class="string">' mode='</span>aspectFill<span class="string">' class='</span>back-home<span class="string">'&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="string">      &lt;/view&gt;</span></span><br><span class="line"><span class="string">    &lt;/view&gt;</span></span><br><span class="line"><span class="string">  &lt;/view&gt;</span></span><br><span class="line"><span class="string">&lt;/view&gt;</span></span><br></pre></td></tr></table></figure>

<p>index.wxss文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 顶部要固定定位   标题要居中   自定义按钮和标题要和右边微信原生的胶囊上下对齐 */</span></span><br><span class="line"><span class="selector-class">.nav-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">9999999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 标题要居中 */</span></span><br><span class="line"><span class="selector-class">.nav-title</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">400</span>rpx;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">36</span>rpx;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2c2b2b</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav-capsule</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">30</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">140</span>rpx;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar-v-line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">32</span>rpx;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e5e5e5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.back-pre</span>, <span class="selector-class">.back-home</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">32</span>rpx;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">36</span>rpx;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">4</span>rpx;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nav-capsule</span> <span class="selector-class">.back-home</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">36</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40</span>rpx;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">3</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.json文件（自定义组件必须）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"component"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js文件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    navbarData: &#123;   <span class="comment">//navbarData   由父页面传递的数据，变量名字自命名</span></span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      value: &#123;&#125;,</span><br><span class="line">      observer: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    height: <span class="string">''</span>,</span><br><span class="line">    <span class="comment">//默认值  默认显示左上角</span></span><br><span class="line">    navbarData: &#123;</span><br><span class="line">      showCapsule: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  attached: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取是否是通过分享进入的小程序</span></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      share: app.globalData.share</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 定义导航栏的高度   方便对齐</span></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      height: app.globalData.height</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">  <span class="comment">// 返回上一页面</span></span><br><span class="line">    _navback() &#123;</span><br><span class="line">      wx.navigateBack()</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="comment">//返回到首页</span></span><br><span class="line">    _backhome() &#123;</span><br><span class="line">      wx.switchTab(&#123;</span><br><span class="line">        url: <span class="string">'/pages/index/index'</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app.js 文件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否由分享进入小程序</span></span><br><span class="line">    <span class="keyword">if</span> (options.scene == <span class="number">1007</span> || options.scene == <span class="number">1008</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.globalData.share = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.globalData.share = <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//获取设备顶部窗口的高度（不同设备窗口高度不一样，根据这个来设置自定义导航栏的高度）</span></span><br><span class="line">    <span class="comment">//这个最初我是在组件中获取，但是出现了一个问题，当第一次进入小程序时导航栏会把</span></span><br><span class="line">    <span class="comment">//页面内容盖住一部分,当打开调试重新进入时就没有问题，这个问题弄得我是莫名其妙</span></span><br><span class="line">    <span class="comment">//虽然最后解决了，但是花费了不少时间</span></span><br><span class="line">    wx.getSystemInfo(&#123;</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.globalData.height = res.statusBarHeight</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  globalData: &#123;</span><br><span class="line">    share: <span class="literal">false</span>,  <span class="comment">// 分享默认为false</span></span><br><span class="line">    height: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app.wxss文件:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**app.wxss**/</span></span><br><span class="line"><span class="selector-tag">pages</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">9999998</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用自定义导航栏：<br>文件目录图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8198580-e0ae0f716b3677e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300/format/webp" alt="img"></p>
<p>文件目录图</p>
<p>在微信小程序页面中：<br>pages文件夹index.wxml文件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入自定义组价。'navbar-data'中navbar是自定义名字，决定了组件中'navbarData'的名字</span></span><br><span class="line">&lt;nav-bar navbar-data=<span class="string">'&#123;&#123;nvabarData&#125;&#125;'</span>&gt;&lt;<span class="regexp">/nav-bar&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;view class='home-page' style='margin-top: &#123;&#123;height&#125;&#125;px'&gt;</span></span><br><span class="line"><span class="regexp">  home page</span></span><br><span class="line"><span class="regexp">&lt;/</span>view&gt;</span><br></pre></td></tr></table></figure>

<p>pages文件夹index.json文件中(声明使用的组件，和组件的地址)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"nav-bar"</span>: <span class="string">"/commpents/navbar/index"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pages文件夹index.js文件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="keyword">data</span>: &#123;</span><br><span class="line">  <span class="comment">// 组件所需的参数</span></span><br><span class="line">    nvabarData: &#123;</span><br><span class="line">      showCapsule: <span class="number">1</span>, <span class="comment">//是否显示左上角图标   1表示显示    0表示不显示</span></span><br><span class="line">      title: <span class="string">'我的主页'</span>, <span class="comment">//导航栏 中间的标题</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此页面 页面内容距最顶部的距离</span></span><br><span class="line">    height: app.globalData.height * <span class="number">2</span> + <span class="number">20</span> ,   </span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.<span class="keyword">data</span>.height)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>pages文件夹index.wxss文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**index.wxss**/</span></span><br><span class="line"><span class="selector-class">.home-page</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1</span>rpx solid red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">60</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由自定义组件引发的一些问题，1.下拉刷新：当页面内容高度不够屏幕高度时，ios的下拉刷新将会出现—-拉下来，上不去了，也是偶尔出现。解决方法就是页面设置个最小高度，精准一点就是页面的高度 + 下拉刷新时顶部内容距离顶部的高度。</p>
<p>参考链接：<a href="https://www.jianshu.com/p/7393c800ba09" target="_blank" rel="noopener">https://www.jianshu.com/p/7393c800ba09</a></p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发随笔（一）</title>
    <url>/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“..&#x2F;”代表当前文件所在目录的上一级目录。</span><br><span class="line"></span><br><span class="line">“..&#x2F;..&#x2F;”代表当前文件所在目录的上上级目录。</span><br><span class="line"></span><br><span class="line">“..&#x2F;..&#x2F;..&#x2F;”可以依次类推。</span><br><span class="line"></span><br><span class="line">“&#x2F;”代表根目录。</span><br><span class="line"></span><br><span class="line">“.&#x2F;”表示当前目录，HTML中，可以省略。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="给对象属性赋值，增加属性"><a href="#给对象属性赋值，增加属性" class="headerlink" title="给对象属性赋值，增加属性"></a>给对象属性赋值，增加属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  tel: &#39;15184138787&#39;,</span><br><span class="line">  list: &#123;</span><br><span class="line">   title: &#39;我是标题哦&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">需求：更改list里title的值</span><br><span class="line"> let  value &#x3D; &#39;list.title&#39;; &#x2F;&#x2F; 注意这里哈</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    [value]: &#39;我是新标题&#39;</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line">需求：list新增动态属性值</span><br><span class="line"> let  value &#x3D; &#96;list.$&#123;name&#125;&#96; &#x2F;&#x2F; 这里的name是动态的哈，可以是1，2，3，4.... 任意值</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    [value]: &#39;我是新属性&#39;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>



<h3 id="页面栈（带参数返回上一个页面）"><a href="#页面栈（带参数返回上一个页面）" class="headerlink" title="页面栈（带参数返回上一个页面）"></a>页面栈（带参数返回上一个页面）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组中第一个元素为首页，最后一个元素为当前页面。</span><br><span class="line"></span><br><span class="line">***注意：</span><br><span class="line">不要尝试修改页面栈，会导致路由以及页面状态错误。</span><br><span class="line">不要在 App.onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。</span><br><span class="line"></span><br><span class="line">按照这个逻辑 pages[pages.length - 1] 我们拿到的就是当前页</span><br><span class="line">pages[pages.length - 2] 我们拿到的是上一页</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取上一个页面的this</span><br><span class="line">let pages &#x3D; getCurrentPages()</span><br><span class="line">var prevPage &#x3D; pages[pages.length - 2]</span><br><span class="line">&#x2F;&#x2F;给上一个的data设置一个想要传递的参数</span><br><span class="line">prevPage.setData(&#123;</span><br><span class="line">xxxx: 1,</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;然后我们在上一个页面的onshow 里面就可以拿到这个值</span><br></pre></td></tr></table></figure>





<h3 id="通过id直接调用组件内部方法"><a href="#通过id直接调用组件内部方法" class="headerlink" title="通过id直接调用组件内部方法"></a>通过id直接调用组件内部方法</h3><blockquote>
<p><img src="/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/4ac158cdc9c648f2951aba06d0452f20/816184259208.png" alt="img"></p>
<p>followUs-component组件里的方法</p>
<p><img src="/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/251ac7f7360748fe8f80002cfe80af9e/816184028689.png" alt="img"></p>
<p>页面调用组件方法</p>
<p><img src="/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/Users/admin/AppData/Local/YNote/data/weixinobU7VjrjuSqZnu6-xPbfCXnjhBIM/6c63b95b03214999a9f7a0bd92a2f6b9/081618435245.png" alt="img"></p>
</blockquote>
<h3 id="禁止下拉-ios下拉空白"><a href="#禁止下拉-ios下拉空白" class="headerlink" title="禁止下拉(ios下拉空白)"></a>禁止下拉(ios下拉空白)</h3><blockquote>
<p>在微信小程序中，用力往下拉动，页面顶部会出现一段空白的地方。 产品的需求不太允许这么做，会影响用户体验，查看文档发现可以使用enablePullDownRefresh这属性来实现，在page.json里面添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;enablePullDownRefresh&quot;:false</span><br></pre></td></tr></table></figure>

<p>这样可以禁用页面下拉滚动，需要注意的是不可在全局配置 app.json中配置。经测试发现：虽然禁止了下拉刷新，但是在部分ios端仍然可以下拉出现空白。那么该如何解决呢？方法：当页面滚动的时候判断与顶部的距离，当这个距离小于0的时候，强制性拉回顶部即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onPageScroll:function(e)&#123;</span><br><span class="line">  if(e.scrollTop&lt;0)&#123;</span><br><span class="line">    wx.pageScrollTo(&#123;</span><br><span class="line">   	 scrollTop: 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="自带水平和垂直滚动事件"><a href="#自带水平和垂直滚动事件" class="headerlink" title="自带水平和垂直滚动事件"></a>自带水平和垂直滚动事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">scroll-y</span>&gt;</span>111<span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">scroll-x</span>&gt;</span>222<span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="text套text，内部text绑定点击事件失效"><a href="#text套text，内部text绑定点击事件失效" class="headerlink" title="text套text，内部text绑定点击事件失效"></a>text套text，内部text绑定点击事件失效</h3><h3 id="hover添加class事件"><a href="#hover添加class事件" class="headerlink" title="hover添加class事件"></a>hover添加class事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hover-class</span>=<span class="string">"none"</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hover-class</span>=<span class="string">"bg_red"</span>  <span class="attr">hover-stop-propagation</span>=<span class="string">"false"</span> <span class="attr">hover-start-time</span>=<span class="string">"50"</span> <span class="attr">hover-stay-time</span>=<span class="string">"400"</span> &gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">hover-stop-propagation属性并不是说完全阻止了祖先节点的被点击能力，它只是代表点击当前view的时候，它的祖先节点不会产生点击效果</span><br><span class="line">hover-start-time按住多久出现点击态</span><br><span class="line">hover-stay-time手指松开后保持点击的状态</span><br><span class="line">通常，当一个 view 组件中包含 image 等不支持 hover-class 的组件，但又需要在该组件上使用 hover-stop-propagation 属性的作用时，需要将不支持 hover-class 的组件用view、button 或 navigator 包裹起来。</span><br></pre></td></tr></table></figure>



<h3 id="使用button标签的open-type-”getUserInfo”引导用户去授权"><a href="#使用button标签的open-type-”getUserInfo”引导用户去授权" class="headerlink" title="使用button标签的open-type=”getUserInfo”引导用户去授权]"></a>使用button标签的open-type=”getUserInfo”引导用户去授权]</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">index.wxml</span><br><span class="line">&lt;button</span><br><span class="line">    wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;canIUse&#125;&#125;"</span></span><br><span class="line">    open-type=<span class="string">"getUserInfo"</span></span><br><span class="line">    bindgetuserinfo=<span class="string">"bindGetUserInfo"</span></span><br><span class="line">&gt;授权登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;view wx:else&gt;请升级微信版本&lt;/</span>view&gt;</span><br><span class="line">index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">     <span class="comment">//判断小程序的API，回调，参数，组件等是否在当前版本可用。</span></span><br><span class="line">    canIUse: wx.canIUse(<span class="string">'button.open-type.getUserInfo'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查看是否授权</span></span><br><span class="line">    wx.getSetting(&#123;</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.authSetting[<span class="string">'scope.userInfo'</span>]) &#123;</span><br><span class="line">          wx.getUserInfo(&#123;</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(res.userInfo)</span><br><span class="line">              <span class="comment">//用户已经授权过</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  bindGetUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.detail.userInfo)</span><br><span class="line">    <span class="keyword">if</span> (e.detail.userInfo)&#123;</span><br><span class="line">      <span class="comment">//用户按了允许授权按钮</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//用户按了拒绝按钮</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="页面跳转方法总结"><a href="#页面跳转方法总结" class="headerlink" title="页面跳转方法总结"></a>页面跳转方法总结</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wx.navigateBack返回上上个页面。</span></span><br><span class="line">wx.navigateBack(&#123;</span><br><span class="line">  delta: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//携带参数</span></span><br><span class="line"><span class="keyword">const</span> pages = getCurrentPages()</span><br><span class="line"><span class="keyword">const</span> prevPage = pages[pages.length<span class="number">-2</span>] <span class="comment">// 上一页</span></span><br><span class="line"><span class="comment">// 调用上一个页面的setData 方法，将数据存储</span></span><br><span class="line">prevPage.setData(&#123;</span><br><span class="line">    testdata: <span class="number">12456</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。</span></span><br><span class="line"><span class="comment">// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈</span></span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">'page/detail/detail?product_id=222'</span>　　<span class="comment">// 页面 </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭当前页面，跳转到应用内的某个页面。</span></span><br><span class="line">wx.redirectTo(&#123;</span><br><span class="line">  url: <span class="string">'page/home/home?user_id=111'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到tabBar页面（在app.json中注册过的tabBar页面），同时关闭其他非tabBar页面。</span></span><br><span class="line">wx.switchTab(&#123;</span><br><span class="line">  url: <span class="string">'page/index/index'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭所有页面，打开到应用内的某个页面。</span></span><br><span class="line">wx.reLanch(&#123;</span><br><span class="line">  url: <span class="string">'page/home/home?user_id=111'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="wxml-页面组件跳转（可以通过设置open-type属性指明页面跳转方式）："><a href="#wxml-页面组件跳转（可以通过设置open-type属性指明页面跳转方式）：" class="headerlink" title="wxml 页面组件跳转（可以通过设置open-type属性指明页面跳转方式）："></a>wxml 页面组件跳转（可以通过设置open-type属性指明页面跳转方式）：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// navigator 组件默认的 open-type 为 navigate </span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"/page/navigate/navigate?title=navigate"</span> <span class="attr">hover-class</span>=<span class="string">"navigator-hover"</span>&gt;</span>跳转到新页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// redirect 对应 API 中的 wx.redirect 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"../../redirect/redirect/redirect?title=redirect"</span> <span class="attr">open-type</span>=<span class="string">"redirect"</span> <span class="attr">hover-class</span>=<span class="string">"other-navigator-hover"</span>&gt;</span>在当前页打开<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// switchTab 对应 API 中的 wx.switchTab 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"/page/index/index"</span> <span class="attr">open-type</span>=<span class="string">"switchTab"</span> <span class="attr">hover-class</span>=<span class="string">"other-navigator-hover"</span>&gt;</span>切换 Tab<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// reLanch 对应 API 中的 wx.reLanch 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"../../redirect/redirect/redirect?title=redirect"</span> <span class="attr">open-type</span>=<span class="string">"redirect"</span> <span class="attr">hover-class</span>=<span class="string">"other-navigator-hover"</span>&gt;</span>关闭所有页面，打开到应用内的某个页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// navigateBack 对应 API 中的 wx.navigateBack 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"/page/index/index"</span> <span class="attr">open-type</span>=<span class="string">"navigateBack"</span> <span class="attr">hover-class</span>=<span class="string">"other-navigator-hover"</span>&gt;</span>关闭当前页面，返回上一级页面或多级页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="离开页面清除定时器"><a href="#离开页面清除定时器" class="headerlink" title="离开页面清除定时器"></a>离开页面清除定时器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//离开页面清除</span></span><br><span class="line">onUnload: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.data.start_timer);</span><br><span class="line">&#125;,</span><br><span class="line">onHide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.data.start_timer);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒计时</span></span><br><span class="line">setCountDown: <span class="function"><span class="keyword">function</span> (<span class="params">Time = <span class="string">'2020-07-28 16:25:00'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Time = <span class="keyword">this</span>.data.paytime;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.paytime,<span class="string">'paytime'</span>);</span><br><span class="line">  <span class="keyword">var</span> setTime = <span class="number">0.5</span> * <span class="number">3600</span> * <span class="number">1000</span>;<span class="comment">//半个小时的毫秒数</span></span><br><span class="line">  <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();<span class="comment">//现在时间（时间戳）</span></span><br><span class="line">  <span class="keyword">var</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>().setTime(<span class="keyword">new</span> <span class="built_in">Date</span>(Time).getTime() + setTime);<span class="comment">//距离参数半个小时后的时间</span></span><br><span class="line">  <span class="keyword">var</span> intDiff = (endTime - nowTime) / <span class="number">1000</span>;<span class="comment">//毫秒数差</span></span><br><span class="line">  <span class="keyword">var</span> day = <span class="number">0</span>,</span><br><span class="line">    hour = <span class="number">24</span>,</span><br><span class="line">    minute = <span class="number">60</span>,</span><br><span class="line">    second = <span class="number">60</span>;<span class="comment">//时间默认值</span></span><br><span class="line">  <span class="keyword">if</span> (intDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    day = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line">    hour = <span class="built_in">Math</span>.floor(intDiff / (<span class="number">60</span> * <span class="number">60</span>)) - (day * <span class="number">24</span>);</span><br><span class="line">    minute = <span class="built_in">Math</span>.floor(intDiff / <span class="number">60</span>) - (day * <span class="number">24</span> * <span class="number">60</span>) - (hour * <span class="number">60</span>);</span><br><span class="line">    second = <span class="built_in">Math</span>.floor(intDiff) - (day * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) - (hour * <span class="number">60</span> * <span class="number">60</span>) - (minute * <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (hour &lt;= <span class="number">9</span>) hour = <span class="string">'0'</span> + hour;</span><br><span class="line">    <span class="keyword">if</span> (minute &lt;= <span class="number">9</span>) minute = <span class="string">'0'</span> + minute;</span><br><span class="line">    <span class="keyword">if</span> (second &lt;= <span class="number">9</span>) second = <span class="string">'0'</span> + second;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      showTime: hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      showTime: <span class="string">'00:00:00'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    start_timer: setTimeout(<span class="keyword">this</span>.setCountDown, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h3 id="ios页面回弹"><a href="#ios页面回弹" class="headerlink" title="ios页面回弹"></a>ios页面回弹</h3><p>给page加一个border-bottom就可，也要给一定的padding-bottom</p>
<h3 id="wx-if和hidden"><a href="#wx-if和hidden" class="headerlink" title="wx:if和hidden"></a>wx:if和hidden</h3><p>wx:if条件为true显示，hidden条件为false显示</p>
<h3 id="微信小程序“对应的服务器证书无效”"><a href="#微信小程序“对应的服务器证书无效”" class="headerlink" title="微信小程序“对应的服务器证书无效”"></a>微信小程序“对应的服务器证书无效”</h3><p><img src="/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94%EF%BC%88%E4%B8%80%EF%BC%89/image-20200927102756626.png" alt="image-20200927102756626"></p>
<p>到腾讯云上，SSL证书管理，可以申请一个免费的证书，申请好了放到nginx配置中，验证可以通过。</p>
<h3 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h3><p>对于用户来说，小程序加载流程变成了：</p>
<p>1.首次启动时，先下载小程序主包，显示主包内的页面；</p>
<p>2.如果用户进入了某个分包的页面，再下载这个对应分包，下载完毕后，显示分包的页面。</p>
<p>采用分包加载，对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务；而对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能</p>
<p><strong>attention：</strong></p>
<p>1.无法在首页面或tabbar页面打开分包中的页面，必须先链接到非首页面或tabbar页面，再进行跳转到分包中的页面。</p>
<p>2.每个页面的js文件必须初始化page({})。</p>
<p>3.避免分包与分包之间引用上的耦合。因为分包的加载是由用户操作触发的，并不能确保某分包加载时，另外一个分包就一定存在，这个时候可能会导致 JS 逻辑异常的情况，例如报「”xxx.js” is not defined」这样的错误；</p>
<p>4.一些公共用到的自定义组件，需要放在主包内。</p>
<p>5.整个小程序所有分包大小不超过 4M</p>
<p>6.单个分包/主包大小不能超过 2M</p>
<p>7.微信 6.6.0 版本开始支持分包加载，而对于低于这个版本的客户端，我们做了兼容处理，开发者不需要对老版本微信客户端做兼容。</p>
<p>对于老版本的客户端，编译后台会将所有的分包打包成一个整包，老版本的客户端依然按照整包的方式进行加载。</p>
<p><strong>how:</strong></p>
<p>当理清了分包的划分后，就可以进行分包的配置了，这一步并不复杂。</p>
<p>假设支持分包的小程序目录结构如下：</p>
<p><img src="https://img-blog.csdn.net/20180422115731135" alt="img"></p>
<p>开发者通过在 app.json<code>subPackages</code>字段声明项目分包结构：</p>
<p><img src="https://img-blog.csdn.net/20180422115740142" alt="img"></p>
<h3 id="添加到我的小程序"><a href="#添加到我的小程序" class="headerlink" title="添加到我的小程序"></a>添加到我的小程序</h3><p>当用户进入小程序后，</p>
<p>能否判断用户是否将当前小程序添加到我的小程序中-否</p>
<p>能否通过js操作将当前小程序添加到我的小程序中-否</p>
<h3 id="AppID、AppKey、AppSecret"><a href="#AppID、AppKey、AppSecret" class="headerlink" title="AppID、AppKey、AppSecret"></a>AppID、AppKey、AppSecret</h3><p>AppID：应用的唯一标识（是用来标记你的开发者账号的）<br>AppKey：公匙（相当于账号）<br>AppSecret：私匙（相当于密码）</p>
<p>token：令牌（过期失效）</p>
<p>使用方法</p>
<p>\1. 向第三方服务器请求授权时，带上AppKey和AppSecret（需存在服务器端）</p>
<p>\2. 第三方服务器验证AppKey和AppSecret在DB中有无记录</p>
<p>\3. 如果有，生成一串唯一的字符串（token令牌），返回给服务器，服务器再返回给客户端</p>
<p>\4. 客户端下次请求敏感数据时带上令牌</p>
<p>关于第一点，可以采用签名的方式发送，当应用服务端向第三方服务端发请求时，带上AppKey、时间戳、随机数、签名，签名可以使用 AppSecret + 时间戳 + 随机数使用sha1生成，第三方服务端收到后，生成本地签名和收到的签名比对，如果一致，校验成功</p>
<h3 id="常见open-type"><a href="#常见open-type" class="headerlink" title="常见open-type"></a>常见open-type</h3><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">contact</td>
<td align="left">打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/customer-message/customer-message.html" target="_blank" rel="noopener">具体说明</a></td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.1.0</a></td>
</tr>
<tr>
<td align="left">share</td>
<td align="left">触发用户转发，使用前建议先阅读<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html#使用指引" target="_blank" rel="noopener">使用指引</a></td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.2.0</a></td>
</tr>
<tr>
<td align="left">getPhoneNumber</td>
<td align="left">获取用户手机号，可以从bindgetphonenumber回调中获取到用户信息，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html" target="_blank" rel="noopener">具体说明</a></td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.2.0</a></td>
</tr>
<tr>
<td align="left">getUserInfo</td>
<td align="left">获取用户信息，可以从bindgetuserinfo回调中获取到用户信息</td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.3.0</a></td>
</tr>
<tr>
<td align="left">launchApp</td>
<td align="left">打开APP，可以通过app-parameter属性设定向APP传的参数<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html" target="_blank" rel="noopener">具体说明</a></td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.9.5</a></td>
</tr>
<tr>
<td align="left">openSetting</td>
<td align="left">打开授权设置页</td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">2.0.7</a></td>
</tr>
<tr>
<td align="left">feedback</td>
<td align="left">打开“意见反馈”页面，用户可提交反馈内容并上传<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getLogManager.html" target="_blank" rel="noopener">日志</a>，开发者可以登录<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">小程序管理后台</a>后进入左侧菜单“客服反馈”页面获取到反馈内容</td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">2.1.0</a></td>
</tr>
</tbody></table>
<h3 id="公众号组件official-account"><a href="#公众号组件official-account" class="headerlink" title="公众号组件official-account"></a>公众号组件official-account</h3><p>tips:</p>
<ol>
<li>使用组件前，需前往小程序后台，在“设置”-&gt;“关注公众号”中设置要展示的公众号。<strong>注：设置的公众号需与小程序主体一致。</strong></li>
<li>在一个小程序的生命周期内，只有从以下场景进入小程序，才具有展示引导关注公众号组件的能力:<ul>
<li>当小程序从扫小程序码场景（场景值1047，场景值1124）打开时</li>
<li>当小程序从聊天顶部场景（场景值1089）中的「最近使用」内打开时，若小程序之前未被销毁，则该组件保持上一次打开小程序时的状态</li>
<li>当从其他小程序返回小程序（场景值1038）时，若小程序之前未被销毁，则该组件保持上一次打开小程序时的状态</li>
</ul>
</li>
<li>为便于开发者调试，基础库 <code>2.7.3</code> 版本起开发版小程序增加以下场景展示公众号组件：<ul>
<li>开发版小程序从扫二维码（场景值 1011）打开 — 体验版小程序打开</li>
</ul>
</li>
<li>组件限定最小宽度为300px，高度为定值84px。</li>
<li>每个页面只能配置一个该组件。</li>
<li>可改变宽度</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">official-account</span> <span class="attr">stlye</span>=<span class="string">"width:200px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">official-account</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="获取unionId"><a href="#获取unionId" class="headerlink" title="获取unionId"></a>获取unionId</h3><p>一个微信开放平台下的相同主体的App、公众号、小程序的unionid是相同的，这样就可以锁定是不是同一个用户</p>
<p>微信针对不同的用户在不同的应用下都有唯一的一个openId, 但是要想确定用户是不是同一个用户，就需要靠unionid来区分</p>
<p>同一个微信开放平台下的相同主体的 App、公众号、小程序，如果用户已经关注公众号，或者曾经登录过App或公众号，则用户打开小程序时，开发者可以直接通过 wx.login 获取到该用户UnionID，无须用户再次授权<br> （解读：用户如果没有登录过app，也没有登录过公众号，也没有关注过公众号的情况下，小程序中通过 wx.login 是获取不到 unionid的）</p>
<p>UnionID获取途径</p>
<ul>
<li>调用接口wx.getUserInfo，从解密数据中获取UnionID。注意本接口需要用户授权，请开发者妥善处理用户拒绝授权后的情况。</li>
<li>如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过wx.login获取到该用户UnionID，无须用户再次授权</li>
</ul>
<p><strong>重点</strong></p>
<p>所有就有两种情况:</p>
<ol>
<li><p>一般情况，用户登录过关联的其他公众号</p>
<p>使用 wx.login 获取code，传到后端，code换openid，unionId</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.login</span></span><br><span class="line">wx.login(&#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: openIdUrl,<span class="comment">//后端接口</span></span><br><span class="line">      data: &#123;</span><br><span class="line">        code: data.code</span><br><span class="line">      &#125;,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        self.globalData.openid = res.data.openid</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'拉取用户openid失败，将无法正常使用开放接口等服务'</span>, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br><span class="line">  &#125;,</span><br><span class="line">  fail: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wx.login 接口调用失败，将无法正常使用开放接口等服务'</span>, err)</span><br><span class="line">    callback(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户没有用过关联的公众号等</p>
<p>这时候 wx.login 就获取不到 unionId 了。需要使用 wx.getUserInfo</p>
<p>解决思路：通过带登录态的 wx.getUserInfo 获取到用户的加密数据 encryptedData 和加密算法的初始向量iv，然后将 encryptdata、iv 以及 code传给后端，后端再去通过接收到的encryptedData、iv以、code 以及之前的 session_key 解密出用户的 openid、unionid 等</p>
</li>
</ol>
   <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">wx.getUserInfo(&#123;</span><br><span class="line">  withCredentials:<span class="literal">false</span>,</span><br><span class="line">  success:<span class="function">(<span class="params">obj</span>)=&gt;</span>&#123;</span><br><span class="line">   </span><br><span class="line">      wx.request(&#123;</span><br><span class="line">          url: openIdUrl,<span class="comment">//后端接口</span></span><br><span class="line">          data: &#123;</span><br><span class="line">              code: data.code,</span><br><span class="line">              encryptedData : obj.encryptedData,</span><br><span class="line">              iv : obj.iv,</span><br><span class="line">          &#125;,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">              self.globalData.openid = res.data.openid</span><br><span class="line">          &#125;,</span><br><span class="line">          fail: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'拉取用户openid失败，将无法正常使用开放接口等服务'</span>, res)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>实际项目中，需要将两种情况整合使用</p>
<p>两种方案：</p>
<p>第一种：（ 前端判断是否有 unionid ）wx.login 向后端上传 code 并且后端返回数据以后，前端判断返回值中是否有 unionid 或者 unionid 是否为 null，null 的情况下去调用带有用户登录态的wx.getUserInfo()，然后再将微信返回的  encryptedData 和 iv 返回给后端，后端解密出相应的信息后再返回给前端；</p>
<p>第二种：（ 后端判断是否有 unionid ）前端调用 wx.login(), wx.getUserInfo() ,把 code,encryptedData 和 iv 返回给后端，后端在拿到前端 code 之后去请求微信的接口拿 unionid，如果返回的 unionid 为空，再用的 encryptedData、iv以及之前的 session_key 解密出 unionid，后端解密出相应的信息后再返回给前端</p>
]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序文字展开收起</title>
    <url>/2020/08/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%87%E5%AD%97%E5%B1%95%E5%BC%80%E6%94%B6%E8%B5%B7/</url>
    <content><![CDATA[<p>微信小程序开发中想要如h5一样获取元素的宽高值进行业务的功能实现，一开始不知道怎么实现，翻看文档发现，微信官方提供了一个非常好的东西</p>
<h1 id="SelectorQuery"><a href="#SelectorQuery" class="headerlink" title="SelectorQuery"></a><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fwxml%2FSelectorQuery.html" target="_blank" rel="noopener">SelectorQuery</a></h1><h3 id="wx-createSelectorQuery"><a href="#wx-createSelectorQuery" class="headerlink" title="wx.createSelectorQuery()"></a>wx.createSelectorQuery()</h3><p>示例代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = wx.createSelectorQuery()</span><br><span class="line">query.select(<span class="string">'#the-id'</span>).boundingClientRect()</span><br><span class="line">query.selectViewport().scrollOffset()</span><br><span class="line">query.exec(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  res[<span class="number">0</span>].top       <span class="comment">// #the-id节点的上边界坐标</span></span><br><span class="line">  res[<span class="number">1</span>].scrollTop <span class="comment">// 显示区域的竖直滚动位置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>1.如果高度要px单位的话：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> query = wx.createSelectorQuery();</span><br><span class="line">query.select(<span class="string">'.content'</span>).boundingClientRect(<span class="function"><span class="params">rect</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> height = rect.height;</span><br><span class="line">  <span class="built_in">console</span>.log(height);</span><br><span class="line">&#125;).exec();</span><br></pre></td></tr></table></figure>

<p>2.如果高度要rpx单位的话，那么可以用宽高比换算获得：（以下的750是该元素的宽度，单位是rpx的）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> query = wx.createSelectorQuery();</span><br><span class="line">query.select(<span class="string">'.content'</span>).boundingClientRect(<span class="function"><span class="params">rect</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clientHeight = rect.height;</span><br><span class="line">  <span class="keyword">let</span> clientWidth = rect.width;</span><br><span class="line">  <span class="keyword">let</span> ratio = <span class="number">750</span> / clientWidth;</span><br><span class="line">  <span class="keyword">let</span> height = clientHeight * ratio;</span><br><span class="line">  <span class="built_in">console</span>.log(height);</span><br><span class="line">&#125;).exec();</span><br></pre></td></tr></table></figure>



<p>3.在页面渲染完成OnReady回调 获取元素高度时，如果不加定时器，获取的元素的高度还是没渲染完异步数据前的高度。故需要加定时器</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">onReady () &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> query = wx.createSelectorQuery();</span><br><span class="line">    query.select(<span class="string">'.content'</span>).boundingClientRect(<span class="function"><span class="params">rect</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> height = rect.height;</span><br><span class="line">        <span class="built_in">console</span>.log(height);</span><br><span class="line">        &#125;).exec();</span><br><span class="line">    &#125;, <span class="number">300</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实例记录</p>
<p>1.WXML</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;view <span class="keyword">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">  &lt;view <span class="keyword">class</span>=<span class="string">'list-box'</span>&gt;</span><br><span class="line">    &lt;view <span class="keyword">class</span>=<span class="string">'list'</span> wx:<span class="keyword">for</span>=<span class="string">"&#123;list&#125;"</span> wx:key=<span class="string">"index"</span>&gt;</span><br><span class="line">        &lt;text <span class="keyword">class</span>=<span class="string">"text &#123;item.collapse?'text-collapse':''&#125;"</span>&gt;&#123;item.text&#125;&lt;/text&gt;</span><br><span class="line">        &lt;text bindtap=<span class="string">"changeCollapse"</span> data-index=<span class="string">"&#123;index&#125;"</span> wx:<span class="keyword">if</span>=<span class="string">"&#123;item.showCollapse&#125;"</span> <span class="keyword">class</span>=<span class="string">'coll-p'</span>&gt;&#123;item.collapse?<span class="string">'全文'</span>:<span class="string">'收起'</span>&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>



<p>2.JS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: [&#123;</span><br><span class="line">                text: &#39;文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                text: &#39;文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                text: &#39;文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章文章&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    onShow: function()&#123;</span><br><span class="line">        this.setCollapse()</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;判断全文收起是否展示</span><br><span class="line">    setCollapse: function() &#123;</span><br><span class="line">        var query &#x3D; wx.createSelectorQuery();</span><br><span class="line">        var that &#x3D; this;</span><br><span class="line">        query.selectAll(&#39;.text&#39;).boundingClientRect(function (rect) &#123;</span><br><span class="line">            rect.forEach((v, i) &#x3D;&gt; &#123;</span><br><span class="line">                if (v.height &gt; 45) &#123;  &#x2F;&#x2F;判断高度,根据各种高度取折中</span><br><span class="line">                    var set &#x3D; &quot;list[&quot; + i + &quot;].collapse&quot;;</span><br><span class="line">                    var set1 &#x3D; &quot;list[&quot; + i + &quot;].showCollapse&quot;;</span><br><span class="line">                    that.setData(&#123;</span><br><span class="line">                        [set]: true,</span><br><span class="line">                        [set1]: true,</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).exec();</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;点击全文收起</span><br><span class="line">    changeCollapse: function(e)&#123;</span><br><span class="line">        var index &#x3D; e.currentTarget.dataset.index;</span><br><span class="line">        var set &#x3D; &quot;list[&quot; + index + &quot;].collapse&quot;;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">            [set]: !this.data.list[index].collapse</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>3.WXSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-box</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">30</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-box</span> <span class="selector-class">.list</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1</span>rpx solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30</span>rpx <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-box</span> <span class="selector-class">.list</span> <span class="selector-tag">text</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">28</span>rpx;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40</span>rpx;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-box</span> <span class="selector-class">.list</span> <span class="selector-tag">text</span><span class="selector-class">.text-collapse</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:-webkit-box;</span><br><span class="line">    <span class="attribute">-webkit-box-orient</span>:vertical; </span><br><span class="line">    <span class="attribute">-webkit-line-clamp</span>:<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-box</span> <span class="selector-class">.coll-p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30</span>rpx;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#5064A3</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>本地文件夹上传github</title>
    <url>/2020/09/22/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0github/</url>
    <content><![CDATA[<p>首先你需要一个github账号，所有还没有的话先去注册吧！</p>
<p><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
<p>我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可：</p>
<p><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">https://git-for-windows.github.io/</a></p>
<p>1.进入Github首页，点击New repository新建一个项目</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823164154526-418441991.png" alt="img"></p>
<a id="more"></a>

<p> 2.填写相应信息后点击create即可 </p>
<p>Repository name: 仓库名称</p>
<p>Description(可选): 仓库描述介绍</p>
<p>Public, Private : 仓库权限（公开共享，私有或指定合作者）</p>
<p>Initialize this repository with a README: 添加一个README.md</p>
<p>gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore</p>
<p>license: 证书类型，对应生成文件LICENSE</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823165025370-49444506.png" alt="img"></p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823165107308-439926006.png" alt="img"></p>
<p>4.点击Clone or dowload会出现一个地址，copy这个地址备用。</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823165450636-1167722003.png" alt="img"></p>
<p>5.接下来就到本地操作了，首先右键你的项目，如果你之前安装git成功的话，右键会出现两个新选项，分别为Git Gui Here,Git Bash Here,这里我们选择Git Bash Here，进入如下界面，Test_Bluetooth即为我的项目名。</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171048308-194895299.png" alt="img"></p>
<p>6.接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地</p>
<p>git clone <a href="https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址）" target="_blank" rel="noopener">https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址）</a></p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171143980-741152042.png" alt="img"></p>
<p> 7.这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个Test文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下，</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171209730-2089496483.png" alt="img"></p>
<p>8.接着继续输入命令 cd Test，进入Test文件夹</p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171454261-10363777.png" alt="img"></p>
<p>9.接下来依次输入以下代码即可完成其他剩余操作：</p>
<p>git add .     （注：别忘记后面的.，空格之后再输入.  此操作是把Test文件夹下面的文件都添加进来）</p>
<p>git commit  -m  “提交信息”  （注：“提交信息”里面换成你需要，如“first commit”）</p>
<p>git push -u origin master  （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）</p>
<p> <img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171557823-3863512.png" alt="img"></p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171651808-1225335136.png" alt="img"></p>
<p><img src="http://images2015.cnblogs.com/blog/913913/201608/913913-20160823171818933-1506815566.png" alt="img"></p>
<p>输入你Github的用户名 和密码：</p>
<p><img src="https://img-blog.csdn.net/20160118172619673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20160118172535690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>上传文件夹</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序登陆</title>
    <url>/2020/07/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h3 id="小程序获取授权，得到用户的昵称头像"><a href="#小程序获取授权，得到用户的昵称头像" class="headerlink" title="小程序获取授权，得到用户的昵称头像"></a>小程序获取授权，得到用户的昵称头像</h3><h5 id="使用button标签的open-type-”getUserInfo”引导用户去授权"><a href="#使用button标签的open-type-”getUserInfo”引导用户去授权" class="headerlink" title="使用button标签的open-type=”getUserInfo”引导用户去授权"></a>使用button标签的open-type=”getUserInfo”引导用户去授权</h5><h4 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"userinfo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">"&#123;!hasUserInfo &amp;&amp; canIUse&#125;"</span> <span class="attr">open-type</span>=<span class="string">"getUserInfo"</span> <span class="attr">bindgetuserinfo</span>=<span class="string">"getUserInfo"</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">bindtap</span>=<span class="string">"bindViewTap"</span> <span class="attr">class</span>=<span class="string">"userinfo-avatar"</span> <span class="attr">src</span>=<span class="string">"&#123;userInfo.avatarUrl&#125;"</span> <span class="attr">mode</span>=<span class="string">"cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"userinfo-nickname"</span>&gt;</span>&#123;userInfo.nickName&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: <span class="string">'Hello World'</span>,</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//判断小程序的API，回调，参数，组件等是否在当前版本可用。</span></span><br><span class="line">    canIUse: wx.canIUse(<span class="string">'button.open-type.getUserInfo'</span>),</span><br><span class="line">    value: <span class="number">3.6</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: <span class="string">'../logs/logs'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line">      <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">      <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">      app.userInfoReadyCallback = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>soft</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式原理分析</title>
    <url>/2020/07/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="十分钟学会正则"><a href="#十分钟学会正则" class="headerlink" title="十分钟学会正则"></a>十分钟学会正则</h3><h5 id="一-限定符"><a href="#一-限定符" class="headerlink" title="(一)限定符"></a>(一)限定符</h5><p>1、<code>?</code>:它前面的字符需要出现0次或1次</p>
<blockquote>
<p>例如：<code>used?</code>可以匹配到<code>use</code>和<code>used</code></p>
</blockquote>
<p>2、<code>*</code>:它会匹配0个或多个字符</p>
<blockquote>
<p>例如：<code>ab*c</code>可以匹配到<code>ac</code>,<code>abc</code>,<code>abbbbbbc</code></p>
</blockquote>
<p>3、<code>+</code>:它会匹配一次及以上的字符</p>
<blockquote>
<p>例如：<code>ab+c</code>可以匹配<code>abc</code>,<code>abbbc</code>,而不会匹配<code>ac</code></p>
</blockquote>
<p>4、<code>{}</code>:可以限定匹配的数量</p>
<blockquote>
<p>例如：<code>ab{6}c</code>,则匹配到<code>abbbbbbc</code>,而要限定<code>b</code>的数量在2到6之间，则是<code>ab{2,6}c</code>，如果只是两次以上，则省略括号里的6，写成<code>ab{2,}c</code></p>
</blockquote>
<h5 id="二-”或”运算符"><a href="#二-”或”运算符" class="headerlink" title="(二)”或”运算符"></a>(二)”或”运算符</h5><blockquote>
<p>例如：<code>a (cat|dog)</code>匹配的是<code>a cat</code>和<code>a dog</code></p>
</blockquote>
<h5 id="三-字符类"><a href="#三-字符类" class="headerlink" title="(三)字符类"></a>(三)字符类</h5><p><code>[]</code>:表示里面的内容只能取自于它们</p>
<blockquote>
<p>例如：<code>[a-z]</code>表示所有小写的英文字母，<code>[abc]</code>能匹配到<code>abc</code>,<code>aabbcc</code>,<code>abcc</code>,<code>[a-zA-Z]</code>表示所有的英文字母，如果在<code>[]</code>前加上<code>^</code>,表示<code>[]</code>之外的字符</p>
</blockquote>
<h5 id="四-元字符"><a href="#四-元字符" class="headerlink" title="(四)元字符"></a>(四)元字符</h5><p><code>\d</code>:数字字符，等同于<code>[0-9]</code><br><code>\w</code>:单词字符<br><code>\s</code>:空白符，包含Tab和换行符<br><code>\D</code>:非数字字符<br><code>\W</code>:非单词字符<br><code>\S</code>:非空白符<br><code>.</code>:代表任意字符，不包含换行符<br><code>^</code>:匹配行首</p>
<blockquote>
<p>例如：<code>^a</code>匹配<code>abv</code>,<code>acccn</code></p>
</blockquote>
<p><code>$</code>:匹配行尾</p>
<blockquote>
<p>例如：<code>a$</code>匹配<code>tea</code>,<code>cba</code></p>
</blockquote>
<h5 id="五-贪婪与懒惰匹配"><a href="#五-贪婪与懒惰匹配" class="headerlink" title="(五)贪婪与懒惰匹配"></a>(五)贪婪与懒惰匹配</h5><blockquote>
<p><strong>贪婪匹配：</strong>正则表达式通常的行为是匹配尽可能多的字符，比如这个表达式：<code>a.*b</code>，它将会匹配最长的以<code>a</code>开始，以<code>b</code>结束的字符串，如果用它来搜索<code>aabab</code>的话，它会匹配整个字符串<code>aabab</code></p>
</blockquote>
<blockquote>
<p><strong>懒惰匹配：</strong>就是匹配尽可能少的字符，在能使整个匹配成功的前提下使用最少的重复，只要在它后面加上一个问号?即可，例如<code>a.*?b</code>匹配最短的，以<code>a</code>开始，以<code>b</code>结束的字符串，如果把它应用于<code>aabab</code>的话，它会匹配<code>aab</code>和<code>ab</code>，为什么第一个匹配是<code>aab</code>（第一到第三个字符）而不是<code>ab</code>（第二到第三个字符）？简单地说，因为正则表达式有一条比懒惰／贪婪规则优先级更高的规则，就是：最先开始的匹配拥有最高的优先权</p>
</blockquote>
<p>*在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#39;00\d&#39;可以匹配&#39;007&#39;，但无法匹配&#39;00A&#39;；</span><br><span class="line"></span><br><span class="line">- &#39;\d\d\d&#39;可以匹配&#39;010&#39;；</span><br><span class="line"></span><br><span class="line">- &#39;\w\w&#39;可以匹配&#39;js&#39;；</span><br><span class="line"></span><br><span class="line">.可以匹配任意字符，所以：</span><br><span class="line"></span><br><span class="line">- &#39;js.&#39;可以匹配&#39;jsp&#39;、&#39;jss&#39;、&#39;js!&#39;等等。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来看一个复杂的例子：\d&#123;3&#125;\s+\d&#123;3,8&#125;。</span><br><span class="line">我们来从左到右解读一下：</span><br><span class="line">1. \d&#123;3&#125;表示匹配3个数字，例如&#39;010&#39;；</span><br><span class="line"></span><br><span class="line">2. \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配&#39; &#39;，&#39;\t\t&#39;等；</span><br><span class="line"></span><br><span class="line">3. \d&#123;3,8&#125;表示3-8个数字，例如&#39;1234567&#39;。</span><br><span class="line"></span><br><span class="line">4. \d&#123;3&#125;\-\d&#123;3,8&#125; 例如&#39;010-12345&#39; 由于&#39;-&#39;是特殊字符，在正则表达式中，要用&#39;\&#39;转义</span><br></pre></td></tr></table></figure>



<p>但是，仍然无法匹配’010 - 12345’，因为带有空格。所以我们需要更复杂的匹配方式。</p>
<p>进阶</p>
<p>要做更精确地匹配，可以用[]表示范围，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；</span><br><span class="line"></span><br><span class="line">- [0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如&#39;a100&#39;，&#39;0_Z&#39;，&#39;js2015&#39;等等；</span><br><span class="line"></span><br><span class="line">- [a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；</span><br><span class="line"></span><br><span class="line">- [a-zA-Z\_\$][0-9a-zA-Z\_\$]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</span><br><span class="line"></span><br><span class="line">A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配&#39;JavaScript&#39;、&#39;Javascript&#39;、&#39;javaScript&#39;或者&#39;javascript&#39;。</span><br><span class="line"></span><br><span class="line">^表示行的开头，^\d表示必须以数字开头。</span><br><span class="line"></span><br><span class="line">$表示行的结束，\d$表示必须以数字结束。</span><br><span class="line"></span><br><span class="line">你可能注意到了，js也可以匹配&#39;jsp&#39;，但是加上^js$就变成了整行匹配，就只能匹配&#39;js&#39;了。</span><br></pre></td></tr></table></figure>



<p>RegExp</p>
<p>JavaScript有两种方式创建一个正则表达式：</p>
<p>第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp(‘正则表达式’)创建一个RegExp对象。</p>
<p>两种写法是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re1 &#x3D; &#x2F;ABC\-001&#x2F;;</span><br><span class="line"></span><br><span class="line">var re2 &#x3D; new RegExp(&#39;ABC\\-001&#39;);</span><br><span class="line"></span><br><span class="line">re1; &#x2F;&#x2F; &#x2F;ABC\-001&#x2F;</span><br><span class="line"></span><br><span class="line">re2; &#x2F;&#x2F; &#x2F;ABC\-001&#x2F;</span><br></pre></td></tr></table></figure>



<p>注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\实际上是一个\。</p>
<p>先看看如何判断正则表达式是否匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.test(&#39;010-12345&#39;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">re.test(&#39;010-1234x&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">re.test(&#39;010 12345&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>



<p>RegExp对象的test()方法用于测试给定的字符串是否符合条件。</p>
<p>切分字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</span><br><span class="line"></span><br><span class="line">&#39;a b   c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">嗯，无法识别连续的空格，用正则表达式试试：</span><br><span class="line"></span><br><span class="line">&#39;a b   c&#39;.split(&#x2F;\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">无论多少个空格都可以正常分割。加入,试试：</span><br><span class="line"></span><br><span class="line">&#39;a,b, c  d&#39;.split(&#x2F;[\s\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br><span class="line"></span><br><span class="line">再加入;试试：</span><br><span class="line"></span><br><span class="line">&#39;a,b;; c  d&#39;.split(&#x2F;[\s\,\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure>



<p>分组</p>
<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：</p>
<p>^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.exec(&#39;010-12345&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]</span><br><span class="line"></span><br><span class="line">re.exec(&#39;010 12345&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>



<p>如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。</p>
<p>exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p>
<p>exec()方法在匹配失败时返回null。</p>
<p>提取子串非常有用。来看一个更凶残的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.exec(&#39;19:05:30&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;19:05:30&#39;, &#39;19&#39;, &#39;05&#39;, &#39;30&#39;]</span><br></pre></td></tr></table></figure>



<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$&#x2F;;</span><br></pre></td></tr></table></figure>



<p>对于’2-30’，’4-31’这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<p>贪婪匹配</p>
<p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d+)(0*)$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.exec(&#39;102300&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;102300&#39;, &#39;102300&#39;, &#39;&#39;]</span><br></pre></td></tr></table></figure>



<p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。</p>
<p>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d+?)(0*)$&#x2F;;</span><br><span class="line"></span><br><span class="line">re.exec(&#39;102300&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;102300&#39;, &#39;1023&#39;, &#39;00&#39;]</span><br></pre></td></tr></table></figure>



<p>全局搜索</p>
<p>JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var r1 &#x3D; &#x2F;test&#x2F;g;</span><br><span class="line"></span><br><span class="line">&#x2F;等价于:var r2 &#x3D; new RegExp(&#39;test&#39;, &#39;g&#39;);</span><br></pre></td></tr></table></figure>



<p>全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;JavaScript, VBScript, JScript and ECMAScript&#39;;</span><br><span class="line"></span><br><span class="line">var re&#x3D;&#x2F;[a-zA-Z]+Script&#x2F;g;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用全局匹配:re.exec(s); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;JavaScript&#39;]</span><br><span class="line"></span><br><span class="line">re.lastIndex; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">re.exec(s);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; [&#39;VBScript&#39;]</span><br><span class="line"></span><br><span class="line">re.lastIndex; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 20</span><br><span class="line"></span><br><span class="line">re.exec(s); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;JScript&#39;]</span><br><span class="line"></span><br><span class="line">re.lastIndex; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 29</span><br><span class="line"></span><br><span class="line">re.exec(s); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&#39;ECMAScript&#39;]</span><br><span class="line"></span><br><span class="line">re.lastIndex;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 44</span><br><span class="line"></span><br><span class="line">re.exec(s); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null，直到结束仍没有匹配到</span><br><span class="line"></span><br><span class="line">全局匹配类似搜索，因此不能使用&#x2F;^...$&#x2F;，那样只会最多匹配一次。</span><br><span class="line"></span><br><span class="line">正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。</span><br></pre></td></tr></table></figure>



<p>小结</p>
<p>正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式方法记录</title>
    <url>/2020/07/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><a id="more"></a>

<blockquote>
<ol>
<li><p>年月日</p>
<p>/^((?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)$/</p>
</li>
<li><p>时分秒</p>
<p>/[0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]/</p>
<p>/^([01]\d|2[0123]):([0-5]\d|59)$/</p>
</li>
<li><p>4-16位字母数字特殊字符</p>
<p>/^(?![^\da-zA-Z]+$).{4,16}$/</p>
</li>
<li><p>密码6-20位，只允许字母、数字、特殊字符的其中两项及以上</p>
<ul>
<li><p>能匹配的组合为：数字+字母，数字+特殊字符，字母+特殊字符，数字+字母+特殊字符组合，而且不能是纯数字，纯字母，纯特殊字符</p>
<p>^(?![\d]+$)(?![a-zA-Z]+$)(?![^\da-zA-Z]+$).{6,20}$</p>
</li>
<li><p>上面的正则里所说的特殊字符是除了数字，字母之外的所有字符 如果要限定特殊字符，例如，特殊字符的范围为 !#$%^&amp;* ，那么可以这么改</p>
<p>^(?![\d]+$)(?![a-zA-Z]+$)(?![!#$%^&amp;<em>]+$)[\da-zA-Z!#$%^&amp;</em>]{6,20}$</p>
</li>
<li><p>下面的是只包含下划线的特殊字符</p>
<p>^(?![\d]+$)(?![a-zA-Z]+$)(?![!_]+$)[\da-zA-Z!_]{6,20}$ </p>
</li>
</ul>
</li>
</ol>
</blockquote>
<ol>
<li>数字：<code>^[0-9]*$</code></li>
<li>n位的数字：<code>^\d{n}$</code></li>
<li>至少n位的数字：<code>^\d{n,}$</code></li>
<li>m-n位的数字：<code>^\d{m,n}$</code></li>
<li>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li>
<li>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]{1,2})?$</code></li>
<li>带1-2位小数的正数或负数：<code>^(\-)?\d+(\.\d{1,2})?$</code></li>
<li>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li>
<li>有两位小数的正实数：<code>^[0-9]+(.[0-9]{2})?$</code></li>
<li>有1~3位小数的正实数：<code>^[0-9]+(.[0-9]{1,3})?$</code></li>
<li>非零的正整数：<code>^[1-9]\d*$</code> 或 <code>^([1-9][0-9]*){1,3}$</code> 或 <code>^\+?[1-9][0-9]*$</code></li>
<li>非零的负整数：<code>^\-[1-9][]0-9&quot;*$</code> 或 <code>^-[1-9]\d*$</code></li>
<li>非负整数：<code>^\d+$</code> 或 <code>^[1-9]\d*|0$</code></li>
<li>非正整数：<code>^-[1-9]\d*|0$</code> 或 <code>^((-\d+)|(0+))$</code></li>
<li>非负浮点数：<code>^\d+(\.\d+)?$</code> 或 <code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code></li>
<li>非正浮点数：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code> 或 <code>^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code></li>
<li>正浮点数：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$</code> 或 <code>^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code></li>
<li>负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code> 或 <code>^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code></li>
<li>浮点数：<code>^(-?\d+)(\.\d+)?$</code> 或 <code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li>
</ol>
<hr>
<ol>
<li>汉字：<code>^[\u4e00-\u9fa5]{0,}$</code></li>
<li>英文和数字：<code>^[A-Za-z0-9]+$</code> 或 <code>^[A-Za-z0-9]{4,40}$</code></li>
<li>长度为3-20的所有字符：<code>^.{3,20}$</code></li>
<li>由26个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li>
<li>由26个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li>
<li>由26个小写英文字母组成的字符串：<code>^[a-z]+$</code></li>
<li>由数字和26个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li>
<li>由数字、26个英文字母或者下划线组成的字符串：<code>^\w+$</code> 或 <code>^\w{3,20}$</code></li>
<li>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li>
<li>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code> 或 <code>^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</code></li>
</ol>
<hr>
<ol>
<li>Email地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></li>
<li>域名：<code>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</code></li>
<li>InternetURL：<code>[a-zA-z]+://[^\s]*</code> 或 <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li>
<li>手机号码：<code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</code></li>
<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<code>^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$</code></li>
<li>国内电话号码(0511-4405222、021-87888822)：<code>\d{3}-\d{8}|\d{4}-\d{7}</code></li>
<li>身份证号(15位、18位数字)：<code>^\d{15}|\d{18}$</code></li>
<li>短身份证号码(数字、字母x结尾)：<code>^([0-9]){7,18}(x|X)?$</code> 或 <code>^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</code></li>
<li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</code></li>
<li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<code>^[a-zA-Z]\w{5,17}$</code></li>
<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></li>
<li>日期格式：<code>^\d{4}-\d{1,2}-\d{1,2}</code></li>
<li>一年的12个月(01～09和1～12)：<code>^(0?[1-9]|1[0-2])$</code></li>
<li>一个月的31天(01～09和1～31)：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li>
<li>xml文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></li>
<li>中文字符的正则表达式：<code>[\u4e00-\u9fa5]</code></li>
<li>双字节字符：<code>[^\x00-\xff]</code> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li>
<li>空白行的正则表达式：<code>\n\s*\r</code> (可以用来删除空白行)</li>
<li>首尾空白字符的正则表达式：<code>^\s*|\s*$</code>或<code>(^\s*)|(\s*$)</code> (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li>
<li>腾讯QQ号：<code>[1-9][0-9]{4,}</code> (腾讯QQ号从10000开始)</li>
<li>中国邮政编码：<code>[1-9]\d{5}(?!\d)</code> (中国邮政编码为6位数字)</li>
<li>IP地址：<code>\d+\.\d+\.\d+\.\d+</code> (提取IP地址时有用)</li>
<li>IP地址：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>
<li>IP-v4地址：<code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</code> (提取IP地址时有用)</li>
<li>子网掩码：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>
<li>校验日期:<code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code>(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。)</li>
<li>抽取注释：<code>&lt;!--(.*?)--&gt;</code></li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的垃圾回收</title>
    <url>/2021/02/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>参考链接</p>
<p><a href="https://mp.weixin.qq.com/s/iZDB6RiQHB_KNvZK5jvz-Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iZDB6RiQHB_KNvZK5jvz-Q</a></p>
<h1 id="面试题1：浏览器怎么进行垃圾回收？"><a href="#面试题1：浏览器怎么进行垃圾回收？" class="headerlink" title="面试题1：浏览器怎么进行垃圾回收？"></a>面试题1：浏览器怎么进行垃圾回收？</h1><p>从三个点来回答什么是垃圾、如何捡垃圾、什么时候捡垃圾。</p>
<ol>
<li><p>什么是垃圾</p>
<p>不再需要，即为垃圾</p>
<p>全局变量随时可能用到，所以一定不是垃圾</p>
</li>
<li><p>如何捡垃圾（遍历算法）</p>
<p>标记空间中「可达」值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 从根节点（Root）出发，遍历所有的对象。</span><br><span class="line">- 可以遍历到的对象，是可达的（reachable）。</span><br><span class="line">- 没有被遍历到的对象，不可达的（unreachable）</span><br></pre></td></tr></table></figure>

<p>回收「不可达」的值所占据的内存。</p>
<p>做内存整理。</p>
</li>
<li><p>什么时候捡垃圾</p>
<p>前端有其特殊性，垃圾回收的时候会造成页面卡顿。</p>
<p>分代收集、增量收集、闲时收集。</p>
</li>
</ol>
<a id="more"></a>

<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>一句话总结分代回收就是：将堆分为新生代与老生代，多回收新生代，少回收老生代。</p>
<p>这样就减少了每次需遍历的对象，从而减少每次垃圾回收的耗时。<img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQTY8gQFASeAbb9cJL8heWK1Qp9gKWVQEuLJ549IibDiarVdoouoiacUIib9c5MHqUh9QnwKib8eV1Nicw2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h3><p>如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。</p>
<p>所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。</p>
<p>这样就解决了长时间停顿的问题。<img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQTY8gQFASeAbb9cJL8heWK1Lys8WTVdEnXkXpRB3YchY8zktWfOSricJRJpk7QY3oHicwuxp691o1NA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="闲时收集"><a href="#闲时收集" class="headerlink" title="闲时收集"></a>闲时收集</h3><p>垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</p>
<h1 id="面试题2：浏览器中不同类型变量的内存都是何时释放？"><a href="#面试题2：浏览器中不同类型变量的内存都是何时释放？" class="headerlink" title="面试题2：浏览器中不同类型变量的内存都是何时释放？"></a>面试题2：浏览器中不同类型变量的内存都是何时释放？</h1><p>Javascritp 中类型：值类型，引用类型。</p>
<ul>
<li><p>引用类型</p>
</li>
<li><ul>
<li>在没有引用之后，通过 V8 自动回收。</li>
</ul>
</li>
<li><p>值类型</p>
</li>
<li><ul>
<li>如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收。</li>
<li>非闭包的情况下，等待 V8 的新生代切换的时候回收。</li>
</ul>
</li>
</ul>
<h1 id="面试题3：哪些情况会导致内存泄露？如何避免？"><a href="#面试题3：哪些情况会导致内存泄露？如何避免？" class="headerlink" title="面试题3：哪些情况会导致内存泄露？如何避免？"></a>面试题3：哪些情况会导致内存泄露？如何避免？</h1><blockquote>
<p>内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。</p>
</blockquote>
<p>以 Vue 为例，通常有这些情况：</p>
<ul>
<li>监听在 <code>window/body</code> 等事件没有解绑</li>
<li>绑在 <code>EventBus</code> 的事件没有解绑</li>
<li><code>Vuex</code> 的 <code>$store</code>，<code>watch</code> 了之后没有 <code>unwatch</code></li>
<li>使用第三方库创建，没有调用正确的销毁函数</li>
</ul>
<p>解决办法：<code>beforeDestroy</code> 中及时销毁</p>
<ul>
<li>绑定了 <code>DOM/BOM</code> 对象中的事件 <code>addEventListener</code> ，<code>removeEventListener</code>。</li>
<li>观察者模式 <code>$on</code>，<code>$off</code>处理。</li>
<li>如果组件中使用了定时器，应销毁处理。</li>
<li>如果在 <code>mounted/created</code> 钩子中使用了第三方库初始化，对应的销毁。</li>
<li>使用弱引用 <code>weakMap</code>、<code>weakSet</code>。</li>
</ul>
<h2 id="闭包会导致内存泄露吗？"><a href="#闭包会导致内存泄露吗？" class="headerlink" title="闭包会导致内存泄露吗？"></a>闭包会导致内存泄露吗？</h2><p>闭包会导致内存泄露吗？正确的答案是不会。</p>
<p>内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。</p>
<p>闭包里面的变量就是我们需要的变量，不能说是内存泄露。</p>
<blockquote>
<p>这个误解是如何来的？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。参考这篇文章</p>
</blockquote>
<h1 id="面试题4：weakMap-weakSet-和-Map-Set-有什么区别？"><a href="#面试题4：weakMap-weakSet-和-Map-Set-有什么区别？" class="headerlink" title="面试题4：weakMap weakSet 和 Map Set 有什么区别？"></a>面试题4：<code>weakMap</code> <code>weakSet</code> 和 <code>Map</code> <code>Set</code> 有什么区别？</h1><p>在 ES6 中为我们新增了两个数据结构 WeakMap、WeakSet，就是为了解决内存泄漏的问题。</p>
<p>它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。</p>
<p>只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。</p>
<p>也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>更全面的介绍可以看这里：第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别</p>
]]></content>
      <categories>
        <category>浏览器回收垃圾</category>
      </categories>
      <tags>
        <tag>浏览器回收垃圾</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染基本原理</title>
    <url>/2020/07/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/k9N4R779RPrE_zB8xmna4A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/k9N4R779RPrE_zB8xmna4A</a></p>
<p><a href="https://wenku.baidu.com/view/43f6de6f846a561252d380eb6294dd88d1d23d06.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/43f6de6f846a561252d380eb6294dd88d1d23d06.html</a></p>
<p><img src="http://note.youdao.com/yws/res/4277/AB6FE614A7284DA09E42D70C34CB2779" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4276/0895E95CD6B94F388805B4003B303ECF" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4255/EE222C21922A4A99AEF1FAEABBB44B30" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4282/995D42C84F7A44ECB44BAE0D6D70B660" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4268/C1BED60D28E5444EA00850BB2ED7E4B3" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4275/AFCEE7C8A8CE4379AFC0A90500F5D7EC" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4261/75DA24369E3C47EB9BB435A28C00BD4A" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4270/960E57F755BE41D980B26965553FBE05" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4271/7A5A0D1E6D514F90903FC2FC8B4889CF" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4274/90F32D72F8154097A71448DB627058AE" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4252/8CDAF1667E844A03943CCCDB8A8383D4" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4281/1E90E3AE969641F998B15E076DEBAD81" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4260/22EB87EF0AFA45A5AA9D792F6C918C68" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4279/5BAAE640B2D845969886053DB2D7F44C" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4283/D9F09BD217474E1A9F2D41FD70CBDDC2" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4269/C2F8519F8FC041409A5DE68752133C42" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4278/BF3A766456E04571815F922E763FA8C7" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4284/234DB30344EF41AFA054D705F2836BD3" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4280/A3BD42A40E534E36A96A733A5D9DFB77" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4264/EB73BB8AE59948C88C564B6FFA89C2F8" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4263/2D6AABD6340148AF93879F5CD66194F4" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4265/04C3B07C45E1484B8D011C23E3C853BE" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4257/F520A8FD508D431DA0863483527347B0" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4258/B6A63060475542D2A12FE924DBCDB047" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4272/8929B48A70304679A1476FA0A36FF402" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4253/B0BCF84D012748B891CB75EF92917157" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4273/A530722F60924E02AB99E64C65EFF057" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4254/635131C32ED9491C896179DEC9038CD1" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4262/7C8B2221AE1B4B1693B079614BBBDE29" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4256/D1EBFEBA4F334306A7A7659743837626" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4266/51CA35C897744305AEDEBBDEFDE5B0DB" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4267/2522117618C54535A56381480FB2A4B6" alt="img"></p>
<p><img src="http://note.youdao.com/yws/res/4259/DDAC63C11C574212A0C600F2120CED6B" alt="img"></p>
<p>更多 <a href="https://mp.weixin.qq.com/s/k9N4R779RPrE_zB8xmna4A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/k9N4R779RPrE_zB8xmna4A</a></p>
<p>参考链接 <a href="https://wenku.baidu.com/view/43f6de6f846a561252d380eb6294dd88d1d23d06.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/43f6de6f846a561252d380eb6294dd88d1d23d06.html</a></p>
]]></content>
      <categories>
        <category>浏览器渲染</category>
      </categories>
      <tags>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>应用性能优化实践</title>
    <url>/2021/02/02/%E7%88%B1%E5%A5%87%E8%89%BA%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><strong>问题梳理</strong></p>
<p>参考链接</p>
<p><a href="https://mp.weixin.qq.com/s/H88469QNdE-IChc8u-pBaQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/H88469QNdE-IChc8u-pBaQ</a></p>
<p>我们先通过提问题的方式，从<strong>资源文件加载、页面渲染性能、接口响应速度</strong>等三个方面分别列出了一些可能存在性能瓶颈的环节。</p>
<a id="more"></a>

<p><strong>资源加载问题</strong></p>
<p>在一个复杂的 Web 应用中，通常会依赖很多 JS/CSS/Images 等资源文件。如何在最短时间内获取页面所需的最小资源，我们需要考虑以下几个问题：</p>
<ul>
<li><p>源码中有无<strong>冗余的模块</strong>？是否进行了<strong>压缩、合并</strong>等操作？</p>
</li>
<li><p>服务器响应及网络传输速度是否正常？有没有最大化利用浏览器的并发请求？</p>
</li>
<li><p>资源文件的缓存策略是否合理？是否每次发布上线都需要重新请求所有文件？</p>
</li>
<li><p>首次页面渲染是否下载了不必要的资源文件？每次渲染所需的资源文件能不能提前加载？</p>
</li>
</ul>
<p><strong>页面渲染问题</strong></p>
<p>由于 JS 是在单线程中执行，而 Vue.js 框架的大部分渲染任务都在浏览器端完成。为了解决白屏、卡顿等问题，我们需要考虑以下几个问题：</p>
<ul>
<li><p>是否可以通过骨架屏等方式提前渲染核心布局？</p>
</li>
<li><p>主线程是否存在非常耗时的长任务？是否可以进行任务分片、延迟渲染？</p>
</li>
<li><p>是否存在时间复杂度过高的算法？是否存在大量重复计算？</p>
</li>
<li><p>是否重复初始化相同的对象？是否存在内存泄露？</p>
</li>
</ul>
<p><strong>接口速度问题</strong></p>
<p>在列表查询等依赖后台数据展示的页面，接口的响应速度也至关重要。由于我们通过 Node.js 搭建的 BFF 来整合多个服务提供方的接口，因此可能存在以下几个问题：</p>
<ul>
<li><p>后端服务提供的接口速度是否响应慢？网关、数据库、索引等服务是否正常？</p>
</li>
<li><p>针对实时性要求较低的数据，是否可以利用缓存服务？</p>
</li>
<li><p>同时调用多方接口时，是否最大化进行并发请求？非必要接口是否可以单独发起请求？</p>
</li>
<li><p>与浏览器脚本一样，是否存在复杂算法、内存泄露等问题代码？</p>
</li>
</ul>
<p><strong>解决方案</strong></p>
<p>带着以上的这些问题，我们开始着手对现有的应用进行一次详细的检查，逐步定位影响性能的关键问题并一一进行解决。</p>
<p><strong>资源加载优化</strong></p>
<p>Webpack 构建问题分析</p>
<p>由于我们的项目通过 Webpack 4.x 构建，因此为了分析资源文件的个数及大小，采用了 Webpack 插件webpack-bundle-analyzer对产出的静态资源文件进行了统计，如下图所示（截取了几个体积较大的文件）。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvtoF6a4RQzicPDXuV98FRlHo3ib1rbSPHaKNjVADB3qUg8kAJwOfl1HiaiaMWKAcwCtnPfV9pYNrf5AMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>根据统计我们发现了以下几个主要问题：</p>
<ul>
<li><p>缓存问题。每次改动任意代码，所有生成的 JS/CSS 等文件的 Hash 值都发生了变化，这意味着每次发布上线，浏览器都需要重新请求全部资源。</p>
</li>
<li><p>文件大小。通过 node_modules 生成的 chunk-vendor 原始大小超过 1.5 M。其中，体积最大的是 ElementUI，超过 650K，其次是 moment.js，体积超过 250K。剩余部分则由 Vue.js、Lodash 等基础类库组成。</p>
</li>
<li><p>重复打包。部分业务模块对应的 chunk 文件原始大小在 500K 左右。其原因是使用到了 d3，echarts 等依赖的模块，直接将它们打包到了对应模块中。而这些第三方库，占整个文件大小的 70% 左右。</p>
</li>
<li><p>资源个数。由 Webpack 自动生成了多个模块间的公共 chunk，大小在几 K 到一百多 K 不等。例如有三个模块 a，b，c，则自动生成的 chunk 包含多种不同的组合 a<del>b.js，a</del>c.js，a<del>b</del>c.js，请求 a 模块的时候也会同步加载这几个文件。随着模块数量增加，组合也更复杂，无形中也增加了请求的数量。</p>
</li>
</ul>
<p>浏览器加载速度分析</p>
<p>通过浏览器 Network 工具，我们发现服务器缓存、网络传输等对加载速度影响很小，导致慢的几个主要问题如下：</p>
<ul>
<li><p>并发数量。通过构建得到的静态资源文件都部署到一个静态域名下面，导致需要排队下载文件。</p>
</li>
<li><p>顺序问题。一些非首次渲染所需要的 JS 文件（如播放器 SDK 、流程图 SDK 等）在页面打开的时候就进行了阻塞加载。</p>
</li>
</ul>
<p>资源构建及部署优化方案</p>
<p>针对以上问题，我们对 Webpack 配置方式做了以下几点改进。</p>
<ul>
<li><p>单独部署基础库至 CDN。生产环境将 Vue.js + VueRouter + Vuex + VueCompositionAPI + ElementUI + Lodash 等基础类库通过 webpack.DllPlugin 提前构建为 library.dll.js 并单独部署，同时整个站点中通过 prefetch 提前加载。</p>
</li>
<li><p>单独部署样式主题至 CDN。项目中用到的 ElementUI 组件样式及团队内部开发的 MaterialTheme 主题样式放弃从 NPM 引入 Sass 源码。而是提前构建好 9 种不同颜色的主题，提前部署至 CDN，并通过 prefetch 提前加载。项目中的自定义样式则通过 Sass Mixin 生成不同主题的规则。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link</span><br><span class="line">  href&#x3D;&quot;&#x2F;&#x2F;static.iqiyi.com&#x2F;lego&#x2F;theme&#x2F;element-ui&#x2F;1.0.0&#x2F;css&#x2F;cyan.css&quot;</span><br><span class="line">  rel&#x3D;&quot;prefetch&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line">&lt;link</span><br><span class="line">  href&#x3D;&quot;&#x2F;&#x2F;static.iqiyi.com&#x2F;lego&#x2F;theme&#x2F;element-material&#x2F;2.0.0&#x2F;css&#x2F;cyan.css&quot;</span><br><span class="line">  rel&#x3D;&quot;prefetch&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>将业务代码部署至与基础库不同的域名。提升浏览器并发请求的数量。</p>
</li>
<li><p>将播放器 SDK、流程图 SDK 等非首次渲染必须的 JS 文件通过 defer 等方式进行异步加载，或改为组件初始化时动态请求。</p>
</li>
<li><p>删除 moment.js 等非必须的第三方类库。通过查看项目源码，发现仅几个地方用到了 moment.js 的格式化功能，因此我们选择通过自己实现一个仅几十行的工具函数来替换。此外根据项目实际情况，也可以考虑在项目中引入体积更小的类库，例如 Day.js 等。</p>
</li>
<li><p>优化 Webpack 的 splitChunks 策略。将 d3，echarts 等依赖抽取为单独的 chunk。此外，考虑到不同模块之间自动生成的公共 chunk（类似 a<del>b</del>c.js）文件不大，反而增加了请求数量，因此禁用了该项配置。同时，显示地将各模块间公共的部分（项目中统一放在 src/common 目录下）打包至 chunk-common 文件中。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack config</span><br><span class="line">&#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        &#x2F;&#x2F; 禁用默认拆分的 chunk</span><br><span class="line">        default: false,</span><br><span class="line">        &#x2F;&#x2F; 显示抽取项目公共 chunk</span><br><span class="line">        common: &#123;</span><br><span class="line">          name: &#39;chunk-common&#39;,</span><br><span class="line">          test: &#x2F;src[\\&#x2F;]common&#x2F;,</span><br><span class="line">          chunks: &#39;all&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 抽取 d3&#x2F;echarts 等第三方类库</span><br><span class="line">        d3: &#123;</span><br><span class="line">          name: &#39;chunk-d3&#39;,</span><br><span class="line">          test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;](d3|dagre|graphlib)&#x2F;,</span><br><span class="line">          priority: 100,</span><br><span class="line">          chunks: &#39;all&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        echarts: &#123;</span><br><span class="line">          name: &#39;chunk-echarts&#39;,</span><br><span class="line">          test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;](echarts|zrender)&#x2F;,</span><br><span class="line">          priority: 110,</span><br><span class="line">          chunks: &#39;all&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>优化构建后文件名中的Hash。在生产环境改用 contenthash 来命名文件，仅当包含的文件内容发生改变时才会重新生成新的文件名，最大化利用缓存。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack config</span><br><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;[name].[contenthash].js&#39;,</span><br><span class="line">    chunkFilename: &#39;js&#x2F;[name].[contenthash].js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过以上优化，最终构建的 chunk-vendor 大小在 500K 左右，体积大约减小 2/3；新抽取的项目公共文件 chunk-common 大小 300K 左右；各个模块打包的文件大小则在 200K 左右， 体积大约减小 3/5。同时，结合 CDN 部署基础类库，prefetch 预加载及 contenthash 缓存控制等，资源加载的速度大幅度提升。</p>
<p><strong>页面渲染优化</strong></p>
<p>考虑到业务场景及开发成本，新版本的前端应用并没有实现服务器端渲染，存在着较长的白屏时间。而老版本则通过 Java + Velocity 在服务器端完成渲染，两相对比，用户体验相差甚多。</p>
<p>浏览器渲染性能分析</p>
<p>为了解决这个问题，我们通过 Chrome Performance 对页面的渲染性能进行了完整的分析。</p>
<p>由于生产环境代码已经压缩，这里建议在开发环境录制 Profile，可以直接定位到相关源码。录制后的时间线展示参见下面截图。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvtoF6a4RQzicPDXuV98FRlHobdvGb2ITB0DEtaNibKictHjI2a7ByK4LGYhTHawIVkWoqZmFzQEI0Xlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其中我们需要重点关注的几个维度如下：</p>
<ul>
<li><p>Frames：渲染的 FPS 以及不同时间点的渲染结果。</p>
</li>
<li><p>Main：渲染主线程，包括 HTML 解析，JavaScript 执行等任务。</p>
</li>
<li><p>Timings：包括 FP、DCL、FCP、LCP 等指标，以及通过 Performance API 记录的运行时间。Vue.js 2.x 中可以通过 Vue.config.performance = true; 开启组件性能记录。下图的截图展示了 Vue.js 组件的渲染耗时情况。</p>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvtoF6a4RQzicPDXuV98FRlHodKRiaWXzP1szQX4owLNcjM1yvQbL4zSPNicBhUs4ibhdZckQKFib0lt8yw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>经过分析，我们发现以下几个主要问题：</p>
<ul>
<li><p>路由激活后的首次渲染任务耗时特别长，已经超过了 2 秒。其中，站点导航、侧边栏等就占用了一半以上的时间。</p>
</li>
<li><p>导航组件中，用于判断链接权限的 AuthService.hasURIAuth 方法占用了 80% 的时间。</p>
</li>
<li><p>在通过配置渲染的动态表单页中，核心组件 FormBuilder 渲染时间也在 2 秒左右。</p>
</li>
</ul>
<p>页面渲染整体优化方案</p>
<p>针对以上问题，我们进行了以下几点改进：</p>
<ul>
<li><p>通过服务器端渲染骨架屏，包括导航等页面基础布局。从视觉效果上减少用户的心理等待。</p>
</li>
<li><p>减少首屏渲染的组件数量。将初始为隐藏状态的导航二级菜单、站点侧边栏、列表高级搜索弹窗等组件通过 webpack 提取至异步 chunk 中，在用户交互时再异步渲染。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AppLayout.vue</span><br><span class="line">&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    AppDrawer: () &#x3D;&gt;</span><br><span class="line">      import(</span><br><span class="line">        &#x2F;* webpackChunkName: &#39;chunk-async-common&#39; *&#x2F;</span><br><span class="line">        &#39;.&#x2F;AppDrawer&#39;</span><br><span class="line">      ),</span><br><span class="line">    AppHeader</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>优化耗时的 JavaScript 函数。这一步需要结合实际代码实现进行优化，以上面提到的权限判断方法 AuthService.hasURIAuth 为例，其中最突出的问题就是循环内函数重复执行以及正则表达式重复创建。我们通过 Memoization 的方式为耗时函数添加记忆化功能，当参数相同时直接返回记忆值；通过 Cache 将正则表达式实例缓存起来以便重复使用。</p>
</li>
<li><p>将根据配置进行渲染的动态表单 FormBuilder 手动拆分为多个渲染任务。由于业务场景的复杂性，通常一个表单拥有 80 余个字段。而在 Vue.js 里面，一次数据变化触发的渲染任务是无法直接拆分的。这里我们采取了另一种方式，将表单配置拆分为多段，首次渲染时仅传递第一段配置，然后在后续的渲染周期依次将配置拼接上去。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;form-builder :config&#x3D;&quot;formConfig&quot;&gt;&lt;&#x2F;form-builder&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getFormConfig().then(() &#x3D;&gt; &#123;</span><br><span class="line">      this.startWork();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    startWork() &#123;</span><br><span class="line">      const work &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 任务调度器</span><br><span class="line">        return scheduler.next(() &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 逐步拼接表单配置</span><br><span class="line">          this.formConfig &#x3D; this.concatNextFormConfig();</span><br><span class="line"></span><br><span class="line">          if (!scheduler.done()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环执行任务</span><br><span class="line">            work();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 启动首次任务</span><br><span class="line">      work();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>接口速度优化</strong></p>
<p>BFF 性能分析</p>
<p>由于业务流程复杂，前端会调用多个服务接口，并对数据进行二次处理，因此一直由前端来负责Java Web层(BFF)的开发。本次升级为了开发更简便，引入了基于TypeScript的NestJS框架替换原来Spring MVC，由NestJS封装面向前端的接口给 VueJS应用。为了定位其中潜在的性能问题，我们做了一些通用的扩展：</p>
<ul>
<li><p>为所有封装的接口添加自定义中间件 TimeMiddleware，用于统计接口的整体响应速度。</p>
</li>
<li><p>为 axios 统一添加 interceptor，用于统计 BFF 调用第三方接口的响应速度。</p>
</li>
</ul>
<p>最后，通过日志、Apache JMeter 等工具对核心接口进行分析，我们主要发现以下几个问题：</p>
<ul>
<li><p>在对千万量级的索引数据进行分页查询的接口 A 中，当前 ES 的查询速度不理想，平均耗时在 2.6 秒左右。</p>
</li>
<li><p>在同时调用多方服务的接口 B 中，存在不必要的串行。此外，其中一个标签查询服务平均耗时在 700ms 左右，成为影响速度的关键因素。</p>
</li>
<li><p>在获取用户信息的接口 C 中，有 20% 左右的请求耗时在 600ms 左右，而其他的请求仅耗时 50ms。经过定位发现是服务集群中某台服务器跨地区导致。</p>
</li>
<li><p>大部分接口都依赖了一个获取频道列表的基础服务，实时性要求很低，然而每次都是通过接口实时获取，耗时大约 50 ms。</p>
</li>
<li><p>整个应用的日志服务继承了 NestJS 的 logger.service ，它默认是通过 process.stdout 同步输出的。因此日志内容较多时在部分机器上开销也很大，平均耗时 100ms 左右。</p>
</li>
</ul>
<p>BFF 整体优化方案</p>
<p>针对以上问题，我们进行了以下几点改进：</p>
<ul>
<li><p>后端同学优化 ES 查询服务，新增多台物理机进行扩容。优化后平均耗时小于 1 秒，速度提升超过 60%。</p>
</li>
<li><p>后端同学为标签查询服务添加缓存机制，优化后平均耗时 200ms 左右，整体提升超过 70%。</p>
</li>
<li><p>移除集群中的跨地区服务器，保证各服务之间尽量在同一个地区、机房。</p>
</li>
<li><p>大化地并行请求，减少请求耗时的关键路径。以其中一个接口为例，优化前平均耗时 1.3 秒，优化后平均耗时仅 700ms，提升 45% 左右。</p>
</li>
<li><p>实时性要求较低的服务通过 Redis 缓存查询结果，例如频道查询服务，平均耗时从 50ms 减少至 15ms，提升 70% 左右。</p>
</li>
<li><p>生产环境的日志取消输出到 process.stdout，通过 winston 等日志框架将其异步写入至指定文件中。</p>
</li>
</ul>
<p><strong>优化后整体效果展示</strong></p>
<p>资源加载速度展示</p>
<p>通过减少文件大小及个数、缓存、并发、预加载、懒加载等各种优化，获取核心资源整体耗时控制在 200ms 左右。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvtoF6a4RQzicPDXuV98FRlHoXlpCKz9mRuRtQJXYaPp0KXqkJe384kib3b9tIn7NHjtBibZTV9TtPk3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>首次加载主题样式与切换主题示例（Prefetch）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvtoF6a4RQzicPDXuV98FRlHoEKXz9y6ZWTGYjMZLr78Obd4TcoITge2NfI7cAoXSU3JiaX5vvqHeZsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>异步加载路由及组件示例（Prefetch）</p>
<p>页面渲染速度展示</p>
<p>通过异步渲染隐藏组件、优化耗时函数、任务分片、骨架屏等方式，让用户尽早看到内容的同时，将首次路由渲染的时间控制在 1 秒以内，结合浏览器自身的优化，在电脑网速及性能正常的情况下，已经感知不到白屏的存在。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvtoF6a4RQzicPDXuV98FRlHo3A53CavcXYjuYuDEav9zgqic1YE8uzC7P0Oz0HBShiacw8BOa5jIiaKqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>接口相应速度展示</p>
<p>通过扩容、缓存、并发、优化耗时函数等方式，我们将核心的几个查询接口的速度也控制在了 1 秒左右。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvtoF6a4RQzicPDXuV98FRlHoEd1LaTYJ3fP2Giabojt3B8Aop3QiaoOpD74RQ7XWfuvMYqfoVaPicibCCw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>优化前后核心数据对比</p>
<table>
<thead>
<tr>
<th>优化环节</th>
<th>优化前</th>
<th>优化后</th>
</tr>
</thead>
<tbody><tr>
<td>首次下载脚本资源</td>
<td>实际下载 JS 文件 7 个，整体大小 3.5M</td>
<td>实际下载 JS 文件 4 个，整体大小 1.8M</td>
</tr>
<tr>
<td>路由首次渲染时间</td>
<td>平均 2.66 秒</td>
<td>平均 790ms</td>
</tr>
<tr>
<td>索引分页查询响应时间</td>
<td>平均 2.60 秒</td>
<td>平均 1.03 秒</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端优化方案</category>
      </categories>
      <tags>
        <tag>前端优化方案</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量process.env</title>
    <url>/2020/07/30/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fprocess-env/</url>
    <content><![CDATA[<p>最近系统接入了公司的单点登录，为了登陆成功后再跳回系统的主页面，又申请了测试和沙箱的域名（之前都是直接用IP登的），本地开发是配置的host。接入之后发现了一个非常麻烦的点就是给单点登录传的跳转地址每次都要修改，开发的时候要写成开发的域名，测试的时候要改成测试的域名，进沙箱的时候要改成跳转沙箱的域名，上线的时候又要改成线上的域名。特别是在测试阶段，开发测试来回切换，不胜其烦。<br>于是就想把它写成配置文件，根据不同环境加载不同的配置，这样就不用来回改了。这个时候，process.env就跳入了脑海，叫嚣着，终于该我出场啦！！</p>
<h4 id="扒一扒process-env"><a href="#扒一扒process-env" class="headerlink" title="扒一扒process.env"></a>扒一扒process.env</h4><p>process对象是全局变量，它提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()。<br>既然process都是一个对象了，env自然是它的一个属性，这个属性返回包含用户环境信息的对象。在终端输入node后，在输入process.env可以看到打印出来的信息。</p>
<a id="more"></a>

<h4 id="主角出场-process-env-NODE-ENV"><a href="#主角出场-process-env-NODE-ENV" class="headerlink" title="主角出场 process.env.NODE_ENV"></a>主角出场 process.env.NODE_ENV</h4><p>NODE_ENV不是process.env对象上原有的属性，它是我们自己添加上去的一个环境变量，用来确定当前所处的开发阶段。一般生产阶段设为production，开发阶段设为develop，然后在脚本中读取process.env.NODE_ENV。<br>运行脚本时，可以这样改变环境变量, 在package.json文件的scripts里面添加命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_ENV&#x3D;production node build.js</span><br></pre></td></tr></table></figure>

<p>但是这个命令使用Windows的同学拉下代码后就报错了，因为Windows上面设置的方式不一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set NODE_ENV&#x3D;production node build.js</span><br></pre></td></tr></table></figure>

<p>但是不同电脑上不同的设置肯定是不行的呀，这个时候cross-env赶来救场了。<br>cross-env可以跨平台的设置和使用环境变量<br>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev cross-env</span><br></pre></td></tr></table></figure>

<p>接下来我们就可以通过cross-env来设置了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cross-env NODE_ENV&#x3D;production node build.js</span><br></pre></td></tr></table></figure>

<p>这样设置之后，我们可以在脚本中使用process.env.NODE_ENV了，但是不能在模块中使用，要想在模块当中直接使用，我们还需要一些配置</p>
<h5 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h5><p>DefinePlugin可以定义一些全局变量，让我们在模块当中直接使用，不用做任何声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &#39;.&#x2F;src&#x2F;app&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &#39;dist&#39;,</span><br><span class="line">        filename: &#39;bundle.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DefinePlugin(&#123;</span><br><span class="line">           &#39;process.env.NODE_ENV&#39;:  &#39;production&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们直接这样定义的时候，编译后是这个样子的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5262488-8d77f226c73186e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/862/format/webp" alt="img"></p>
<p>bundle.png</p>
<p>DefinePlugin直接将内容替换了，而不是一个字符串，所以我们经常这样定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.DefinePlugin(&#123;</span><br><span class="line">      &#39;process.env.NODE_ENV&#39;: JSON.stringify(process.env.NODE_ENV)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样就可以直接使用啦_<br>现在我们要在模块中根据环境变量来配置不同的url了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let url &#x3D; &#39;&#39;;</span><br><span class="line"> if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;testing&#39;) &#123;</span><br><span class="line">   url &#x3D; &#39;http:&#x2F;&#x2F;my.test.cn&#39;;</span><br><span class="line"> &#125; else if (process.env.alpord &#x3D;&#x3D;&#x3D; &#39;alpord&#39;) &#123;</span><br><span class="line">   url &#x3D; &#39;http:&#x2F;&#x2F;my.alpord.cn&#39;;</span><br><span class="line"> &#125; else if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">   url &#x3D; &#39;http:&#x2F;&#x2F;my.product.cn&#39;;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   url &#x3D; &#39;http:&#x2F;&#x2F;my.develop.cn&#39;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这只是简单列了一下process.env.NODE_ENV的用法，大家知道怎么用就好啦</p>
<p>参考链接 <a href="https://www.jianshu.com/p/c8f9c61c2f20" target="_blank" rel="noopener">https://www.jianshu.com/p/c8f9c61c2f20</a></p>
]]></content>
      <categories>
        <category>环境变量</category>
      </categories>
      <tags>
        <tag>环境变量</tag>
        <tag>process-env</tag>
      </tags>
  </entry>
  <entry>
    <title>环境搭建从无到有</title>
    <url>/2020/08/18/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/</url>
    <content><![CDATA[<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="nodeJs"><a href="#nodeJs" class="headerlink" title="nodeJs"></a>nodeJs</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p><a href="https://git-scm.com/" target="_blank" rel="noopener">官网地址</a></p>
<a id="more"></a>

<h3 id="GitExtensions"><a href="#GitExtensions" class="headerlink" title="GitExtensions"></a>GitExtensions</h3><p><a href="https://sourceforge.net/projects/gitextensions/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="Tortoisegit-小乌龟"><a href="#Tortoisegit-小乌龟" class="headerlink" title="Tortoisegit(小乌龟)"></a>Tortoisegit(小乌龟)</h3><p><a href="https://tortoisegit.org/download/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="KDiff3（比较工具一）"><a href="#KDiff3（比较工具一）" class="headerlink" title="KDiff3（比较工具一）"></a>KDiff3（比较工具一）</h3><p><a href="https://sourceforge.net/projects/kdiff3/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="beyond-compare（比较工具二）"><a href="#beyond-compare（比较工具二）" class="headerlink" title="beyond compare（比较工具二）"></a>beyond compare（比较工具二）</h3><p><a href="http://www.scootersoftware.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="vs和插件"><a href="#vs和插件" class="headerlink" title="vs和插件"></a>vs和插件</h3><p><a href="https://marketplace.visualstudio.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="vsCode"><a href="#vsCode" class="headerlink" title="vsCode"></a>vsCode</h3><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="微信开发者工具"><a href="#微信开发者工具" class="headerlink" title="微信开发者工具"></a>微信开发者工具</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h3><p><a href="https://www.google.cn/chrome/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="Snipaste截图工具"><a href="#Snipaste截图工具" class="headerlink" title="Snipaste截图工具"></a>Snipaste截图工具</h3><p><a href="https://www.snipaste.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="向日葵远程连接工具"><a href="#向日葵远程连接工具" class="headerlink" title="向日葵远程连接工具"></a>向日葵远程连接工具</h3><p><a href="https://sunlogin.oray.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="同程电脑管家"><a href="#同程电脑管家" class="headerlink" title="同程电脑管家"></a>同程电脑管家</h3><p><a href="http://guanjia.tcent.cn/" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="前端测试工具"><a href="#前端测试工具" class="headerlink" title="前端测试工具"></a>前端测试工具</h2><h3 id="charles-抓包"><a href="#charles-抓包" class="headerlink" title="charles(抓包)"></a>charles(抓包)</h3><p><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="totalcontrol（控制手机）"><a href="#totalcontrol（控制手机）" class="headerlink" title="totalcontrol（控制手机）"></a>totalcontrol（控制手机）</h3><p><a href="http://tc.sigma-rt.com.cn/index.php" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="书写工具"><a href="#书写工具" class="headerlink" title="书写工具"></a>书写工具</h2><h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h3><p><a href="https://www.typora.io/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="notepad"><a href="#notepad" class="headerlink" title="notepad"></a>notepad</h3><p><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="聊天工具"><a href="#聊天工具" class="headerlink" title="聊天工具"></a>聊天工具</h2><h3 id="WeChat"><a href="#WeChat" class="headerlink" title="WeChat"></a>WeChat</h3><p><a href="https://pc.weixin.qq.com/?t=win_weixin" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="DingTalk"><a href="#DingTalk" class="headerlink" title="DingTalk"></a>DingTalk</h3><p><a href="https://www.dingtalk.com/" target="_blank" rel="noopener">官网地址</a></p>
<h2 id="录屏工具"><a href="#录屏工具" class="headerlink" title="录屏工具"></a>录屏工具</h2><h3 id="GifCam"><a href="#GifCam" class="headerlink" title="GifCam"></a>GifCam</h3><p><a href="http://blog.bahraniapps.com/gifcam/#download" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="ScreenToGif"><a href="#ScreenToGif" class="headerlink" title="ScreenToGif"></a>ScreenToGif</h3><p><a href="http://www.screentogif.com/" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="快压"><a href="#快压" class="headerlink" title="快压"></a>快压</h3><p><a href="http://www.kuaizip.com/" target="_blank" rel="noopener">官网地址</a></p>
]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>软件官网</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点链接</title>
    <url>/2020/09/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>vue生命周期从源码看</p>
<p><a href="https://mp.weixin.qq.com/s/6-WDKTyyDnkbw224WOEpjw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6-WDKTyyDnkbw224WOEpjw</a></p>
<p>作为一位Vue工程师，这些开发技巧你都会吗？</p>
<p><a href="https://mp.weixin.qq.com/s/QqMfogiIPLrsSBRUkN_WlQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QqMfogiIPLrsSBRUkN_WlQ</a></p>
<a id="more"></a>

<p>Vue项目从2.5M优化到200kb的全过程</p>
<p><a href="https://mp.weixin.qq.com/s/FRay4O1VAJ9c1RDyvjkzpg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FRay4O1VAJ9c1RDyvjkzpg</a></p>
<p>很多人不知道可以使用这种 key 的方式来对 Vue 组件进行重新渲染！</p>
<p><a href="https://mp.weixin.qq.com/s/DA2X_aIqBolHSKlYt9aH5Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DA2X_aIqBolHSKlYt9aH5Q</a></p>
<p>Vue.use中都发生了什么？</p>
<p><a href="https://mp.weixin.qq.com/s/LBaQiq4CVGYXSDC9GgGp4Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LBaQiq4CVGYXSDC9GgGp4Q</a></p>
<p>Vue keep-alive深入理解及实践总结</p>
<p><a href="https://mp.weixin.qq.com/s/NgrrK_HC_ci_mOd2PiiWxA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NgrrK_HC_ci_mOd2PiiWxA</a></p>
<p>Vue中mixin怎么理解？</p>
<p><a href="https://mp.weixin.qq.com/s/0tRYs-tlf8NaWoqu5qvYcw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0tRYs-tlf8NaWoqu5qvYcw</a></p>
<p>从Vue源码角度深挖Watch、Computed</p>
<p><a href="https://mp.weixin.qq.com/s/ApYLgnuQ9cxvQrFekAU75w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ApYLgnuQ9cxvQrFekAU75w</a></p>
<p>从源码解读 Vuex 注入 Vue 生命周期的过程</p>
<p><a href="https://mp.weixin.qq.com/s/15YA0baY5MGIjG3CkamDyA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/15YA0baY5MGIjG3CkamDyA</a></p>
<p>一文看懂Vue3周边配套现状</p>
<p><a href="https://mp.weixin.qq.com/s/Em_fOGXBzEtQ8UEA2_Bdew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Em_fOGXBzEtQ8UEA2_Bdew</a></p>
<p> 为你的 Vue.js 单页应用提速</p>
<p><a href="https://mp.weixin.qq.com/s/5DAm7WvU9htzkdYGM5Tmkw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5DAm7WvU9htzkdYGM5Tmkw</a></p>
<p>Vue超好玩的新特性：在CSS中使用JS变量</p>
<p><a href="https://mp.weixin.qq.com/s/DW_G5W3tz1CzbFz4aYDXcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DW_G5W3tz1CzbFz4aYDXcA</a></p>
<p>彻底理解 Cookie、Session、Token、JWT</p>
<p><a href="https://mp.weixin.qq.com/s/Du9GIaV87BU3disvC2gtGQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Du9GIaV87BU3disvC2gtGQ</a></p>
<p>10个Vue开发技巧助力成为更好的工程师</p>
<p><a href="https://mp.weixin.qq.com/s/_W-0JoGtaJPXDjF6Mx6u4Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_W-0JoGtaJPXDjF6Mx6u4Q</a></p>
<p>Vue 开发必须知道的 36 个技巧</p>
<p><a href="https://mp.weixin.qq.com/s/dr4c0HWmHsGrrw91l_mk-Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dr4c0HWmHsGrrw91l_mk-Q</a></p>
<p>Vue最全知识点（基础到进阶，覆盖vue3.0，持续更新整理，欢迎补充讨论）</p>
<p><a href="https://mp.weixin.qq.com/s/uat5Tt21ZU7-q4S3xMqTdg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uat5Tt21ZU7-q4S3xMqTdg</a></p>
<p>前端一键换肤的N种方案，请收下</p>
<p><a href="https://mp.weixin.qq.com/s/5rejEt5xvRYTNPFvhLyEoQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5rejEt5xvRYTNPFvhLyEoQ</a></p>
<p>一份值得收藏的 Git 异常处理清单</p>
<p><a href="https://mp.weixin.qq.com/s/GKdhcb0ekirjg4jEwERizA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GKdhcb0ekirjg4jEwERizA</a></p>
<p>前端工程师如何处理10万条数据</p>
<p><a href="https://mp.weixin.qq.com/s/0duasKMCrIYjwWZvoZikrQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0duasKMCrIYjwWZvoZikrQ</a></p>
<p>那些不常见，但却非常实用的css属性(整理不易)</p>
<p><a href="https://mp.weixin.qq.com/s/yt6dNfSxJZwtMTSrbprquQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yt6dNfSxJZwtMTSrbprquQ</a></p>
<p>你可能不知道的15个有用的Github功能</p>
<p><a href="https://mp.weixin.qq.com/s/abeqBYe__mzZ3CVNxbaw5Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/abeqBYe__mzZ3CVNxbaw5Q</a></p>
<p>7个快速发现 bug 神仙调试工具</p>
<p><a href="https://mp.weixin.qq.com/s/BOJv26_ul3RidiKSECQ_uA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BOJv26_ul3RidiKSECQ_uA</a></p>
<p>9个很棒的CSS边框技巧</p>
<p><a href="https://mp.weixin.qq.com/s/dbG4LzlRYNAxXzmvjEBtkw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dbG4LzlRYNAxXzmvjEBtkw</a></p>
<p>通过事例讲解如果在 Vue 创建及使用过滤器</p>
<p><a href="https://mp.weixin.qq.com/s/Zyzb5f0cNVmcCp2dxcxP-w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Zyzb5f0cNVmcCp2dxcxP-w</a></p>
<p>分分钟教会你搭建企业级的 npm 私有仓库</p>
<p><a href="https://mp.weixin.qq.com/s/otSFSAmedqihFRMUvVHL0Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/otSFSAmedqihFRMUvVHL0Q</a></p>
<p>npx， 你了解吗？</p>
<p><a href="https://mp.weixin.qq.com/s/2FkK_hANiCDhTpikAT7UxA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2FkK_hANiCDhTpikAT7UxA</a></p>
<p>5个JavaScript的字符串处理库</p>
<p><a href="https://mp.weixin.qq.com/s/1R3jRyH-y8hSVmCIVevKzw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1R3jRyH-y8hSVmCIVevKzw</a></p>
<p>JavaScript闭包的深入理解</p>
<p><a href="https://mp.weixin.qq.com/s/5FbV4U4AyJAYdCtzgHM9bg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5FbV4U4AyJAYdCtzgHM9bg</a></p>
<p><a href="https://mp.weixin.qq.com/s/A9pLVDAIn-DGLbkkBgKmFA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/A9pLVDAIn-DGLbkkBgKmFA</a></p>
<p>CSS中的背景用法大全</p>
<p><a href="https://mp.weixin.qq.com/s/P5BmWbWGjpVKQnttQXi5zQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/P5BmWbWGjpVKQnttQXi5zQ</a></p>
<p>107条Javascript的常用语句</p>
<p><a href="https://mp.weixin.qq.com/s/eB6plUyXqGc1rwX9K9ZGKg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eB6plUyXqGc1rwX9K9ZGKg</a></p>
<p>display的32种写法</p>
<p><a href="https://mp.weixin.qq.com/s/Wk_1prutXU6bvt9gYxKQ2g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Wk_1prutXU6bvt9gYxKQ2g</a></p>
<p>60个非常实用的CSS代码片段，千万要收藏好了！</p>
<p><a href="https://mp.weixin.qq.com/s/uOlu39yKWe8B076vEXVPZA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uOlu39yKWe8B076vEXVPZA</a></p>
<p>浏览器缓存机制</p>
<p><a href="https://mp.weixin.qq.com/s/o0B38SgXj-2tcpPIr-x7Bw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/o0B38SgXj-2tcpPIr-x7Bw</a></p>
<p>ES6中常用的数组方法总结</p>
<p><a href="https://mp.weixin.qq.com/s/oEwhydO00rx7YtBV1Vz0yA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oEwhydO00rx7YtBV1Vz0yA</a></p>
<p>ES6中常用的对象方法总结</p>
<p><a href="https://mp.weixin.qq.com/s/GbIDW9PnUVi6MGJWL3Y4UQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GbIDW9PnUVi6MGJWL3Y4UQ</a></p>
<p>ES6中Promise方法总结</p>
<p><a href="https://mp.weixin.qq.com/s/1cbG6D1mWbLtUmwu2OIjQA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1cbG6D1mWbLtUmwu2OIjQA</a></p>
<p>一文搞懂ES6中的模块化</p>
<p><a href="https://mp.weixin.qq.com/s/p24ZtSV8vGmdUm2lKu5ksg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/p24ZtSV8vGmdUm2lKu5ksg</a></p>
<p>写给初中级前端的高级进阶指南（万字长文，建议收藏）</p>
<p><a href="https://mp.weixin.qq.com/s/vaVd_laecfCVth0s6SCOfQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vaVd_laecfCVth0s6SCOfQ</a></p>
<p>7种你应该知道的JavaScript常见的错误</p>
<p><a href="https://mp.weixin.qq.com/s/FbMv8YH6AVHxCeBYE1NzRw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FbMv8YH6AVHxCeBYE1NzRw</a></p>
<p>JavaScript的6种继承方式及其优缺点汇总</p>
<p><a href="https://mp.weixin.qq.com/s/CaT3-IeBuLx_ELo2BKMUcg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CaT3-IeBuLx_ELo2BKMUcg</a></p>
<p>能解决 80% 需求的 10个 CSS动画库</p>
<p><a href="https://mp.weixin.qq.com/s/s4A-KI1FepWcJjmevhJOsA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/s4A-KI1FepWcJjmevhJOsA</a></p>
<p>CSS calc()函数的用法</p>
<p><a href="https://mp.weixin.qq.com/s/YgRjhS7JX_pIf0oO2mb0zg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YgRjhS7JX_pIf0oO2mb0zg</a></p>
<p>10个非常实用的JS工具函数</p>
<p><a href="https://mp.weixin.qq.com/s/FF_-Mi2ntESUCWsEo4BB1Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FF_-Mi2ntESUCWsEo4BB1Q</a></p>
<p>我和大佬之间差一个JS工具函数大全…</p>
<p><a href="https://mp.weixin.qq.com/s/AdVQxNgj5gB5Z4CmfZX9-g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AdVQxNgj5gB5Z4CmfZX9-g</a></p>
<p>通过删除“ if-else”语句来清理代码</p>
<p><a href="https://mp.weixin.qq.com/s/LOOU0LPFPQH_jv93mR9KMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LOOU0LPFPQH_jv93mR9KMw</a></p>
<p>15条值得收藏的高效JS技巧</p>
<p><a href="https://mp.weixin.qq.com/s/EXAh91-qM4TmVm6D9Wxxig" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EXAh91-qM4TmVm6D9Wxxig</a></p>
<p>JSON.stringify() 的 5 个秘密特性</p>
<p><a href="https://mp.weixin.qq.com/s/wVF2VX5BZWLP2TbDWhqVVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wVF2VX5BZWLP2TbDWhqVVA</a></p>
<p>处理 JS中 undefined 的 7 个技巧</p>
<p><a href="https://mp.weixin.qq.com/s/KZYfxG54WcPnAQhNhBvYsQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KZYfxG54WcPnAQhNhBvYsQ</a></p>
<p>JavaScript 里的奇葩知识</p>
<p><a href="https://mp.weixin.qq.com/s/rQ3bFYxQYDNes1eJWl6zwg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rQ3bFYxQYDNes1eJWl6zwg</a></p>
<p>如何优雅的实现一个九宫格抽奖</p>
<p><a href="https://mp.weixin.qq.com/s/z58BmufL_vwCvy4C6NNAjg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/z58BmufL_vwCvy4C6NNAjg</a></p>
<p>JavaScript原型与继承的秘密</p>
<p><a href="https://mp.weixin.qq.com/s/Jvu48weJiAS1IejVd-QWYQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Jvu48weJiAS1IejVd-QWYQ</a></p>
<p><a href="https://www.cnblogs.com/ayseeing/p/3990815.html" target="_blank" rel="noopener">window的cmd窗口运行git</a></p>
<p><a href="https://www.cnblogs.com/ayseeing/p/3990815.html" target="_blank" rel="noopener">https://www.cnblogs.com/ayseeing/p/3990815.html</a></p>
<p>js判断苹果机型</p>
<p><a href="https://www.cnblogs.com/heroine/p/6710848.html" target="_blank" rel="noopener">https://www.cnblogs.com/heroine/p/6710848.html</a></p>
<p>「前端编程实战 57」HTML+CSS3实现效响应盒模型特效</p>
<p><a href="https://mp.weixin.qq.com/s/8jDmr5wehAeWg1o1XJaXfQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8jDmr5wehAeWg1o1XJaXfQ</a></p>
<p>手把手教你如何实现大量图片的自适应图片页面的排列</p>
<p><a href="https://mp.weixin.qq.com/s/G95WTM2pNkjkA7Qn8BmArg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/G95WTM2pNkjkA7Qn8BmArg</a></p>
<p>13 个 npm 快速开发技巧</p>
<p><a href="https://mp.weixin.qq.com/s/tK5X23Osg197gWvE_q_AhA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tK5X23Osg197gWvE_q_AhA</a></p>
<p>15个前端必须懂的linux命令</p>
<p><a href="https://mp.weixin.qq.com/s/-b9WxWtWwQMhXZkBMySjkA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-b9WxWtWwQMhXZkBMySjkA</a></p>
<p>js函数式编程术语总结</p>
<p><a href="https://mp.weixin.qq.com/s/WA00OYXKv73s7HWrVMOV1Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WA00OYXKv73s7HWrVMOV1Q</a></p>
<p>node 写爬虫，原来这么简单</p>
<p><a href="https://mp.weixin.qq.com/s/qfcfW4JXLrRjagTlIZl6mQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qfcfW4JXLrRjagTlIZl6mQ</a></p>
<p>重磅：小程序开放“分享朋友圈”功能</p>
<p><a href="https://mp.weixin.qq.com/s/EMULfoSjCf21MVJVhFK2Eg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EMULfoSjCf21MVJVhFK2Eg</a></p>
<p>强烈推介的几个微信小程序开发小技巧，简单又实用</p>
<p><a href="https://mp.weixin.qq.com/s/CuX3p0hKRHlxDYXyJlJo3g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CuX3p0hKRHlxDYXyJlJo3g</a></p>
<p>微信支持H5跳转App、跳转小程序</p>
<p><a href="https://mp.weixin.qq.com/s/KewfM91K5To1Jj_xMWqqPw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KewfM91K5To1Jj_xMWqqPw</a></p>
<p><strong>hookEvent</strong>,原来可以这样监听组件生命周期</p>
<p><a href="https://mp.weixin.qq.com/s/KL1jB5UYXNXOOF8gau0sFA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KL1jB5UYXNXOOF8gau0sFA</a></p>
<p>18款Webpack插件，总会有你想要的！</p>
<p><a href="https://mp.weixin.qq.com/s/GGEmCQVr7ShMcP6_KsmaMQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GGEmCQVr7ShMcP6_KsmaMQ</a></p>
<p>webpack原理</p>
<p><a href="https://mp.weixin.qq.com/s/Arx6XIzPhlUaEPpH_wLMjg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Arx6XIzPhlUaEPpH_wLMjg</a></p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>算法排序</title>
    <url>/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>简单递归</p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/01.png" alt="01"></p>
<a id="more"></a>

<p>冒泡排序</p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/02.png" alt="02"></p>
<p>插入排序</p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/03.png" alt="03"></p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/04.png" alt="04"></p>
<p>快速排序（<a href="https://www.bilibili.com/video/BV1b441117Rn/?spm_id_from=trigger_reload" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1b441117Rn/?spm_id_from=trigger_reload</a>）</p>
<p>简单版</p>
<p><img src="/2020/07/30/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/05.png" alt="05"></p>
<p>精简版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const quickSort &#x3D; function (arr) &#123;</span><br><span class="line">    if(arr.length &lt; 2) return arr;</span><br><span class="line">    &#x2F;&#x2F; 随机选择0～arr.length之间选一个基准值</span><br><span class="line">    const pivot &#x3D; Math.floor(Math.random() * arr.length)</span><br><span class="line">    &#x2F;&#x2F; 声明两个数组，分别用于存放比基准值小的数据和比基准值大的数据</span><br><span class="line">    let minArr &#x3D; [];</span><br><span class="line">    let maxArr &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 根据基准值填充数组</span><br><span class="line">    for(let i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 大于基准值就放maxArr里</span><br><span class="line">        if(arr[i] &gt;&#x3D; arr[pivot] &amp;&amp; i !&#x3D;&#x3D; pivot)&#123;</span><br><span class="line">            maxArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 小于基准值就放minArr里</span><br><span class="line">        if(arr[i] &lt; arr[pivot] &amp;&amp; i !&#x3D;&#x3D; pivot)&#123;</span><br><span class="line">            minArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 分别对基准值划分出来的数组递归调用快速排序，然后合并数组</span><br><span class="line">    return [...quickSort(minArr), arr[pivot], ...quickSort(maxArr)];</span><br><span class="line">&#125;</span><br><span class="line">测试</span><br><span class="line">const dataArr &#x3D; [3,5,8,1,2,9,4,7,6];</span><br><span class="line">console.log(quickSort(dataArr))</span><br></pre></td></tr></table></figure>

<p>快速排序优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @param arr 需要进行三路快排的数组</span><br><span class="line"> * @param L 数组的起始位置</span><br><span class="line"> * @param R 数组的末尾位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">function partition(arr, L, R) &#123;</span><br><span class="line">  if(L&gt;&#x3D;R)return;</span><br><span class="line">  let left&#x3D;L,right&#x3D;R;</span><br><span class="line">  let pivot&#x3D;arr[left]</span><br><span class="line">  while(left&lt;right)&#123;</span><br><span class="line">    while(left&lt;right&amp;&amp;arr[right]&gt;&#x3D;pivot)&#123;</span><br><span class="line">      right--</span><br><span class="line">    &#125;</span><br><span class="line">    if(left&lt;right)&#123;</span><br><span class="line">      arr[left]&#x3D;arr[right]</span><br><span class="line">    &#125;</span><br><span class="line">    while (left &lt; right &amp;&amp; arr[left] &lt;&#x3D; pivot) &#123;</span><br><span class="line">      left++</span><br><span class="line">    &#125;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">      arr[right] &#x3D; arr[left]</span><br><span class="line">    &#125;</span><br><span class="line">    if(left&gt;&#x3D;right)&#123;</span><br><span class="line">      arr[left]&#x3D;pivot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  partition(arr, L, right-1)</span><br><span class="line">  partition(arr, right+1, R)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">const dataArr &#x3D; [3, 5, 8, 1, 2, 9, 4, 7, 610, 0, -1];</span><br><span class="line">console.log(partition(dataArr, 0, dataArr.length - 1));</span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line">const dataArr &#x3D; [3,5,8,1,2,9,4,7,6];</span><br><span class="line">console.log(partition(dataArr,0,dataArr.length - 1));</span><br></pre></td></tr></table></figure>



<p>给对象按照某一个属性从小到大排序（对象排序）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var compare &#x3D; function (prop) &#123;</span><br><span class="line">  return function (obj1, obj2) &#123;</span><br><span class="line">      var val1 &#x3D; obj1[prop];</span><br><span class="line">      var val2 &#x3D; obj2[prop];</span><br><span class="line">      if (!isNaN(Number(val1)) &amp;&amp; !isNaN(Number(val2))) &#123;</span><br><span class="line">          val1 &#x3D; Number(val1);</span><br><span class="line">          val2 &#x3D; Number(val2);</span><br><span class="line">      &#125;</span><br><span class="line">      if (val1 &lt; val2) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">      &#125; else if (val1 &gt; val2) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [&#123; name: &quot;zlw&quot;, age: 25 &#125;, &#123; name: &quot;wlz&quot;, age: 30 &#125;, &#123; name: &quot;wlz&quot;, age: 27 &#125;, &#123; name: &quot;wlz&quot;, age: 29 &#125;];</span><br><span class="line">console.log(arr.sort(compare(&quot;age&quot;)));</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机设置相关</title>
    <url>/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="设置与关闭自启动软件"><a href="#设置与关闭自启动软件" class="headerlink" title="设置与关闭自启动软件"></a>设置与关闭自启动软件</h3><p>方法一：开机启动文件夹</p>
<p>1、我们打开文件夹：C:\Users（用户）\Administrator（当前用户名）\AppData\Roaming\Microsoft\Windows\Start Menu\Programs（「开始」菜单）\Programs（程序）\Startup（启动 ）即可找到启动文件夹，如图：</p>
<p>PS：也可以在运行中粘贴以下路径回车打开<br>%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup  </p>
<p>2、然后我们把软件的快捷方式，或是文件放到该启动文件夹中，Win10开机后就可以自动运行了。</p>
<h3 id="关闭允许计算机更改我的电脑提示"><a href="#关闭允许计算机更改我的电脑提示" class="headerlink" title="关闭允许计算机更改我的电脑提示"></a>关闭允许计算机更改我的电脑提示</h3><p>关闭是否允许计算器更改我的设置<br>控制面板\用户帐户\更改用户帐户控制设置，将滑块拉到最下面最后一个，如果要还原，拉到第二个</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>配置本地iis</title>
    <url>/2020/08/18/%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0iis/</url>
    <content><![CDATA[<h3 id="开启iis"><a href="#开启iis" class="headerlink" title="开启iis"></a>开启iis</h3><p>控制面板-程序-启用或者关闭windows功能</p>
<a id="more"></a>

<p><img src="https://i.loli.net/2020/08/18/ubYlvzxaKsMFrNn.png" alt="iis.png"></p>
<p>新建应用程序</p>
<p><img src="https://i.loli.net/2020/08/18/nT59tOQ8RxPYlC4.png" alt="应用程序.png"></p>
<p>生成解决方案时，需要新增Nuget包才能成功</p>
<p>工具-Nuget包管理器-程序包管理器设置-程序包源-新增-更新-确定-生成解决方案-编译成功</p>
]]></content>
      <categories>
        <category>iis</category>
      </categories>
      <tags>
        <tag>iis</tag>
        <tag>localhost</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之seekcy开发历程记录1</title>
    <url>/2020/10/29/vue%E4%B9%8Bseekcy%E5%BC%80%E5%8F%91%E5%8E%86%E7%A8%8B%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><h3 id="解决vue路由跳转未匹配路径时出现空白页的问题"><a href="#解决vue路由跳转未匹配路径时出现空白页的问题" class="headerlink" title="解决vue路由跳转未匹配路径时出现空白页的问题"></a>解决vue路由跳转未匹配路径时出现空白页的问题</h3><p>利用该特性，可以使用下面的代码端解决未匹配路由的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.matched.length ===<span class="number">0</span>) &#123;  <span class="comment">//如果未匹配到路由</span></span><br><span class="line">    <span class="keyword">from</span>.path? next(&#123; <span class="attr">path</span>:<span class="keyword">from</span>.path&#125;) : next(<span class="string">'/'</span>);   <span class="comment">//如果上级也未匹配到路由则跳转主页面，如果上级能匹配到则转上级路由</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();    <span class="comment">//如果匹配到正确跳转</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>2.匹配所有路由</p>
<p>路由的匹配规则是按照书写的顺序执行的，第一条匹配成功则不去匹配下一条，利用这一特性，可以在所有匹配路由的下面拦截匹配所有路由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由对象并配置路由规则</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">       &#123;<span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:&#123;<span class="attr">name</span>:<span class="string">"home"</span>&#125;&#125;,  <span class="comment">// 重定向到主页</span></span><br><span class="line">       &#123;<span class="attr">name</span>:<span class="string">'home'</span>,<span class="attr">path</span>:<span class="string">'/home'</span>,<span class="attr">component</span>:Home&#125;,</span><br><span class="line">       &#123;<span class="attr">name</span>:<span class="string">'login'</span>,<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:Login&#125;,</span><br><span class="line">       &#123;<span class="attr">path</span>:<span class="string">'*'</span>,<span class="attr">component</span>:NotFound&#125;,<span class="comment">//全不匹配的情况下，匹配NotFound组件，路由按顺序从上到下，依次匹配。最后一个*能匹配全部，</span></span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3.重定向</p>
<p>原理同方法2，只不过在匹配到*时，重定向到根路径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由对象并配置路由规则</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">       &#123;<span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:&#123;<span class="attr">name</span>:<span class="string">"home"</span>&#125;&#125;,  <span class="comment">// 重定向到主页</span></span><br><span class="line">       &#123;<span class="attr">name</span>:<span class="string">'home'</span>,<span class="attr">path</span>:<span class="string">'/home'</span>,<span class="attr">component</span>:Home&#125;,</span><br><span class="line">       &#123;<span class="attr">name</span>:<span class="string">'login'</span>,<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:Login&#125;,</span><br><span class="line">       &#123;<span class="attr">path</span>:<span class="string">'*'</span>,<span class="attr">redirect</span>:<span class="string">'/'</span>&#125;,<span class="comment">//路由按顺序从上到下，依次匹配。最后一个*能匹配全部，然后重定向到主页面</span></span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>报错</p>
<p><img src="https://img-blog.csdnimg.cn/2020082419134573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzA4NDI3NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><a href="mailto:vue-router@3.0">vue-router@3.0</a>版本及以上回调形式已经改成promise api的形式了，返回的是一个promise，如果路由地址跳转相同（<code>重复路由跳转</code>）, 且没有捕获到错误，控制台始终会出现如图所示的警告 （注：3.0以下版本则不会出现以下警告！！！，因路由回调问题…，可以直接降到3.0一下版本）</p>
<p><img src="/2020/10/29/vue%E4%B9%8Bseekcy%E5%BC%80%E5%8F%91%E5%8E%86%E7%A8%8B%E8%AE%B0%E5%BD%951/image-20201102193540065.png" alt="image-20201102193540065"></p>
<p>问题出现原因：<code>重复路由跳转</code>，比如说当前路由是商品详情页面/goodsDetail，但是点击按钮进行this.$router.push操作，要跳转的还是商品详情页面/goodsDetail。</p>
<p>综合解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">const originalPush &#x3D; Router.prototype.push</span><br><span class="line">Router.prototype.push &#x3D; function push(location) &#123;</span><br><span class="line">  return originalPush.call(this, location).catch(err &#x3D;&gt; err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：官方vue-router@3.0及以上新版本路由默认回调返回的都是promise，原先旧版本的路由回调将废弃！！！！</span><br></pre></td></tr></table></figure>



<h3 id="addRoutes"><a href="#addRoutes" class="headerlink" title="addRoutes"></a>addRoutes</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$router.addRoutes(</span><br><span class="line">    routeData.concat([</span><br><span class="line">        &#123; path: &#39;&#x2F;404&#39;, component: NotFound &#125;,</span><br><span class="line">        &#123; path: &#39;*&#39;, redirect: &#39;&#x2F;404&#39; &#125;</span><br><span class="line">    ])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>







<h2 id="指令（directive）"><a href="#指令（directive）" class="headerlink" title="指令（directive）"></a>指令（directive）</h2><p>全局的自定义指令需要写在 <strong>new Vue()</strong> 的前面</p>
<h3 id="v-focus-自定义指令解决autofocus失效"><a href="#v-focus-自定义指令解决autofocus失效" class="headerlink" title="v-focus(自定义指令解决autofocus失效)"></a>v-focus(自定义指令解决autofocus失效)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">    focus: &#123;</span><br><span class="line">      inserted: function(el) &#123;</span><br><span class="line">        el.querySelector(&quot;input&quot;).focus();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="动态指令参数"><a href="#动态指令参数" class="headerlink" title="动态指令参数"></a>动态指令参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div @click&#x3D;&quot;link&quot; v-style:[mystyle]&#x3D;&quot;&#39;100px&#39;&quot;&gt;带参数跳转&lt;&#x2F;div&gt;</span><br><span class="line">js</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    	mystyle: &#39;margin&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">main.js</span><br><span class="line">Vue.directive(&quot;style&quot;, function (el, binding, vnode) &#123;</span><br><span class="line">    el.style[binding.arg] &#x3D; binding.value </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="高精度权限控制—自定义指令directive"><a href="#高精度权限控制—自定义指令directive" class="headerlink" title="高精度权限控制—自定义指令directive"></a>高精度权限控制—自定义指令directive</h3><p>我们先在新建个 array.js 文件，用于存放与权限相关的全局函数；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; array.js</span><br><span class="line">export function checkArray (key) &#123;</span><br><span class="line">  let arr &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;demo&#39;]</span><br><span class="line">  let index &#x3D; arr.indexOf(key)</span><br><span class="line">  if (index &gt; -1) &#123;</span><br><span class="line">    return true &#x2F;&#x2F; 有权限</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false &#x2F;&#x2F; 无权限</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在将 array 文件挂载到全局中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import &#123; checkArray &#125; from &quot;.&#x2F;common&#x2F;array&quot;;</span><br><span class="line">Vue.directive(&quot;permission&quot;, &#123;</span><br><span class="line">  inserted (el, binding) &#123;</span><br><span class="line">    let permission &#x3D; binding.value; &#x2F;&#x2F; 获取到 v-permission的值</span><br><span class="line">    if (permission) &#123;</span><br><span class="line">      let hasPermission &#x3D; checkArray(permission);</span><br><span class="line">      if (!hasPermission) &#123; &#x2F;&#x2F; 没有权限 移除Dom元素</span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后我们在页面中就可以通过自定义指令 v-permission 来判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;btns&quot;&gt;</span><br><span class="line">    &lt;button v-permission&#x3D;&quot;&#39;1&#39;&quot;&gt;权限按钮1&lt;&#x2F;button&gt;  &#x2F;&#x2F; 会显示</span><br><span class="line">    &lt;button v-permission&#x3D;&quot;&#39;2&#39;&quot;&gt;权限按钮2&lt;&#x2F;button&gt;  &#x2F;&#x2F; 无显示</span><br><span class="line">    &lt;button v-permission&#x3D;&quot;&#39;demo&#39;&quot;&gt;权限按钮demo&lt;&#x2F;button&gt; &#x2F;&#x2F; 会显示</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h2 id="修改dev地址为自动获取本地ip"><a href="#修改dev地址为自动获取本地ip" class="headerlink" title="修改dev地址为自动获取本地ip"></a>修改dev地址为自动获取本地ip</h2><p><img src="/2020/10/29/vue%E4%B9%8Bseekcy%E5%BC%80%E5%8F%91%E5%8E%86%E7%A8%8B%E8%AE%B0%E5%BD%951/image-20201103113345574.png" alt="image-20201103113345574"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 修改启动时浏览器地址localhost为自动获取本地ip,并以ip为地址 *&#x2F;</span><br><span class="line">const os &#x3D; require(&#39;os&#39;)</span><br><span class="line">let localhost &#x3D; &#39;&#39;</span><br><span class="line">try &#123;</span><br><span class="line">    const network &#x3D; os.networkInterfaces()</span><br><span class="line">    localhost &#x3D; network[Object.keys(network)[0]][1].address</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    localhost &#x3D; &#39;localhost&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tips:上述代码有可能获取到127.0.0.1，也有可能获取到ip，建议使用下面的方法</span><br><span class="line">const os &#x3D; require(&#39;os&#39;).networkInterfaces()</span><br><span class="line">function getIP() &#123;</span><br><span class="line">  var interfaces &#x3D; os;</span><br><span class="line">  console.log(interfaces)</span><br><span class="line">  for (var devName in interfaces) &#123;</span><br><span class="line">    var iface &#x3D; interfaces[devName];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; iface.length; i++) &#123;</span><br><span class="line">      var alias &#x3D; iface[i];</span><br><span class="line">      if (alias.family &#x3D;&#x3D;&#x3D; &#39;IPv4&#39; &amp;&amp; alias.address !&#x3D;&#x3D; &#39;127.0.0.1&#39; &amp;&amp; !alias.internal) &#123;</span><br><span class="line">        return alias.address;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">localhost &#x3D; getIP();</span><br></pre></td></tr></table></figure>



<h3 id="在npm-run-dev之后，Vue都做了哪些工作呢"><a href="#在npm-run-dev之后，Vue都做了哪些工作呢" class="headerlink" title="在npm run dev之后，Vue都做了哪些工作呢"></a>在npm run dev之后，Vue都做了哪些工作呢</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/4MXV7svuTWI1DCpR2ibcNHRdddtrc6czxjKO7rwKyUgyZtBCrvxa365vxKamvibPGDEAoEqxdYicWdsCj4nib0siaEA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其实很简单，Vue类里面其实就是调用了一个_init方法，这一段代码调用了五个方法，并传入了Vue类。</p>
<p>initMixin，它的作用是给vue的原型链里加入Vue类里调用的_init方法</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/4MXV7svuTWI1DCpR2ibcNHRdddtrc6czxU3WA03eWNCEfpgJtdhXGjCINeTiadxbAMB7lFcd0CAOtX36wysuVTzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">stateMixin也和前面的initMixin类似，其实就是往Vue的原型里注入了$data,$props属性，以及$set、$delete 以及 $watch方法。</span><br><span class="line"></span><br><span class="line">eventMixin就是往vue原型链里注入了事件的监听与触发，即我们常用的$emit，$on。</span><br><span class="line"></span><br><span class="line">lifecycleMixin，就是注入了一些生命周期函数。</span><br><span class="line"></span><br><span class="line">renderMixin就和后面的具体编译有关。</span><br></pre></td></tr></table></figure>



<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>查看三部曲：</p>
<ul>
<li>build文件夹下的utils.js 中 publicPath：” ../../“</li>
<li>config 中的 index.js 中 assetsPublicPath: “./“</li>
<li>webpack.prod.conf.js 中 output模块中添加 publicPath: “./“</li>
</ul>
<p>总结一下，vue里面引用图片在打包后仍能正常使用的正确引用方式：</p>
<ul>
<li><p><strong>html内：</strong>img src以相对路径引入；</p>
</li>
<li><p><strong>css：</strong>style以background属性作为背景图片以相对路径引入，需以类名方式引入，行内样式可能会不生效；</p>
</li>
<li><p><strong>js：</strong>以require(‘…/url’)引入，赋予变量；</p>
</li>
</ul>
<h3 id="js-css找不到"><a href="#js-css找不到" class="headerlink" title="js/css找不到"></a>js/css找不到</h3><p>因为项目打包后的CSS和JS的引用路径是绝对路径，项目部署后会将静态当成根目录，就造成了文件引用路径的错误，解决方法是通过修改配置文件，将绝对路径改为相对路径，从而达到资源的相对引用。</p>
<p>一。<strong>‘/’指的是项目的根目录 ，’./’指的是当前目录</strong></p>
<p>1.publicPath 并不会对生成文件的路径造成影响，主要是对你的页面里面引入的资源的路径做对应的补全，常见的就是css文件里面引入的图片</p>
<p>2.assetsPublicPath属性作用是指定编译发布的根目录</p>
<p>具体操作如下：</p>
<p>1.打开webpack.prod.conf.js；</p>
<p>2.在output模块中添加 publicPath: ‘./‘ ，如下图所示：</p>
<p><img src="https://img2018.cnblogs.com/blog/1149000/201901/1149000-20190108162846264-467114685.png" alt="img"></p>
<h3 id="背景图片找不到"><a href="#背景图片找不到" class="headerlink" title="背景图片找不到"></a>背景图片找不到</h3><p>修改打包后背景图片的引用路径<br>资源内的图片是通过css加载的，CSS代码如：background：url（../ assets / img-bg / buttonbg.png）no-repeat;</p>
<p>但是打包过后的CSS变成了背景：url（../../ static / img / buttonbg.68979b3.png）no-repeat;我们需要修改配置文件，是的CSS代码打包后，资源引用路径还是相对路径;</p>
<p>解决办法：</p>
<p>1.打开build文件夹下的utils.js ;</p>
<p>2.在下图位置添加 publicPath：” ../../</p>
<p> <img src="https://img2018.cnblogs.com/blog/1149000/201901/1149000-20190108162728713-1887350521.png" alt="img"></p>
<h3 id="router-view中的内容显示不出来（关闭路由history模式）"><a href="#router-view中的内容显示不出来（关闭路由history模式）" class="headerlink" title="router-view中的内容显示不出来（关闭路由history模式）"></a>router-view中的内容显示不出来（关闭路由history模式）</h3><p><strong>第二个问题：router-view中的内容显示不出来。</strong>路由history模式。</p>
<p>这个坑是当你使用了路由之后，<strong>在没有后端配合的情况下就手贱打开路由history模式的时候</strong>，打包出来的文件也会是一片空白的情况，</p>
<p>很多人踩这个坑的时候花了很多时间，网上的教程基本上都是说的第一个坑，这个坑很少有人提起。</p>
<p><strong><img src="https://images2017.cnblogs.com/blog/1202246/201711/1202246-20171121095445961-1591205997.png" alt="img"></strong></p>
<p>解决：<code>// mode: &#39;history&#39;,//将这个模式关闭就好</code></p>
<h3 id="打包出错显示空白页，或者Failed-to-load-resource-net-ERR-FILE-NOT-FOUND"><a href="#打包出错显示空白页，或者Failed-to-load-resource-net-ERR-FILE-NOT-FOUND" class="headerlink" title="打包出错显示空白页，或者Failed to load resource: net::ERR_FILE_NOT_FOUND"></a>打包出错显示空白页，或者Failed to load resource: net::ERR_FILE_NOT_FOUND</h3><p>解决办法</p>
<p>​        webpack.prod.conf.js 中output添加参数publicPath:’./‘</p>
<p><img src="https://img-blog.csdnimg.cn/20191104102906668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjcxOTk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="Vue-elementUI-build打包部署后字体图标丢失，控制台显示文件element-icons-woff和element-icons-ttf文件404"><a href="#Vue-elementUI-build打包部署后字体图标丢失，控制台显示文件element-icons-woff和element-icons-ttf文件404" class="headerlink" title="Vue+elementUI  build打包部署后字体图标丢失，控制台显示文件element-icons.woff和element-icons.ttf文件404"></a>Vue+elementUI  build打包部署后字体图标丢失，控制台显示文件element-icons.woff和element-icons.ttf文件404</h3><p><img src="https://img2018.cnblogs.com/blog/935329/201905/935329-20190528164613052-25776252.png" alt="img"></p>
<p>解决办法</p>
<p>webpack utils.js 修改：（build目录下utils.js）</p>
<p>添加  publicPath: ‘../../‘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (options.extract) &#123;</span><br><span class="line">    return ExtractTextPlugin.extract(&#123;</span><br><span class="line">        use: loaders,</span><br><span class="line">        fallback: &#39;vue-style-loader&#39;,</span><br><span class="line">        publicPath: &#39;..&#x2F;..&#x2F;&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	return [&#39;vue-style-loader&#39;].concat(loaders)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><blockquote>
<p>You have not concluded your merge (MERGE_HEAD exists). Please, commit your changes before you can merge.</p>
</blockquote>
<h4 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h4><p>上一次pull的代码有冲突自动合并失败，在下一次pull之前你没有很好的解决这个冲突</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>撤销这次合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git merge --abort</span><br><span class="line">2、git reset --merge</span><br></pre></td></tr></table></figure>
<p>3、解决冲突<br>4、<code>git add</code>和<code>git commit</code><br>5、 这时候<code>git pull</code>应该就可以使用了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## js</span><br><span class="line"></span><br><span class="line">### 采用函数式编程的思想求数组对象中某个属性的值之和</span><br></pre></td></tr></table></figure>
<p>const programmerOutput = [<br>  {<br>    name: ‘Uncle Bobby’,<br>    linesOfCode: 500<br>  }, {<br>    name: ‘Suzie Q’,<br>    linesOfCode: 1500<br>  }, {<br>    name: ‘Jimmy Gosling’,<br>    linesOfCode: 150<br>  }, {<br>    name: ‘Gracie Hopper’,<br>    linesOfCode: 1000<br>  }<br>];</p>
<p>var totalOutput = programmerOutput<br>  .map((programmer) =&gt; programmer.linesOfCode)<br>  .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, 0);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 使用 Object.assign 设置函数参数的默认对象</span><br><span class="line"></span><br><span class="line">&#96;Object.assign&#96;方法的第一个参数是目标对象，后面的参数都是源对象。</span><br><span class="line"></span><br><span class="line">&#96;Object.assign&#96;方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</span><br><span class="line"></span><br><span class="line">注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</span><br></pre></td></tr></table></figure>
<p>var menuConfig = {<br>  title: null,<br>  body: ‘Bar’,<br>  buttonText: null,<br>  cancellable: true<br>}</p>
<p>function createMenu(config) {<br>  config.title = config.title || ‘Foo’<br>  config.body = config.body || ‘Bar’<br>  config.buttonText = config.buttonText || ‘Baz’<br>  config.cancellable = config.cancellable === undefined ? config.cancellable : true;</p>
<p>}</p>
<p>//使用Object.assign<br>var menuConfig = {<br>  title: ‘Order’,<br>  // User did not include ‘body’ key<br>  buttonText: ‘Send’,<br>  cancellable: true<br>}</p>
<p>function createMenu(config) {<br>  config = Object.assign({<br>    title: ‘Foo’,<br>    body: ‘Bar’,<br>    buttonText: ‘Baz’,<br>    cancellable: true<br>  }, config);<br>}</p>
<p>createMenu(menuConfig);<br>//{ “title”: “Order”, “body”: “Bar”, “buttonText”: “Send”, “cancellable”: true}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 判断数组和数组对象中是否有重复值</span><br><span class="line"></span><br><span class="line">数组：</span><br></pre></td></tr></table></figure>
<p>简单方式一<br>const elementsAreEqual = array =&gt; array.some(el =&gt; el === array[0]);<br>elementsAreEqual([9, 8, 7, 7, 5]); // true<br>复杂方式二<br>isRepeat(arr) {<br>            var hash = {};<br>            let that = this;<br>            for (var i in arr) {<br>                if (hash[arr[i]]){<br>                    that.repeatSn = arr[i];<br>                    return true;<br>                }<br>                hash[arr[i]] = true;<br>            }<br>            return false;<br>        },<br>true – 有重复值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">数组对象</span><br></pre></td></tr></table></figure>
<p>isRepeat(arr) {<br>      for (var i = 0; i &lt; arr.length - 1; i++) {<br>        for (var j = i + 1; j &lt; arr.length; j++) {<br>          if (arr[i].sn === arr[j].sn) {<br>            this.repeatSn=arr[i].sn;<br>            return false;<br>          }<br>        }<br>      }<br>      return true;<br>    },<br>false – 有重复值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 返回数字数组中的最大值（一个或多个）</span><br></pre></td></tr></table></figure>
<p>const maxElementsFromArray = (array, len = 1) =&gt; […array].sort((x, y) =&gt; y - x).slice(0, len);</p>
<p>maxElementsFromArray([1, 2, 3, 4, 5]); // [5]<br>maxElementsFromArray([7, 8, 9, 10, 10], 2); // [10, 10]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 论如何优雅的取随机字符串</span><br></pre></td></tr></table></figure>
<p>Math.random().toString(16).substring(2) // 13位<br>Math.random().toString(36).substring(2) // 11位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 如何优雅的实现金钱格式化</span><br><span class="line"></span><br><span class="line">用正则魔法实现：</span><br></pre></td></tr></table></figure>
<p>var test1 = ‘1234567890’<br>var format = test1.replace(/\B(?=(\d{3})+(?!\d))/g, ‘,’)<br>console.log(format) // 1,234,567,890</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">非正则的优雅实现：</span><br></pre></td></tr></table></figure>
<p> function formatCash(str) {<br>       return str.split(‘’).reverse().reduce((prev, next, index) =&gt; {<br>            return ((index % 3) ? next : (next + ‘,’)) + prev<br>       })<br>}<br>console.log(formatCash(‘1234567890’)) // 1,234,567,890</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 论如何最佳的让两个整数交换数值</span><br></pre></td></tr></table></figure>
<p>a ^= b;<br>b ^= a;<br>a ^= b;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 用最短的代码实现一个长度为m(6)且值都n(8)的数组</span><br></pre></td></tr></table></figure>
<p>Array(6).fill(8)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 短路表达式</span><br></pre></td></tr></table></figure>
<p>var a = b &amp;&amp; 1<br>    // 相当于<br>if (b) {<br>    a = 1<br>} else {<br>    a = b<br>}<br>var a = b || 1<br>    // 相当于<br>if (b) {<br>    a = b<br>} else {<br>    a = 1<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### js提取字符串中的数字</span><br></pre></td></tr></table></figure>
<p>1.前面带数字,后面非数字,可以直接用parseFloat()函数:<br>var num1 = parseFloat(“2.89元”); //num1 : 2.89</p>
<p>2.像”生于1999年”这样字符串中只含有一个整型数值的字符串,直接使用正则表达式将数字的字符删除掉就行<br>var str1 = ‘生于1999年’;<br>var num1 = str1.replace(/[^\d]/g,’ ‘);</p>
<p>3.对于字符串中含有多数值,使用字符串的match方法,通过正则表达式提取字符串的所有数字(包含整数和小数):<br>var str=”1 plus 2 equal 3”<br>var arr=str.match(/\d+/g)<br>// arr: [‘1’,’2’,’3’]</p>
<p>var str = ‘大米:2.57斤/元,白菜:3.65元/斤’;<br>var arr = str.match(/\d+(.\d+)?/g);<br>// arr: [“2.75”,”3.65”]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 类型转换那些事</span><br></pre></td></tr></table></figure>
<p>Number(‘324abc’) // NaN<br>只要有一个字符无法转成数值，整个字符串就会被转为NaN</p>
<p>parseInt(‘32a3’) //32<br>逐个解析字符，遇到不能转换的字符就停下来</p>
<p>//对象<br>String({a: 1}) // “[object Object]”<br>String([1, 2, 3]) // “1,2,3”</p>
<p>Boolean(new Boolean(false)) //true</p>
<p>自动转换为布尔值<br>在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用Boolean函数<br>可以得出个小结：<br>undefined<br>null<br>false<br>+0<br>-0<br>NaN<br>“”<br>除了上面几种会被转化成false，其他都换被转化成true</p>
<p>自动转换成字符串<br>遇到预期为字符串的地方，就会将非字符串的值自动转为字符串<br>具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串<br>常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作<br>‘5’ + 1 // ‘51’<br>‘5’ + true // “5true”<br>‘5’ + false // “5false”<br>‘5’ + {} // “5[object Object]”<br>‘5’ + [] // “5”<br>‘5’ + function (){} // “5function (){}”<br>‘5’ + undefined // “5undefined”<br>‘5’ + null // “5null”</p>
<p>自动转换成数值<br>除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值<br>‘5’ - ‘2’ // 3<br>‘5’ * ‘2’ // 10<br>true - 1  // 0<br>false - 1 // -1<br>‘1’ - 1   // 0<br>‘5’ * []    // 0<br>false / ‘5’ // 0<br>‘abc’ - 1   // NaN<br>null + 1 // 1<br>undefined + 1 // NaN<br>null转为数值时，值为0 。undefined转为数值时，值为NaN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 对于如何替换JS字符串中匹配到多处中某一指定节点</span><br></pre></td></tr></table></figure>
<p>const str =”这是主体内容，有很多内容，喜欢看这个内容就关注吧”;<br>const reg = new RegExp(‘内容‘, ‘g‘);<br>let ret;<br>const arr=[];<br>while((ret = reg.exec(str))!==null) {<br>    arr.push({id:ret.index,content:ret.input})<br>}<br>const replaceStr = (strs, index, text,len) =&gt; {<br>    return strs.substring(0, index) + text + strs.substring(index + len);<br>};<br> // 替换文本的第三处“内容”为 “文章”<br>const newVal= replaceStr(str, arr[2].id, ‘文章‘,2);<br>console.log(newVal)  // 这是主体内容，有很多内容，喜欢看这个文章就关注吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 打字机动画</span><br></pre></td></tr></table></figure>
<p>(function () {<br>  const container = document.getElementById(‘content’)<br>  const data = ‘与 setTimeout 相比，requestAnimationFrame 最大的优势是 由系统来决定回调函数的执行时机。具体一点讲就是，系统每次绘制之前会主动调用 requestAnimationFrame 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，requestAnimationFrame 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。’.split(‘’)<br>  let index = 0<br>  function writing() {<br>        if (index &lt; data.length) {<br>          container.innerHTML += data[index++]<br>          window.requestAnimationFrame(writing)<br>          //减慢速度<br>          setTimeout(() =&gt; {<br>            window.requestAnimationFrame(writing)<br>          }, 200);<br>          //<br>      }<br>  }<br>      writing()<br>})();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 小技巧</span><br></pre></td></tr></table></figure>
<ol>
<li><p>交换两个变量<br>[x, y] = [y, x];</p>
</li>
<li><p>多条件检查<br>if ([1, ‘one’, 2, ‘two’].indexOf(value) &gt;= 0) {<br> // Execute some code<br>}</p>
</li>
</ol>
<p>if ([1, ‘one’, 2, ‘two’].includes(value)) {<br>    // Execute some code<br>}</p>
<ol start="3">
<li><p>对象属性复制<br>let firstname = ‘Amitav’;<br>let lastname = ‘Mishra’;<br>let obj = {firstname, lastname};</p>
</li>
<li><p>重复一个字符串多次<br>‘sorry\n’.repeat(100);</p>
</li>
<li><p>指数幂<br>const power = 4**3</p>
</li>
<li><p>双非位运算符 (<del>)<br>const floor = ~</del>6.8;</p>
</li>
</ol>
<p>7.找出数组中的最大和最小数字<br>const arr = [2, 8, 15, 4];<br>Math.max(…arr); // 15<br>Math.min(…arr); // 2</p>
<p>8.深拷贝多级对象<br>let obj = {x: 20, y: {z: 30}};<br>//Longhand<br>const makeDeepClone = (obj) =&gt; {<br>  let newObject = {};<br>  Object.keys(obj).map(key =&gt; {<br>    if(typeof obj[key] === ‘object’){<br>      newObject[key] = makeDeepClone(obj[key]);<br>    } else {<br>      newObject[key] = obj[key];<br>    }<br>  });<br> return newObject;<br>}<br>const cloneObj = makeDeepClone(obj);</p>
<p>//Shorthand<br>const cloneObj = JSON.parse(JSON.stringify(obj));</p>
<p>//Shorthand for single level object<br>let obj = {x: 20, y: ‘hello’};<br>const cloneObj = {…obj};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### !!</span><br></pre></td></tr></table></figure>
<p>如何把一个任意类型的值转换为布尔类型？<br>用！！ 一个！是取非 再一个！又取非 相当于把这个数据转换为boolen类型了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 数阶乘</span><br></pre></td></tr></table></figure>
<p>const factorialOfNumber = number =&gt;<br>  number &lt; 0<br>    ? (() =&gt; {<br>      throw new TypeError(‘No negative numbers please’);<br>    })()<br>    : number &lt;= 1<br>      ? 1<br>      : number * factorialOfNumber(number - 1);</p>
<p>factorialOfNumber(4); // 24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 整数转数组</span><br></pre></td></tr></table></figure>
<p>const convertToArray = number =&gt; […<code>${number}</code>].map(el =&gt; parseInt(el))</p>
<p>convertToArray(5678); // [5, 6, 7, 8]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 检查是否为2的幂数</span><br></pre></td></tr></table></figure>
<p>const isNumberPowerOfTwo = number =&gt; !!number &amp;&amp; (number &amp; (number - 1)) === 0;</p>
<p>isNumberPowerOfTwo(100); // false<br>isNumberPowerOfTwo(128); // true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 生成一个0-999顺序的列表</span><br></pre></td></tr></table></figure>
<p>Array.from({ length: 1000 }, (v, i) =&gt; i)<br>// [0, 1, 2, 3, 4, 5, 6….999]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### RGB→转换为十六进制</span><br></pre></td></tr></table></figure>
<p>var rgb2hex = (r, g, b) =&gt; {<br>    return ‘#’+ ((1&lt;&lt;24)+(r&lt;&lt;16)+(g&lt;&lt;8)+b)<br>    .toString(16)//转成16进制，返回字符串<br>    .substr(1);//去除字符串的最高位，返回后面六个字符串<br>}<br>var rgb2hex = (r, g, b) =&gt; ‘#’+ ((1&lt;&lt;24)+(r&lt;&lt;16)+(g&lt;&lt;8)+b).toString(16).substr(1);<br>rgb2hex(76, 11, 181);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 转换十六进制→RGB</span><br></pre></td></tr></table></figure>
<p>const hex2rgb = hex =&gt; [1, 3, 5].map((h) =&gt; parseInt(hex.substring(h, h + 2), 16));</p>
<p>hex2rgb(“#4c0bb5”);<br>// [76, 11, 181]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## vue全局防抖和节流</span><br></pre></td></tr></table></figure>
<p>// 防抖处理-立即执行<br>const on = Vue.prototype.$on<br>Vue.prototype.$on = function (event, func) {<br>  let timer;<br>  let flag = true;<br>  let newFunc = func<br>  if (event == ‘click’) {<br>    newFunc = function () {<br>      if(flag) {<br>        func.apply(this, arguments)<br>        flag = false<br>      }<br>      clearTimeout(timer)<br>      timer = setTimeout(function () {<br>        flag = true<br>      }, 500)<br>    }<br>  }<br>  on.call(this, event, newFunc)<br>}</p>
<p>// 防抖处理 – 最后执行<br>const on = Vue.prototype.$on<br>Vue.prototype.$on = function (event, func) {<br>  let timer<br>  let newFunc = func<br>  if (event === ‘click’) {<br>    newFunc = function () {<br>      clearTimeout(timer)<br>      timer = setTimeout(function () {<br>        func.apply(this, arguments)<br>      }, 500)<br>    }<br>  }<br>  on.call(this, event, newFunc)<br>}</p>
<p>// 节流<br>const on = Vue.prototype.$on<br>Vue.prototype.$on = function (event, func) {<br>  let previous = 0<br>  let newFunc = func<br>  if (event === ‘click’) {<br>    newFunc = function () {<br>      const now = new Date().getTime()<br>      if (previous + 1000 &lt;= now) {<br>        func.apply(this, arguments)<br>        previous = now<br>      }<br>    }<br>  }<br>  on.call(this, event, newFunc)<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 支持webp格式图片</span><br><span class="line"></span><br><span class="line">npm install file-loader</span><br></pre></td></tr></table></figure>
<p>rules中新增</p>
<p>{<br>                test: /.webp$/,<br>                use: [<br>                    {<br>                        loader: ‘file-loader’,<br>                        query: {<br>                            limit: 10000,<br>                            name: utils.assetsPath(‘img/[name].[hash:7].[ext]’)<br>                        }<br>                    }<br>                ]<br>}</p>
<p>服务器可能不支持webp格式图片，做了拦截<br>原来是服务器上面不能解析webp，自己在百度上面上找到了方法解决，在iis的MIME类型中中添加webp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 标签中src循环图片</span><br></pre></td></tr></table></figure>
<img :src="require('../../../static/imgs/board/'+item.url+'.png')" style="width:36px">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 禁止蒙层底部页面跟随滚动</span><br><span class="line"></span><br><span class="line">将页面固定视窗后，内容会回头最顶端，这里我们需要记录一下，同步top值。</span><br></pre></td></tr></table></figure>
let bodyEl = document.body
let top = 0
data() {
    return {
        isFixed: true
    }
},
watch: {
    isFixed() {
        this.stopBodyScroll();
    }
},

<p>function stopBodyScroll (isFixed) {<br>  if (this.isFixed) {<br>    top = window.scrollY<br>    bodyEl.style.position = ‘fixed’<br>    bodyEl.style.top = -top + ‘px’<br>  } else {<br>    bodyEl.style.position = ‘’<br>    bodyEl.style.top = ‘’<br>    window.scrollTo(0, top) // 回到原先的top<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## css</span><br><span class="line"></span><br><span class="line">css文字超出显示省略号</span><br><span class="line"></span><br><span class="line">### 单号：</span><br></pre></td></tr></table></figure>
<p>white-space:nowrap;<br>overflow:hidden;<br>text-overflow:ellipsis;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 多行：</span><br></pre></td></tr></table></figure>
<p>word-break: break-all;<br>text-overflow: ellipsis;<br>overflow: hidden;<br>display: -webkit-box;<br>-webkit-line-clamp: 2;<br>-webkit-box-orient: vertical;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 移动端0.5px</span><br></pre></td></tr></table></figure>
<p>/* 底边框 */<br>.b-border {<br>  position: relative;<br>}<br>.b-border:before {<br>  content: ‘’;<br>  position: absolute;<br>  left: 0;<br>  bottom: 0;<br>  width: 100%;<br>  height: 1px;<br>  background: #d9d9d9;<br>  -webkit-transform: scaleY(0.5);<br>  transform: scaleY(0.5);<br>  -webkit-transform-origin: 0 0;<br>  transform-origin: 0 0;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 文字和图片的模糊效果</span><br></pre></td></tr></table></figure>
<p>文字<br>{<br>color: transparent;<br>text-shadow: #111 0 0 5px;<br>}</p>
<p>图片<br>{filter: blur(10px);}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 多重边框</span><br></pre></td></tr></table></figure>
<p>div {<br>    box-shadow: 0 0 0 6px rgba(0, 0, 0, 0.2), 0 0 0 12px rgba(0, 0, 0, 0.2), 0 0 0 18px rgba(0, 0, 0, 0.2), 0 0 0 24px rgba(0, 0, 0, 0.2);<br>    height: 200px;<br>    margin: 50px auto;<br>    width: 400px<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![图片](https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_png&#x2F;JIv7z1kbomC1q64N8lmP3G4pmFoVadU1pJSIJvFyqr5aGADc7ibWE0lKAibtUG9bicIMWSCBVd5icJyssbG2JiahpLQ&#x2F;640?wx_fmt&#x3D;png&amp;tp&#x3D;webp&amp;wxfrom&#x3D;5&amp;wx_lazy&#x3D;1&amp;wx_co&#x3D;1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 不用使用:last-child()&#123;border:none&#125;技巧</span><br></pre></td></tr></table></figure>
<p>ul {<br>    width: 200px;<br>    margin: auto;<br>    list-style: none;<br>    padding: 0;<br>    border: 1px solid red;<br>    text-align: center;<br>}</p>
<p>li + li {<br>    border-top: 1px solid red;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20210326143420979](vue之seekcy开发历程记录1.assets&#x2F;image-20210326143420979.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 瀑布流布局</span><br></pre></td></tr></table></figure>
<p>html<br><template><br>    <div class="waterfall"><br>        <div v-for="(item,index) in 20" :style="{height:heights[Math.floor(Math.random()*4)] + 'px',background:colors[Math.floor(Math.random()*12)]}" :key="index"><br>            <br>        </div><br>    </div><br></template></p>
<p>js<br>data() {<br>        return {<br>            //模拟随机高度<br>            heights: [200, 250, 150, 300],<br>            //颜色尽量随机,区别每个模块<br>            colors: [‘#eccf2c’, ‘#b8232c’, ‘#125d9e’, ‘#367945’, ‘#fca91b’, ‘#26ada7’, ‘#77bfbf’, ‘#ff5c87’,<br>                ‘#f40’, ‘#ee2061’, ‘#feee39’, ‘#f5a79a’, ‘#ec70d0’, ‘#b4a1cf’]<br>        }<br>}</p>
<p>css<br>.waterfall {<br>    width: 400px;<br>    margin: 0 auto;<br>    column-count: 3;<br>    column-gap: 10px;<br>}<br>.waterfall &gt; div {<br>    break-inside: avoid;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### pointer-events属性</span><br><span class="line"></span><br><span class="line">pointer-events是css3的一个属性，指定在什么情况下元素可以成为鼠标事件的target（包括鼠标的样式）</span><br><span class="line"></span><br><span class="line">属性值：</span><br><span class="line"></span><br><span class="line">- auto——效果和没有定义pointer-events属性相同，鼠标不会穿透当前层。在SVG中，该值和visiblePainted的效果相同。</span><br><span class="line">- none——元素永远不会成为鼠标事件的[target](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;event.target)（目标）。但是，当其后代元素的&#96;pointer-events&#96;属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。实际上默  认就可以穿透当前层，因为pointer-events默认为auto</span><br></pre></td></tr></table></figure>
<p>案例一：禁用 a 标签事件效果</p>
<p>在做 tab 切换的时候，当选中当前项，禁用当前标签的事件，只有切换其他 tab 的时候，才重新请求新的数据。</p>
 <!--CSS-->
 <style>
     .active{
         pointer-events: none;
     }
 </style>
 <!--HTML-->
 <ul>
     <li><a class="tab"></a></li>
     <li><a class="tab active"></a></li>
     <li><a class="tab"></a></li>
 </ul>复制代码


<p>案例二：切换开/关按钮状态</p>
<p>点击提交按钮的时候，为了防止用户一直点击按钮，发送请求，当请求未返回结果之前，给按钮增加 pointer-events: none，可以防止这种情况，这种情况在业务中也十分常见。</p>
 <!--CSS-->
<p>.j-pro{ pointer-events: none; }</p>
<!--HTML-->
<p>&lt;button r-model={this.submit()} r-class={“j-pro”: flag}&gt;提交</p>
<!--JS-->
<p>submit: function(){<br>　　this.data.flag = true;<br>　　this.$request(url, {<br>　　　　// … onload: function(json){<br>　　　　　　　　if(json.retCode == 200){<br>　　　　　　　　　　this.data.flag = false;<br>　　　　　　　　} }.bind(this)<br>　　　　// …<br>　　});<br>}<br>案例三：防止透明元素和可点击元素重叠不能点击</p>
<p>一些内容的展示区域，为了实现一些好看的 css 效果，当元素上方有其他元素遮盖，为了不影响下方元素的事件，给被遮盖的元素增加 pointer-events: none; 可以解决。</p>
 <!--CSS-->
<p>.layer{ backround: linear-gradient(180deg, #fff, transparent); }<br>.j-pro{ poninter-events: none; }</p>
<!--HTML-->
<ul>
　　<li class="layer j-pro"></li>
　　<li class="item"></li>
　　<li class="item"></li>
　　<li class="item"></li>
</ul>
参考
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 通过background:linear-gradient写矩形边角</span><br></pre></td></tr></table></figure>
.rect {
    position: absolute;
    width: 200px;
    height: 200px;
    background:
    linear-gradient(to left, red, red) left top no-repeat,
        linear-gradient(to bottom, red, red) left top no-repeat,
        linear-gradient(to left, red, red) right top no-repeat,
        linear-gradient(to bottom, red, red) right top no-repeat,
        linear-gradient(to left, red, red) left bottom no-repeat,
        linear-gradient(to bottom, red, red) left bottom no-repeat,
        linear-gradient(to left, red, red) right bottom no-repeat,
        linear-gradient(to left, red, red) right bottom no-repeat;
    background-size: 10px 40px, 40px 10px, 10px 40px, 40px 10px;
    background-color: #00ff00;
}

<p>scss的混合宏封装<br>@mixin four-corner($color,$width,$height,$bgcolor){<br>    background: linear-gradient(to left, $color, $color) left top no-repeat,<br>        linear-gradient(to bottom, $color, $color) left top no-repeat,<br>        linear-gradient(to left, $color, $color) right top no-repeat,<br>        linear-gradient(to bottom, $color, $color) right top no-repeat,<br>        linear-gradient(to left, $color, $color) left bottom no-repeat,<br>        linear-gradient(to bottom, $color, $color) left bottom no-repeat,<br>        linear-gradient(to left, $color, $color) right bottom no-repeat,<br>        linear-gradient(to left, $color, $color) right bottom no-repeat;<br>    background-size: $height $width, $width $height, $height $width, $width $height;<br>    background-color: $bgcolor;<br>}<br>.rect {<br>     @include four-corner(red,40px,10px,#00ff00);<br>    position: absolute;<br>    width: 200px;<br>    height: 200px;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 滚动条的样式</span><br></pre></td></tr></table></figure>
<p>在app.vue中</p>
<p>::-webkit-scrollbar {<br>    width: 20px;//竖直方向的宽度，高度自适应<br>    height: 20px;//水平方向的高度，宽度自适应<br>}<br>::-webkit-scrollbar-thumb {<br>    border-radius: 20px;<br>    background:blue;<br>}<br>::-webkit-scrollbar-track {<br>    border-radius: 0;<br>    background:green;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### transition(通过它简单控制css属性的动画效果)</span><br><span class="line"></span><br><span class="line">transition: *property duration timing-function delay*;</span><br><span class="line"></span><br><span class="line">| 值                                                           |                    描述                    |</span><br><span class="line">| :----------------------------------------------------------- | :----------------------------------------: |</span><br><span class="line">| *[transition-property](https:&#x2F;&#x2F;www.runoob.com&#x2F;cssref&#x2F;css3-pr-transition-property.html)* |     指定CSS属性的name，transition效果      |</span><br><span class="line">| *[transition-duration](https:&#x2F;&#x2F;www.runoob.com&#x2F;cssref&#x2F;css3-pr-transition-duration.html)* | transition效果需要指定多少秒或毫秒才能完成 |</span><br><span class="line">| *[transition-timing-function](https:&#x2F;&#x2F;www.runoob.com&#x2F;cssref&#x2F;css3-pr-transition-timing-function.html)* |        指定transition效果的转速曲线        |</span><br><span class="line">| *[transition-delay](https:&#x2F;&#x2F;www.runoob.com&#x2F;cssref&#x2F;css3-pr-transition-delay.html)* |        定义transition效果开始的时候        |</span><br></pre></td></tr></table></figure>
<p>.search{<br>    width:80px;<br>    height:40px;<br>    border-radius:40px;<br>    border:2px solid lightblue;<br>    position: absolute;<br>    right:200px;<br>    outline:none;<br>    text-indent:12px;<br>    color:#666;<br>    font-size:16px;<br>    padding:0;<br>    -webkit-transition:width 5s;<br>    -webkit-transition:height 5s;<br>    -webkit-transition:background-color 5s;<br>    -webkit-transition:color 5s;<br>    -webkit-transition:opacity 5s;<br>}<br>.search:focus{<br>    width:200px;<br>    height: 100px;<br>    background: red;<br>    color:blue;<br>    opacity: 0;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 伪元素和伪类</span><br><span class="line"></span><br><span class="line">其中伪类和伪元素的根本区别在于：**它们是否创造了新的元素。**</span><br><span class="line"></span><br><span class="line">伪元素选择符</span><br><span class="line">![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2019052717580919.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3Njc0NDM5,size_16,color_FFFFFF,t_70)</span><br><span class="line">伪类：存在DOM文档中，逻辑上存在但在文档树中却无须标识的“幽灵”分类。</span><br><span class="line"></span><br><span class="line">伪类选择符</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190527175840224.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3Njc0NDM5,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">### 输入框光标的颜色</span><br></pre></td></tr></table></figure>
<p>caret-color: red;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### max() &#x2F; min()</span><br></pre></td></tr></table></figure>
<p>width: max(50vw, 300px);<br>width: min(50vw, 300px);<br>font-size:min(50vw, 300px);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### clamp() [在定义的 三个值之间，取大小在中间的那个值]</span><br></pre></td></tr></table></figure>
<p>font-size: clamp(1px, 3px, 2px);    //中间值为2px<br>width: clamp(200rem, 25vw, 150px); //在这三个之间取中间值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 卡券效果制作</span><br><span class="line"></span><br><span class="line">![image-20210311153400216](vue之seekcy开发历程记录1.assets&#x2F;image-20210311153400216.png)</span><br></pre></td></tr></table></figure>

<p class="coupon">
 <span>200</span>优惠券
</p>

<p>.coupon {<br> width: 300px;<br>  height: 100px;<br>  line-height: 100px;<br>  margin: 50px auto;<br>  text-align: center;<br>  position: relative;<br>  background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right /50% 51px no-repeat,<br>  radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left / 50% 51px no-repeat,<br>  radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right / 50% 51px no-repeat,<br>  radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left / 50% 51px no-repeat;<br>  filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, .2));<br>}<br>.coupon span {<br>  display: inline-block;<br>  vertical-align: middle;<br>  margin-right: 10px;<br>  color: red;<br>  font-size: 50px;<br>  font-weight: 400;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20210311154859537](vue之seekcy开发历程记录1.assets&#x2F;image-20210311154859537.png)</span><br></pre></td></tr></table></figure>
 <div class="quan clear">
            <div class="quanLeft">
                <p class="money">¥ 10</p>
                <p class="tit">美味立享折扣券</p>
                <p class="conts">无满额限制,立减折扣</p>
                <p class="dates">有效期: 2018.8.12 - 2019.8.12</p>
            </div>
            <div class="quanRight">
                <p class="ft">折扣券</p> 
                <p class="sd">官网使用</p>
            </div>
</div>

<p> .quan{<br>            position: relative;<br>            width: 96%;<br>            margin: 5% auto;<br>            padding: 6px;<br>            padding-right:0;<br>            box-sizing: border-box;<br>            background-color: #ff6347;<br>            color: #fff;<br>            background-image: radial-gradient(#fff 35%,#ff6374 35%);<br>            background-size: 17px 17px;<br>            background-position: -9px 0;<br>            background-repeat: repeat-y<br>        }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## HTML</span><br><span class="line"></span><br><span class="line">### 浏览器地址栏运行HTML代码</span><br></pre></td></tr></table></figure>
<p>data:text/html,</p><h1>Hello, everybody!</h1><p></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![图片](https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_png&#x2F;JIv7z1kbomC1q64N8lmP3G4pmFoVadU1tagUE9S7wlzyWOBQECxMjZnzia02PUfaMzFtMtLrOdqJcN5JcjZY6xQ&#x2F;640?wx_fmt&#x3D;png&amp;tp&#x3D;webp&amp;wxfrom&#x3D;5&amp;wx_lazy&#x3D;1&amp;wx_co&#x3D;1)</span><br><span class="line"></span><br><span class="line">### 浏览器秒变编辑器</span><br><span class="line"></span><br><span class="line">这个还是在浏览器地址栏上面做文章，将以下代码复制粘贴到浏览器地址栏，运行后浏览器就变成了一个原始简单的编辑器，和window自带的notepad差不多，长见识了吧，话不多说，我们来试试。</span><br></pre></td></tr></table></figure>
<p>data:text/html, <html contenteditable></html></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![图片](https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_gif&#x2F;JIv7z1kbomC1q64N8lmP3G4pmFoVadU1ZHrg2H3oiaF6Ffu76rlWyTSQwM8BHRyAZRy3o1fMpiaqnqibia5DEewxfQ&#x2F;640?wx_fmt&#x3D;gif&amp;tp&#x3D;webp&amp;wxfrom&#x3D;5&amp;wx_lazy&#x3D;1)</span><br><span class="line"></span><br><span class="line">&gt; 归根结底多亏了HTML5中新加的&#96;contenteditable&#96;属性，当元素指定了该属性后，元素的内容成为可编辑状态。</span><br><span class="line"></span><br><span class="line">### 在控制台执行以下代码，将整个页面变得可以编辑。</span><br></pre></td></tr></table></figure>
<p>document.body.contentEditable=’true’;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![图片](https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_gif&#x2F;JIv7z1kbomC1q64N8lmP3G4pmFoVadU11PG17MIGs0MCvicic605XN3OJ7zekILOKsKkg32UcomztFUKoWLZ9xnQ&#x2F;640?wx_fmt&#x3D;gif&amp;tp&#x3D;webp&amp;wxfrom&#x3D;5&amp;wx_lazy&#x3D;1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## watch</span><br><span class="line"></span><br><span class="line">#### echarts数据更新页面不更新</span><br><span class="line"></span><br><span class="line">深度监听对象数组</span><br></pre></td></tr></table></figure>
<p>watch: {<br>//监听对象数组的变化<br>bet: {<br>　　　　handler(newValue, oldValue) {<br>　　　　　　console.log(newValue)<br>　　　　},<br>　　　　deep: true<br>　　},<br>//深拷贝<br>　　winChips: {<br>　　　　handler(newValue, oldValue) {<br>　　　　　　for (let i = 0; i &lt; newValue.length; i++) {<br>　　　　　　　　if (oldValue[i] != newValue[i]) {<br>　　　　　　　　　　console.log(newValue)<br>　　　　　　　　}<br>　　　　　　}<br>　　　　},<br>　　　　deep: true<br>　　}<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Promise(C 依赖 B 的结果，D 依赖 ABC 的结果，最终输出 D 的结果)</span><br></pre></td></tr></table></figure>
<p>function A() {<br>    return new Promise(r =&gt; {<br>        let timeObj = setTimeout(() =&gt; {<br>            console.log(‘AAAAAAAAA’);<br>            clearTimeout(timeObj);<br>            r(“a”)<br>        }, 2000);<br>    })<br>}<br>function B() {<br>    return new Promise(r =&gt; {<br>        let timeObj = setTimeout(() =&gt; {<br>            console.log(‘BBBBBBBBBBBB’);<br>            clearTimeout(timeObj)<br>            r(“b”)<br>        }, 2000);<br>    })<br>}<br>function C() {<br>    return new Promise(r =&gt; {<br>        let timeObj = setTimeout(() =&gt; {<br>            console.log(‘CCCCCCCCCCCC’);<br>            clearTimeout(timeObj)<br>            r(“c”)<br>        }, 2000);<br>    })<br>}<br>function D() {<br>    return new Promise(r =&gt; {<br>        let timeObj = setTimeout(() =&gt; {<br>            console.log(‘DDDDDDDDDDDDDD’);<br>            clearTimeout(timeObj)<br>            r(“d1321231”)<br>        }, 2000);<br>    })<br>}<br>async function asyncBC() {<br>    const resb = await B();<br>    const resc = await C(resb);<br>    return {resb,resc}<br>}<br>async function asyncTask() {<br>    const [resa,{resb,resc}]=await Promise.all([A(),asyncBC()])<br>    const resd=await D(resa,resb,resc)<br>    return resd<br>}<br>asyncTask().then(resd=&gt;{<br>    console.log(‘this is D result’,resd);</p>
<p>})</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Axios</span><br><span class="line"></span><br><span class="line">Form Data 和 Request Payload 区别</span><br><span class="line"></span><br><span class="line">1. 设置Content-Type: application&#x2F;x-www-form-urlencoded，那么这个请求被认为是表单请求，参数出现在Form Data里，格式为key&#x3D;value&amp;key&#x3D;value&amp;key&#x3D;value…,请求参数应为json对象。</span><br><span class="line">2. 设置Content-Type:application&#x2F;json，或者使用默认的请求头Content-Type:text&#x2F;plain;参数会显示在Request payload块里提交。请求参数应为字符串。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">qs.stringify和json.stringify区别</span><br></pre></td></tr></table></figure>
<p>var a = {name:’hehe’,age:10};<br> qs.stringify(a)<br>// ‘name=hehe&amp;age=10’<br>JSON.stringify(a)<br>// ‘{“name”:”hehe”,”age”:10}’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">qs.parse()</span><br></pre></td></tr></table></figure>
<p>let url = ‘method=query_sql_dataset_data&amp;projectId=85&amp;appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0’;<br>qs.parse(url);<br>{<br>method:query_sql_dataset_data,<br>projectId:85,<br>appToken:7d22e38e-5717-11e7-907b-a6006ad3dba0<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 结合axiso，elementUI全局loading（部分接口不请求配置）</span><br></pre></td></tr></table></figure>

<p>import axios from ‘axios’;<br>import { Message, Loading } from ‘element-ui’;</p>
<p>// import store from ‘../store’;<br>import qs from ‘qs’;<br>import router from ‘../router’</p>
<p>//全局loading在请求接口时出现，结束时消失<br>let loading;<br>let loadingNum = 0;<br>//开始loading<br>function startLoading() {<br>    if (loadingNum == 0) {<br>        loading = Loading.service({<br>            lock: true,<br>              text: ‘Loading’,<br>              spinner: ‘el-icon-loading’,<br>              background: ‘rgba(0, 0, 0, 0.7)’,<br>              //target: document.querySelector(‘.div1’)<br>        })<br>    }<br>    loadingNum++;<br>}</p>
<p>//结束loading<br>function endLoading() {<br>    loading.close()<br>}</p>
<p>function tryHideLoading() {<br>    if (loadingNum &lt;= 0) return<br>    loadingNum–<br>    if (loadingNum === 0) {<br>        setInterval(() =&gt; {<br>            endLoading()<br>        }, 500);<br>    }<br>}</p>
<p>// 创建axios实例<br>const http = axios.create({<br>    baseURL: ‘/vital-signs/‘,<br>    timeout: 600000,                  // 请求超时时间<br>    transformRequest: obj =&gt; qs.stringify(obj)<br>    // headers: { ‘Content-Type’: ‘application/json’ }<br>});</p>
<p>// request拦截器<br>http.interceptors.request.use(<br>    config =&gt; {<br>        if (config.headers.showLoading !== false) {<br>            startLoading();<br>        }<br>        if (!sessionStorage.getItem(‘token’) &amp;&amp; config.url.indexOf(“login”) == -1) {<br>            Message({<br>                message: “登录信息失效，请重新登录”,<br>                type: ‘error’<br>            });<br>            if (config.url.indexOf(“loginAuto”)!=-1){<br>              return<br>          }<br>            setTimeout(() =&gt; {<br>                router.replace(‘/login’)<br>                location.reload()<br>            }, 2000);<br>        }<br>        config.headers.Authorization = “Bearer “ + sessionStorage.getItem(‘token’);<br>        config.headers.buildId = sessionStorage.getItem(“buildId”) || “200036”;<br>        config.headers.deptId = localStorage.getItem(“departmentId”)<br>        return config;<br>    },<br>    error =&gt; {<br>        tryHideLoading();<br>        Promise.reject(error);<br>    }<br>)</p>
<p>// respone拦截器<br>http.interceptors.response.use(<br>    response =&gt; {<br>        tryHideLoading();<br>        if (response.data.code === 0) {<br>            // console.dir(response);<br>            return Promise.resolve(response);<br>        } else {<br>            Message({<br>                message: response.data.msg,<br>                type: ‘error’,<br>            });<br>            return Promise.reject(response);<br>            // return Promise.resolve(response);<br>        }<br>    },<br>    error =&gt; {<br>        tryHideLoading();<br>        console.dir(error);// for debug<br>        if (error.response) {<br>            if (error.response.status == ‘401’&amp;&amp;sessionStorage.getItem(‘token’)) {<br>                Message({<br>                    message: error.response.data.msg,<br>                    type: ‘error’<br>                });<br>                setTimeout(() =&gt; {<br>                    router.push({ path: “/login” })<br>                }, 3000);</p>
<pre><code>            return;
        } else if (error.response.status == 500) {
            Message({
                message: error.response.data.error,
                type: &apos;error&apos;
            });
        }
    } else {
        let msg = &apos;服务器请求出错&apos;;
        if (error.message.indexOf(&apos;timeout&apos;) !== -1) {
            msg = &apos;请求超时&apos;;
        } else if (error.message.indexOf(&apos;Network Error&apos;) !== -1) {
            msg = &apos;网络出错&apos;;
        }

    }
    return Promise.reject(error);
}</code></pre><p>)</p>
<p>http.postJson = (path, params) =&gt; http({</p>
<pre><code>url: path,
method: &apos;post&apos;,
data: addparams(params),
transformRequest: obj =&gt; JSON.stringify(obj),
headers: { &apos;Content-Type&apos;: &apos;application/json&apos; }</code></pre><p>})</p>
<p>http.put = (path, params) =&gt; http({<br>    url: path,<br>    method: ‘put’,<br>    data: addparams(params),<br>    transformRequest: obj =&gt; JSON.stringify(obj),<br>    headers: { ‘Content-Type’: ‘application/json’ }<br>})</p>
<p>http.uploadFile = (path, params) =&gt; http({<br>    url: path,<br>    method: ‘post’,<br>    data: { file: params.file },<br>    transformRequest: (obj) =&gt; {</p>
<pre><code>},
headers: {
    &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,
    &apos;Authorization&apos;: &quot;Bearer &quot; + sessionStorage.getItem(&apos;token&apos;),
    &apos;buildId&apos;: &quot;200036&quot;
}</code></pre><p>})</p>
<p>http.login = (path, params) =&gt; http({</p>
<pre><code>url: path,
method: &apos;post&apos;,
data: params,


transformRequest: obj =&gt; JSON.stringify(obj),
headers: { &apos;Content-Type&apos;: &apos;application/json&apos; }</code></pre><p>})</p>
<p>function addparams(params) {<br>    //数组不转换<br>    if (params instanceof Array) {<br>        return params<br>    } else if (params instanceof Object){<br>        const pp = {<br>            // timestamp: Date.parse(new Date()) / 1000<br>        }<br>        return Object.assign(pp, params);<br>    }<br>}</p>
<p>/<em>备注：使用create重置过后无法使用all、spread、Cancel、CancelToken、isCancel等方法/,只需要加上一行代码，但以下代码无法在eslint模式下使用，因为在eslint里是不允许对<strong>proto</strong>进行重新赋值的。</em>/</p>
<p>/* eslint-disable no-proto <em>/<br>http.<strong>proto</strong> = axios<br>/</em> eslint-enable */</p>
<p>export default http;</p>
<p>.vue<br>get请求<br> this.$http.get(‘/alarm/getNumOfAlarm/‘,{headers:{showLoading:false},params:{id:id}})<br>                .then(res =&gt; {<br>                    this.remindCount = res.data.data;<br>                })<br> post请求<br>this.$http.post(‘/alarm/getNumOfAlarm/‘,{id:id},{headers:{showLoading:false}})<br>                .then(res =&gt; {<br>                    this.remindCount = res.data.data;<br>                })</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">参考链接</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;lianzhang861&#x2F;article&#x2F;details&#x2F;100019049</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 后端要求只传数组，不需要参数名？</span><br><span class="line"></span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
<p>在封装好的axios中<br>function addparams(params) {<br>    //数组不转换<br>    if (params instanceof Array) {<br>        return params<br>    } else if (params instanceof Object){<br>    //添加默认参数<br>       const pp = {<br>            clientVersion: ‘1.0’,<br>            sign: ‘string’,<br>            signType: ‘string’,<br>            timestamp: Date.parse(new Date()) / 1000<br>        }<br>        return Object.assign(pp, params);<br>    }<br>}</p>
<p>//使用<br>this.axios.postJson(‘/api/js/stream/streamBreath/‘,  [‘baby_care__11__@<strong>hik</strong>live__null’, ‘baby_care__12__@<strong>dahua</strong>live__null’])<br>    .then(res =&gt; {</p>
<p>})</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 增加token和默认参数</span><br></pre></td></tr></table></figure>
<p>service.interceptors.request.use(<br>    config =&gt; {<br>        if (getToken()) {<br>            config.headers[‘X-Auth-Token’] = getToken(); // 让每个请求携带自定义token 请根据实际情况自行修改<br>        }</p>
<pre><code>    if (!config.noparams) {
        if (getBuildInfo()) {
            if (config.method === &apos;post&apos;) {
                console.log(config.data, &apos;post的config.data&apos;);
                config.data = {
                    username: getUserInfo() ? getUserInfo().username : &apos;&apos;,
                    buildId: getBuildInfo() ? getBuildInfo().buildid : &apos;&apos;,
                    ...config.data
                }
                config.params = {
                    username: getUserInfo() ? getUserInfo().username : &apos;&apos;,
                    buildId: getBuildInfo() ? getBuildInfo().buildid : &apos;&apos;
                }
            } else if (config.method === &apos;get&apos;) {
                config.params = {
                    username: getUserInfo() ? getUserInfo().username : &apos;&apos;,
                    buildId: getBuildInfo() ? getBuildInfo().buildid : &apos;&apos;,
                    ...config.params
                }
            }
        }
    }
    return config;
},
error =&gt; {
    // Do something with request error
    console.log(error); // for debug
    Promise.reject(error);
}</code></pre><p>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## fetch.js的使用简述</span><br><span class="line"></span><br><span class="line">### 两个参数</span><br><span class="line"></span><br><span class="line">1. 第一个参数是 URL 地址</span><br><span class="line">2. 第二个参数是请求的配置信息，包含headers、请求类型（GET&#x2F;POST）、是否跨域等信息</span><br><span class="line"></span><br><span class="line">### 参数说明</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">	body: JSON.stringify(data), &#x2F;&#x2F; must match &#39;Content-Type&#39; header</span><br><span class="line">	cache: &quot;no-cache&quot;, &#x2F;&#x2F; *default, no-cache, reload, force-cache, only-if-cached</span><br><span class="line">	credentials: &quot;same-origin&quot;, &#x2F;&#x2F; include, same-origin, *omit</span><br><span class="line">	headers: &#123;</span><br><span class="line">		&quot;user-agent&quot;: &quot;Mozilla&#x2F;4.0 MDN Example&quot;,</span><br><span class="line">		&quot;content-type&quot;: &quot;application&#x2F;json&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	method: &quot;POST&quot;, &#x2F;&#x2F; *GET, POST, PUT, DELETE, etc.</span><br><span class="line">	mode: &quot;cors&quot;, &#x2F;&#x2F; no-cors, cors, *same-origin</span><br><span class="line">	redirect: &quot;follow&quot;, &#x2F;&#x2F; manual, *follow, error</span><br><span class="line">	referrer: &quot;no-referrer&quot; &#x2F;&#x2F; *client, no-referrer</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(response &#x3D;&gt; response.json()) &#x2F;&#x2F; parses response to JSON</span><br><span class="line">	.then(function(myJson) &#123;</span><br><span class="line">		console.log(myJson);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="设置elementUI的Message的全局默认属性"><a href="#设置elementUI的Message的全局默认属性" class="headerlink" title="设置elementUI的Message的全局默认属性"></a>设置elementUI的Message的全局默认属性</h2><p>main.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype.Message &#x3D; function (obj) &#123;</span><br><span class="line">    ElementUI.Message(&#123;</span><br><span class="line">        message: obj.message,</span><br><span class="line">        type:obj.type,</span><br><span class="line">        showClose: true</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>plus:消息框多次弹窗解决</p>
<h2 id="全局filters"><a href="#全局filters" class="headerlink" title="全局filters"></a>全局filters</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建filters&#x2F;index.js</span><br><span class="line"></span><br><span class="line">const isNullOrEmpty &#x3D; function(val) &#123;</span><br><span class="line">    if (val &#x3D;&#x3D; null || val &#x3D;&#x3D; &quot;&quot; || typeof(val) &#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const timeFormat &#x3D; (value, format) &#x3D;&gt; &#123;</span><br><span class="line">    let date &#x3D; new Date(value);</span><br><span class="line">    let y &#x3D; date.getFullYear();</span><br><span class="line">    let m &#x3D; date.getMonth() + 1;</span><br><span class="line">    let d &#x3D; date.getDate();</span><br><span class="line">    let h &#x3D; date.getHours();</span><br><span class="line">    let min &#x3D; date.getMinutes();</span><br><span class="line">    let s &#x3D; date.getSeconds();</span><br><span class="line">    let result &#x3D; &quot;&quot;;</span><br><span class="line">    if (format &#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        result &#x3D; &#96;$&#123;y&#125;-$&#123;m &lt; 10 ? &quot;0&quot; + m : m&#125;-$&#123;d &lt; 10 ? &quot;0&quot; + d : d&#125; $&#123;</span><br><span class="line">        h &lt; 10 ? &quot;0&quot; + h : h</span><br><span class="line">      &#125;:$&#123;min &lt; 10 ? &quot;0&quot; + min : min&#125;:$&#123;s &lt; 10 ? &quot;0&quot; + s : s&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (format &#x3D;&#x3D; &quot;yyyy-mm-dd&quot;) &#123;</span><br><span class="line">        result &#x3D; &#96;$&#123;y&#125;-$&#123;m &lt; 10 ? &quot;0&quot; + m : m&#125;-$&#123;d &lt; 10 ? &quot;0&quot; + d : d&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (format &#x3D;&#x3D; &quot;yyyy-mm&quot;) &#123;</span><br><span class="line">        result &#x3D; &#96;$&#123;y&#125;-$&#123;m &lt; 10 ? &quot;0&quot; + m : m&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (format &#x3D;&#x3D; &quot;mm-dd&quot;) &#123;</span><br><span class="line">        result &#x3D; &#96; $&#123;mm &lt; 10 ? &quot;0&quot; + mm : mm&#125;:$&#123;ddmin &lt; 10 ? &quot;0&quot; + dd : dd&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (format &#x3D;&#x3D; &quot;hh:mm&quot;) &#123;</span><br><span class="line">        result &#x3D; &#96; $&#123;h &lt; 10 ? &quot;0&quot; + h : h&#125;:$&#123;min &lt; 10 ? &quot;0&quot; + min : min&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (format &#x3D;&#x3D; &quot;yyyy&quot;) &#123;</span><br><span class="line">        result &#x3D; &#96;$&#123;y&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">export &#123;</span><br><span class="line">    isNullOrEmpty,</span><br><span class="line">    timeFormat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main.js中引入和注册全局过滤器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as filters from &#39;..&#x2F;filters&#x2F;index&#39;</span><br><span class="line">Object.keys(filters).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">    Vue.filter(key, filters[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时就可以在不同的.vue中使用定义的全局过滤器了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;&#123;date|isNullOrEmpty&#125;是否为空&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>



<p>简易版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.js</span><br><span class="line">Vue.filter(&#39;tofixed&#39;, function (value,num&#x3D;2) &#123;</span><br><span class="line">  if (!value) return 0</span><br><span class="line">  return value.toFixed(num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h2 id="使用特殊字体（digital等）"><a href="#使用特殊字体（digital等）" class="headerlink" title="使用特殊字体（digital等）"></a>使用特殊字体（digital等）</h2><p>一、CDN引入</p>
<pre><code>&lt;style&gt;
@font-face{
    font-family:QingKe;
    src:url(&quot;https://g.alicdn.com/TSG/damo-static/2019.918.162009/damo/css/font/iozzkhwu.ttf&quot;)
    /* src: url-loader(&quot;@/assets/iozzkhwu.ttf&quot;);  这种方式是错误的*/
}
@font-face{
    font-family:SYHT;
    src: url(&apos;https://tuyu.hnbcdn.com/SHSCN-ELight.eot&apos;);
    src:url(https://tuyu.hnbcdn.com/SHSCN-ELight.eot);
    src:local(&apos;鈽�&apos;),url(https://tuyu.hnbcdn.com/SHSCN-ELight.woff) format(&apos;woff&apos;),url(https://tuyu.hnbcdn.com/SHSCN-ELight.ttf) format(&apos;truetype&apos;),url(https://tuyu.hnbcdn.com/SHSCN-ELight.svg) format(&apos;svg&apos;);font-weight:400;font-style:normal
}
.wenzi{
  font-family: SYHT;
      letter-spacing:3px;
      font-weight: 100;
}
&lt;/style&gt;</code></pre><p>二、assets中引入静态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line"> font-family: &#39;SHIZHONGZITI&#39;;</span><br><span class="line"> src: url(.&#x2F;assets&#x2F;DIGITAL-7_MONO-WEBFONT.ttf);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.teshu &#123;</span><br><span class="line"> font-family: SHIZHONGZITI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sass安装失败"><a href="#sass安装失败" class="headerlink" title="sass安装失败"></a>sass安装失败</h2><p>坑四：安装sass失败</p>
<p>由于sass-loader依赖于node-sass，所以按如下顺序分别下载依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev node-sass</span><br><span class="line">npm install --save-dev sass-loader</span><br><span class="line"></span><br><span class="line">如果报错，则安装以下版本</span><br><span class="line">&quot;node-sass&quot;: &quot;^4.7.2&quot;,</span><br><span class="line">&quot;sass-loader&quot;: &quot;^6.0.5&quot;,</span><br></pre></td></tr></table></figure>



<h2 id="随机获取布尔值（true-false"><a href="#随机获取布尔值（true-false" class="headerlink" title="随机获取布尔值（true/false"></a><strong>随机获取布尔值（true/false</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const randomBoolean &#x3D; () &#x3D;&gt; Math.random() &gt;&#x3D; 0.5;</span><br><span class="line">console.log(randomBoolean());</span><br></pre></td></tr></table></figure>



<h2 id="判断给的日期是否为工作日"><a href="#判断给的日期是否为工作日" class="headerlink" title="判断给的日期是否为工作日"></a><strong>判断给的日期是否为工作日</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isWeekday &#x3D; (date) &#x3D;&gt; date.getDay() % 6 !&#x3D;&#x3D; 0;</span><br><span class="line">console.log(isWeekday(new Date(2021, 0, 11)));</span><br><span class="line">&#x2F;&#x2F; Result: true (Monday)  getDay()&#x3D;[0,1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>



<h2 id="localstorage清除特定的一类"><a href="#localstorage清除特定的一类" class="headerlink" title="localstorage清除特定的一类"></a>localstorage清除特定的一类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.keys(localStorage).forEach(item &#x3D;&gt; item.indexOf(&#39;mine&#39;) !&#x3D;&#x3D; -1 ? localStorage.removeItem(item) : &#39;&#39;);</span><br><span class="line"></span><br><span class="line">删除带mine字段的缓存</span><br></pre></td></tr></table></figure>



<h2 id="布署服务器后刷新404"><a href="#布署服务器后刷新404" class="headerlink" title="布署服务器后刷新404"></a>布署服务器后刷新404</h2><p>参考链接 <a href="https://mp.weixin.qq.com/s/DqS4shzElGQUqwKGD5oweA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DqS4shzElGQUqwKGD5oweA</a></p>
<h3 id="为什么history模式下有问题"><a href="#为什么history模式下有问题" class="headerlink" title="为什么history模式下有问题"></a>为什么history模式下有问题</h3><p><code>Vue</code>是属于单页应用（single-page application）</p>
<p>而<code>SPA</code>是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个<code>index.html</code></p>
<p>现在，我们回头来看一下我们的<code>nginx</code>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  www.xxx.com;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    index  &#x2F;data&#x2F;dist&#x2F;index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以根据 <code>nginx</code> 配置得出，当我们在地址栏输入 <code>www.xxx.com</code> 时，这时会打开我们 <code>dist</code>目录下的 <code>index.html</code> 文件，然后我们在跳转路由进入到 <code>www.xxx.com/login</code></p>
<p>关键在这里，当我们在 <code>website.com/login</code> 页执行刷新操作，<code>nginx location</code> 是没有相关配置的，所以就会出现 404 的情况</p>
<h3 id="为什么hash模式下没有问题"><a href="#为什么hash模式下没有问题" class="headerlink" title="为什么hash模式下没有问题"></a>为什么hash模式下没有问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router hash&#96; 模式我们都知道是用符号#表示的，如  &#96;website.com&#x2F;#&#x2F;login&#96;, &#96;hash&#96; 的值为&#96;#&#x2F;login</span><br></pre></td></tr></table></figure>

<p>它的特点在于：<code>hash</code> 虽然出现在 <code>URL</code> 中，但不会被包括在 <code>HTTP</code> 请求中，对服务端完全没有影响，因此改变 <code>hash</code> 不会重新加载页面</p>
<p><code>hash</code> 模式下，仅 <code>hash</code> 符号之前的内容会被包含在请求中，如 <code>website.com/#/login</code> 只有<code>website.com</code> 会被包含在请求中 ，因此对于服务端来说，即使没有配置<code>location</code>，也不会返回404错误</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>看到这里我相信大部分同学都能想到怎么解决问题了，</p>
<p>产生问题的本质是因为我们的路由是通过JS来执行视图切换的，</p>
<p>当我们进入到子路由时刷新页面，<code>web</code>容器没有相对应的页面此时会出现404</p>
<p>所以我们只需要配置将任意页面都重定向到 <code>index.html</code>，把路由交由前端处理</p>
<p>对<code>nginx</code>配置文件<code>.conf</code>修改，添加<code>try_files $uri $uri/ /index.html;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  www.xxx.com;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    index  &#x2F;data&#x2F;dist&#x2F;index.html;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完配置文件后记得配置的更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 <code>index.html</code>文件</p>
<p>为了避免这种情况，你应该在 <code>Vue</code> 应用里面覆盖所有的路由情况，然后在给出一个 404 页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;*&#39;, component: NotFoundComponent &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="监听页面或者元素的滚动-控制元素的滚动（jquery）"><a href="#监听页面或者元素的滚动-控制元素的滚动（jquery）" class="headerlink" title="监听页面或者元素的滚动/控制元素的滚动（jquery）"></a>监听页面或者元素的滚动/控制元素的滚动（jquery）</h2><ol>
<li>监听页面滚动</li>
</ol>
<p>在生命周期mounted中进行监听滚动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    window.addEventListener(&#39;scroll&#39;, this.scrollToTop)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在方法中定义监听滚动执行的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrollToTop() &#123;</span><br><span class="line"> 　　var scrollTop &#x3D; window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line"> 　　console.log(scrollTop)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听某元素滚动</li>
</ol>
<p>tips：监听的这个元素是父级元素，固定高度后overflow:auto,</p>
<p>vue组件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;scrollcont&quot; style&#x3D;&quot;height:350px;overflow:auto;background:red;&quot; @scroll&#x3D;&quot;scrollEvent&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;read-con&quot; style&#x3D;&quot;height:1000px;margin:10px;background:pink;&quot;&gt;&lt;&#x2F;div&gt;           </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>在方法中定义scrolldiv，是监听class为read-con滚动以后需要执行的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrollEvent () &#123;</span><br><span class="line">   let _this &#x3D; this</span><br><span class="line">   let scrollcont &#x3D; _this.$el.querySelector(&#39;#scrollcont&#39;)</span><br><span class="line">   console.log(scrollcont.scrollToTop)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>vue中控制元素滚动到底部</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clickMe()&#123;</span><br><span class="line">  let _this &#x3D; this</span><br><span class="line">  let read &#x3D; _this.$el.querySelector(&#39;.test&#39;)  </span><br><span class="line">  &#x2F;&#x2F;返回第一个class为test元素，this.$el.querySelectorAll(&#39;.test&#39;)，返回所有</span><br><span class="line">  read.scrollTop &#x3D; read.scrollHeight</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>jquery控制元素滚动到底部</li>
</ol>
<p>jquery取 scrollHeight, $(“#scrollTopCont”).scrollHeight 拿不到<br>$(“#scrollTopCont”)[0].scrollHeight //取值scrollHeight</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F; console.log($(&quot;#scrollTopCont&quot;)[0].scrollHeight, );</span><br><span class="line">   $(&quot;#scrollTopCont&quot;).scrollTop($(&quot;#scrollTopCont&quot;)[0].scrollHeight)</span><br><span class="line">&#125;, 100);</span><br></pre></td></tr></table></figure>



<h2 id="上传图片-excel文件到接口"><a href="#上传图片-excel文件到接口" class="headerlink" title="上传图片/excel文件到接口"></a>上传图片/excel文件到接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">submitData() &#123;</span><br><span class="line">    const that &#x3D; this;</span><br><span class="line">    const fd &#x3D; new FormData()&#x2F;&#x2F; FormData 对象</span><br><span class="line">    fd.append(&#39;file&#39;, this.fileObj)&#x2F;&#x2F; 文件对象  &#39;upload&#39;是后台接收的参数名</span><br><span class="line">    const config &#x3D; &#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;,</span><br><span class="line">        &quot;Authorization&quot;: localStorage.getItem(&#39;token_IOT&#39;),</span><br><span class="line">        &quot;buildId&quot;: localStorage.getItem(&quot;buildId_IOT&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    axios.post(axiosUrl, fd, config)</span><br><span class="line">    .then(function (response) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>





<h2 id="preserveWhitespace-去除空格"><a href="#preserveWhitespace-去除空格" class="headerlink" title="preserveWhitespace(去除空格)"></a><strong>preserveWhitespace</strong>(去除空格)</h2><p>场景:开发 vue 代码一般会有空格,这个时候打包压缩如果不去掉空格会加大包的体积<br>配置preserveWhitespace可以减小包的体积</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">     &#123;</span><br><span class="line">       test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">       loader: &#39;vue-loader&#39;,</span><br><span class="line">       options: &#123;</span><br><span class="line">         compilerOptions: &#123;</span><br><span class="line">           preserveWhitespace: false</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="img-加载失败"><a href="#img-加载失败" class="headerlink" title="img 加载失败"></a><strong>img 加载失败</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; page 代码</span><br><span class="line">&lt;img :src&#x3D;&quot;imgUrl&quot; @error&#x3D;&quot;handleError&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line"> data()&#123;</span><br><span class="line">  return&#123;</span><br><span class="line">   imgUrl:&#39;&#39;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods:&#123;</span><br><span class="line">  handleError(e)&#123;</span><br><span class="line">   e.target.src&#x3D;reqiure(&#39;图片路径&#39;) </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="require-context"><a href="#require-context" class="headerlink" title="require.context()"></a><strong>require.context()</strong></h2><p>1.场景:如页面需要导入多个组件,原始写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import titleCom from &#39;@&#x2F;components&#x2F;home&#x2F;titleCom&#39;</span><br><span class="line">import bannerCom from &#39;@&#x2F;components&#x2F;home&#x2F;bannerCom&#39;</span><br><span class="line">import cellCom from &#39;@&#x2F;components&#x2F;home&#x2F;cellCom&#39;</span><br><span class="line">components:&#123;titleCom,bannerCom,cellCom&#125;</span><br></pre></td></tr></table></figure>

<p>2.这样就写了大量重复的代码,利用 require.context 可以写成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const files &#x3D; require.context(&#39;@&#x2F;components&#x2F;home&#39;, false, &#x2F;\.vue$&#x2F;)</span><br><span class="line">const modules &#x3D; &#123;&#125;</span><br><span class="line">files.keys().forEach(key &#x3D;&gt; &#123;</span><br><span class="line"> const name &#x3D; path.basename(key, &#39;.vue&#39;)</span><br><span class="line"> modules[name] &#x3D; files(key).default || files(key)</span><br><span class="line">&#125;)</span><br><span class="line">components:modules</span><br></pre></td></tr></table></figure>

<p>这样不管页面引入多少组件,都可以使用这个方法</p>
<p>状态管理的modules也可以使用同样的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const modulesFiles &#x3D; require.context(&#39;.&#x2F;modules&#39;, true, &#x2F;\.js$&#x2F;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; you do not need &#96;import app from &#39;.&#x2F;modules&#x2F;app&#39;&#96;</span><br><span class="line">&#x2F;&#x2F; it will auto require all vuex module from modules file</span><br><span class="line">const modules &#x3D; modulesFiles.keys().reduce((modules, modulePath) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; set &#39;.&#x2F;app.js&#39; &#x3D;&gt; &#39;app&#39;</span><br><span class="line">  const moduleName &#x3D; modulePath.replace(&#x2F;^\.\&#x2F;(.*)\.\w+$&#x2F;, &#39;$1&#39;);</span><br><span class="line">  const value &#x3D; modulesFiles(modulePath);</span><br><span class="line">  modules[moduleName] &#x3D; value.default;</span><br><span class="line">  return modules;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  modules,</span><br><span class="line">  getters</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<p>3.API 方法</p>
<blockquote>
<p>实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用<br>require.context(directory,useSubdirectories,regExp)<br>接收三个参数:<br>directory：说明需要检索的目录<br>useSubdirectories：是否检索子目录<br>regExp: 匹配文件的正则表达式,一般是文件名</p>
</blockquote>
<h2 id="在vue项目中监听键盘事件的方法"><a href="#在vue项目中监听键盘事件的方法" class="headerlink" title="在vue项目中监听键盘事件的方法"></a>在vue项目中监听键盘事件的方法</h2><p>1在main.js文件中写入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$keyBoard &#x3D; function (vm, methodName, code) &#123;</span><br><span class="line"></span><br><span class="line"> document.onkeydown &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">  let key &#x3D; window.event.keyCode;</span><br><span class="line"></span><br><span class="line">  if (key &#x3D;&#x3D; code) &#123;</span><br><span class="line"></span><br><span class="line">   vm[methodName](code); &#x2F;&#x2F; 触发methodName事件</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2在需要监听键盘事件的组件里的mounted 生命周期内写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line"></span><br><span class="line">  this.$keyBoard(this, &#39;onClickEnter&#39;, 13) &#x2F;&#x2F; 13就是回车键的keycode,这样点击回车就能触发onClickEnter这个事件了</span><br><span class="line"></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>



<p>3在组件中定义被键盘事件触发的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line"></span><br><span class="line">  onClickEnter () &#123;</span><br><span class="line"></span><br><span class="line">   alert(&#39;哈哈&#39;)</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用插件vue-clipboard2复制内容至剪切板-两种使用方法"><a href="#使用插件vue-clipboard2复制内容至剪切板-两种使用方法" class="headerlink" title="使用插件vue-clipboard2复制内容至剪切板(两种使用方法)"></a>使用插件vue-clipboard2复制内容至剪切板(两种使用方法)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save vue-clipboard2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueClipboard from &#39;vue-clipboard2&#39;</span><br><span class="line"> </span><br><span class="line">Vue.use(VueClipboard)</span><br></pre></td></tr></table></figure>

<h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">  &lt;button class&#x3D;&quot;fs12&quot;</span><br><span class="line">            v-clipboard:copy&#x3D;&quot;&#39;地址：&#39;+detail.address+&#39;\n姓名：&#39;+detail.name+&#39;\n电话：&#39;+detail.phone&quot;</span><br><span class="line">        v-clipboard:success&#x3D;&quot;onCopy&quot; </span><br><span class="line">        v-clipboard:error&#x3D;&quot;onError&quot;&gt;复制&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">       detail:&#123;</span><br><span class="line">        address:&#39;地址&#39;,</span><br><span class="line">        name:&#39;名字&#39;,</span><br><span class="line">        phone:&#39;1234567&#39;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onCopy: function (e) &#123;</span><br><span class="line">        alert(&#39;You just copied: &#39; + e.text)</span><br><span class="line">      &#125;,</span><br><span class="line">      onError: function (e) &#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">        alert(&#39;Failed to copy texts&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">     &lt;button class&#x3D;&quot;fs12&quot; @click&#x3D;&quot;copyCode&quot;&gt;复制&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        detail:&#123;</span><br><span class="line">        address:&#39;地址&#39;,</span><br><span class="line">        name:&#39;名字&#39;,</span><br><span class="line">        phone:&#39;1234567&#39;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">    copyCode() &#123;</span><br><span class="line">	this.$copyText(&#96;地址：$&#123;this.detail.address&#125;\n收件人：    $&#123;this.detail.name&#125;\n电话：$&#123;this.detail.phone&#125;&#96;).then(</span><br><span class="line">		        res &#x3D;&gt; &#123;</span><br><span class="line">		          console.log(res)</span><br><span class="line">		          this.$toast(&quot;已成功复制，可直接去粘贴&quot;);</span><br><span class="line">		        &#125;,</span><br><span class="line">		        err &#x3D;&gt; &#123;</span><br><span class="line">		          this.$toast(&quot;复制失败&quot;);</span><br><span class="line">		        &#125;</span><br><span class="line">		      )</span><br><span class="line">		    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="在vue中使用vue-qriously生成二维码"><a href="#在vue中使用vue-qriously生成二维码" class="headerlink" title="在vue中使用vue-qriously生成二维码"></a>在vue中使用vue-qriously生成二维码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、安装</span><br><span class="line">npm i  vue-qriously -S</span><br><span class="line"></span><br><span class="line">2、引入</span><br><span class="line">&#x2F;&#x2F;main.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueQriously from &#39;vue-qriously&#39;</span><br><span class="line">Vue.use(VueQriously)</span><br><span class="line"></span><br><span class="line">3、使用</span><br><span class="line">&#x2F;&#x2F;home.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;qriously :value&#x3D;&quot;qrcode&quot; :size&#x3D;&quot;200&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            qrcode: &#39;www.baidu.com&#39;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="使用html2canvas截取图片"><a href="#使用html2canvas截取图片" class="headerlink" title="使用html2canvas截取图片"></a>使用html2canvas截取图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">先引入插件</span><br><span class="line">npm install --save html2canvas</span><br><span class="line"></span><br><span class="line">之后在你所需要使用的页面引入</span><br><span class="line">import html2canvas from &quot;html2canvas&quot;</span><br><span class="line"></span><br><span class="line">html</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;about&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;imageWrapper&quot; ref&#x3D;&quot;imageWrapper&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;success&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;img&quot;&gt;</span><br><span class="line">                    &lt;img class&#x3D;&quot;img-icon&quot; src&#x3D;&quot;https:&#x2F;&#x2F;t10.baidu.com&#x2F;it&#x2F;u1&#x3D;1637861796&amp;u2&#x3D;2420578710&amp;fm&#x3D;76&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;p style&#x3D;&quot;font-weight: 600; font-size: 18px&quot;&gt;支付成功&lt;&#x2F;p&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;success-detail&quot;&gt;</span><br><span class="line">                &lt;el-row style&#x3D;&quot;margin-top: 10px;&quot;&gt;</span><br><span class="line">                    &lt;el-col :span&#x3D;&quot;5&quot; class&#x3D;&quot;col-left-suc&quot;&gt;收款商家&lt;&#x2F;el-col&gt;</span><br><span class="line">                    &lt;el-col :span&#x3D;&quot;16&quot; class&#x3D;&quot;col-right&quot;&gt;是谁&lt;&#x2F;el-col&gt;</span><br><span class="line">                &lt;&#x2F;el-row&gt;</span><br><span class="line">                &lt;el-row style&#x3D;&quot;margin-top: 10px;&quot;&gt;</span><br><span class="line">                    &lt;el-col :span&#x3D;&quot;5&quot; class&#x3D;&quot;col-left-suc&quot;&gt;费用名称&lt;&#x2F;el-col&gt;</span><br><span class="line">                    &lt;el-col :span&#x3D;&quot;16&quot; class&#x3D;&quot;col-right&quot;&gt;保护费&lt;&#x2F;el-col&gt;</span><br><span class="line">                &lt;&#x2F;el-row&gt;</span><br><span class="line">                &lt;el-row style&#x3D;&quot;margin-top: 10px;&quot;&gt;</span><br><span class="line">                    &lt;el-col :span&#x3D;&quot;5&quot; class&#x3D;&quot;col-left-suc&quot;&gt;缴费金额&lt;&#x2F;el-col&gt;</span><br><span class="line">                    &lt;el-col :span&#x3D;&quot;16&quot; class&#x3D;&quot;col-right&quot;&gt;200元&lt;&#x2F;el-col&gt;</span><br><span class="line">                &lt;&#x2F;el-row&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;button&quot;&gt;</span><br><span class="line">            &lt;el-button style&#x3D;&quot;width: 70%;&quot; type&#x3D;&quot;success&quot; size&#x3D;&quot;small&quot; @click&#x3D;&quot;toImage&quot;&gt;生成截图&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;img class&#x3D;&quot;real_pic&quot; :src&#x3D;&quot;dataURL&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">js</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import html2canvas from &#39;html2canvas&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            dataURL: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        toImage() &#123;</span><br><span class="line">            html2canvas(this.$refs.imageWrapper, &#123;</span><br><span class="line">                backgroundColor: null,&#x2F;&#x2F;设置背景颜色为null</span><br><span class="line">                useCORS:true &#x2F;&#x2F;允许使用跨域资源的图片</span><br><span class="line">            &#125;).then((canvas) &#x3D;&gt; &#123;</span><br><span class="line">                let dataURL &#x3D; canvas.toDataURL(&quot;image&#x2F;png&quot;);</span><br><span class="line">                this.dataURL &#x3D; dataURL;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">属性链接</span><br><span class="line">https:&#x2F;&#x2F;html2canvas.hertzen.com&#x2F;configuration</span><br></pre></td></tr></table></figure>



<h2 id="document文档加载过程分析"><a href="#document文档加载过程分析" class="headerlink" title="document文档加载过程分析"></a>document文档加载过程分析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.addEventListener(&quot;DOMContentLoaded&quot;, function (event) &#123;</span><br><span class="line">    	console.log(&quot;初始DOM 加载并解析&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    window.addEventListener(&quot;load&quot;, function (event) &#123;</span><br><span class="line">    	console.log(&quot;window 所有资源加载完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">    	console.log(document.readyState)</span><br><span class="line">   		if (document.readyState &#x3D;&#x3D;&#x3D; &quot;complete&quot;) &#123;</span><br><span class="line">    		console.log(&#39;初始DOM,加载解析完成&#39;)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    window.addEventListener(&quot;beforeunload&quot;, function (event) &#123;</span><br><span class="line">    	console.log(&#39;即将关闭1&#39;)</span><br><span class="line">    	event.returnValue &#x3D; &quot;\o&#x2F;&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    window.addEventListener(&#39;unload&#39;, function (event) &#123;</span><br><span class="line">    	console.log(&#39;即将关闭2&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">console.log</span><br><span class="line">interactive &#x2F;&#x2F;(index):15</span><br><span class="line">初始DOM 加载并解析 &#x2F;&#x2F;(index):8</span><br><span class="line">complet&#x2F;&#x2F;(index):15 </span><br><span class="line">初始DOM,加载解析完成&#x2F;&#x2F;(index):17 </span><br><span class="line">window 所有资源加载完成&#x2F;&#x2F;(index):11 </span><br><span class="line">&#x2F;&#x2F;点击关闭按钮</span><br><span class="line">即将关闭1</span><br><span class="line">即将关闭2</span><br></pre></td></tr></table></figure>



<h2 id="Object-defineProperty-和Proxy"><a href="#Object-defineProperty-和Proxy" class="headerlink" title="Object.defineProperty,和Proxy"></a>Object.defineProperty,和Proxy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相比于Object.defineProperty, Proxy到底有哪些优势。</span><br><span class="line">第一点</span><br><span class="line">Object.defineProperty只能监听到对象属性的读取或者是写入</span><br><span class="line">Proxy除读写外还可以监听对象中属性的删除，对对象当中方法的调用等等。</span><br><span class="line">第二点</span><br><span class="line">对于数组对象进行监视，通常我们想要监视数组的变化，基本要依靠重写数组方法，这也是Vue的实现方式，proxy可以直接监视数组的变化。以往我们想要通过Object.defineProperty去监视数组的操作最常见的方式是重写数组的操作方法，这也是Vue.js中所使用的方式，大体的方式就是通过自定义的方法去覆盖掉数组原型对象上的push，shift之类的方法，以此来劫持对应的方法调用的过程。</span><br></pre></td></tr></table></figure>



<h2 id="Vue-js使用Blob的方式实现excel表格的下载-流文件下载"><a href="#Vue-js使用Blob的方式实现excel表格的下载-流文件下载" class="headerlink" title="Vue.js使用Blob的方式实现excel表格的下载(流文件下载)"></a>Vue.js使用Blob的方式实现excel表格的下载(流文件下载)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;el-button @click&#x3D;&quot;downloadUrl&quot;&gt;导出Excel&lt;&#x2F;el-button&gt;        </span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import api from &quot;..&#x2F;..&#x2F;api&#x2F;api.js&quot;;</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">		pageSize:30,</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    downloadUrl() &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(api.serverUrl);</span><br><span class="line">      let params &#x3D; &#123;</span><br><span class="line">        pageNum: &quot;1&quot;,</span><br><span class="line">        pageSize: this.pageSize,</span><br><span class="line">        companyId: JSON.parse(sessionStorage.getItem(&quot;companyId&quot;))</span><br><span class="line">      &#125;;</span><br><span class="line">      this.download_accountsDetails_info(params);</span><br><span class="line">    &#125;,</span><br><span class="line">    download_accountsDetails_info(params) &#123;</span><br><span class="line">      return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        axios</span><br><span class="line">          .get(api.serverUrl + &quot;&#x2F;order&#x2F;exportOrder&quot;, &#123;</span><br><span class="line">            params: params,</span><br><span class="line">            responseType: &quot;blob&quot; &#x2F;&#x2F; 1.首先设置responseType对象格式为 blob:</span><br><span class="line">          &#125;)</span><br><span class="line">          .then(</span><br><span class="line">            res &#x3D;&gt; &#123;</span><br><span class="line">              &#x2F;&#x2F;resolve(res)</span><br><span class="line">              let blob &#x3D; new Blob([res.data], &#123;</span><br><span class="line">                type: &quot;application&#x2F;vnd.ms-excel&quot;</span><br><span class="line">              &#125;); &#x2F;&#x2F; 2.获取请求返回的response对象中的blob 设置文件类型，这里以excel为例</span><br><span class="line">              let url &#x3D; window.URL.createObjectURL(blob); &#x2F;&#x2F; 3.创建一个临时的url指向blob对象</span><br><span class="line"></span><br><span class="line">              &#x2F;&#x2F; 4.创建url之后可以模拟对此文件对象的一系列操作，例如：预览、下载</span><br><span class="line">              let a &#x3D; document.createElement(&quot;a&quot;);</span><br><span class="line">              a.href &#x3D; url;</span><br><span class="line">              a.download &#x3D; &quot;导出表格.xlsx&quot;;</span><br><span class="line">              a.click();</span><br><span class="line">              &#x2F;&#x2F; 5.释放这个临时的对象url</span><br><span class="line">              window.URL.revokeObjectURL(url);</span><br><span class="line">            &#125;,</span><br><span class="line">            err &#x3D;&gt; &#123;</span><br><span class="line">              resolve(err.response);</span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">          .catch(error &#x3D;&gt; &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>



<h2 id="vue-echarts入门使用"><a href="#vue-echarts入门使用" class="headerlink" title="vue-echarts入门使用"></a>vue-echarts入门使用</h2><p>1、下载(需要同时下载echarts和vue-echarts)</p>
<p>npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install echarts vue-echarts</span><br></pre></td></tr></table></figure>

<p>cdn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;“https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;echarts@4.1.0&#x2F;dist&#x2F;echarts.js”&gt;</span><br><span class="line">&lt;script src&#x3D;“https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue-echarts@4.0.2”&gt;</span><br></pre></td></tr></table></figure>




<p>2、文件内引入使用</p>
<p>*注：这种方式写的时候需要tooltips或者legend这类的时候，都需要import ‘echarts/lib/component/legend’;这样引入一下，不然不会显示出来</p>
<p>// 局部引入vue-echarts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;echarts&#x2F;lib&#x2F;chart&#x2F;line&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;import ECharts from &#39;vue-echarts&#39;;</span><br><span class="line">import ECharts from &#39;vue-echarts&#x2F;components&#x2F;ECharts.vue&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动引入 ECharts 各模块来减小打包体积</span><br><span class="line">import &#39;echarts&#x2F;lib&#x2F;chart&#x2F;bar&#39;</span><br><span class="line">import &#39;echarts&#x2F;lib&#x2F;chart&#x2F;pie&#39;</span><br><span class="line">import &#39;echarts&#x2F;lib&#x2F;chart&#x2F;line&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;echarts&#x2F;lib&#x2F;component&#x2F;tooltip&#39;</span><br><span class="line">import &#39;echarts&#x2F;lib&#x2F;component&#x2F;polar&#39;</span><br><span class="line">import &#39;echarts&#x2F;lib&#x2F;component&#x2F;legend&#39;</span><br><span class="line">import &#39;echarts&#x2F;lib&#x2F;component&#x2F;title.js&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册组件后即可使用</span><br><span class="line">Vue.component(&#39;v-chart&#39;, ECharts)</span><br><span class="line">Vue.prototype.$echarts &#x3D; ECharts</span><br></pre></td></tr></table></figure>



<p>3、html部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">"charts"</span>&gt;</span><br><span class="line">    &lt;v-chart</span><br><span class="line">      :options=<span class="string">"options"</span></span><br><span class="line">      auto-resize</span><br><span class="line">      style=<span class="string">"width:100%;height:300px;"</span></span><br><span class="line">      /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>4、css部分</p>
<p>样式中必须有.echarts宽高的定义，不然会不显示</p>
<style scoped>
.charts{
  width: 100%;
  height: 100%;
}
.echarts {
  width: 100%;
  height: 100%;
}
</style>
<p>5、配置项部分</p>
<p>环形图</p>
<pre><code>options: { // echarts配置项
    tooltip: { show: false }, // 提示框组件，环形图可以不用这个用其他的
    series: [ // 系列列表
      {
        name: &apos;&apos;, // 系列名称
        type: &apos;pie&apos;, // 类型
        data: [3, 12, 4], // 数据，此处可以通过接口获取，使用this.options.series[0].data = 接口返回数据即可
        radius: [&apos;60%&apos;, &apos;81%&apos;], // [内半径， 外半径], 可以是百分数，也可以直接是数值，不用数组只写单个百分数或数值就是正常的饼图
        center: [&apos;50%&apos;, &apos;50%&apos;], // 圆心位置[横坐标，纵坐标]
        label: { // 饼图图形上的文本标签
          show: false,
          lineHeight: 20,
          padding: [0, -100],
          color: &apos;auto&apos;
        },
        labelLine: { // 视觉引导线的长度
          length: 25,
          length2: 100
        },
        itemStyle: {
          // 饼图颜色采用渐变色
          color: (params) =&gt; {
            // 色值数组，从浅色到深色
            const colorList = [
              [&apos;#A5ABFF&apos;, &apos;#6C73FF&apos;],
                 [&apos;#64BAFF&apos;, &apos;#4487FF&apos;],
              [&apos;#53E7C9&apos;, &apos;#29CB98&apos;]
            ];

            let index = params.dataIndex;

            // 柱子个数超过colorList设置的个数，循环使用
            if (index &gt;= colorList.length) {
              index -= colorList.length;
            }

            // 这里的this.$echarts是项目中的echarts示例，改成对应的名字就好
            return new this.$echarts.graphic.LinearGradient(0, 0, 0, 1, [{
              offset: 0,
              color: colorList[index][0]
            }, {
              offset: 1,
              color: colorList[index][1]
            }]);
          }
        },
        emphasis: { // 饼图视觉引导线样式
          label: {
            show: true,
            verticalAlign: &apos;bottom&apos;, // 文字与视觉引导线的底部对齐
            lineHeight: 20,
            // 保证引导线上的文字水平位置正确
            padding: [0, -100],
            formatter: &apos;{b} {gray|{d}%} {gray|{c}}&apos;, // 此处可以参考文档
            rich: {
              gray: {
                color: &apos;#5B6479&apos;
              }
            }
          },
          labelLine: {
            show: true,
            lineStyle: {
              shadowBlur: { // 引导线阴影
                shadowColor: &apos;rgba(58, 120, 214, 0.14)&apos;,
                shadowBlur: 12
              }
            }
          }
        }
      }
    ]
  }</code></pre><h2 id="vue使用鼠标中键，左键，右键事件"><a href="#vue使用鼠标中键，左键，右键事件" class="headerlink" title="vue使用鼠标中键，左键，右键事件"></a>vue使用鼠标中键，左键，右键事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div @click&#x3D;&quot;test(params,$event)&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">test(id,e)&#123;</span><br><span class="line">    if (e.button &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">   	    console.log(&#39;左键&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (e.button &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    	console.log(&#39;中键&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (e.button &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    	console.log(&#39;右键&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="animate动画库的数字增长动画组件"><a href="#animate动画库的数字增长动画组件" class="headerlink" title="animate动画库的数字增长动画组件"></a>animate动画库的数字增长动画组件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save animated-number-vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;animated-number </span><br><span class="line">    :value&#x3D;&quot;value&quot; </span><br><span class="line">    :formatValue&#x3D;&quot;formatToPrice&quot; </span><br><span class="line">    :duration&#x3D;&quot;300&quot;</span><br><span class="line">    &gt;&lt;&#x2F;animated-number&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import AnimatedNumber from &quot;animated-number-vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    AnimatedNumber</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      value: 1000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    formatToPrice(value) &#123;</span><br><span class="line">      return &#96;$ $&#123;value.toFixed(2)&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="vue使用刮刮乐组件"><a href="#vue使用刮刮乐组件" class="headerlink" title="vue使用刮刮乐组件"></a>vue使用刮刮乐组件</h2><p>参考链接：<a href="https://blog.csdn.net/until_you0311/article/details/106276527" target="_blank" rel="noopener">https://blog.csdn.net/until_you0311/article/details/106276527</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用npm下载安装</span><br><span class="line">npm install lzy-scratch-card --save</span><br><span class="line"></span><br><span class="line">2.vue项目的引用</span><br><span class="line">import scratchCard from &#39;lzy-scratch-card&#39;</span><br><span class="line"></span><br><span class="line">3.vue项目中使用</span><br><span class="line">&lt;scratch-card</span><br><span class="line">        elementId&#x3D;&quot;scratch&quot;</span><br><span class="line">        width&#x3D;&quot;600px&quot;</span><br><span class="line">        height&#x3D;&quot;300px&quot;</span><br><span class="line">        :moveRadius&#x3D;&quot;15&quot;</span><br><span class="line">        :ratio&#x3D;&quot;0.5&quot;</span><br><span class="line">        :startCallback&#x3D;&quot;startCallback&quot;</span><br><span class="line">        :clearCallback&#x3D;&quot;clearCallbackUp&quot;</span><br><span class="line">        coverColor&#x3D;&quot;#222222&quot;</span><br><span class="line">        coverImg&#x3D;&quot;https:&#x2F;&#x2F;liquid-games.oss-cn-beijing.aliyuncs.com&#x2F;single_game_images&#x2F;entertainment&#x2F;scratch_card_mask_up.png&quot;</span><br><span class="line">        :result&#x3D;&quot;result&quot;</span><br><span class="line">      &gt;</span><br><span class="line">&lt;&#x2F;scratch-card&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/29/vue%E4%B9%8Bseekcy%E5%BC%80%E5%8F%91%E5%8E%86%E7%A8%8B%E8%AE%B0%E5%BD%951/image-20210311173714259.png" alt="image-20210311173714259"></p>
<h2 id="vue使用滑块验证组件"><a href="#vue使用滑块验证组件" class="headerlink" title="vue使用滑块验证组件"></a>vue使用滑块验证组件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line">npm install vue-drag-verify --save</span><br><span class="line">npm install font-awesome --save</span><br><span class="line"></span><br><span class="line">html</span><br><span class="line">    &lt;drag-verify </span><br><span class="line">    :width&#x3D;&quot;width&quot; </span><br><span class="line">    :height&#x3D;&quot;height&quot; </span><br><span class="line">    :text&#x3D;&quot;text&quot; </span><br><span class="line">    :success-text&#x3D;&quot;successText&quot; </span><br><span class="line">    :background&#x3D;&quot;background&quot; </span><br><span class="line">    :progress-bar-bg&#x3D;&quot;progressBarBg&quot; </span><br><span class="line">    :completed-bg&#x3D;&quot;completedBg&quot; </span><br><span class="line">    :handler-bg&#x3D;&quot;handlerBg&quot; </span><br><span class="line">    :handler-icon&#x3D;&quot;handlerIcon&quot; </span><br><span class="line">    :text-size&#x3D;&quot;textSize&quot; </span><br><span class="line">    :success-icon&#x3D;&quot;successIcon&quot;</span><br><span class="line">    ref&#x3D;&quot;Verify&quot;</span><br><span class="line">    &gt;</span><br><span class="line">&lt;&#x2F;drag-verify&gt;</span><br><span class="line"></span><br><span class="line">js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#39;font-awesome&#x2F;css&#x2F;font-awesome.min.css&#39;</span><br><span class="line">import dragVerify from &#39;vue-drag-verify&#39;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;app&#39;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    dragVerify</span><br><span class="line">  &#125;,</span><br><span class="line"> data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      handlerIcon: &quot;fa fa-angle-double-right&quot;,</span><br><span class="line">      successIcon: &quot;fa fa-check&quot;,</span><br><span class="line">      background: &quot;#cccccc&quot;,</span><br><span class="line">      progressBarBg: &quot;#4b0&quot;,</span><br><span class="line">      completedBg: &quot;#66cc66&quot;,</span><br><span class="line">      handlerBg: &quot;#fff&quot;,</span><br><span class="line">      text: &quot;请将滑块拖动到右侧&quot;,</span><br><span class="line">      successText: &quot;验证成功&quot;,</span><br><span class="line">      width: 320,</span><br><span class="line">      height: 42,</span><br><span class="line">      textSize: &quot;18px&quot;,</span><br><span class="line">      isCircle:&#39;true&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">验证</span><br><span class="line"> console.log(this.$refs.Verify.isMoving)</span><br><span class="line"> console.log(this.$refs.Verify.isPassing)</span><br><span class="line"> console.log(this.$refs.Verify.handlerIconClass)</span><br><span class="line">结果</span><br><span class="line">&#x2F;&#x2F;未滑动完打印</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line"> fa fa-check</span><br><span class="line">&#x2F;&#x2F;滑动完成打印</span><br><span class="line"> false</span><br><span class="line"> true</span><br><span class="line"> fa fa-angle-double-right</span><br><span class="line"></span><br><span class="line">插件的各参数</span><br><span class="line">名称 | 类型 | 默认值 | 说明</span><br><span class="line">--- | --- | --- | ---</span><br><span class="line">width | Number | 200 | 组件的宽度</span><br><span class="line">height | Number | 60 | 组件的高度</span><br><span class="line">text | String | swiping to the right side | 提示信息文字</span><br><span class="line">successText | String | success | 验证通过时的提示信息文字</span><br><span class="line">background | String | #ccc | 组件背景色</span><br><span class="line">color | String | #ffffff | 组件文字颜色</span><br><span class="line">progressBarBg | String | #FFFF99 | 拖拽过程中的背景颜色</span><br><span class="line">completedBg | String | #66cc66 | 验证成功的背景颜色</span><br><span class="line">circle | Boolean | true | 设为true,组件为圆形按钮，否则为长方形</span><br><span class="line">handlerIcon | String | - | 拖拽按钮的icon</span><br><span class="line">successIcon | String | - | 验证通过时拖拽按钮的icon</span><br><span class="line">handlerBg | String | #fff | 拖拽按钮的背景色</span><br><span class="line">textSize | String | 20px | 组件的文字大小</span><br></pre></td></tr></table></figure>



<h2 id="vue使用Print-js"><a href="#vue使用Print-js" class="headerlink" title="vue使用Print.js"></a>vue使用Print.js</h2><p>一、vue安装命令：<br>npm install print-js –save</p>
<p>二、引入<br>这个引入不需要在main.js中，直接在使用的.vue中引入即可</p>
<p><img src="https://img-blog.csdnimg.cn/20200724183357229.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjk2NTA3Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里颜色虽然是灰色，但是也要添加，否则会报错。</p>
<p>三、编码<br>我这里要打印 html 中的div ，调用函数找到 div 的 id。</p>
<p><img src="https://img-blog.csdnimg.cn/20200724183448993.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjk2NTA3Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">		goPrint()&#123;</span><br><span class="line">                console.log(&#39;打印&#39;)</span><br><span class="line">                printJS(&#123;</span><br><span class="line">                    printable: &#39;printCons&#39;,</span><br><span class="line">                    type: &#39;html&#39;,</span><br><span class="line">                    &#x2F;&#x2F;properties: [</span><br><span class="line">                    &#x2F;&#x2F;    &#123; field: &#39;name&#39;, displayName: &#39;姓名&#39;, columnSize:&#96;50%&#96;&#125;,</span><br><span class="line">                    &#x2F;&#x2F;    &#123; field: &#39;sex&#39;, displayName: &#39;性别&#39;,columnSize:&#96;50%&#96;&#125;,</span><br><span class="line">                    &#x2F;&#x2F;],</span><br><span class="line">                    &#x2F;&#x2F; header: &#96;&lt;p class&#x3D;&quot;custom-p&quot;&gt; 名单 &lt;&#x2F;p&gt;&#96;,</span><br><span class="line">                    &#x2F;&#x2F; style: &#39;#printCons &#123;width: 600px;&#125; .no-print&#123;width: 0px&#125; .itemText1 &#123; width: 200px &#125; .itemText2 &#123; width: 200px &#125; .itemText3 &#123; width: 200px &#125; .itemText4 &#123; width: 200px &#125;&#39;,</span><br><span class="line">                    &#x2F;&#x2F; gridHeaderStyle:&#39;font-size:12px; padding:3px; border:1px solid; font-weight: 100; text-align:left;&#39;,</span><br><span class="line">                    &#x2F;&#x2F; gridStyle:&#39;font-size:12px; padding:3px; border:1px solid; text-align:left;&#39;,</span><br><span class="line">                    &#x2F;&#x2F; repeatTableHeader: true,</span><br><span class="line">                    &#x2F;&#x2F; scanStyles:true,</span><br><span class="line">                    targetStyles: [&#39;*&#39;],</span><br><span class="line">                    ignoreElements:[&#39;no-print&#39;,&#39;bc&#39;,&#39;gb&#39;]</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printable:要打印的id。</span><br><span class="line">type:可以是 html 、pdf、 json 等。</span><br><span class="line">properties:是打印json时所需要的数据属性。</span><br><span class="line">gridHeaderStyle和gridStyle都是打印json时可选的样式。</span><br><span class="line">repeatTableHeader:在打印JSON数据时使用。设置为时false，数据表标题将仅在第一页显示。</span><br><span class="line">scanStyles:设置为false时，库将不处理应用于正在打印的html的样式。使用css参数时很有用。</span><br><span class="line">targetStyles: [’*’],这样设置继承了页面要打印元素原有的css属性。</span><br><span class="line">style:传入自定义样式的字符串，使用在要打印的html页面 也就是纸上的样子。</span><br><span class="line">ignoreElements：传入要打印的div中的子元素id，使其不打印。非常好用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tips：需要强制分页，加一个这样的style即可</span><br><span class="line">page-break-after:always</span><br><span class="line">示例</span><br><span class="line">&lt;div style&#x3D;&quot;page-break-after:always&quot;&gt;我是封面&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;page-break-after:always&quot;&gt;我是目录，你不知道我的内容有多长&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;我是正文，我需要从一个新页面开始展示&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h2 id="vue下划线跟随的两种方式"><a href="#vue下划线跟随的两种方式" class="headerlink" title="vue下划线跟随的两种方式"></a>vue下划线跟随的两种方式</h2><h3 id="纯css方式"><a href="#纯css方式" class="headerlink" title="纯css方式"></a>纯css方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html</span><br><span class="line">&lt;div class&#x3D;&quot;main&quot;&gt;</span><br><span class="line">    &lt;div v-for&#x3D;&quot;(nav,index) in navs&quot; :key&#x3D;&quot;index&quot; class&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">    	&lt;div&gt;&#123;&#123;nav.name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">js</span><br><span class="line">navs: [&#123; name: &quot;北京&quot; &#125;, &#123; name: &quot;哈尔滨黑龙江&quot; &#125;, &#123; name: &quot;上海&quot; &#125;, &#123; name: &quot;三个人&quot; &#125;,],</span><br><span class="line"></span><br><span class="line">css</span><br><span class="line">.main &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: fit-content;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    text-align: center;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.nav &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.nav::after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 100%;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 2px;</span><br><span class="line">    background-color: #000;</span><br><span class="line">    transition: all 0.3s ease-out;</span><br><span class="line">&#125;</span><br><span class="line">.nav &#123;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      left: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp; + .nav::after &#123;</span><br><span class="line">      left: 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="js事件方式（高阶用法）"><a href="#js事件方式（高阶用法）" class="headerlink" title="js事件方式（高阶用法）"></a>js事件方式（高阶用法）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html</span><br><span class="line">&lt;div class&#x3D;&quot;main&quot; ref&#x3D;&quot;MainHeader&quot;&gt;</span><br><span class="line">            &lt;div v-for&#x3D;&quot;(nav,index) in navs&quot; :key&#x3D;&quot;index&quot; :class&#x3D;&quot;&#123;nav:true,active:index&#x3D;&#x3D;activeNav&#125;&quot;</span><br><span class="line">                @mouseenter&#x3D;&quot;setCurrentNav(index)&quot; @click&#x3D;&quot;setActiveNav(index)&quot; @mouseleave&#x3D;&quot;handleLeaveMainHeader &quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;nav-title&quot;&gt;&#123;&#123;nav.name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;i class&#x3D;&quot;nav-underline&quot; :style&#x3D;&quot;navLineStyle&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        </span><br><span class="line">js</span><br><span class="line">data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            activeNav: 0,</span><br><span class="line">            activeNavStyle:&#123;width:0,left:0&#125;,</span><br><span class="line">            currentNav: 0,</span><br><span class="line">            currentNavStyle:&#123;width:0,left:0&#125;,</span><br><span class="line">            navs: [&#123; name: &quot;北京&quot; &#125;, &#123; name: &quot;哈尔滨黑龙江&quot; &#125;, &#123; name: &quot;上海&quot; &#125;, &#123; name: &quot;三个人&quot; &#125;,],</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        navLineStyle() &#123;</span><br><span class="line">            let style &#x3D; this.currentNavStyle || this.activeNavStyle;</span><br><span class="line">            return &#123; width: &#96;$&#123;style.width&#125;px&#96;, left: &#96;$&#123;style.left&#125;px&#96; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleLeaveMainHeader() &#123;</span><br><span class="line">            &#x2F;&#x2F; 鼠标离开导航栏时，重置下划线状态</span><br><span class="line">            this.currentNavStyle &#x3D; null</span><br><span class="line">        &#125;,</span><br><span class="line">        setActiveNav(index) &#123;</span><br><span class="line">            &#x2F;&#x2F; 点击导航时，设置激活样式</span><br><span class="line">            this.activeNav &#x3D; index</span><br><span class="line">            this.activeNavStyle &#x3D; this.getNavStyle(index)</span><br><span class="line">        &#125;,</span><br><span class="line">        setCurrentNav(index) &#123;</span><br><span class="line">            &#x2F;&#x2F; 鼠标移动到导航时，记录临时状态</span><br><span class="line">            this.currentNav &#x3D; index</span><br><span class="line">            this.currentNavStyle &#x3D; this.getNavStyle(index)</span><br><span class="line">        &#125;,</span><br><span class="line">        getNavStyle(index) &#123; &#x2F;&#x2F; 根据导航的 index 移动下划线</span><br><span class="line">            let childNodes &#x3D; this.$refs.MainHeader.childNodes</span><br><span class="line">            &#x2F;&#x2F; 根据当前导航的宽度，设置下划线的宽度</span><br><span class="line">            let width &#x3D; childNodes[index].clientWidth</span><br><span class="line">            &#x2F;&#x2F; 设置下划线的默认位置</span><br><span class="line">            let left &#x3D; 0</span><br><span class="line">            if (index &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 计算左边导航的总宽度，设置为下划线的左移距离</span><br><span class="line">                for (let i &#x3D; 0; i &lt; index; i++) &#123;</span><br><span class="line">                    left +&#x3D; childNodes[i].clientWidth</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return &#123; width, left &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
